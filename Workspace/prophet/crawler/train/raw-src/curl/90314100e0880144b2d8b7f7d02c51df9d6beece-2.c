# 1 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 312 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 23 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
# 1 "../lib/curl_setup.h" 1
# 41 "../lib/curl_setup.h"
# 1 "../lib/curl_config.h" 1
# 42 "../lib/curl_setup.h" 2
# 132 "../lib/curl_setup.h"
# 1 "../include/curl/curlbuild.h" 1
# 131 "../include/curl/curlbuild.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 352 "/usr/include/features.h" 3 4
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 353 "/usr/include/features.h" 2 3 4
# 374 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 385 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 386 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 375 "/usr/include/features.h" 2 3 4
# 398 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 399 "/usr/include/features.h" 2 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 121 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 122 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 30 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;
# 60 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;
# 98 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 132 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 59 "/usr/include/time.h" 3 4
typedef __clock_t clock_t;
# 75 "/usr/include/time.h" 3 4
typedef __time_t time_t;
# 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 133 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 146 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 58 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 147 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 194 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 216 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 61 "/usr/include/endian.h" 2 3 4
# 217 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;






# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
# 44 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 46 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 64 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 106 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 220 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int
__attribute__ ((__nothrow__ )) gnu_dev_major (unsigned long long int __dev)
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int
__attribute__ ((__nothrow__ )) gnu_dev_minor (unsigned long long int __dev)
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned long long int
__attribute__ ((__nothrow__ )) gnu_dev_makedev (unsigned int __major, unsigned int __minor)
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
   | (((unsigned long long int) (__minor & ~0xff)) << 12)
   | (((unsigned long long int) (__major & ~0xfff)) << 32));
}
# 223 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 270 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4
# 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;





typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    short __spins;
    short __elision;
    __pthread_list_t __list;
# 124 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
# 211 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 132 "../include/curl/curlbuild.h" 2
# 152 "../include/curl/curlbuild.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/socket.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/uio.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uio.h" 1 3 4
# 43 "/usr/include/x86_64-linux-gnu/bits/uio.h" 3 4
struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 29 "/usr/include/x86_64-linux-gnu/sys/uio.h" 2 3 4
# 39 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t readv (int __fd, const struct iovec *__iovec, int __count)
       ;
# 50 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t writev (int __fd, const struct iovec *__iovec, int __count)
       ;
# 65 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t preadv (int __fd, const struct iovec *__iovec, int __count,
         __off_t __offset) ;
# 77 "/usr/include/x86_64-linux-gnu/sys/uio.h" 3 4
extern ssize_t pwritev (int __fd, const struct iovec *__iovec, int __count,
   __off_t __offset) ;
# 27 "/usr/include/x86_64-linux-gnu/sys/socket.h" 2 3 4

# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/sys/socket.h" 2 3 4
# 38 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/socket.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4





typedef __socklen_t socklen_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/socket_type.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/socket_type.h" 3 4
enum __socket_type
{
  SOCK_STREAM = 1,


  SOCK_DGRAM = 2,


  SOCK_RAW = 3,

  SOCK_RDM = 4,

  SOCK_SEQPACKET = 5,


  SOCK_DCCP = 6,

  SOCK_PACKET = 10,







  SOCK_CLOEXEC = 02000000,


  SOCK_NONBLOCK = 00004000


};
# 39 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4
# 146 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h" 3 4
typedef unsigned short int sa_family_t;
# 147 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4


struct sockaddr
  {
    sa_family_t sa_family;
    char sa_data[14];
  };
# 162 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
struct sockaddr_storage
  {
    sa_family_t ss_family;
    unsigned long int __ss_align;
    char __ss_padding[(128 - (2 * sizeof (unsigned long int)))];
  };



enum
  {
    MSG_OOB = 0x01,

    MSG_PEEK = 0x02,

    MSG_DONTROUTE = 0x04,






    MSG_CTRUNC = 0x08,

    MSG_PROXY = 0x10,

    MSG_TRUNC = 0x20,

    MSG_DONTWAIT = 0x40,

    MSG_EOR = 0x80,

    MSG_WAITALL = 0x100,

    MSG_FIN = 0x200,

    MSG_SYN = 0x400,

    MSG_CONFIRM = 0x800,

    MSG_RST = 0x1000,

    MSG_ERRQUEUE = 0x2000,

    MSG_NOSIGNAL = 0x4000,

    MSG_MORE = 0x8000,

    MSG_WAITFORONE = 0x10000,

    MSG_FASTOPEN = 0x20000000,


    MSG_CMSG_CLOEXEC = 0x40000000



  };




struct msghdr
  {
    void *msg_name;
    socklen_t msg_namelen;

    struct iovec *msg_iov;
    size_t msg_iovlen;

    void *msg_control;
    size_t msg_controllen;




    int msg_flags;
  };


struct cmsghdr
  {
    size_t cmsg_len;




    int cmsg_level;
    int cmsg_type;

    __extension__ unsigned char __cmsg_data [];

  };
# 272 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
          struct cmsghdr *__cmsg) __attribute__ ((__nothrow__ ));




extern __inline __attribute__ ((__gnu_inline__)) struct cmsghdr *
__attribute__ ((__nothrow__ )) __cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg)
{
  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))

    return (struct cmsghdr *) 0;

  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
          + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1)));
  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
     + __mhdr->msg_controllen)
      || ((unsigned char *) __cmsg + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1))
   > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))

    return (struct cmsghdr *) 0;
  return __cmsg;
}




enum
  {
    SCM_RIGHTS = 0x01





  };
# 345 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/socket.h" 1 3 4
# 1 "/usr/include/asm-generic/socket.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/asm/sockios.h" 1 3 4
# 1 "/usr/include/asm-generic/sockios.h" 1 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/sockios.h" 2 3 4
# 5 "/usr/include/asm-generic/socket.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/socket.h" 2 3 4
# 346 "/usr/include/x86_64-linux-gnu/bits/socket.h" 2 3 4
# 379 "/usr/include/x86_64-linux-gnu/bits/socket.h" 3 4
struct linger
  {
    int l_onoff;
    int l_linger;
  };
# 39 "/usr/include/x86_64-linux-gnu/sys/socket.h" 2 3 4




struct osockaddr
  {
    unsigned short int sa_family;
    unsigned char sa_data[14];
  };




enum
{
  SHUT_RD = 0,

  SHUT_WR,

  SHUT_RDWR

};
# 113 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern int socket (int __domain, int __type, int __protocol) __attribute__ ((__nothrow__ ));





extern int socketpair (int __domain, int __type, int __protocol,
         int __fds[2]) __attribute__ ((__nothrow__ ));


extern int bind (int __fd, const struct sockaddr * __addr, socklen_t __len)
     __attribute__ ((__nothrow__ ));


extern int getsockname (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ ));
# 137 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern int connect (int __fd, const struct sockaddr * __addr, socklen_t __len);



extern int getpeername (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ ));






extern ssize_t send (int __fd, const void *__buf, size_t __n, int __flags);






extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);






extern ssize_t sendto (int __fd, const void *__buf, size_t __n,
         int __flags, const struct sockaddr * __addr,
         socklen_t __addr_len);
# 174 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
    int __flags, struct sockaddr *__restrict __addr,
    socklen_t *__restrict __addr_len);







extern ssize_t sendmsg (int __fd, const struct msghdr *__message,
   int __flags);
# 202 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);
# 219 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern int getsockopt (int __fd, int __level, int __optname,
         void *__restrict __optval,
         socklen_t *__restrict __optlen) __attribute__ ((__nothrow__ ));




extern int setsockopt (int __fd, int __level, int __optname,
         const void *__optval, socklen_t __optlen) __attribute__ ((__nothrow__ ));





extern int listen (int __fd, int __n) __attribute__ ((__nothrow__ ));
# 243 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern int accept (int __fd, struct sockaddr *__restrict __addr,
     socklen_t *__restrict __addr_len);
# 261 "/usr/include/x86_64-linux-gnu/sys/socket.h" 3 4
extern int shutdown (int __fd, int __how) __attribute__ ((__nothrow__ ));




extern int sockatmark (int __fd) __attribute__ ((__nothrow__ ));







extern int isfdtype (int __fd, int __fdtype) __attribute__ ((__nothrow__ ));
# 153 "../include/curl/curlbuild.h" 2
# 172 "../include/curl/curlbuild.h"
typedef socklen_t curl_socklen_t;





typedef long curl_off_t;
# 133 "../lib/curl_setup.h" 2





# 1 "../include/curl/curlrules.h" 1
# 141 "../include/curl/curlrules.h"
typedef char
  __curl_rule_01__
    [sizeof(long) == 8 ? 1 : -1];







typedef char
  __curl_rule_02__
    [sizeof(curl_off_t) == 8 ? 1 : -1];







typedef char
  __curl_rule_03__
    [sizeof(curl_off_t) >= sizeof(long) ? 1 : -1];







typedef char
  __curl_rule_04__
    [sizeof(curl_socklen_t) == 4 ? 1 : -1];







typedef char
  __curl_rule_05__
    [sizeof(curl_socklen_t) >= sizeof(int) ? 1 : -1];
# 139 "../lib/curl_setup.h" 2
# 321 "../lib/curl_setup.h"
# 1 "/usr/include/stdio.h" 1 3 4
# 33 "/usr/include/stdio.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4
# 44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;
# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 31 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 32 "/usr/include/libio.h" 2 3 4
# 49 "/usr/include/libio.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stdarg.h" 1 3 4
# 30 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stdarg.h" 3 4
typedef __builtin_va_list va_list;
# 50 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 50 "/usr/include/libio.h" 2 3 4
# 144 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 154 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 302 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 338 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);
# 390 "/usr/include/libio.h" 3 4
extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 434 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ ));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ ));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ ));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ ));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ ));
# 464 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ ));
# 75 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 110 "/usr/include/stdio.h" 3 4
typedef _G_fpos_t fpos_t;
# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) __attribute__ ((__nothrow__ ));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ ));




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ ));
# 195 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) ;
# 209 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ )) ;





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ )) ;
# 227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) ;
# 237 "/usr/include/stdio.h" 3 4
extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 272 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 306 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ )) ;
# 319 "/usr/include/stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ )) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ )) ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ ));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ ));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ ));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ ));
# 356 "/usr/include/stdio.h" 3 4
extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));
# 412 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));
# 425 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ ));
# 443 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf") ;


extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf") ;

extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ ));
# 471 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ )) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 494 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ ))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 531 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);
# 550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 573 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);
# 622 "/usr/include/stdio.h" 3 4
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
          ;
# 638 "/usr/include/stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));
# 665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;
# 689 "/usr/include/stdio.h" 3 4
extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);
# 749 "/usr/include/stdio.h" 3 4
extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 773 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 798 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 826 "/usr/include/stdio.h" 3 4
extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ ));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ )) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ )) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ ));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ )) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ )) ;
# 846 "/usr/include/stdio.h" 3 4
extern void perror (const char *__s);







# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ )) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ )) ;
# 873 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ ));
# 913 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ ));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ )) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ ));
# 934 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}



extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return _IO_getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}
# 124 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) feof_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x10) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) ferror_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x20) != 0);
}
# 935 "/usr/include/stdio.h" 2 3 4
# 322 "../lib/curl_setup.h" 2

# 1 "/usr/include/assert.h" 1 3 4
# 69 "/usr/include/assert.h" 3 4
extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));
# 324 "../lib/curl_setup.h" 2
# 479 "../lib/curl_setup.h"
     int fileno( FILE *stream);
# 665 "../lib/curl_setup.h"
# 1 "../lib/curl_setup_once.h" 1
# 31 "../lib/curl_setup_once.h"
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 86 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 3 4
typedef int wchar_t;
# 33 "/usr/include/stdlib.h" 2 3 4








# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "/usr/include/stdlib.h" 2 3 4
# 67 "/usr/include/stdlib.h" 3 4
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
# 97 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ )) ;




extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 277 "/usr/include/stdlib.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) atoi (const char *__nptr)
{
  return (int) strtol (__nptr, (char **) ((void*)0), 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__nothrow__ )) atol (const char *__nptr)
{
  return strtol (__nptr, (char **) ((void*)0), 10);
}




__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__nothrow__ )) atoll (const char *__nptr)
{
  return strtoll (__nptr, (char **) ((void*)0), 10);
}
# 305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ )) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
# 321 "/usr/include/stdlib.h" 3 4
extern long int random (void) __attribute__ ((__nothrow__ ));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ ));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__ ));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ ));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ ));







extern double drand48 (void) __attribute__ ((__nothrow__ ));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ ));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ ));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ ));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
# 466 "/usr/include/stdlib.h" 3 4
extern void *malloc (size_t __size) __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) ;
# 480 "/usr/include/stdlib.h" 3 4
extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__ ));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__ ));




# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ ));
# 493 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
# 515 "/usr/include/stdlib.h" 3 4
extern void abort (void) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 535 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));
# 557 "/usr/include/stdlib.h" 3 4
extern void _Exit (int __status) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
# 578 "/usr/include/stdlib.h" 3 4
extern int putenv (char *__string) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ ));
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 620 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 642 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 663 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
# 717 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;
# 734 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ )) ;






typedef int (*__compar_fn_t) (const void *, const void *);
# 755 "/usr/include/stdlib.h" 3 4
extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 return (void *) __p;
    }

  return ((void*)0);
}
# 761 "/usr/include/stdlib.h" 2 3 4




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 775 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;
# 812 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ ));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ ));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ ));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ ));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ ));
# 888 "/usr/include/stdlib.h" 3 4
extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
# 899 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2, 3))) ;
# 951 "/usr/include/stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__nothrow__ )) atof (const char *__nptr)
{
  return strtod (__nptr, (char **) ((void*)0));
}
# 956 "/usr/include/stdlib.h" 2 3 4
# 32 "../lib/curl_setup_once.h" 2
# 1 "/usr/include/string.h" 1 3 4
# 32 "/usr/include/string.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4
# 46 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 96 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 129 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));







# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 164 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 236 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 263 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 285 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 315 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 342 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
# 399 "/usr/include/string.h" 3 4
extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__ ));
# 427 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
# 445 "/usr/include/string.h" 3 4
extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__ ));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 489 "/usr/include/string.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 517 "/usr/include/string.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 534 "/usr/include/string.h" 3 4
extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 557 "/usr/include/string.h" 3 4
extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ ));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
# 632 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/string.h" 1 3 4
# 633 "/usr/include/string.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/string2.h" 1 3 4
# 393 "/usr/include/x86_64-linux-gnu/bits/string2.h" 3 4
extern void *__rawmemchr (const void *__s, int __c);
# 945 "/usr/include/x86_64-linux-gnu/bits/string2.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) size_t __strcspn_c1 (const char *__s, int __reject);
extern __inline __attribute__ ((__gnu_inline__)) size_t
__strcspn_c1 (const char *__s, int __reject)
{
  size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject)
    ++__result;
  return __result;
}

extern __inline __attribute__ ((__gnu_inline__)) size_t __strcspn_c2 (const char *__s, int __reject1,
         int __reject2);
extern __inline __attribute__ ((__gnu_inline__)) size_t
__strcspn_c2 (const char *__s, int __reject1, int __reject2)
{
  size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject1
  && __s[__result] != __reject2)
    ++__result;
  return __result;
}

extern __inline __attribute__ ((__gnu_inline__)) size_t __strcspn_c3 (const char *__s, int __reject1,
         int __reject2, int __reject3);
extern __inline __attribute__ ((__gnu_inline__)) size_t
__strcspn_c3 (const char *__s, int __reject1, int __reject2,
       int __reject3)
{
  size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject1
  && __s[__result] != __reject2 && __s[__result] != __reject3)
    ++__result;
  return __result;
}
# 1021 "/usr/include/x86_64-linux-gnu/bits/string2.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) size_t __strspn_c1 (const char *__s, int __accept);
extern __inline __attribute__ ((__gnu_inline__)) size_t
__strspn_c1 (const char *__s, int __accept)
{
  size_t __result = 0;

  while (__s[__result] == __accept)
    ++__result;
  return __result;
}

extern __inline __attribute__ ((__gnu_inline__)) size_t __strspn_c2 (const char *__s, int __accept1,
        int __accept2);
extern __inline __attribute__ ((__gnu_inline__)) size_t
__strspn_c2 (const char *__s, int __accept1, int __accept2)
{
  size_t __result = 0;

  while (__s[__result] == __accept1 || __s[__result] == __accept2)
    ++__result;
  return __result;
}

extern __inline __attribute__ ((__gnu_inline__)) size_t __strspn_c3 (const char *__s, int __accept1,
        int __accept2, int __accept3);
extern __inline __attribute__ ((__gnu_inline__)) size_t
__strspn_c3 (const char *__s, int __accept1, int __accept2, int __accept3)
{
  size_t __result = 0;

  while (__s[__result] == __accept1 || __s[__result] == __accept2
  || __s[__result] == __accept3)
    ++__result;
  return __result;
}
# 1097 "/usr/include/x86_64-linux-gnu/bits/string2.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) char *__strpbrk_c2 (const char *__s, int __accept1,
        int __accept2);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strpbrk_c2 (const char *__s, int __accept1, int __accept2)
{

  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2)
    ++__s;
  return *__s == '\0' ? ((void*)0) : (char *) (size_t) __s;
}

extern __inline __attribute__ ((__gnu_inline__)) char *__strpbrk_c3 (const char *__s, int __accept1,
        int __accept2, int __accept3);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strpbrk_c3 (const char *__s, int __accept1, int __accept2, int __accept3)
{

  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2
  && *__s != __accept3)
    ++__s;
  return *__s == '\0' ? ((void*)0) : (char *) (size_t) __s;
}
# 1147 "/usr/include/x86_64-linux-gnu/bits/string2.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) char *__strtok_r_1c (char *__s, char __sep, char **__nextp);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strtok_r_1c (char *__s, char __sep, char **__nextp)
{
  char *__result;
  if (__s == ((void*)0))
    __s = *__nextp;
  while (*__s == __sep)
    ++__s;
  __result = ((void*)0);
  if (*__s != '\0')
    {
      __result = __s++;
      while (*__s != '\0')
 if (*__s++ == __sep)
   {
     __s[-1] = '\0';
     break;
   }
    }
  *__nextp = __s;
  return __result;
}
# 1179 "/usr/include/x86_64-linux-gnu/bits/string2.h" 3 4
extern char *__strsep_g (char **__stringp, const char *__delim);
# 1197 "/usr/include/x86_64-linux-gnu/bits/string2.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) char *__strsep_1c (char **__s, char __reject);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strsep_1c (char **__s, char __reject)
{
  char *__retval = *__s;
  if (__retval != ((void*)0) && (*__s = (__extension__ (__builtin_constant_p (__reject) && !__builtin_constant_p (__retval) && (__reject) == '\0' ? (char *) __rawmemchr (__retval, __reject) : __builtin_strchr (__retval, __reject)))) != ((void*)0))
    *(*__s)++ = '\0';
  return __retval;
}

extern __inline __attribute__ ((__gnu_inline__)) char *__strsep_2c (char **__s, char __reject1, char __reject2);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strsep_2c (char **__s, char __reject1, char __reject2)
{
  char *__retval = *__s;
  if (__retval != ((void*)0))
    {
      char *__cp = __retval;
      while (1)
 {
   if (*__cp == '\0')
     {
       __cp = ((void*)0);
   break;
     }
   if (*__cp == __reject1 || *__cp == __reject2)
     {
       *__cp++ = '\0';
       break;
     }
   ++__cp;
 }
      *__s = __cp;
    }
  return __retval;
}

extern __inline __attribute__ ((__gnu_inline__)) char *__strsep_3c (char **__s, char __reject1, char __reject2,
       char __reject3);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strsep_3c (char **__s, char __reject1, char __reject2, char __reject3)
{
  char *__retval = *__s;
  if (__retval != ((void*)0))
    {
      char *__cp = __retval;
      while (1)
 {
   if (*__cp == '\0')
     {
       __cp = ((void*)0);
   break;
     }
   if (*__cp == __reject1 || *__cp == __reject2 || *__cp == __reject3)
     {
       *__cp++ = '\0';
       break;
     }
   ++__cp;
 }
      *__s = __cp;
    }
  return __retval;
}
# 1278 "/usr/include/x86_64-linux-gnu/bits/string2.h" 3 4
extern char *__strdup (const char *__string) __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__));
# 1297 "/usr/include/x86_64-linux-gnu/bits/string2.h" 3 4
extern char *__strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__));
# 636 "/usr/include/string.h" 2 3 4
# 33 "../lib/curl_setup_once.h" 2

# 1 "/usr/include/ctype.h" 1 3 4
# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 110 "/usr/include/ctype.h" 3 4
extern int isalnum (int) __attribute__ ((__nothrow__ ));
extern int isalpha (int) __attribute__ ((__nothrow__ ));
extern int iscntrl (int) __attribute__ ((__nothrow__ ));
extern int isdigit (int) __attribute__ ((__nothrow__ ));
extern int islower (int) __attribute__ ((__nothrow__ ));
extern int isgraph (int) __attribute__ ((__nothrow__ ));
extern int isprint (int) __attribute__ ((__nothrow__ ));
extern int ispunct (int) __attribute__ ((__nothrow__ ));
extern int isspace (int) __attribute__ ((__nothrow__ ));
extern int isupper (int) __attribute__ ((__nothrow__ ));
extern int isxdigit (int) __attribute__ ((__nothrow__ ));



extern int tolower (int __c) __attribute__ ((__nothrow__ ));


extern int toupper (int __c) __attribute__ ((__nothrow__ ));
# 136 "/usr/include/ctype.h" 3 4
extern int isblank (int) __attribute__ ((__nothrow__ ));
# 150 "/usr/include/ctype.h" 3 4
extern int isascii (int __c) __attribute__ ((__nothrow__ ));



extern int toascii (int __c) __attribute__ ((__nothrow__ ));



extern int _toupper (int) __attribute__ ((__nothrow__ ));
extern int _tolower (int) __attribute__ ((__nothrow__ ));
# 214 "/usr/include/ctype.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) tolower (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
}

extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) toupper (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
}
# 271 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int isalpha_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int iscntrl_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int isdigit_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int islower_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int isgraph_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int isprint_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int ispunct_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int isspace_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int isupper_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int isxdigit_l (int, __locale_t) __attribute__ ((__nothrow__ ));

extern int isblank_l (int, __locale_t) __attribute__ ((__nothrow__ ));



extern int __tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ ));
extern int tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ ));


extern int __toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ ));
extern int toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ ));
# 35 "../lib/curl_setup_once.h" 2


# 1 "/usr/include/errno.h" 1 3 4
# 35 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
extern int *__errno_location (void) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 36 "/usr/include/errno.h" 2 3 4
# 38 "../lib/curl_setup_once.h" 2
# 53 "../lib/curl_setup_once.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 105 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };
# 106 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 209 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
# 238 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
# 263 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
# 284 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ ));





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ ));
# 321 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ ));
# 399 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename,
      struct stat *__stat_buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename,
       struct stat *__stat_buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename,
         struct stat *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4)));
# 442 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 5)));




extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) stat (const char *__path, struct stat *__statbuf)
{
  return __xstat (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) lstat (const char *__path, struct stat *__statbuf)
{
  return __lxstat (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) fstat (int __fd, struct stat *__statbuf)
{
  return __fxstat (1, __fd, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) fstatat (int __fd, const char *__filename, struct stat *__statbuf, int __flag)

{
  return __fxstatat (1, __fd, __filename, __statbuf, __flag);
}



extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) mknod (const char *__path, __mode_t __mode, __dev_t __dev)
{
  return __xmknod (0, __path, __mode, &__dev);
}



extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) mknodat (int __fd, const char *__path, __mode_t __mode, __dev_t __dev)

{
  return __xmknodat (0, __fd, __path, __mode, &__dev);
}
# 54 "../lib/curl_setup_once.h" 2



# 1 "/usr/include/x86_64-linux-gnu/sys/time.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/time.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/sys/time.h" 2 3 4
# 55 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 71 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));




extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     __attribute__ ((__nothrow__ ));





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) __attribute__ ((__nothrow__ ));




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };






typedef int __itimer_which_t;




extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) __attribute__ ((__nothrow__ ));




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) __attribute__ ((__nothrow__ ));




extern int utimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern int lutimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) __attribute__ ((__nothrow__ ));
# 58 "../lib/curl_setup_once.h" 2

# 1 "/usr/include/time.h" 1 3 4
# 37 "/usr/include/time.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 38 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 42 "/usr/include/time.h" 2 3 4
# 133 "/usr/include/time.h" 3 4
struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 161 "/usr/include/time.h" 3 4
struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 189 "/usr/include/time.h" 3 4
extern clock_t clock (void) __attribute__ ((__nothrow__ ));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ ));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ ));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ ));
# 223 "/usr/include/time.h" 3 4
extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) __attribute__ ((__nothrow__ ));
# 239 "/usr/include/time.h" 3 4
extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ ));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ ));





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ ));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ ));





extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ ));


extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ ));







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ ));


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ ));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ ));



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) __attribute__ ((__nothrow__ ));
# 319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ ));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ ));


extern int dysize (int __year) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 334 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ ));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ ));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ ));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ ));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ ));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ ));


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ ));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ ));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ ));
# 60 "../lib/curl_setup_once.h" 2
# 73 "../lib/curl_setup_once.h"
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stdbool.h" 1 3
# 74 "../lib/curl_setup_once.h" 2



# 1 "/usr/include/unistd.h" 1 3 4
# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 255 "/usr/include/unistd.h" 3 4
typedef __useconds_t useconds_t;
# 267 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 304 "/usr/include/unistd.h" 3 4
extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;
# 334 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ ));
# 353 "/usr/include/unistd.h" 3 4
extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 376 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 417 "/usr/include/unistd.h" 3 4
extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ )) ;
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ ));
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ ));






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ )) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ )) ;
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ )) ;
# 525 "/usr/include/unistd.h" 3 4
extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__ )) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ ));
# 543 "/usr/include/unistd.h" 3 4
extern char **__environ;







extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
# 598 "/usr/include/unistd.h" 3 4
extern int nice (int __inc) __attribute__ ((__nothrow__ )) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));






# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ ));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ ));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ ));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ ));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ ));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ ));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ ));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ ));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ ));
# 660 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ ));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ ));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ ));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ ));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ ));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ ));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ ));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ )) ;
# 700 "/usr/include/unistd.h" 3 4
extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ )) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ )) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ )) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ )) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ )) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ )) ;
# 756 "/usr/include/unistd.h" 3 4
extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ ));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ ));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__ ));





extern int ttyslot (void) __attribute__ ((__nothrow__ ));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ ));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ ));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 871 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 57 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 71 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 150 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ ));
# 872 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__ )) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__ ));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ ));



extern char *getusershell (void) __attribute__ ((__nothrow__ ));
extern void endusershell (void) __attribute__ ((__nothrow__ ));
extern void setusershell (void) __attribute__ ((__nothrow__ ));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ )) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);
# 969 "/usr/include/unistd.h" 3 4
extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ ));





extern int getpagesize (void) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ ));
# 993 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
# 1016 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ )) ;
# 1037 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ )) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ ));
# 1058 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ ));
# 1081 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1112 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);
# 78 "../lib/curl_setup_once.h" 2
# 666 "../lib/curl_setup.h" 2
# 24 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2


# 1 "/usr/include/netinet/in.h" 1 3 4
# 22 "/usr/include/netinet/in.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stdint.h" 1 3 4
# 63 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
# 48 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
# 65 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 90 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 103 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 122 "/usr/include/stdint.h" 3 4
typedef unsigned long int uintptr_t;
# 134 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
# 64 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stdint.h" 2 3 4
# 23 "/usr/include/netinet/in.h" 2 3 4







typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };



# 1 "/usr/include/x86_64-linux-gnu/bits/in.h" 1 3 4
# 112 "/usr/include/x86_64-linux-gnu/bits/in.h" 3 4
struct ip_opts
  {
    struct in_addr ip_dst;
    char ip_opts[40];
  };


struct ip_mreqn
  {
    struct in_addr imr_multiaddr;
    struct in_addr imr_address;
    int imr_ifindex;
  };


struct in_pktinfo
  {
    int ipi_ifindex;
    struct in_addr ipi_spec_dst;
    struct in_addr ipi_addr;
  };
# 38 "/usr/include/netinet/in.h" 2 3 4


enum
  {
    IPPROTO_IP = 0,

    IPPROTO_ICMP = 1,

    IPPROTO_IGMP = 2,

    IPPROTO_IPIP = 4,

    IPPROTO_TCP = 6,

    IPPROTO_EGP = 8,

    IPPROTO_PUP = 12,

    IPPROTO_UDP = 17,

    IPPROTO_IDP = 22,

    IPPROTO_TP = 29,

    IPPROTO_DCCP = 33,

    IPPROTO_IPV6 = 41,

    IPPROTO_RSVP = 46,

    IPPROTO_GRE = 47,

    IPPROTO_ESP = 50,

    IPPROTO_AH = 51,

    IPPROTO_MTP = 92,

    IPPROTO_BEETPH = 94,

    IPPROTO_ENCAP = 98,

    IPPROTO_PIM = 103,

    IPPROTO_COMP = 108,

    IPPROTO_SCTP = 132,

    IPPROTO_UDPLITE = 136,

    IPPROTO_RAW = 255,

    IPPROTO_MAX
  };





enum
  {
    IPPROTO_HOPOPTS = 0,

    IPPROTO_ROUTING = 43,

    IPPROTO_FRAGMENT = 44,

    IPPROTO_ICMPV6 = 58,

    IPPROTO_NONE = 59,

    IPPROTO_DSTOPTS = 60,

    IPPROTO_MH = 135

  };



typedef uint16_t in_port_t;


enum
  {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,


    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,


    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,


    IPPORT_RESERVED = 1024,


    IPPORT_USERRESERVED = 5000
  };
# 209 "/usr/include/netinet/in.h" 3 4
struct in6_addr
  {
    union
      {
 uint8_t __u6_addr8[16];

 uint16_t __u6_addr16[8];
 uint32_t __u6_addr32[4];

      } __in6_u;





  };


extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
# 237 "/usr/include/netinet/in.h" 3 4
struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;


    unsigned char sin_zero[sizeof (struct sockaddr) -
      (sizeof (unsigned short int)) -
      sizeof (in_port_t) -
      sizeof (struct in_addr)];
  };



struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
  };




struct ip_mreq
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;
  };

struct ip_mreq_source
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;


    struct in_addr imr_sourceaddr;
  };




struct ipv6_mreq
  {

    struct in6_addr ipv6mr_multiaddr;


    unsigned int ipv6mr_interface;
  };




struct group_req
  {

    uint32_t gr_interface;


    struct sockaddr_storage gr_group;
  };

struct group_source_req
  {

    uint32_t gsr_interface;


    struct sockaddr_storage gsr_group;


    struct sockaddr_storage gsr_source;
  };



struct ip_msfilter
  {

    struct in_addr imsf_multiaddr;


    struct in_addr imsf_interface;


    uint32_t imsf_fmode;


    uint32_t imsf_numsrc;

    struct in_addr imsf_slist[1];
  };





struct group_filter
  {

    uint32_t gf_interface;


    struct sockaddr_storage gf_group;


    uint32_t gf_fmode;


    uint32_t gf_numsrc;

    struct sockaddr_storage gf_slist[1];
};
# 374 "/usr/include/netinet/in.h" 3 4
extern uint32_t ntohl (uint32_t __netlong) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
extern uint16_t ntohs (uint16_t __netshort)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
extern uint32_t htonl (uint32_t __hostlong)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));





# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 386 "/usr/include/netinet/in.h" 2 3 4
# 501 "/usr/include/netinet/in.h" 3 4
extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) __attribute__ ((__nothrow__ ));


extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     __attribute__ ((__nothrow__ ));
# 27 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2


# 1 "/usr/include/netdb.h" 1 3 4
# 32 "/usr/include/netdb.h" 3 4
# 1 "/usr/include/rpc/netdb.h" 1 3 4
# 42 "/usr/include/rpc/netdb.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 43 "/usr/include/rpc/netdb.h" 2 3 4



struct rpcent
{
  char *r_name;
  char **r_aliases;
  int r_number;
};

extern void setrpcent (int __stayopen) __attribute__ ((__nothrow__ ));
extern void endrpcent (void) __attribute__ ((__nothrow__ ));
extern struct rpcent *getrpcbyname (const char *__name) __attribute__ ((__nothrow__ ));
extern struct rpcent *getrpcbynumber (int __number) __attribute__ ((__nothrow__ ));
extern struct rpcent *getrpcent (void) __attribute__ ((__nothrow__ ));


extern int getrpcbyname_r (const char *__name, struct rpcent *__result_buf,
      char *__buffer, size_t __buflen,
      struct rpcent **__result) __attribute__ ((__nothrow__ ));

extern int getrpcbynumber_r (int __number, struct rpcent *__result_buf,
        char *__buffer, size_t __buflen,
        struct rpcent **__result) __attribute__ ((__nothrow__ ));

extern int getrpcent_r (struct rpcent *__result_buf, char *__buffer,
   size_t __buflen, struct rpcent **__result) __attribute__ ((__nothrow__ ));
# 33 "/usr/include/netdb.h" 2 3 4
# 42 "/usr/include/netdb.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/netdb.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/netdb.h" 3 4
struct netent
{
  char *n_name;
  char **n_aliases;
  int n_addrtype;
  uint32_t n_net;
};
# 43 "/usr/include/netdb.h" 2 3 4
# 61 "/usr/include/netdb.h" 3 4
extern int *__h_errno_location (void) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 92 "/usr/include/netdb.h" 3 4
extern void herror (const char *__str) __attribute__ ((__nothrow__ ));


extern const char *hstrerror (int __err_num) __attribute__ ((__nothrow__ ));




struct hostent
{
  char *h_name;
  char **h_aliases;
  int h_addrtype;
  int h_length;
  char **h_addr_list;



};






extern void sethostent (int __stay_open);





extern void endhostent (void);






extern struct hostent *gethostent (void);






extern struct hostent *gethostbyaddr (const void *__addr, __socklen_t __len,
          int __type);





extern struct hostent *gethostbyname (const char *__name);
# 155 "/usr/include/netdb.h" 3 4
extern struct hostent *gethostbyname2 (const char *__name, int __af);
# 167 "/usr/include/netdb.h" 3 4
extern int gethostent_r (struct hostent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct hostent **__restrict __result,
    int *__restrict __h_errnop);

extern int gethostbyaddr_r (const void *__restrict __addr, __socklen_t __len,
       int __type,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname_r (const char *__restrict __name,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname2_r (const char *__restrict __name, int __af,
        struct hostent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct hostent **__restrict __result,
        int *__restrict __h_errnop);
# 198 "/usr/include/netdb.h" 3 4
extern void setnetent (int __stay_open);





extern void endnetent (void);






extern struct netent *getnetent (void);






extern struct netent *getnetbyaddr (uint32_t __net, int __type);





extern struct netent *getnetbyname (const char *__name);
# 237 "/usr/include/netdb.h" 3 4
extern int getnetent_r (struct netent *__restrict __result_buf,
   char *__restrict __buf, size_t __buflen,
   struct netent **__restrict __result,
   int *__restrict __h_errnop);

extern int getnetbyaddr_r (uint32_t __net, int __type,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);

extern int getnetbyname_r (const char *__restrict __name,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);




struct servent
{
  char *s_name;
  char **s_aliases;
  int s_port;
  char *s_proto;
};






extern void setservent (int __stay_open);





extern void endservent (void);






extern struct servent *getservent (void);






extern struct servent *getservbyname (const char *__name, const char *__proto);






extern struct servent *getservbyport (int __port, const char *__proto);
# 308 "/usr/include/netdb.h" 3 4
extern int getservent_r (struct servent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct servent **__restrict __result);

extern int getservbyname_r (const char *__restrict __name,
       const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);

extern int getservbyport_r (int __port, const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);




struct protoent
{
  char *p_name;
  char **p_aliases;
  int p_proto;
};






extern void setprotoent (int __stay_open);





extern void endprotoent (void);






extern struct protoent *getprotoent (void);





extern struct protoent *getprotobyname (const char *__name);





extern struct protoent *getprotobynumber (int __proto);
# 374 "/usr/include/netdb.h" 3 4
extern int getprotoent_r (struct protoent *__restrict __result_buf,
     char *__restrict __buf, size_t __buflen,
     struct protoent **__restrict __result);

extern int getprotobyname_r (const char *__restrict __name,
        struct protoent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct protoent **__restrict __result);

extern int getprotobynumber_r (int __proto,
          struct protoent *__restrict __result_buf,
          char *__restrict __buf, size_t __buflen,
          struct protoent **__restrict __result);
# 395 "/usr/include/netdb.h" 3 4
extern int setnetgrent (const char *__netgroup);







extern void endnetgrent (void);
# 412 "/usr/include/netdb.h" 3 4
extern int getnetgrent (char **__restrict __hostp,
   char **__restrict __userp,
   char **__restrict __domainp);
# 423 "/usr/include/netdb.h" 3 4
extern int innetgr (const char *__netgroup, const char *__host,
      const char *__user, const char *__domain);







extern int getnetgrent_r (char **__restrict __hostp,
     char **__restrict __userp,
     char **__restrict __domainp,
     char *__restrict __buffer, size_t __buflen);
# 451 "/usr/include/netdb.h" 3 4
extern int rcmd (char **__restrict __ahost, unsigned short int __rport,
   const char *__restrict __locuser,
   const char *__restrict __remuser,
   const char *__restrict __cmd, int *__restrict __fd2p);
# 463 "/usr/include/netdb.h" 3 4
extern int rcmd_af (char **__restrict __ahost, unsigned short int __rport,
      const char *__restrict __locuser,
      const char *__restrict __remuser,
      const char *__restrict __cmd, int *__restrict __fd2p,
      sa_family_t __af);
# 479 "/usr/include/netdb.h" 3 4
extern int rexec (char **__restrict __ahost, int __rport,
    const char *__restrict __name,
    const char *__restrict __pass,
    const char *__restrict __cmd, int *__restrict __fd2p);
# 491 "/usr/include/netdb.h" 3 4
extern int rexec_af (char **__restrict __ahost, int __rport,
       const char *__restrict __name,
       const char *__restrict __pass,
       const char *__restrict __cmd, int *__restrict __fd2p,
       sa_family_t __af);
# 505 "/usr/include/netdb.h" 3 4
extern int ruserok (const char *__rhost, int __suser,
      const char *__remuser, const char *__locuser);
# 515 "/usr/include/netdb.h" 3 4
extern int ruserok_af (const char *__rhost, int __suser,
         const char *__remuser, const char *__locuser,
         sa_family_t __af);
# 528 "/usr/include/netdb.h" 3 4
extern int iruserok (uint32_t __raddr, int __suser,
       const char *__remuser, const char *__locuser);
# 539 "/usr/include/netdb.h" 3 4
extern int iruserok_af (const void *__raddr, int __suser,
   const char *__remuser, const char *__locuser,
   sa_family_t __af);
# 551 "/usr/include/netdb.h" 3 4
extern int rresvport (int *__alport);
# 560 "/usr/include/netdb.h" 3 4
extern int rresvport_af (int *__alport, sa_family_t __af);






struct addrinfo
{
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  socklen_t ai_addrlen;
  struct sockaddr *ai_addr;
  char *ai_canonname;
  struct addrinfo *ai_next;
};
# 662 "/usr/include/netdb.h" 3 4
extern int getaddrinfo (const char *__restrict __name,
   const char *__restrict __service,
   const struct addrinfo *__restrict __req,
   struct addrinfo **__restrict __pai);


extern void freeaddrinfo (struct addrinfo *__ai) __attribute__ ((__nothrow__ ));


extern const char *gai_strerror (int __ecode) __attribute__ ((__nothrow__ ));





extern int getnameinfo (const struct sockaddr *__restrict __sa,
   socklen_t __salen, char *__restrict __host,
   socklen_t __hostlen, char *__restrict __serv,
   socklen_t __servlen, int __flags);
# 30 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2


# 1 "/usr/include/arpa/inet.h" 1 3 4
# 34 "/usr/include/arpa/inet.h" 3 4
extern in_addr_t inet_addr (const char *__cp) __attribute__ ((__nothrow__ ));


extern in_addr_t inet_lnaof (struct in_addr __in) __attribute__ ((__nothrow__ ));



extern struct in_addr inet_makeaddr (in_addr_t __net, in_addr_t __host)
     __attribute__ ((__nothrow__ ));


extern in_addr_t inet_netof (struct in_addr __in) __attribute__ ((__nothrow__ ));



extern in_addr_t inet_network (const char *__cp) __attribute__ ((__nothrow__ ));



extern char *inet_ntoa (struct in_addr __in) __attribute__ ((__nothrow__ ));




extern int inet_pton (int __af, const char *__restrict __cp,
        void *__restrict __buf) __attribute__ ((__nothrow__ ));




extern const char *inet_ntop (int __af, const void *__restrict __cp,
         char *__restrict __buf, socklen_t __len)
     __attribute__ ((__nothrow__ ));






extern int inet_aton (const char *__cp, struct in_addr *__inp) __attribute__ ((__nothrow__ ));



extern char *inet_neta (in_addr_t __net, char *__buf, size_t __len) __attribute__ ((__nothrow__ ));




extern char *inet_net_ntop (int __af, const void *__cp, int __bits,
       char *__buf, size_t __len) __attribute__ ((__nothrow__ ));




extern int inet_net_pton (int __af, const char *__cp,
     void *__buf, size_t __len) __attribute__ ((__nothrow__ ));




extern unsigned int inet_nsap_addr (const char *__cp,
        unsigned char *__buf, int __len) __attribute__ ((__nothrow__ ));



extern char *inet_nsap_ntoa (int __len, const unsigned char *__cp,
        char *__buf) __attribute__ ((__nothrow__ ));
# 33 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2


# 1 "/usr/include/net/if.h" 1 3 4
# 33 "/usr/include/net/if.h" 3 4
struct if_nameindex
  {
    unsigned int if_index;
    char *if_name;
  };




enum
  {
    IFF_UP = 0x1,

    IFF_BROADCAST = 0x2,

    IFF_DEBUG = 0x4,

    IFF_LOOPBACK = 0x8,

    IFF_POINTOPOINT = 0x10,

    IFF_NOTRAILERS = 0x20,

    IFF_RUNNING = 0x40,

    IFF_NOARP = 0x80,

    IFF_PROMISC = 0x100,



    IFF_ALLMULTI = 0x200,


    IFF_MASTER = 0x400,

    IFF_SLAVE = 0x800,


    IFF_MULTICAST = 0x1000,


    IFF_PORTSEL = 0x2000,

    IFF_AUTOMEDIA = 0x4000,

    IFF_DYNAMIC = 0x8000

  };






struct ifaddr
  {
    struct sockaddr ifa_addr;
    union
      {
 struct sockaddr ifu_broadaddr;
 struct sockaddr ifu_dstaddr;
      } ifa_ifu;
    struct iface *ifa_ifp;
    struct ifaddr *ifa_next;
  };
# 111 "/usr/include/net/if.h" 3 4
struct ifmap
  {
    unsigned long int mem_start;
    unsigned long int mem_end;
    unsigned short int base_addr;
    unsigned char irq;
    unsigned char dma;
    unsigned char port;

  };





struct ifreq
  {


    union
      {
 char ifrn_name[16];
      } ifr_ifrn;

    union
      {
 struct sockaddr ifru_addr;
 struct sockaddr ifru_dstaddr;
 struct sockaddr ifru_broadaddr;
 struct sockaddr ifru_netmask;
 struct sockaddr ifru_hwaddr;
 short int ifru_flags;
 int ifru_ivalue;
 int ifru_mtu;
 struct ifmap ifru_map;
 char ifru_slave[16];
 char ifru_newname[16];
 __caddr_t ifru_data;
      } ifr_ifru;
  };
# 176 "/usr/include/net/if.h" 3 4
struct ifconf
  {
    int ifc_len;
    union
      {
 __caddr_t ifcu_buf;
 struct ifreq *ifcu_req;
      } ifc_ifcu;
  };
# 193 "/usr/include/net/if.h" 3 4
extern unsigned int if_nametoindex (const char *__ifname) __attribute__ ((__nothrow__ ));
extern char *if_indextoname (unsigned int __ifindex, char *__ifname) __attribute__ ((__nothrow__ ));


extern struct if_nameindex *if_nameindex (void) __attribute__ ((__nothrow__ ));


extern void if_freenameindex (struct if_nameindex *__ptr) __attribute__ ((__nothrow__ ));
# 36 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2


# 1 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/ioctls.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/ioctls.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/ioctls.h" 1 3 4
# 1 "/usr/include/asm-generic/ioctls.h" 1 3 4



# 1 "/usr/include/linux/ioctl.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/asm/ioctl.h" 1 3 4
# 1 "/usr/include/asm-generic/ioctl.h" 1 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/ioctl.h" 2 3 4
# 5 "/usr/include/linux/ioctl.h" 2 3 4
# 5 "/usr/include/asm-generic/ioctls.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/ioctls.h" 2 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/ioctls.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/ioctls.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h" 2 3 4


struct winsize
  {
    unsigned short int ws_row;
    unsigned short int ws_col;
    unsigned short int ws_xpixel;
    unsigned short int ws_ypixel;
  };


struct termio
  {
    unsigned short int c_iflag;
    unsigned short int c_oflag;
    unsigned short int c_cflag;
    unsigned short int c_lflag;
    unsigned char c_line;
    unsigned char c_cc[8];
};
# 30 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/sys/ttydefaults.h" 1 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/ioctl.h" 2 3 4




extern int ioctl (int __fd, unsigned long int __request, ...) __attribute__ ((__nothrow__ ));
# 39 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2



# 1 "/usr/include/x86_64-linux-gnu/sys/param.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/sys/param.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4


# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/limits.h" 1 3 4
# 37 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 143 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 144 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 148 "/usr/include/limits.h" 2 3 4
# 38 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/limits.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4

# 1 "/usr/include/signal.h" 1 3 4
# 32 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 102 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
extern int __sigismember (const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);
# 116 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int __sigismember (const __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return (__set->__val[__word] & __mask) ? 1 : 0; }
extern __inline __attribute__ ((__gnu_inline__)) int __sigaddset ( __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return ((__set->__val[__word] |= __mask), 0); }
extern __inline __attribute__ ((__gnu_inline__)) int __sigdelset ( __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return ((__set->__val[__word] &= ~__mask), 0); }
# 33 "/usr/include/signal.h" 2 3 4







typedef __sig_atomic_t sig_atomic_t;
# 57 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/signum.h" 1 3 4
# 58 "/usr/include/signal.h" 2 3 4
# 80 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 2 3 4







typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;
# 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 3 4
typedef __clock_t __sigchld_clock_t;



typedef struct
  {
    int si_signo;
    int si_errno;

    int si_code;

    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __sigchld_clock_t si_utime;
     __sigchld_clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
     short int si_addr_lsb;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;


 struct
   {
     void *_call_addr;
     int _syscall;
     unsigned int _arch;
   } _sigsys;
      } _sifields;
  } siginfo_t ;
# 153 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 3 4
enum
{
  SI_ASYNCNL = -60,

  SI_TKILL = -6,

  SI_SIGIO,

  SI_ASYNCIO,

  SI_MESGQ,

  SI_TIMER,

  SI_QUEUE,

  SI_USER,

  SI_KERNEL = 0x80

};



enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR,

  BUS_MCEERR_AR,

  BUS_MCEERR_AO

};


enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE

};


enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};
# 307 "/usr/include/x86_64-linux-gnu/bits/siginfo.h" 3 4
typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;






enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4

};
# 81 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ ));
# 102 "/usr/include/signal.h" 3 4
extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ ));
# 127 "/usr/include/signal.h" 3 4
extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__ ));






extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__ ));




extern int raise (int __sig) __attribute__ ((__nothrow__ ));




extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ ));
extern int gsignal (int __sig) __attribute__ ((__nothrow__ ));




extern void psignal (int __sig, const char *__s);




extern void psiginfo (const siginfo_t *__pinfo, const char *__s);
# 167 "/usr/include/signal.h" 3 4
extern int __sigpause (int __sig_or_mask, int __is_sig);
# 189 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) __attribute__ ((__nothrow__ )) __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) __attribute__ ((__nothrow__ )) __attribute__ ((__deprecated__));


extern int siggetmask (void) __attribute__ ((__nothrow__ )) __attribute__ ((__deprecated__));
# 209 "/usr/include/signal.h" 3 4
typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int sigismember (const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 245 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 246 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__ ));






extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__ ));


extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));






extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));






extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     __attribute__ ((__nothrow__ ));
# 303 "/usr/include/signal.h" 3 4
extern const char *const _sys_siglist[65];
extern const char *const sys_siglist[65];


struct sigvec
  {
    __sighandler_t sv_handler;
    int sv_mask;

    int sv_flags;

  };
# 327 "/usr/include/signal.h" 3 4
extern int sigvec (int __sig, const struct sigvec *__vec,
     struct sigvec *__ovec) __attribute__ ((__nothrow__ ));




# 1 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpx_sw_bytes
{
  __uint32_t magic1;
  __uint32_t extended_size;
  __uint64_t xstate_bv;
  __uint32_t xstate_size;
  __uint32_t padding[7];
};

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short padding[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};
# 121 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _fpxreg _st[8];
  struct _xmmreg _xmm[16];
  __uint32_t padding[24];
};

struct sigcontext
{
  __uint64_t r8;
  __uint64_t r9;
  __uint64_t r10;
  __uint64_t r11;
  __uint64_t r12;
  __uint64_t r13;
  __uint64_t r14;
  __uint64_t r15;
  __uint64_t rdi;
  __uint64_t rsi;
  __uint64_t rbp;
  __uint64_t rbx;
  __uint64_t rdx;
  __uint64_t rax;
  __uint64_t rcx;
  __uint64_t rsp;
  __uint64_t rip;
  __uint64_t eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  __uint64_t err;
  __uint64_t trapno;
  __uint64_t oldmask;
  __uint64_t cr2;
  __extension__ union
    {
      struct _fpstate * fpstate;
      __uint64_t __fpstate_word;
    };
  __uint64_t __reserved1 [8];
};



struct _xsave_hdr
{
  __uint64_t xstate_bv;
  __uint64_t reserved1[2];
  __uint64_t reserved2[5];
};

struct _ymmh_state
{
  __uint32_t ymmh_space[64];
};

struct _xstate
{
  struct _fpstate fpstate;
  struct _xsave_hdr xstate_hdr;
  struct _ymmh_state ymmh;
};
# 333 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__ ));







# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 343 "/usr/include/signal.h" 2 3 4




extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__ ));


# 1 "/usr/include/x86_64-linux-gnu/bits/sigstack.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };



enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 49 "/usr/include/x86_64-linux-gnu/bits/sigstack.h" 3 4
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 350 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
# 1 "/usr/include/signal.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 2 3 4








__extension__ typedef long long int greg_t;





typedef greg_t gregset_t[23];
# 92 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
struct _libc_fpxreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
  unsigned short int padding[3];
};

struct _libc_xmmreg
{
  __uint32_t element[4];
};

struct _libc_fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _libc_fpxreg _st[8];
  struct _libc_xmmreg _xmm[16];
  __uint32_t padding[24];
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;

    fpregset_t fpregs;
    __extension__ unsigned long long __reserved1 [8];
} mcontext_t;


typedef struct ucontext
  {
    unsigned long int uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;
# 353 "/usr/include/signal.h" 2 3 4





extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__ )) __attribute__ ((__deprecated__));



extern int sigaltstack (const struct sigaltstack *__restrict __ss,
   struct sigaltstack *__restrict __oss) __attribute__ ((__nothrow__ ));
# 388 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__ ));


extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__ ));
# 389 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__ ));

extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__ ));
# 29 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/param.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/param.h" 3 4
# 1 "/usr/include/linux/param.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/asm/param.h" 1 3 4
# 1 "/usr/include/asm-generic/param.h" 1 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/param.h" 2 3 4
# 5 "/usr/include/linux/param.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/param.h" 2 3 4
# 32 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4
# 43 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2








# 1 "/usr/include/x86_64-linux-gnu/sys/un.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/sys/un.h" 3 4
struct sockaddr_un
  {
    sa_family_t sun_family;
    char sun_path[108];
  };
# 52 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 81 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
# 1 "../lib/urldata.h" 1
# 82 "../lib/urldata.h"
# 1 "../lib/cookie.h" 1
# 26 "../lib/cookie.h"
# 1 "../include/curl/curl.h" 1
# 33 "../include/curl/curl.h"
# 1 "../include/curl/curlver.h" 1
# 34 "../include/curl/curl.h" 2
# 93 "../include/curl/curl.h"
typedef void CURL;
# 119 "../include/curl/curl.h"
typedef int curl_socket_t;





struct curl_httppost {
  struct curl_httppost *next;
  char *name;
  long namelength;
  char *contents;
  long contentslength;
  char *buffer;
  long bufferlength;
  char *contenttype;
  struct curl_slist* contentheader;
  struct curl_httppost *more;


  long flags;
# 152 "../include/curl/curl.h"
  char *showfilename;


  void *userp;

};



typedef int (*curl_progress_callback)(void *clientp,
                                      double dltotal,
                                      double dlnow,
                                      double ultotal,
                                      double ulnow);



typedef int (*curl_xferinfo_callback)(void *clientp,
                                      curl_off_t dltotal,
                                      curl_off_t dlnow,
                                      curl_off_t ultotal,
                                      curl_off_t ulnow);
# 196 "../include/curl/curl.h"
typedef size_t (*curl_write_callback)(char *buffer,
                                      size_t size,
                                      size_t nitems,
                                      void *outstream);




typedef enum {
  CURLFILETYPE_FILE = 0,
  CURLFILETYPE_DIRECTORY,
  CURLFILETYPE_SYMLINK,
  CURLFILETYPE_DEVICE_BLOCK,
  CURLFILETYPE_DEVICE_CHAR,
  CURLFILETYPE_NAMEDPIPE,
  CURLFILETYPE_SOCKET,
  CURLFILETYPE_DOOR,

  CURLFILETYPE_UNKNOWN
} curlfiletype;
# 230 "../include/curl/curl.h"
struct curl_fileinfo {
  char *filename;
  curlfiletype filetype;
  time_t time;
  unsigned int perm;
  int uid;
  int gid;
  curl_off_t size;
  long int hardlinks;

  struct {

    char *time;
    char *perm;
    char *user;
    char *group;
    char *target;
  } strings;

  unsigned int flags;


  char * b_data;
  size_t b_size;
  size_t b_used;
};
# 265 "../include/curl/curl.h"
typedef long (*curl_chunk_bgn_callback)(const void *transfer_info,
                                        void *ptr,
                                        int remains);
# 279 "../include/curl/curl.h"
typedef long (*curl_chunk_end_callback)(void *ptr);
# 288 "../include/curl/curl.h"
typedef int (*curl_fnmatch_callback)(void *ptr,
                                     const char *pattern,
                                     const char *string);






typedef int (*curl_seek_callback)(void *instream,
                                  curl_off_t offset,
                                  int origin);
# 308 "../include/curl/curl.h"
typedef size_t (*curl_read_callback)(char *buffer,
                                      size_t size,
                                      size_t nitems,
                                      void *instream);

typedef enum {
  CURLSOCKTYPE_IPCXN,
  CURLSOCKTYPE_ACCEPT,
  CURLSOCKTYPE_LAST
} curlsocktype;
# 326 "../include/curl/curl.h"
typedef int (*curl_sockopt_callback)(void *clientp,
                                     curl_socket_t curlfd,
                                     curlsocktype purpose);

struct curl_sockaddr {
  int family;
  int socktype;
  int protocol;
  unsigned int addrlen;


  struct sockaddr addr;
};

typedef curl_socket_t
(*curl_opensocket_callback)(void *clientp,
                            curlsocktype purpose,
                            struct curl_sockaddr *address);

typedef int
(*curl_closesocket_callback)(void *clientp, curl_socket_t item);

typedef enum {
  CURLIOE_OK,
  CURLIOE_UNKNOWNCMD,
  CURLIOE_FAILRESTART,
  CURLIOE_LAST
} curlioerr;

typedef enum {
  CURLIOCMD_NOP,
  CURLIOCMD_RESTARTREAD,
  CURLIOCMD_LAST
} curliocmd;

typedef curlioerr (*curl_ioctl_callback)(CURL *handle,
                                         int cmd,
                                         void *clientp);







typedef void *(*curl_malloc_callback)(size_t size);
typedef void (*curl_free_callback)(void *ptr);
typedef void *(*curl_realloc_callback)(void *ptr, size_t size);
typedef char *(*curl_strdup_callback)(const char *str);
typedef void *(*curl_calloc_callback)(size_t nmemb, size_t size);


typedef enum {
  CURLINFO_TEXT = 0,
  CURLINFO_HEADER_IN,
  CURLINFO_HEADER_OUT,
  CURLINFO_DATA_IN,
  CURLINFO_DATA_OUT,
  CURLINFO_SSL_DATA_IN,
  CURLINFO_SSL_DATA_OUT,
  CURLINFO_END
} curl_infotype;

typedef int (*curl_debug_callback)
       (CURL *handle,
        curl_infotype type,
        char *data,
        size_t size,
        void *userptr);
# 403 "../include/curl/curl.h"
typedef enum {
  CURLE_OK = 0,
  CURLE_UNSUPPORTED_PROTOCOL,
  CURLE_FAILED_INIT,
  CURLE_URL_MALFORMAT,
  CURLE_NOT_BUILT_IN,

  CURLE_COULDNT_RESOLVE_PROXY,
  CURLE_COULDNT_RESOLVE_HOST,
  CURLE_COULDNT_CONNECT,
  CURLE_FTP_WEIRD_SERVER_REPLY,
  CURLE_REMOTE_ACCESS_DENIED,


  CURLE_FTP_ACCEPT_FAILED,

  CURLE_FTP_WEIRD_PASS_REPLY,
  CURLE_FTP_ACCEPT_TIMEOUT,


  CURLE_FTP_WEIRD_PASV_REPLY,
  CURLE_FTP_WEIRD_227_FORMAT,
  CURLE_FTP_CANT_GET_HOST,
  CURLE_HTTP2,


  CURLE_FTP_COULDNT_SET_TYPE,
  CURLE_PARTIAL_FILE,
  CURLE_FTP_COULDNT_RETR_FILE,
  CURLE_OBSOLETE20,
  CURLE_QUOTE_ERROR,
  CURLE_HTTP_RETURNED_ERROR,
  CURLE_WRITE_ERROR,
  CURLE_OBSOLETE24,
  CURLE_UPLOAD_FAILED,
  CURLE_READ_ERROR,
  CURLE_OUT_OF_MEMORY,




  CURLE_OPERATION_TIMEDOUT,
  CURLE_OBSOLETE29,
  CURLE_FTP_PORT_FAILED,
  CURLE_FTP_COULDNT_USE_REST,
  CURLE_OBSOLETE32,
  CURLE_RANGE_ERROR,
  CURLE_HTTP_POST_ERROR,
  CURLE_SSL_CONNECT_ERROR,
  CURLE_BAD_DOWNLOAD_RESUME,
  CURLE_FILE_COULDNT_READ_FILE,
  CURLE_LDAP_CANNOT_BIND,
  CURLE_LDAP_SEARCH_FAILED,
  CURLE_OBSOLETE40,
  CURLE_FUNCTION_NOT_FOUND,
  CURLE_ABORTED_BY_CALLBACK,
  CURLE_BAD_FUNCTION_ARGUMENT,
  CURLE_OBSOLETE44,
  CURLE_INTERFACE_FAILED,
  CURLE_OBSOLETE46,
  CURLE_TOO_MANY_REDIRECTS ,
  CURLE_UNKNOWN_OPTION,
  CURLE_TELNET_OPTION_SYNTAX ,
  CURLE_OBSOLETE50,
  CURLE_PEER_FAILED_VERIFICATION,

  CURLE_GOT_NOTHING,
  CURLE_SSL_ENGINE_NOTFOUND,
  CURLE_SSL_ENGINE_SETFAILED,

  CURLE_SEND_ERROR,
  CURLE_RECV_ERROR,
  CURLE_OBSOLETE57,
  CURLE_SSL_CERTPROBLEM,
  CURLE_SSL_CIPHER,
  CURLE_SSL_CACERT,
  CURLE_BAD_CONTENT_ENCODING,
  CURLE_LDAP_INVALID_URL,
  CURLE_FILESIZE_EXCEEDED,
  CURLE_USE_SSL_FAILED,
  CURLE_SEND_FAIL_REWIND,

  CURLE_SSL_ENGINE_INITFAILED,
  CURLE_LOGIN_DENIED,

  CURLE_TFTP_NOTFOUND,
  CURLE_TFTP_PERM,
  CURLE_REMOTE_DISK_FULL,
  CURLE_TFTP_ILLEGAL,
  CURLE_TFTP_UNKNOWNID,
  CURLE_REMOTE_FILE_EXISTS,
  CURLE_TFTP_NOSUCHUSER,
  CURLE_CONV_FAILED,
  CURLE_CONV_REQD,




  CURLE_SSL_CACERT_BADFILE,

  CURLE_REMOTE_FILE_NOT_FOUND,
  CURLE_SSH,



  CURLE_SSL_SHUTDOWN_FAILED,

  CURLE_AGAIN,


  CURLE_SSL_CRL_BADFILE,

  CURLE_SSL_ISSUER_ERROR,

  CURLE_FTP_PRET_FAILED,
  CURLE_RTSP_CSEQ_ERROR,
  CURLE_RTSP_SESSION_ERROR,
  CURLE_FTP_BAD_FILE_LIST,
  CURLE_CHUNK_FAILED,
  CURLE_NO_CONNECTION_AVAILABLE,

  CURLE_SSL_PINNEDPUBKEYNOTMATCH,

  CURLE_SSL_INVALIDCERTSTATUS,
  CURL_LAST
} CURLcode;
# 603 "../include/curl/curl.h"
typedef CURLcode (*curl_conv_callback)(char *buffer, size_t length);

typedef CURLcode (*curl_ssl_ctx_callback)(CURL *curl,
                                          void *ssl_ctx,

                                          void *userptr);

typedef enum {
  CURLPROXY_HTTP = 0,

  CURLPROXY_HTTP_1_0 = 1,

  CURLPROXY_SOCKS4 = 4,

  CURLPROXY_SOCKS5 = 5,
  CURLPROXY_SOCKS4A = 6,
  CURLPROXY_SOCKS5_HOSTNAME = 7


} curl_proxytype;
# 669 "../include/curl/curl.h"
enum curl_khtype {
  CURLKHTYPE_UNKNOWN,
  CURLKHTYPE_RSA1,
  CURLKHTYPE_RSA,
  CURLKHTYPE_DSS
};

struct curl_khkey {
  const char *key;

  size_t len;
  enum curl_khtype keytype;
};



enum curl_khstat {
  CURLKHSTAT_FINE_ADD_TO_FILE,
  CURLKHSTAT_FINE,
  CURLKHSTAT_REJECT,
  CURLKHSTAT_DEFER,


  CURLKHSTAT_LAST
};


enum curl_khmatch {
  CURLKHMATCH_OK,
  CURLKHMATCH_MISMATCH,
  CURLKHMATCH_MISSING,
  CURLKHMATCH_LAST
};

typedef int
  (*curl_sshkeycallback) (CURL *easy,
                          const struct curl_khkey *knownkey,
                          const struct curl_khkey *foundkey,
                          enum curl_khmatch,
                          void *clientp);


typedef enum {
  CURLUSESSL_NONE,
  CURLUSESSL_TRY,
  CURLUSESSL_CONTROL,
  CURLUSESSL_ALL,
  CURLUSESSL_LAST
} curl_usessl;
# 743 "../include/curl/curl.h"
typedef enum {
  CURLFTPSSL_CCC_NONE,
  CURLFTPSSL_CCC_PASSIVE,
  CURLFTPSSL_CCC_ACTIVE,
  CURLFTPSSL_CCC_LAST
} curl_ftpccc;


typedef enum {
  CURLFTPAUTH_DEFAULT,
  CURLFTPAUTH_SSL,
  CURLFTPAUTH_TLS,
  CURLFTPAUTH_LAST
} curl_ftpauth;


typedef enum {
  CURLFTP_CREATE_DIR_NONE,
  CURLFTP_CREATE_DIR,


  CURLFTP_CREATE_DIR_RETRY,

  CURLFTP_CREATE_DIR_LAST
} curl_ftpcreatedir;


typedef enum {
  CURLFTPMETHOD_DEFAULT,
  CURLFTPMETHOD_MULTICWD,
  CURLFTPMETHOD_NOCWD,
  CURLFTPMETHOD_SINGLECWD,
  CURLFTPMETHOD_LAST
} curl_ftpmethod;
# 844 "../include/curl/curl.h"
typedef enum {

  CURLOPT_WRITEDATA = 10000 + 1,


  CURLOPT_URL = 10000 + 2,


  CURLOPT_PORT = 0 + 3,


  CURLOPT_PROXY = 10000 + 4,


  CURLOPT_USERPWD = 10000 + 5,


  CURLOPT_PROXYUSERPWD = 10000 + 6,


  CURLOPT_RANGE = 10000 + 7,




  CURLOPT_READDATA = 10000 + 9,



  CURLOPT_ERRORBUFFER = 10000 + 10,



  CURLOPT_WRITEFUNCTION = 20000 + 11,



  CURLOPT_READFUNCTION = 20000 + 12,


  CURLOPT_TIMEOUT = 0 + 13,
# 895 "../include/curl/curl.h"
  CURLOPT_INFILESIZE = 0 + 14,


  CURLOPT_POSTFIELDS = 10000 + 15,


  CURLOPT_REFERER = 10000 + 16,



  CURLOPT_FTPPORT = 10000 + 17,


  CURLOPT_USERAGENT = 10000 + 18,
# 917 "../include/curl/curl.h"
  CURLOPT_LOW_SPEED_LIMIT = 0 + 19,


  CURLOPT_LOW_SPEED_TIME = 0 + 20,







  CURLOPT_RESUME_FROM = 0 + 21,


  CURLOPT_COOKIE = 10000 + 22,



  CURLOPT_HTTPHEADER = 10000 + 23,


  CURLOPT_HTTPPOST = 10000 + 24,


  CURLOPT_SSLCERT = 10000 + 25,


  CURLOPT_KEYPASSWD = 10000 + 26,


  CURLOPT_CRLF = 0 + 27,


  CURLOPT_QUOTE = 10000 + 28,



  CURLOPT_HEADERDATA = 10000 + 29,



  CURLOPT_COOKIEFILE = 10000 + 31,



  CURLOPT_SSLVERSION = 0 + 32,


  CURLOPT_TIMECONDITION = 0 + 33,



  CURLOPT_TIMEVALUE = 0 + 34,







  CURLOPT_CUSTOMREQUEST = 10000 + 36,


  CURLOPT_STDERR = 10000 + 37,




  CURLOPT_POSTQUOTE = 10000 + 39,

  CURLOPT_OBSOLETE40 = 10000 + 40,

  CURLOPT_VERBOSE = 0 + 41,
  CURLOPT_HEADER = 0 + 42,
  CURLOPT_NOPROGRESS = 0 + 43,
  CURLOPT_NOBODY = 0 + 44,
  CURLOPT_FAILONERROR = 0 + 45,
  CURLOPT_UPLOAD = 0 + 46,
  CURLOPT_POST = 0 + 47,
  CURLOPT_DIRLISTONLY = 0 + 48,

  CURLOPT_APPEND = 0 + 50,



  CURLOPT_NETRC = 0 + 51,

  CURLOPT_FOLLOWLOCATION = 0 + 52,

  CURLOPT_TRANSFERTEXT = 0 + 53,
  CURLOPT_PUT = 0 + 54,







  CURLOPT_PROGRESSFUNCTION = 20000 + 56,



  CURLOPT_PROGRESSDATA = 10000 + 57,



  CURLOPT_AUTOREFERER = 0 + 58,



  CURLOPT_PROXYPORT = 0 + 59,


  CURLOPT_POSTFIELDSIZE = 0 + 60,


  CURLOPT_HTTPPROXYTUNNEL = 0 + 61,


  CURLOPT_INTERFACE = 10000 + 62,




  CURLOPT_KRBLEVEL = 10000 + 63,


  CURLOPT_SSL_VERIFYPEER = 0 + 64,



  CURLOPT_CAINFO = 10000 + 65,





  CURLOPT_MAXREDIRS = 0 + 68,



  CURLOPT_FILETIME = 0 + 69,


  CURLOPT_TELNETOPTIONS = 10000 + 70,


  CURLOPT_MAXCONNECTS = 0 + 71,

  CURLOPT_OBSOLETE72 = 0 + 72,






  CURLOPT_FRESH_CONNECT = 0 + 74,




  CURLOPT_FORBID_REUSE = 0 + 75,



  CURLOPT_RANDOM_FILE = 10000 + 76,


  CURLOPT_EGDSOCKET = 10000 + 77,



  CURLOPT_CONNECTTIMEOUT = 0 + 78,



  CURLOPT_HEADERFUNCTION = 20000 + 79,




  CURLOPT_HTTPGET = 0 + 80,




  CURLOPT_SSL_VERIFYHOST = 0 + 81,



  CURLOPT_COOKIEJAR = 10000 + 82,


  CURLOPT_SSL_CIPHER_LIST = 10000 + 83,



  CURLOPT_HTTP_VERSION = 0 + 84,




  CURLOPT_FTP_USE_EPSV = 0 + 85,


  CURLOPT_SSLCERTTYPE = 10000 + 86,


  CURLOPT_SSLKEY = 10000 + 87,


  CURLOPT_SSLKEYTYPE = 10000 + 88,


  CURLOPT_SSLENGINE = 10000 + 89,




  CURLOPT_SSLENGINE_DEFAULT = 0 + 90,


  CURLOPT_DNS_USE_GLOBAL_CACHE = 0 + 91,


  CURLOPT_DNS_CACHE_TIMEOUT = 0 + 92,


  CURLOPT_PREQUOTE = 10000 + 93,


  CURLOPT_DEBUGFUNCTION = 20000 + 94,


  CURLOPT_DEBUGDATA = 10000 + 95,


  CURLOPT_COOKIESESSION = 0 + 96,



  CURLOPT_CAPATH = 10000 + 97,


  CURLOPT_BUFFERSIZE = 0 + 98,




  CURLOPT_NOSIGNAL = 0 + 99,


  CURLOPT_SHARE = 10000 + 100,



  CURLOPT_PROXYTYPE = 0 + 101,




  CURLOPT_ACCEPT_ENCODING = 10000 + 102,


  CURLOPT_PRIVATE = 10000 + 103,


  CURLOPT_HTTP200ALIASES = 10000 + 104,




  CURLOPT_UNRESTRICTED_AUTH = 0 + 105,




  CURLOPT_FTP_USE_EPRT = 0 + 106,




  CURLOPT_HTTPAUTH = 0 + 107,




  CURLOPT_SSL_CTX_FUNCTION = 20000 + 108,



  CURLOPT_SSL_CTX_DATA = 10000 + 109,





  CURLOPT_FTP_CREATE_MISSING_DIRS = 0 + 110,




  CURLOPT_PROXYAUTH = 0 + 111,





  CURLOPT_FTP_RESPONSE_TIMEOUT = 0 + 112,





  CURLOPT_IPRESOLVE = 0 + 113,






  CURLOPT_MAXFILESIZE = 0 + 114,




  CURLOPT_INFILESIZE_LARGE = 30000 + 115,




  CURLOPT_RESUME_FROM_LARGE = 30000 + 116,




  CURLOPT_MAXFILESIZE_LARGE = 30000 + 117,





  CURLOPT_NETRC_FILE = 10000 + 118,






  CURLOPT_USE_SSL = 0 + 119,


  CURLOPT_POSTFIELDSIZE_LARGE = 30000 + 120,


  CURLOPT_TCP_NODELAY = 0 + 121,
# 1292 "../include/curl/curl.h"
  CURLOPT_FTPSSLAUTH = 0 + 129,

  CURLOPT_IOCTLFUNCTION = 20000 + 130,
  CURLOPT_IOCTLDATA = 10000 + 131,






  CURLOPT_FTP_ACCOUNT = 10000 + 134,


  CURLOPT_COOKIELIST = 10000 + 135,


  CURLOPT_IGNORE_CONTENT_LENGTH = 0 + 136,





  CURLOPT_FTP_SKIP_PASV_IP = 0 + 137,



  CURLOPT_FTP_FILEMETHOD = 0 + 138,


  CURLOPT_LOCALPORT = 0 + 139,




  CURLOPT_LOCALPORTRANGE = 0 + 140,



  CURLOPT_CONNECT_ONLY = 0 + 141,



  CURLOPT_CONV_FROM_NETWORK_FUNCTION = 20000 + 142,



  CURLOPT_CONV_TO_NETWORK_FUNCTION = 20000 + 143,




  CURLOPT_CONV_FROM_UTF8_FUNCTION = 20000 + 144,



  CURLOPT_MAX_SEND_SPEED_LARGE = 30000 + 145,
  CURLOPT_MAX_RECV_SPEED_LARGE = 30000 + 146,


  CURLOPT_FTP_ALTERNATIVE_TO_USER = 10000 + 147,


  CURLOPT_SOCKOPTFUNCTION = 20000 + 148,
  CURLOPT_SOCKOPTDATA = 10000 + 149,



  CURLOPT_SSL_SESSIONID_CACHE = 0 + 150,


  CURLOPT_SSH_AUTH_TYPES = 0 + 151,


  CURLOPT_SSH_PUBLIC_KEYFILE = 10000 + 152,
  CURLOPT_SSH_PRIVATE_KEYFILE = 10000 + 153,


  CURLOPT_FTP_SSL_CCC = 0 + 154,


  CURLOPT_TIMEOUT_MS = 0 + 155,
  CURLOPT_CONNECTTIMEOUT_MS = 0 + 156,



  CURLOPT_HTTP_TRANSFER_DECODING = 0 + 157,
  CURLOPT_HTTP_CONTENT_DECODING = 0 + 158,



  CURLOPT_NEW_FILE_PERMS = 0 + 159,
  CURLOPT_NEW_DIRECTORY_PERMS = 0 + 160,



  CURLOPT_POSTREDIR = 0 + 161,


  CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 = 10000 + 162,





  CURLOPT_OPENSOCKETFUNCTION = 20000 + 163,
  CURLOPT_OPENSOCKETDATA = 10000 + 164,


  CURLOPT_COPYPOSTFIELDS = 10000 + 165,


  CURLOPT_PROXY_TRANSFER_MODE = 0 + 166,


  CURLOPT_SEEKFUNCTION = 20000 + 167,
  CURLOPT_SEEKDATA = 10000 + 168,


  CURLOPT_CRLFILE = 10000 + 169,


  CURLOPT_ISSUERCERT = 10000 + 170,


  CURLOPT_ADDRESS_SCOPE = 0 + 171,



  CURLOPT_CERTINFO = 0 + 172,


  CURLOPT_USERNAME = 10000 + 173,
  CURLOPT_PASSWORD = 10000 + 174,


  CURLOPT_PROXYUSERNAME = 10000 + 175,
  CURLOPT_PROXYPASSWORD = 10000 + 176,
# 1437 "../include/curl/curl.h"
  CURLOPT_NOPROXY = 10000 + 177,


  CURLOPT_TFTP_BLKSIZE = 0 + 178,


  CURLOPT_SOCKS5_GSSAPI_SERVICE = 10000 + 179,


  CURLOPT_SOCKS5_GSSAPI_NEC = 0 + 180,





  CURLOPT_PROTOCOLS = 0 + 181,





  CURLOPT_REDIR_PROTOCOLS = 0 + 182,


  CURLOPT_SSH_KNOWNHOSTS = 10000 + 183,



  CURLOPT_SSH_KEYFUNCTION = 20000 + 184,


  CURLOPT_SSH_KEYDATA = 10000 + 185,


  CURLOPT_MAIL_FROM = 10000 + 186,


  CURLOPT_MAIL_RCPT = 10000 + 187,


  CURLOPT_FTP_USE_PRET = 0 + 188,


  CURLOPT_RTSP_REQUEST = 0 + 189,


  CURLOPT_RTSP_SESSION_ID = 10000 + 190,


  CURLOPT_RTSP_STREAM_URI = 10000 + 191,


  CURLOPT_RTSP_TRANSPORT = 10000 + 192,


  CURLOPT_RTSP_CLIENT_CSEQ = 0 + 193,


  CURLOPT_RTSP_SERVER_CSEQ = 0 + 194,


  CURLOPT_INTERLEAVEDATA = 10000 + 195,


  CURLOPT_INTERLEAVEFUNCTION = 20000 + 196,


  CURLOPT_WILDCARDMATCH = 0 + 197,



  CURLOPT_CHUNK_BGN_FUNCTION = 20000 + 198,



  CURLOPT_CHUNK_END_FUNCTION = 20000 + 199,


  CURLOPT_FNMATCH_FUNCTION = 20000 + 200,


  CURLOPT_CHUNK_DATA = 10000 + 201,


  CURLOPT_FNMATCH_DATA = 10000 + 202,


  CURLOPT_RESOLVE = 10000 + 203,


  CURLOPT_TLSAUTH_USERNAME = 10000 + 204,


  CURLOPT_TLSAUTH_PASSWORD = 10000 + 205,


  CURLOPT_TLSAUTH_TYPE = 10000 + 206,
# 1545 "../include/curl/curl.h"
  CURLOPT_TRANSFER_ENCODING = 0 + 207,



  CURLOPT_CLOSESOCKETFUNCTION = 20000 + 208,
  CURLOPT_CLOSESOCKETDATA = 10000 + 209,


  CURLOPT_GSSAPI_DELEGATION = 0 + 210,


  CURLOPT_DNS_SERVERS = 10000 + 211,



  CURLOPT_ACCEPTTIMEOUT_MS = 0 + 212,


  CURLOPT_TCP_KEEPALIVE = 0 + 213,


  CURLOPT_TCP_KEEPIDLE = 0 + 214,
  CURLOPT_TCP_KEEPINTVL = 0 + 215,


  CURLOPT_SSL_OPTIONS = 0 + 216,


  CURLOPT_MAIL_AUTH = 10000 + 217,


  CURLOPT_SASL_IR = 0 + 218,




  CURLOPT_XFERINFOFUNCTION = 20000 + 219,


  CURLOPT_XOAUTH2_BEARER = 10000 + 220,




  CURLOPT_DNS_INTERFACE = 10000 + 221,



  CURLOPT_DNS_LOCAL_IP4 = 10000 + 222,



  CURLOPT_DNS_LOCAL_IP6 = 10000 + 223,


  CURLOPT_LOGIN_OPTIONS = 10000 + 224,


  CURLOPT_SSL_ENABLE_NPN = 0 + 225,


  CURLOPT_SSL_ENABLE_ALPN = 0 + 226,



  CURLOPT_EXPECT_100_TIMEOUT_MS = 0 + 227,



  CURLOPT_PROXYHEADER = 10000 + 228,


  CURLOPT_HEADEROPT = 0 + 229,



  CURLOPT_PINNEDPUBLICKEY = 10000 + 230,


  CURLOPT_UNIX_SOCKET_PATH = 10000 + 231,


  CURLOPT_SSL_VERIFYSTATUS = 0 + 232,

  CURLOPT_LASTENTRY
} CURLoption;
# 1672 "../include/curl/curl.h"
enum {
  CURL_HTTP_VERSION_NONE,


  CURL_HTTP_VERSION_1_0,
  CURL_HTTP_VERSION_1_1,
  CURL_HTTP_VERSION_2_0,

  CURL_HTTP_VERSION_LAST
};




enum {
    CURL_RTSPREQ_NONE,
    CURL_RTSPREQ_OPTIONS,
    CURL_RTSPREQ_DESCRIBE,
    CURL_RTSPREQ_ANNOUNCE,
    CURL_RTSPREQ_SETUP,
    CURL_RTSPREQ_PLAY,
    CURL_RTSPREQ_PAUSE,
    CURL_RTSPREQ_TEARDOWN,
    CURL_RTSPREQ_GET_PARAMETER,
    CURL_RTSPREQ_SET_PARAMETER,
    CURL_RTSPREQ_RECORD,
    CURL_RTSPREQ_RECEIVE,
    CURL_RTSPREQ_LAST
};


enum CURL_NETRC_OPTION {
  CURL_NETRC_IGNORED,

  CURL_NETRC_OPTIONAL,

  CURL_NETRC_REQUIRED,


  CURL_NETRC_LAST
};

enum {
  CURL_SSLVERSION_DEFAULT,
  CURL_SSLVERSION_TLSv1,
  CURL_SSLVERSION_SSLv2,
  CURL_SSLVERSION_SSLv3,
  CURL_SSLVERSION_TLSv1_0,
  CURL_SSLVERSION_TLSv1_1,
  CURL_SSLVERSION_TLSv1_2,

  CURL_SSLVERSION_LAST
};

enum CURL_TLSAUTH {
  CURL_TLSAUTH_NONE,
  CURL_TLSAUTH_SRP,
  CURL_TLSAUTH_LAST
};
# 1744 "../include/curl/curl.h"
typedef enum {
  CURL_TIMECOND_NONE,

  CURL_TIMECOND_IFMODSINCE,
  CURL_TIMECOND_IFUNMODSINCE,
  CURL_TIMECOND_LASTMOD,

  CURL_TIMECOND_LAST
} curl_TimeCond;




__attribute__ ((__visibility__ ("default"))) int (curl_strequal)(const char *s1, const char *s2);
__attribute__ ((__visibility__ ("default"))) int (curl_strnequal)(const char *s1, const char *s2, size_t n);
# 1772 "../include/curl/curl.h"
typedef enum {
  CURLFORM_NOTHING,


  CURLFORM_COPYNAME,
  CURLFORM_PTRNAME,
  CURLFORM_NAMELENGTH,
  CURLFORM_COPYCONTENTS,
  CURLFORM_PTRCONTENTS,
  CURLFORM_CONTENTSLENGTH,
  CURLFORM_FILECONTENT,
  CURLFORM_ARRAY,
  CURLFORM_OBSOLETE,
  CURLFORM_FILE,

  CURLFORM_BUFFER,
  CURLFORM_BUFFERPTR,
  CURLFORM_BUFFERLENGTH,

  CURLFORM_CONTENTTYPE,
  CURLFORM_CONTENTHEADER,
  CURLFORM_FILENAME,
  CURLFORM_END,
  CURLFORM_OBSOLETE2,

  CURLFORM_STREAM,

  CURLFORM_LASTENTRY
} CURLformoption;




struct curl_forms {
  CURLformoption option;
  const char *value;
};
# 1826 "../include/curl/curl.h"
typedef enum {
  CURL_FORMADD_OK,

  CURL_FORMADD_MEMORY,
  CURL_FORMADD_OPTION_TWICE,
  CURL_FORMADD_NULL,
  CURL_FORMADD_UNKNOWN_OPTION,
  CURL_FORMADD_INCOMPLETE,
  CURL_FORMADD_ILLEGAL_ARRAY,
  CURL_FORMADD_DISABLED,

  CURL_FORMADD_LAST
} CURLFORMcode;
# 1849 "../include/curl/curl.h"
__attribute__ ((__visibility__ ("default"))) CURLFORMcode curl_formadd(struct curl_httppost **httppost,
                                      struct curl_httppost **last_post,
                                      ...);
# 1861 "../include/curl/curl.h"
typedef size_t (*curl_formget_callback)(void *arg, const char *buf,
                                        size_t len);
# 1874 "../include/curl/curl.h"
__attribute__ ((__visibility__ ("default"))) int curl_formget(struct curl_httppost *form, void *arg,
                             curl_formget_callback append);







__attribute__ ((__visibility__ ("default"))) void curl_formfree(struct curl_httppost *form);
# 1893 "../include/curl/curl.h"
__attribute__ ((__visibility__ ("default"))) char *curl_getenv(const char *variable);
# 1902 "../include/curl/curl.h"
__attribute__ ((__visibility__ ("default"))) char *curl_version(void);
# 1913 "../include/curl/curl.h"
__attribute__ ((__visibility__ ("default"))) char *curl_easy_escape(CURL *handle,
                                   const char *string,
                                   int length);


__attribute__ ((__visibility__ ("default"))) char *curl_escape(const char *string,
                              int length);
# 1933 "../include/curl/curl.h"
__attribute__ ((__visibility__ ("default"))) char *curl_easy_unescape(CURL *handle,
                                     const char *string,
                                     int length,
                                     int *outlength);


__attribute__ ((__visibility__ ("default"))) char *curl_unescape(const char *string,
                                int length);
# 1950 "../include/curl/curl.h"
__attribute__ ((__visibility__ ("default"))) void curl_free(void *p);
# 1962 "../include/curl/curl.h"
__attribute__ ((__visibility__ ("default"))) CURLcode curl_global_init(long flags);
# 1977 "../include/curl/curl.h"
__attribute__ ((__visibility__ ("default"))) CURLcode curl_global_init_mem(long flags,
                                          curl_malloc_callback m,
                                          curl_free_callback f,
                                          curl_realloc_callback r,
                                          curl_strdup_callback s,
                                          curl_calloc_callback c);
# 1992 "../include/curl/curl.h"
__attribute__ ((__visibility__ ("default"))) void curl_global_cleanup(void);


struct curl_slist {
  char *data;
  struct curl_slist *next;
};
# 2008 "../include/curl/curl.h"
__attribute__ ((__visibility__ ("default"))) struct curl_slist *curl_slist_append(struct curl_slist *,
                                                 const char *);
# 2018 "../include/curl/curl.h"
__attribute__ ((__visibility__ ("default"))) void curl_slist_free_all(struct curl_slist *);
# 2029 "../include/curl/curl.h"
__attribute__ ((__visibility__ ("default"))) time_t curl_getdate(const char *p, const time_t *unused);



struct curl_certinfo {
  int num_of_certs;
  struct curl_slist **certinfo;


};


typedef enum {
  CURLSSLBACKEND_NONE = 0,
  CURLSSLBACKEND_OPENSSL = 1,
  CURLSSLBACKEND_GNUTLS = 2,
  CURLSSLBACKEND_NSS = 3,
  CURLSSLBACKEND_OBSOLETE4 = 4,
  CURLSSLBACKEND_GSKIT = 5,
  CURLSSLBACKEND_POLARSSL = 6,
  CURLSSLBACKEND_CYASSL = 7,
  CURLSSLBACKEND_SCHANNEL = 8,
  CURLSSLBACKEND_DARWINSSL = 9,
  CURLSSLBACKEND_AXTLS = 10
} curl_sslbackend;




struct curl_tlssessioninfo {
  curl_sslbackend backend;
  void *internals;
};
# 2070 "../include/curl/curl.h"
typedef enum {
  CURLINFO_NONE,
  CURLINFO_EFFECTIVE_URL = 0x100000 + 1,
  CURLINFO_RESPONSE_CODE = 0x200000 + 2,
  CURLINFO_TOTAL_TIME = 0x300000 + 3,
  CURLINFO_NAMELOOKUP_TIME = 0x300000 + 4,
  CURLINFO_CONNECT_TIME = 0x300000 + 5,
  CURLINFO_PRETRANSFER_TIME = 0x300000 + 6,
  CURLINFO_SIZE_UPLOAD = 0x300000 + 7,
  CURLINFO_SIZE_DOWNLOAD = 0x300000 + 8,
  CURLINFO_SPEED_DOWNLOAD = 0x300000 + 9,
  CURLINFO_SPEED_UPLOAD = 0x300000 + 10,
  CURLINFO_HEADER_SIZE = 0x200000 + 11,
  CURLINFO_REQUEST_SIZE = 0x200000 + 12,
  CURLINFO_SSL_VERIFYRESULT = 0x200000 + 13,
  CURLINFO_FILETIME = 0x200000 + 14,
  CURLINFO_CONTENT_LENGTH_DOWNLOAD = 0x300000 + 15,
  CURLINFO_CONTENT_LENGTH_UPLOAD = 0x300000 + 16,
  CURLINFO_STARTTRANSFER_TIME = 0x300000 + 17,
  CURLINFO_CONTENT_TYPE = 0x100000 + 18,
  CURLINFO_REDIRECT_TIME = 0x300000 + 19,
  CURLINFO_REDIRECT_COUNT = 0x200000 + 20,
  CURLINFO_PRIVATE = 0x100000 + 21,
  CURLINFO_HTTP_CONNECTCODE = 0x200000 + 22,
  CURLINFO_HTTPAUTH_AVAIL = 0x200000 + 23,
  CURLINFO_PROXYAUTH_AVAIL = 0x200000 + 24,
  CURLINFO_OS_ERRNO = 0x200000 + 25,
  CURLINFO_NUM_CONNECTS = 0x200000 + 26,
  CURLINFO_SSL_ENGINES = 0x400000 + 27,
  CURLINFO_COOKIELIST = 0x400000 + 28,
  CURLINFO_LASTSOCKET = 0x200000 + 29,
  CURLINFO_FTP_ENTRY_PATH = 0x100000 + 30,
  CURLINFO_REDIRECT_URL = 0x100000 + 31,
  CURLINFO_PRIMARY_IP = 0x100000 + 32,
  CURLINFO_APPCONNECT_TIME = 0x300000 + 33,
  CURLINFO_CERTINFO = 0x400000 + 34,
  CURLINFO_CONDITION_UNMET = 0x200000 + 35,
  CURLINFO_RTSP_SESSION_ID = 0x100000 + 36,
  CURLINFO_RTSP_CLIENT_CSEQ = 0x200000 + 37,
  CURLINFO_RTSP_SERVER_CSEQ = 0x200000 + 38,
  CURLINFO_RTSP_CSEQ_RECV = 0x200000 + 39,
  CURLINFO_PRIMARY_PORT = 0x200000 + 40,
  CURLINFO_LOCAL_IP = 0x100000 + 41,
  CURLINFO_LOCAL_PORT = 0x200000 + 42,
  CURLINFO_TLS_SESSION = 0x400000 + 43,


  CURLINFO_LASTONE = 43
} CURLINFO;





typedef enum {
  CURLCLOSEPOLICY_NONE,

  CURLCLOSEPOLICY_OLDEST,
  CURLCLOSEPOLICY_LEAST_RECENTLY_USED,
  CURLCLOSEPOLICY_LEAST_TRAFFIC,
  CURLCLOSEPOLICY_SLOWEST,
  CURLCLOSEPOLICY_CALLBACK,

  CURLCLOSEPOLICY_LAST
} curl_closepolicy;
# 2149 "../include/curl/curl.h"
typedef enum {
  CURL_LOCK_DATA_NONE = 0,




  CURL_LOCK_DATA_SHARE,
  CURL_LOCK_DATA_COOKIE,
  CURL_LOCK_DATA_DNS,
  CURL_LOCK_DATA_SSL_SESSION,
  CURL_LOCK_DATA_CONNECT,
  CURL_LOCK_DATA_LAST
} curl_lock_data;


typedef enum {
  CURL_LOCK_ACCESS_NONE = 0,
  CURL_LOCK_ACCESS_SHARED = 1,
  CURL_LOCK_ACCESS_SINGLE = 2,
  CURL_LOCK_ACCESS_LAST
} curl_lock_access;

typedef void (*curl_lock_function)(CURL *handle,
                                   curl_lock_data data,
                                   curl_lock_access locktype,
                                   void *userptr);
typedef void (*curl_unlock_function)(CURL *handle,
                                     curl_lock_data data,
                                     void *userptr);

typedef void CURLSH;

typedef enum {
  CURLSHE_OK,
  CURLSHE_BAD_OPTION,
  CURLSHE_IN_USE,
  CURLSHE_INVALID,
  CURLSHE_NOMEM,
  CURLSHE_NOT_BUILT_IN,
  CURLSHE_LAST
} CURLSHcode;

typedef enum {
  CURLSHOPT_NONE,
  CURLSHOPT_SHARE,
  CURLSHOPT_UNSHARE,
  CURLSHOPT_LOCKFUNC,
  CURLSHOPT_UNLOCKFUNC,
  CURLSHOPT_USERDATA,

  CURLSHOPT_LAST
} CURLSHoption;

__attribute__ ((__visibility__ ("default"))) CURLSH *curl_share_init(void);
__attribute__ ((__visibility__ ("default"))) CURLSHcode curl_share_setopt(CURLSH *, CURLSHoption option, ...);
__attribute__ ((__visibility__ ("default"))) CURLSHcode curl_share_cleanup(CURLSH *);





typedef enum {
  CURLVERSION_FIRST,
  CURLVERSION_SECOND,
  CURLVERSION_THIRD,
  CURLVERSION_FOURTH,
  CURLVERSION_LAST
} CURLversion;
# 2225 "../include/curl/curl.h"
typedef struct {
  CURLversion age;
  const char *version;
  unsigned int version_num;
  const char *host;
  int features;
  const char *ssl_version;
  long ssl_version_num;
  const char *libz_version;

  const char * const *protocols;


  const char *ares;
  int ares_num;


  const char *libidn;




  int iconv_ver_num;

  const char *libssh_version;

} curl_version_info_data;
# 2286 "../include/curl/curl.h"
__attribute__ ((__visibility__ ("default"))) curl_version_info_data *curl_version_info(CURLversion);
# 2297 "../include/curl/curl.h"
__attribute__ ((__visibility__ ("default"))) const char *curl_easy_strerror(CURLcode);
# 2308 "../include/curl/curl.h"
__attribute__ ((__visibility__ ("default"))) const char *curl_share_strerror(CURLSHcode);
# 2319 "../include/curl/curl.h"
__attribute__ ((__visibility__ ("default"))) CURLcode curl_easy_pause(CURL *handle, int bitmask);
# 2336 "../include/curl/curl.h"
# 1 "../include/curl/easy.h" 1
# 28 "../include/curl/easy.h"
__attribute__ ((__visibility__ ("default"))) CURL *curl_easy_init(void);
__attribute__ ((__visibility__ ("default"))) CURLcode curl_easy_setopt(CURL *curl, CURLoption option, ...);
__attribute__ ((__visibility__ ("default"))) CURLcode curl_easy_perform(CURL *curl);
__attribute__ ((__visibility__ ("default"))) void curl_easy_cleanup(CURL *curl);
# 46 "../include/curl/easy.h"
__attribute__ ((__visibility__ ("default"))) CURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, ...);
# 61 "../include/curl/easy.h"
__attribute__ ((__visibility__ ("default"))) CURL* curl_easy_duphandle(CURL *curl);
# 74 "../include/curl/easy.h"
__attribute__ ((__visibility__ ("default"))) void curl_easy_reset(CURL *curl);
# 84 "../include/curl/easy.h"
__attribute__ ((__visibility__ ("default"))) CURLcode curl_easy_recv(CURL *curl, void *buffer, size_t buflen,
                                    size_t *n);
# 95 "../include/curl/easy.h"
__attribute__ ((__visibility__ ("default"))) CURLcode curl_easy_send(CURL *curl, const void *buffer,
                                    size_t buflen, size_t *n);
# 2337 "../include/curl/curl.h" 2
# 1 "../include/curl/multi.h" 1
# 49 "../include/curl/multi.h"
# 1 "../include/curl/curl.h" 1
# 50 "../include/curl/multi.h" 2





typedef void CURLM;

typedef enum {
  CURLM_CALL_MULTI_PERFORM = -1,

  CURLM_OK,
  CURLM_BAD_HANDLE,
  CURLM_BAD_EASY_HANDLE,
  CURLM_OUT_OF_MEMORY,
  CURLM_INTERNAL_ERROR,
  CURLM_BAD_SOCKET,
  CURLM_UNKNOWN_OPTION,
  CURLM_ADDED_ALREADY,

  CURLM_LAST
} CURLMcode;






typedef enum {
  CURLMSG_NONE,
  CURLMSG_DONE,

  CURLMSG_LAST
} CURLMSG;

struct CURLMsg {
  CURLMSG msg;
  CURL *easy_handle;
  union {
    void *whatever;
    CURLcode result;
  } data;
};
typedef struct CURLMsg CURLMsg;
# 101 "../include/curl/multi.h"
struct curl_waitfd {
  curl_socket_t fd;
  short events;
  short revents;
};
# 114 "../include/curl/multi.h"
__attribute__ ((__visibility__ ("default"))) CURLM *curl_multi_init(void);
# 123 "../include/curl/multi.h"
__attribute__ ((__visibility__ ("default"))) CURLMcode curl_multi_add_handle(CURLM *multi_handle,
                                            CURL *curl_handle);
# 133 "../include/curl/multi.h"
__attribute__ ((__visibility__ ("default"))) CURLMcode curl_multi_remove_handle(CURLM *multi_handle,
                                               CURL *curl_handle);
# 145 "../include/curl/multi.h"
__attribute__ ((__visibility__ ("default"))) CURLMcode curl_multi_fdset(CURLM *multi_handle,
                                       fd_set *read_fd_set,
                                       fd_set *write_fd_set,
                                       fd_set *exc_fd_set,
                                       int *max_fd);
# 159 "../include/curl/multi.h"
__attribute__ ((__visibility__ ("default"))) CURLMcode curl_multi_wait(CURLM *multi_handle,
                                      struct curl_waitfd extra_fds[],
                                      unsigned int extra_nfds,
                                      int timeout_ms,
                                      int *ret);
# 181 "../include/curl/multi.h"
__attribute__ ((__visibility__ ("default"))) CURLMcode curl_multi_perform(CURLM *multi_handle,
                                         int *running_handles);
# 194 "../include/curl/multi.h"
__attribute__ ((__visibility__ ("default"))) CURLMcode curl_multi_cleanup(CURLM *multi_handle);
# 224 "../include/curl/multi.h"
__attribute__ ((__visibility__ ("default"))) CURLMsg *curl_multi_info_read(CURLM *multi_handle,
                                          int *msgs_in_queue);
# 236 "../include/curl/multi.h"
__attribute__ ((__visibility__ ("default"))) const char *curl_multi_strerror(CURLMcode);
# 259 "../include/curl/multi.h"
typedef int (*curl_socket_callback)(CURL *easy,
                                    curl_socket_t s,
                                    int what,
                                    void *userp,

                                    void *socketp);
# 276 "../include/curl/multi.h"
typedef int (*curl_multi_timer_callback)(CURLM *multi,
                                         long timeout_ms,
                                         void *userp);


__attribute__ ((__visibility__ ("default"))) CURLMcode curl_multi_socket(CURLM *multi_handle, curl_socket_t s,
                                        int *running_handles);

__attribute__ ((__visibility__ ("default"))) CURLMcode curl_multi_socket_action(CURLM *multi_handle,
                                               curl_socket_t s,
                                               int ev_bitmask,
                                               int *running_handles);

__attribute__ ((__visibility__ ("default"))) CURLMcode curl_multi_socket_all(CURLM *multi_handle,
                                            int *running_handles);
# 308 "../include/curl/multi.h"
__attribute__ ((__visibility__ ("default"))) CURLMcode curl_multi_timeout(CURLM *multi_handle,
                                         long *milliseconds);
# 324 "../include/curl/multi.h"
typedef enum {

  CURLMOPT_SOCKETFUNCTION = 20000 + 1,


  CURLMOPT_SOCKETDATA = 10000 + 2,


  CURLMOPT_PIPELINING = 0 + 3,


  CURLMOPT_TIMERFUNCTION = 20000 + 4,


  CURLMOPT_TIMERDATA = 10000 + 5,


  CURLMOPT_MAXCONNECTS = 0 + 6,


  CURLMOPT_MAX_HOST_CONNECTIONS = 0 + 7,


  CURLMOPT_MAX_PIPELINE_LENGTH = 0 + 8,



  CURLMOPT_CONTENT_LENGTH_PENALTY_SIZE = 30000 + 9,



  CURLMOPT_CHUNK_LENGTH_PENALTY_SIZE = 30000 + 10,



  CURLMOPT_PIPELINING_SITE_BL = 10000 + 11,



  CURLMOPT_PIPELINING_SERVER_BL = 10000 + 12,


  CURLMOPT_MAX_TOTAL_CONNECTIONS = 0 + 13,

  CURLMOPT_LASTENTRY
} CURLMoption;
# 379 "../include/curl/multi.h"
__attribute__ ((__visibility__ ("default"))) CURLMcode curl_multi_setopt(CURLM *multi_handle,
                                        CURLMoption option, ...);
# 392 "../include/curl/multi.h"
__attribute__ ((__visibility__ ("default"))) CURLMcode curl_multi_assign(CURLM *multi_handle,
                                        curl_socket_t sockfd, void *sockp);
# 2338 "../include/curl/curl.h" 2
# 27 "../lib/cookie.h" 2

struct Cookie {
  struct Cookie *next;
  char *name;
  char *value;
  char *path;
  char *spath;
  char *domain;
  curl_off_t expires;
  char *expirestr;
  _Bool tailmatch;


  char *version;
  char *maxage;

  _Bool secure;
  _Bool livecookie;
  _Bool httponly;
};

struct CookieInfo {

  struct Cookie *cookies;

  char *filename;
  _Bool running;
  long numcookies;
  _Bool newsession;
};
# 73 "../lib/cookie.h"
struct SessionHandle;





struct Cookie *Curl_cookie_add(struct SessionHandle *data,
                               struct CookieInfo *, _Bool header, char *lineptr,
                               const char *domain, const char *path);

struct Cookie *Curl_cookie_getlist(struct CookieInfo *, const char *,
                                   const char *, _Bool);
void Curl_cookie_freelist(struct Cookie *cookies, _Bool cookiestoo);
void Curl_cookie_clearall(struct CookieInfo *cookies);
void Curl_cookie_clearsess(struct CookieInfo *cookies);
# 96 "../lib/cookie.h"
void Curl_flush_cookies(struct SessionHandle *data, int cleanup);
void Curl_cookie_cleanup(struct CookieInfo *);
struct CookieInfo *Curl_cookie_init(struct SessionHandle *data,
                                    const char *, struct CookieInfo *, _Bool);
struct curl_slist *Curl_cookie_list(struct SessionHandle *data);
void Curl_cookie_loadfiles(struct SessionHandle *data);
# 83 "../lib/urldata.h" 2
# 1 "../lib/formdata.h" 1
# 25 "../lib/formdata.h"
enum formtype {
  FORM_DATA,
  FORM_CONTENT,
  FORM_CALLBACK,

  FORM_FILE

};


struct FormData {
  struct FormData *next;
  enum formtype type;
  char *line;
  size_t length;
};

struct Form {
  struct FormData *data;
  size_t sent;

  FILE *fp;
  curl_read_callback fread_func;
};


typedef struct FormInfo {
  char *name;
  _Bool name_alloc;
  size_t namelength;
  char *value;
  _Bool value_alloc;
  size_t contentslength;
  char *contenttype;
  _Bool contenttype_alloc;
  long flags;
  char *buffer;
  size_t bufferlength;
  char *showfilename;

  _Bool showfilename_alloc;
  char *userp;
  struct curl_slist* contentheader;
  struct FormInfo *more;
} FormInfo;

int Curl_FormInit(struct Form *form, struct FormData *formdata );

CURLcode Curl_getformdata(struct SessionHandle *data,
                          struct FormData **,
                          struct curl_httppost *post,
                          const char *custom_contenttype,
                          curl_off_t *size);


size_t Curl_FormReader(char *buffer,
                       size_t size,
                       size_t nitems,
                       FILE *mydata);






char *Curl_formpostheader(void *formp, size_t *len);

char *Curl_FormBoundary(void);

void Curl_formclean(struct FormData **);

CURLcode Curl_formconvert(struct SessionHandle *, struct FormData *);
# 84 "../lib/urldata.h" 2
# 172 "../lib/urldata.h"
# 1 "../lib/timeval.h" 1
# 32 "../lib/timeval.h"
struct timeval curlx_tvnow(void);







long curlx_tvdiff(struct timeval t1, struct timeval t2);






double curlx_tvdiff_secs(struct timeval t1, struct timeval t2);

long Curl_tvlong(struct timeval t1);
# 173 "../lib/urldata.h" 2


# 1 "/usr/include/zlib.h" 1 3 4
# 34 "/usr/include/zlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/zconf.h" 1 3 4
# 368 "/usr/include/x86_64-linux-gnu/zconf.h" 3 4
typedef unsigned char Byte;

typedef unsigned int uInt;
typedef unsigned long uLong;





   typedef Byte Bytef;

typedef char charf;
typedef int intf;
typedef uInt uIntf;
typedef uLong uLongf;


   typedef void const *voidpc;
   typedef void *voidpf;
   typedef void *voidp;
# 406 "/usr/include/x86_64-linux-gnu/zconf.h" 3 4
   typedef unsigned z_crc_t;
# 35 "/usr/include/zlib.h" 2 3 4
# 80 "/usr/include/zlib.h" 3 4
typedef voidpf (*alloc_func) (voidpf opaque, uInt items, uInt size);
typedef void (*free_func) (voidpf opaque, voidpf address);

struct internal_state;

typedef struct z_stream_s {
            Bytef *next_in;
    uInt avail_in;
    uLong total_in;

    Bytef *next_out;
    uInt avail_out;
    uLong total_out;

            char *msg;
    struct internal_state *state;

    alloc_func zalloc;
    free_func zfree;
    voidpf opaque;

    int data_type;
    uLong adler;
    uLong reserved;
} z_stream;

typedef z_stream *z_streamp;





typedef struct gz_header_s {
    int text;
    uLong time;
    int xflags;
    int os;
    Bytef *extra;
    uInt extra_len;
    uInt extra_max;
    Bytef *name;
    uInt name_max;
    Bytef *comment;
    uInt comm_max;
    int hcrc;
    int done;

} gz_header;

typedef gz_header *gz_headerp;
# 216 "/usr/include/zlib.h" 3 4
extern const char * zlibVersion (void);
# 246 "/usr/include/zlib.h" 3 4
extern int deflate (z_streamp strm, int flush);
# 353 "/usr/include/zlib.h" 3 4
extern int deflateEnd (z_streamp strm);
# 392 "/usr/include/zlib.h" 3 4
extern int inflate (z_streamp strm, int flush);
# 508 "/usr/include/zlib.h" 3 4
extern int inflateEnd (z_streamp strm);
# 587 "/usr/include/zlib.h" 3 4
extern int deflateSetDictionary (z_streamp strm, const Bytef *dictionary, uInt dictLength);
# 631 "/usr/include/zlib.h" 3 4
extern int deflateCopy (z_streamp dest, z_streamp source);
# 649 "/usr/include/zlib.h" 3 4
extern int deflateReset (z_streamp strm);
# 660 "/usr/include/zlib.h" 3 4
extern int deflateParams (z_streamp strm, int level, int strategy);
# 681 "/usr/include/zlib.h" 3 4
extern int deflateTune (z_streamp strm, int good_length, int max_lazy, int nice_length, int max_chain);
# 698 "/usr/include/zlib.h" 3 4
extern uLong deflateBound (z_streamp strm, uLong sourceLen);
# 713 "/usr/include/zlib.h" 3 4
extern int deflatePending (z_streamp strm, unsigned *pending, int *bits);
# 728 "/usr/include/zlib.h" 3 4
extern int deflatePrime (z_streamp strm, int bits, int value);
# 745 "/usr/include/zlib.h" 3 4
extern int deflateSetHeader (z_streamp strm, gz_headerp head);
# 819 "/usr/include/zlib.h" 3 4
extern int inflateSetDictionary (z_streamp strm, const Bytef *dictionary, uInt dictLength);
# 842 "/usr/include/zlib.h" 3 4
extern int inflateGetDictionary (z_streamp strm, Bytef *dictionary, uInt *dictLength);
# 857 "/usr/include/zlib.h" 3 4
extern int inflateSync (z_streamp strm);
# 876 "/usr/include/zlib.h" 3 4
extern int inflateCopy (z_streamp dest, z_streamp source);
# 892 "/usr/include/zlib.h" 3 4
extern int inflateReset (z_streamp strm);
# 902 "/usr/include/zlib.h" 3 4
extern int inflateReset2 (z_streamp strm, int windowBits);
# 914 "/usr/include/zlib.h" 3 4
extern int inflatePrime (z_streamp strm, int bits, int value);
# 935 "/usr/include/zlib.h" 3 4
extern long inflateMark (z_streamp strm);
# 963 "/usr/include/zlib.h" 3 4
extern int inflateGetHeader (z_streamp strm, gz_headerp head);
# 1025 "/usr/include/zlib.h" 3 4
typedef unsigned (*in_func) (void *, unsigned char * *);

typedef int (*out_func) (void *, unsigned char *, unsigned);

extern int inflateBack (z_streamp strm, in_func in, void *in_desc, out_func out, void *out_desc);
# 1099 "/usr/include/zlib.h" 3 4
extern int inflateBackEnd (z_streamp strm);







extern uLong zlibCompileFlags (void);
# 1160 "/usr/include/zlib.h" 3 4
extern int compress (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen);
# 1174 "/usr/include/zlib.h" 3 4
extern int compress2 (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen, int level);
# 1190 "/usr/include/zlib.h" 3 4
extern uLong compressBound (uLong sourceLen);






extern int uncompress (Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen);
# 1224 "/usr/include/zlib.h" 3 4
typedef struct gzFile_s *gzFile;
# 1264 "/usr/include/zlib.h" 3 4
extern gzFile gzdopen (int fd, const char *mode);
# 1287 "/usr/include/zlib.h" 3 4
extern int gzbuffer (gzFile file, unsigned size);
# 1304 "/usr/include/zlib.h" 3 4
extern int gzsetparams (gzFile file, int level, int strategy);
# 1313 "/usr/include/zlib.h" 3 4
extern int gzread (gzFile file, voidp buf, unsigned len);
# 1341 "/usr/include/zlib.h" 3 4
extern int gzwrite (gzFile file, voidpc buf, unsigned len);







extern int gzprintf (gzFile file, const char *format, ...);
# 1364 "/usr/include/zlib.h" 3 4
extern int gzputs (gzFile file, const char *s);







extern char * gzgets (gzFile file, char *buf, int len);
# 1385 "/usr/include/zlib.h" 3 4
extern int gzputc (gzFile file, int c);





extern int gzgetc (gzFile file);
# 1400 "/usr/include/zlib.h" 3 4
extern int gzungetc (int c, gzFile file);
# 1412 "/usr/include/zlib.h" 3 4
extern int gzflush (gzFile file, int flush);
# 1447 "/usr/include/zlib.h" 3 4
extern int gzrewind (gzFile file);
# 1475 "/usr/include/zlib.h" 3 4
extern int gzeof (gzFile file);
# 1490 "/usr/include/zlib.h" 3 4
extern int gzdirect (gzFile file);
# 1511 "/usr/include/zlib.h" 3 4
extern int gzclose (gzFile file);
# 1524 "/usr/include/zlib.h" 3 4
extern int gzclose_r (gzFile file);
extern int gzclose_w (gzFile file);
# 1536 "/usr/include/zlib.h" 3 4
extern const char * gzerror (gzFile file, int *errnum);
# 1552 "/usr/include/zlib.h" 3 4
extern void gzclearerr (gzFile file);
# 1569 "/usr/include/zlib.h" 3 4
extern uLong adler32 (uLong adler, const Bytef *buf, uInt len);
# 1600 "/usr/include/zlib.h" 3 4
extern uLong crc32 (uLong crc, const Bytef *buf, uInt len);
# 1633 "/usr/include/zlib.h" 3 4
extern int deflateInit_ (z_streamp strm, int level, const char *version, int stream_size);

extern int inflateInit_ (z_streamp strm, const char *version, int stream_size);

extern int deflateInit2_ (z_streamp strm, int level, int method, int windowBits, int memLevel, int strategy, const char *version, int stream_size);



extern int inflateInit2_ (z_streamp strm, int windowBits, const char *version, int stream_size);

extern int inflateBackInit_ (z_streamp strm, int windowBits, unsigned char *window, const char *version, int stream_size);
# 1670 "/usr/include/zlib.h" 3 4
struct gzFile_s {
    unsigned have;
    unsigned char *next;
    off_t pos;
};
extern int gzgetc_ (gzFile file);
# 1725 "/usr/include/zlib.h" 3 4
   extern gzFile gzopen (const char *, const char *);
   extern off_t gzseek (gzFile, off_t, int);
   extern off_t gztell (gzFile);
   extern off_t gzoffset (gzFile);
   extern uLong adler32_combine (uLong, uLong, off_t);
   extern uLong crc32_combine (uLong, uLong, off_t);
# 1742 "/usr/include/zlib.h" 3 4
    struct internal_state {int dummy;};



extern const char * zError (int);
extern int inflateSyncPoint (z_streamp);
extern const z_crc_t * get_crc_table (void);
extern int inflateUndermine (z_streamp, int);
extern int inflateResetKeep (z_streamp);
extern int deflateResetKeep (z_streamp);






extern int gzvprintf (gzFile file, const char *format, va_list va);
# 176 "../lib/urldata.h" 2








# 1 "../lib/http_chunks.h" 1
# 31 "../lib/http_chunks.h"
typedef enum {


  CHUNK_HEX,


  CHUNK_LF,



  CHUNK_DATA,




  CHUNK_POSTLF,




  CHUNK_STOP,



  CHUNK_TRAILER,



  CHUNK_TRAILER_CR,





  CHUNK_TRAILER_POSTCR
} ChunkyState;

typedef enum {
  CHUNKE_STOP = -1,
  CHUNKE_OK = 0,
  CHUNKE_TOO_LONG_HEX = 1,
  CHUNKE_ILLEGAL_HEX,
  CHUNKE_BAD_CHUNK,
  CHUNKE_WRITE_ERROR,
  CHUNKE_BAD_ENCODING,
  CHUNKE_OUT_OF_MEMORY,
  CHUNKE_LAST
} CHUNKcode;

const char *Curl_chunked_strerror(CHUNKcode code);

struct Curl_chunker {
  char hexbuffer[ 16 + 1];
  int hexindex;
  ChunkyState state;
  curl_off_t datasize;
  size_t dataleft;
};
# 185 "../lib/urldata.h" 2
# 1 "../lib/hostip.h" 1
# 26 "../lib/hostip.h"
# 1 "../lib/hash.h" 1
# 27 "../lib/hash.h"
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3
# 47 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 3
typedef long int ptrdiff_t;
# 28 "../lib/hash.h" 2

# 1 "../lib/llist.h" 1
# 26 "../lib/llist.h"
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3
# 27 "../lib/llist.h" 2

typedef void (*curl_llist_dtor)(void *, void *);

struct curl_llist_element {
  void *ptr;

  struct curl_llist_element *prev;
  struct curl_llist_element *next;
};

struct curl_llist {
  struct curl_llist_element *head;
  struct curl_llist_element *tail;

  curl_llist_dtor dtor;

  size_t size;
};

struct curl_llist *Curl_llist_alloc(curl_llist_dtor);
int Curl_llist_insert_next(struct curl_llist *, struct curl_llist_element *,
                           const void *);
int Curl_llist_remove(struct curl_llist *, struct curl_llist_element *,
                      void *);
size_t Curl_llist_count(struct curl_llist *);
void Curl_llist_destroy(struct curl_llist *, void *);
int Curl_llist_move(struct curl_llist *, struct curl_llist_element *,
                    struct curl_llist *, struct curl_llist_element *);
# 30 "../lib/hash.h" 2


typedef size_t (*hash_function) (void* key,
                                 size_t key_length,
                                 size_t slots_num);




typedef size_t (*comp_function) (void* key1,
                                 size_t key1_len,
                                 void*key2,
                                 size_t key2_len);

typedef void (*curl_hash_dtor)(void *);

struct curl_hash {
  struct curl_llist **table;


  hash_function hash_func;


  comp_function comp_func;
  curl_hash_dtor dtor;
  int slots;
  size_t size;
};

struct curl_hash_element {
  void *ptr;
  char *key;
  size_t key_len;
};

struct curl_hash_iterator {
  struct curl_hash *hash;
  int slot_index;
  struct curl_llist_element *current_element;
};

int Curl_hash_init(struct curl_hash *h,
                   int slots,
                   hash_function hfunc,
                   comp_function comparator,
                   curl_hash_dtor dtor);

struct curl_hash *Curl_hash_alloc(int slots,
                                  hash_function hfunc,
                                  comp_function comparator,
                                  curl_hash_dtor dtor);

void *Curl_hash_add(struct curl_hash *h, void *key, size_t key_len, void *p);
int Curl_hash_delete(struct curl_hash *h, void *key, size_t key_len);
void *Curl_hash_pick(struct curl_hash *, void * key, size_t key_len);
void Curl_hash_apply(struct curl_hash *h, void *user,
                     void (*cb)(void *user, void *ptr));
int Curl_hash_count(struct curl_hash *h);
void Curl_hash_clean(struct curl_hash *h);
void Curl_hash_clean_with_criterium(struct curl_hash *h, void *user,
                                    int (*comp)(void *, void *));
void Curl_hash_destroy(struct curl_hash *h);

size_t Curl_hash_str(void* key, size_t key_length, size_t slots_num);
size_t Curl_str_key_compare(void*k1, size_t key1_len, void*k2,
                            size_t key2_len);

void Curl_hash_start_iterate(struct curl_hash *hash,
                             struct curl_hash_iterator *iter);
struct curl_hash_element *
Curl_hash_next_element(struct curl_hash_iterator *iter);

void Curl_hash_print(struct curl_hash *h,
                     void (*func)(void *));
# 27 "../lib/hostip.h" 2
# 1 "../lib/curl_addrinfo.h" 1
# 51 "../lib/curl_addrinfo.h"
struct Curl_addrinfo {
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  curl_socklen_t ai_addrlen;
  char *ai_canonname;
  struct sockaddr *ai_addr;
  struct Curl_addrinfo *ai_next;
};
typedef struct Curl_addrinfo Curl_addrinfo;

void
Curl_freeaddrinfo(Curl_addrinfo *cahead);


int
Curl_getaddrinfo_ex(const char *nodename,
                    const char *servname,
                    const struct addrinfo *hints,
                    Curl_addrinfo **result);


Curl_addrinfo *
Curl_he2ai(const struct hostent *he, int port);

Curl_addrinfo *
Curl_ip2addr(int af, const void *inaddr, const char *hostname, int port);

Curl_addrinfo *Curl_str2addr(char *dotted, int port);


Curl_addrinfo *Curl_unix2addr(const char *path);
# 28 "../lib/hostip.h" 2
# 1 "../lib/asyn.h" 1
# 28 "../lib/asyn.h"
struct addrinfo;
struct hostent;
struct SessionHandle;
struct connectdata;
struct Curl_dns_entry;
# 47 "../lib/asyn.h"
int Curl_resolver_global_init(void);





void Curl_resolver_global_cleanup(void);
# 63 "../lib/asyn.h"
CURLcode Curl_resolver_init(void **resolver);
# 72 "../lib/asyn.h"
void Curl_resolver_cleanup(void *resolver);
# 82 "../lib/asyn.h"
int Curl_resolver_duphandle(void **to, void *from);
# 91 "../lib/asyn.h"
void Curl_resolver_cancel(struct connectdata *conn);
# 101 "../lib/asyn.h"
int Curl_resolver_getsock(struct connectdata *conn, curl_socket_t *sock,
                          int numsocks);
# 113 "../lib/asyn.h"
CURLcode Curl_resolver_is_resolved(struct connectdata *conn,
                                   struct Curl_dns_entry **dns);
# 128 "../lib/asyn.h"
CURLcode Curl_resolver_wait_resolv(struct connectdata *conn,
                                   struct Curl_dns_entry **dnsentry);
# 142 "../lib/asyn.h"
Curl_addrinfo *Curl_resolver_getaddrinfo(struct connectdata *conn,
                                         const char *hostname,
                                         int port,
                                         int *waitp);
# 29 "../lib/hostip.h" 2


# 1 "/usr/include/setjmp.h" 1 3 4
# 29 "/usr/include/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 30 "/usr/include/setjmp.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 31 "/usr/include/setjmp.h" 2 3 4



struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };




typedef struct __jmp_buf_tag jmp_buf[1];



extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));






extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __attribute__ ((__nothrow__));



extern int _setjmp (struct __jmp_buf_tag __env[1]) __attribute__ ((__nothrow__));
# 74 "/usr/include/setjmp.h" 3 4
extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







typedef struct __jmp_buf_tag sigjmp_buf[1];
# 102 "/usr/include/setjmp.h" 3 4
extern void siglongjmp (sigjmp_buf __env, int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
# 32 "../lib/hostip.h" 2
# 51 "../lib/hostip.h"
struct addrinfo;
struct hostent;
struct SessionHandle;
struct connectdata;
# 63 "../lib/hostip.h"
struct curl_hash *Curl_global_host_cache_init(void);
void Curl_global_host_cache_dtor(void);

struct Curl_dns_entry {
  Curl_addrinfo *addr;


  time_t timestamp;
  long inuse;

};
# 87 "../lib/hostip.h"
int Curl_resolv(struct connectdata *conn, const char *hostname,
                int port, struct Curl_dns_entry **dnsentry);
int Curl_resolv_timeout(struct connectdata *conn, const char *hostname,
                        int port, struct Curl_dns_entry **dnsentry,
                        long timeoutms);





_Bool Curl_ipv6works(void);
# 106 "../lib/hostip.h"
_Bool Curl_ipvalid(struct connectdata *conn);
# 115 "../lib/hostip.h"
Curl_addrinfo *Curl_getaddrinfo(struct connectdata *conn,
                                const char *hostname,
                                int port,
                                int *waitp);



void Curl_resolv_unlock(struct SessionHandle *data,
                        struct Curl_dns_entry *dns);


void Curl_scan_cache_used(void *user, void *ptr);


struct curl_hash *Curl_mk_dnscache(void);


void Curl_hostcache_prune(struct SessionHandle *data);


int Curl_num_addresses (const Curl_addrinfo *addr);
# 147 "../lib/hostip.h"
Curl_addrinfo *Curl_ipv4_resolve_r(const char * hostname, int port);

CURLcode Curl_async_resolved(struct connectdata *conn,
                             _Bool *protocol_connect);
# 162 "../lib/hostip.h"
CURLcode Curl_addrinfo_callback(struct connectdata *conn,
                                int status,
                                Curl_addrinfo *ai);






const char *Curl_printable_address(const Curl_addrinfo *ip,
                                   char *buf, size_t bufsize);






struct Curl_dns_entry *
Curl_fetch_addr(struct connectdata *conn,
                const char *hostname,
                int port);





struct Curl_dns_entry *
Curl_cache_addr(struct SessionHandle *data, Curl_addrinfo *addr,
                const char *hostname, int port);
# 204 "../lib/hostip.h"
extern sigjmp_buf curl_jmpenv;





CURLcode Curl_set_dns_servers(struct SessionHandle *data, char *servers);





CURLcode Curl_set_dns_interface(struct SessionHandle *data,
                                const char *interf);





CURLcode Curl_set_dns_local_ip4(struct SessionHandle *data,
                                const char *local_ip4);





CURLcode Curl_set_dns_local_ip6(struct SessionHandle *data,
                                const char *local_ip6);




void Curl_hostcache_clean(struct SessionHandle *data, struct curl_hash *hash);




void Curl_hostcache_destroy(struct SessionHandle *data);




CURLcode Curl_loadhostpairs(struct SessionHandle *data);
# 186 "../lib/urldata.h" 2

# 1 "../lib/splay.h" 1
# 26 "../lib/splay.h"
struct Curl_tree {
  struct Curl_tree *smaller;
  struct Curl_tree *larger;
  struct Curl_tree *same;
  struct timeval key;
  void *payload;
};

struct Curl_tree *Curl_splay(struct timeval i,
                             struct Curl_tree *t);

struct Curl_tree *Curl_splayinsert(struct timeval key,
                                   struct Curl_tree *t,
                                   struct Curl_tree *newnode);







struct Curl_tree *Curl_splaygetbest(struct timeval key,
                                    struct Curl_tree *t,
                                    struct Curl_tree **removed);

int Curl_splayremovebyaddr(struct Curl_tree *t,
                           struct Curl_tree *removenode,
                           struct Curl_tree **newroot);
# 188 "../lib/urldata.h" 2

# 1 "../lib/imap.h" 1
# 25 "../lib/imap.h"
# 1 "../lib/pingpong.h" 1
# 33 "../lib/pingpong.h"
struct connectdata;

typedef enum {
  FTPTRANSFER_BODY,
  FTPTRANSFER_INFO,
  FTPTRANSFER_NONE,
  FTPTRANSFER_LAST
} curl_pp_transfer;







struct pingpong {
  char *cache;
  size_t cache_size;
  size_t nread_resp;
  char *linestart_resp;

  _Bool pending_resp;


  char *sendthis;

  size_t sendleft;
  size_t sendsize;
  struct timeval response;

  long response_time;


  struct connectdata *conn;





  CURLcode (*statemach_act)(struct connectdata *conn);

  _Bool (*endofresp)(struct connectdata *conn, char *ptr, size_t len,
                    int *code);
};







CURLcode Curl_pp_statemach(struct pingpong *pp, _Bool block);


void Curl_pp_init(struct pingpong *pp);



long Curl_pp_state_timeout(struct pingpong *pp);
# 104 "../lib/pingpong.h"
CURLcode Curl_pp_sendf(struct pingpong *pp,
                       const char *fmt, ...);
# 117 "../lib/pingpong.h"
CURLcode Curl_pp_vsendf(struct pingpong *pp,
                        const char *fmt,
                        va_list args);






CURLcode Curl_pp_readresp(curl_socket_t sockfd,
                          struct pingpong *pp,
                          int *code,
                          size_t *size);


CURLcode Curl_pp_flushsend(struct pingpong *pp);


CURLcode Curl_pp_disconnect(struct pingpong *pp);

int Curl_pp_getsock(struct pingpong *pp, curl_socket_t *socks,
                    int numsocks);
# 148 "../lib/pingpong.h"
_Bool Curl_pp_moredata(struct pingpong *pp);
# 26 "../lib/imap.h" 2
# 1 "../lib/curl_sasl.h" 1
# 27 "../lib/curl_sasl.h"
struct SessionHandle;
struct connectdata;


struct digestdata;
# 68 "../lib/curl_sasl.h"
enum {
  CURLDIGESTALGO_MD5,
  CURLDIGESTALGO_MD5SESS
};


typedef enum {
  SASL_STOP,
  SASL_PLAIN,
  SASL_LOGIN,
  SASL_LOGIN_PASSWD,
  SASL_EXTERNAL,
  SASL_CRAMMD5,
  SASL_DIGESTMD5,
  SASL_DIGESTMD5_RESP,
  SASL_NTLM,
  SASL_NTLM_TYPE2MSG,
  SASL_GSSAPI,
  SASL_GSSAPI_TOKEN,
  SASL_GSSAPI_NO_DATA,
  SASL_XOAUTH2,
  SASL_CANCEL,
  SASL_FINAL
} saslstate;


typedef enum {
  SASL_IDLE,
  SASL_INPROGRESS,
  SASL_DONE
} saslprogress;


struct SASLproto {
  const char *service;
  int contcode;
  int finalcode;
  size_t maxirlen;
  CURLcode (*sendauth)(struct connectdata *conn,
                       const char *mech, const char *ir);

  CURLcode (*sendcont)(struct connectdata *conn, const char *contauth);

  void (*getmessage)(char *buffer, char **outptr);

};


struct SASL {
  const struct SASLproto *params;
  saslstate state;
  unsigned int authmechs;
  unsigned int prefmech;
  unsigned int authused;
  _Bool resetprefs;
  _Bool mutual_auth;
  _Bool force_ir;
};
# 134 "../lib/curl_sasl.h"
char *Curl_sasl_build_spn(const char *service, const char *instance);
# 146 "../lib/curl_sasl.h"
CURLcode Curl_sasl_create_digest_md5_message(struct SessionHandle *data,
                                             const char *chlg64,
                                             const char *userp,
                                             const char *passwdp,
                                             const char *service,
                                             char **outptr, size_t *outlen);


CURLcode Curl_sasl_decode_digest_http_message(const char *chlg,
                                              struct digestdata *digest);


CURLcode Curl_sasl_create_digest_http_message(struct SessionHandle *data,
                                              const char *userp,
                                              const char *passwdp,
                                              const unsigned char *request,
                                              const unsigned char *uri,
                                              struct digestdata *digest,
                                              char **outptr, size_t *outlen);


void Curl_sasl_digest_cleanup(struct digestdata *digest);
# 221 "../lib/curl_sasl.h"
void Curl_sasl_cleanup(struct connectdata *conn, unsigned int authused);


unsigned int Curl_sasl_decode_mech(const char *ptr,
                                   size_t maxlen, size_t *len);


CURLcode Curl_sasl_parse_url_auth_option(struct SASL *sasl,
                                         const char *value, size_t len);


void Curl_sasl_init(struct SASL *sasl, const struct SASLproto *params);


_Bool Curl_sasl_can_authenticate(struct SASL *sasl, struct connectdata *conn);


CURLcode Curl_sasl_start(struct SASL *sasl, struct connectdata *conn,
                         _Bool force_ir, saslprogress *progress);


CURLcode Curl_sasl_continue(struct SASL *sasl, struct connectdata *conn,
                            int code, saslprogress *progress);
# 27 "../lib/imap.h" 2




typedef enum {
  IMAP_STOP,
  IMAP_SERVERGREET,

  IMAP_CAPABILITY,
  IMAP_STARTTLS,
  IMAP_UPGRADETLS,

  IMAP_AUTHENTICATE,
  IMAP_LOGIN,
  IMAP_LIST,
  IMAP_SELECT,
  IMAP_FETCH,
  IMAP_FETCH_FINAL,
  IMAP_APPEND,
  IMAP_APPEND_FINAL,
  IMAP_SEARCH,
  IMAP_LOGOUT,
  IMAP_LAST
} imapstate;





struct IMAP {
  curl_pp_transfer transfer;
  char *mailbox;
  char *uidvalidity;
  char *uid;
  char *section;
  char *partial;
  char *query;
  char *custom;
  char *custom_params;
};



struct imap_conn {
  struct pingpong pp;
  imapstate state;
  _Bool ssldone;
  struct SASL sasl;
  unsigned int preftype;
  int cmdid;
  char resptag[5];
  _Bool tls_supported;
  _Bool login_disabled;
  _Bool ir_supported;
  char *mailbox;
  char *mailbox_uidvalidity;
};

extern const struct Curl_handler Curl_handler_imap;
extern const struct Curl_handler Curl_handler_imaps;
# 190 "../lib/urldata.h" 2
# 1 "../lib/pop3.h" 1
# 31 "../lib/pop3.h"
typedef enum {
  POP3_STOP,
  POP3_SERVERGREET,

  POP3_CAPA,
  POP3_STARTTLS,
  POP3_UPGRADETLS,

  POP3_AUTH,
  POP3_APOP,
  POP3_USER,
  POP3_PASS,
  POP3_COMMAND,
  POP3_QUIT,
  POP3_LAST
} pop3state;





struct POP3 {
  curl_pp_transfer transfer;
  char *id;
  char *custom;
};



struct pop3_conn {
  struct pingpong pp;
  pop3state state;
  _Bool ssldone;
  size_t eob;

  size_t strip;

  struct SASL sasl;
  unsigned int authtypes;
  unsigned int preftype;
  char *apoptimestamp;
  _Bool tls_supported;
};

extern const struct Curl_handler Curl_handler_pop3;
extern const struct Curl_handler Curl_handler_pop3s;
# 93 "../lib/pop3.h"
CURLcode Curl_pop3_write(struct connectdata *conn, char *str, size_t nread);
# 191 "../lib/urldata.h" 2
# 1 "../lib/smtp.h" 1
# 31 "../lib/smtp.h"
typedef enum {
  SMTP_STOP,
  SMTP_SERVERGREET,

  SMTP_EHLO,
  SMTP_HELO,
  SMTP_STARTTLS,
  SMTP_UPGRADETLS,

  SMTP_AUTH,
  SMTP_COMMAND,
  SMTP_MAIL,
  SMTP_RCPT,
  SMTP_DATA,
  SMTP_POSTDATA,
  SMTP_QUIT,
  SMTP_LAST
} smtpstate;





struct SMTP {
  curl_pp_transfer transfer;
  char *custom;
  struct curl_slist *rcpt;
  size_t eob;

  _Bool trailing_crlf;
};



struct smtp_conn {
  struct pingpong pp;
  smtpstate state;
  _Bool ssldone;
  char *domain;
  struct SASL sasl;
  _Bool tls_supported;
  _Bool size_supported;

  _Bool auth_supported;
};

extern const struct Curl_handler Curl_handler_smtp;
extern const struct Curl_handler Curl_handler_smtps;
# 89 "../lib/smtp.h"
CURLcode Curl_smtp_escape_eob(struct connectdata *conn, const ssize_t nread);
# 192 "../lib/urldata.h" 2
# 1 "../lib/ftp.h" 1
# 28 "../lib/ftp.h"
extern const struct Curl_handler Curl_handler_ftp;





CURLcode Curl_ftpsendf(struct connectdata *, const char *fmt, ...);
CURLcode Curl_GetFTPResponse(ssize_t *nread, struct connectdata *conn,
                             int *ftpcode);





typedef enum {
  FTP_STOP,
  FTP_WAIT220,

  FTP_AUTH,
  FTP_USER,
  FTP_PASS,
  FTP_ACCT,
  FTP_PBSZ,
  FTP_PROT,
  FTP_CCC,
  FTP_PWD,
  FTP_SYST,
  FTP_NAMEFMT,
  FTP_QUOTE,
  FTP_RETR_PREQUOTE,
  FTP_STOR_PREQUOTE,
  FTP_POSTQUOTE,
  FTP_CWD,
  FTP_MKD,
  FTP_MDTM,
  FTP_TYPE,
  FTP_LIST_TYPE,
  FTP_RETR_TYPE,
  FTP_STOR_TYPE,
  FTP_SIZE,
  FTP_RETR_SIZE,
  FTP_STOR_SIZE,
  FTP_REST,
  FTP_RETR_REST,
  FTP_PORT,
  FTP_PRET,
  FTP_PASV,
  FTP_LIST,
  FTP_RETR,
  FTP_STOR,
  FTP_QUIT,
  FTP_LAST
} ftpstate;

struct ftp_parselist_data;

struct ftp_wc_tmpdata {
  struct ftp_parselist_data *parser;

  struct {
    curl_write_callback write_function;
    FILE *file_descriptor;
  } backup;
};

typedef enum {
  FTPFILE_MULTICWD = 1,
  FTPFILE_NOCWD = 2,
  FTPFILE_SINGLECWD = 3

} curl_ftpfile;





struct FTP {
  curl_off_t *bytecountp;
  char *user;
  char *passwd;



  curl_pp_transfer transfer;
  curl_off_t downloadsize;
};




struct ftp_conn {
  struct pingpong pp;
  char *entrypath;
  char **dirs;
  int dirdepth;
  int diralloc;
  char *file;
  _Bool dont_check;


  _Bool ctl_valid;


  _Bool cwddone;

  _Bool cwdfail;

  _Bool wait_data_conn;
  char *prevpath;
  char transfertype;

  int count1;
  int count2;
  int count3;
  ftpstate state;
  ftpstate state_saved;

  curl_off_t retr_size_saved;
  char * server_os;
  curl_off_t known_filesize;




  char *newhost;
  unsigned short newport;

};
# 193 "../lib/urldata.h" 2
# 1 "../lib/file.h" 1
# 29 "../lib/file.h"
struct FILEPROTO {
  char *path;
  char *freepath;

  int fd;
};


extern const struct Curl_handler Curl_handler_file;
# 194 "../lib/urldata.h" 2
# 1 "../lib/ssh.h" 1
# 35 "../lib/ssh.h"
typedef enum {
  SSH_NO_STATE = -1,
  SSH_STOP = 0,

  SSH_INIT,
  SSH_S_STARTUP,
  SSH_HOSTKEY,
  SSH_AUTHLIST,
  SSH_AUTH_PKEY_INIT,
  SSH_AUTH_PKEY,
  SSH_AUTH_PASS_INIT,
  SSH_AUTH_PASS,
  SSH_AUTH_AGENT_INIT,
  SSH_AUTH_AGENT_LIST,
  SSH_AUTH_AGENT,
  SSH_AUTH_HOST_INIT,
  SSH_AUTH_HOST,
  SSH_AUTH_KEY_INIT,
  SSH_AUTH_KEY,
  SSH_AUTH_DONE,
  SSH_SFTP_INIT,
  SSH_SFTP_REALPATH,

  SSH_SFTP_QUOTE_INIT,
  SSH_SFTP_POSTQUOTE_INIT,
  SSH_SFTP_QUOTE,
  SSH_SFTP_NEXT_QUOTE,
  SSH_SFTP_QUOTE_STAT,
  SSH_SFTP_QUOTE_SETSTAT,
  SSH_SFTP_QUOTE_SYMLINK,
  SSH_SFTP_QUOTE_MKDIR,
  SSH_SFTP_QUOTE_RENAME,
  SSH_SFTP_QUOTE_RMDIR,
  SSH_SFTP_QUOTE_UNLINK,
  SSH_SFTP_TRANS_INIT,
  SSH_SFTP_UPLOAD_INIT,
  SSH_SFTP_CREATE_DIRS_INIT,
  SSH_SFTP_CREATE_DIRS,
  SSH_SFTP_CREATE_DIRS_MKDIR,
  SSH_SFTP_READDIR_INIT,
  SSH_SFTP_READDIR,
  SSH_SFTP_READDIR_LINK,
  SSH_SFTP_READDIR_BOTTOM,
  SSH_SFTP_READDIR_DONE,
  SSH_SFTP_DOWNLOAD_INIT,
  SSH_SFTP_DOWNLOAD_STAT,
  SSH_SFTP_CLOSE,
  SSH_SFTP_SHUTDOWN,
  SSH_SCP_TRANS_INIT,
  SSH_SCP_UPLOAD_INIT,
  SSH_SCP_DOWNLOAD_INIT,
  SSH_SCP_DONE,
  SSH_SCP_SEND_EOF,
  SSH_SCP_WAIT_EOF,
  SSH_SCP_WAIT_CLOSE,
  SSH_SCP_CHANNEL_FREE,
  SSH_SESSION_DISCONNECT,
  SSH_SESSION_FREE,
  SSH_QUIT,
  SSH_LAST
} sshstate;





struct SSHPROTO {
  char *path;
};



struct ssh_conn {
  const char *authlist;
# 157 "../lib/ssh.h"
};
# 195 "../lib/urldata.h" 2
# 1 "../lib/http.h" 1
# 32 "../lib/http.h"
extern const struct Curl_handler Curl_handler_http;






_Bool Curl_compareheader(const char *headerline,
                        const char *header,
                        const char *content);

char *Curl_checkheaders(const struct connectdata *conn,
                        const char *thisheader);
char *Curl_copy_header_value(const char *header);

char *Curl_checkProxyheaders(const struct connectdata *conn,
                             const char *thisheader);






struct Curl_send_buffer {
  char *buffer;
  size_t size_max;
  size_t size_used;
};
typedef struct Curl_send_buffer Curl_send_buffer;

Curl_send_buffer *Curl_add_buffer_init(void);
CURLcode Curl_add_bufferf(Curl_send_buffer *in, const char *fmt, ...);
CURLcode Curl_add_buffer(Curl_send_buffer *in, const void *inptr, size_t size);
CURLcode Curl_add_buffer_send(Curl_send_buffer *in,
                              struct connectdata *conn,
                              long *bytes_written,
                              size_t included_body_bytes,
                              int socketindex);

CURLcode Curl_add_timecondition(struct SessionHandle *data,
                                Curl_send_buffer *buf);
CURLcode Curl_add_custom_headers(struct connectdata *conn,
                                 _Bool is_connect,
                                 Curl_send_buffer *req_buffer);


CURLcode Curl_http(struct connectdata *conn, _Bool *done);
CURLcode Curl_http_done(struct connectdata *, CURLcode, _Bool premature);
CURLcode Curl_http_connect(struct connectdata *conn, _Bool *done);
CURLcode Curl_http_setup_conn(struct connectdata *conn);


void Curl_httpchunk_init(struct connectdata *conn);
CHUNKcode Curl_httpchunk_read(struct connectdata *conn, char *datap,
                              ssize_t length, ssize_t *wrote);


void Curl_http_auth_stage(struct SessionHandle *data, int stage);
CURLcode Curl_http_input_auth(struct connectdata *conn, _Bool proxy,
                              const char *auth);
CURLcode Curl_http_auth_act(struct connectdata *conn);
CURLcode Curl_http_perhapsrewind(struct connectdata *conn);
# 126 "../lib/http.h"
struct HTTP {
  struct FormData *sendit;
  curl_off_t postsize;
  const char *postdata;

  const char *p_pragma;
  const char *p_accept;
  curl_off_t readbytecount;
  curl_off_t writebytecount;


  struct Form form;

  struct back {
    curl_read_callback fread_func;
    void *fread_in;
    const char *postdata;
    curl_off_t postsize;
  } backup;

  enum {
    HTTPSEND_NADA,
    HTTPSEND_REQUEST,
    HTTPSEND_BODY,
    HTTPSEND_LAST
  } sending;

  void *send_buffer;

};

typedef int (*sending)(void);
typedef int (*recving)(void);

struct http_conn {
# 192 "../lib/http.h"
  int unused;

};

CURLcode Curl_http_readwrite_headers(struct SessionHandle *data,
                                     struct connectdata *conn,
                                     ssize_t *nread,
                                     _Bool *stop_reading);
# 215 "../lib/http.h"
CURLcode
Curl_http_output_auth(struct connectdata *conn,
                      const char *request,
                      const char *path,
                      _Bool proxytunnel);
# 196 "../lib/urldata.h" 2
# 1 "../lib/rtsp.h" 1
# 26 "../lib/rtsp.h"
extern const struct Curl_handler Curl_handler_rtsp;

_Bool Curl_rtsp_connisdead(struct connectdata *check);
CURLcode Curl_rtsp_parseheader(struct connectdata *conn, char *header);
# 43 "../lib/rtsp.h"
struct rtsp_conn {
  char *rtp_buf;
  ssize_t rtp_bufsize;
  int rtp_channel;
};




struct RTSP {
# 61 "../lib/rtsp.h"
  struct HTTP http_wrapper;

  long CSeq_sent;
  long CSeq_recv;
};
# 197 "../lib/urldata.h" 2
# 1 "../lib/smb.h" 1
# 25 "../lib/smb.h"
enum smb_conn_state {
  SMB_NOT_CONNECTED = 0,
  SMB_CONNECTING,
  SMB_NEGOTIATE,
  SMB_SETUP,
  SMB_CONNECTED
};

struct smb_conn {
  enum smb_conn_state state;
  char *user;
  char *domain;
  unsigned char challenge[8];
  unsigned int session_key;
  unsigned short uid;
  char *recv_buf;
  size_t upload_size;
  size_t send_size;
  size_t sent;
  size_t got;
};
# 198 "../lib/urldata.h" 2
# 1 "../lib/wildcard.h" 1
# 28 "../lib/wildcard.h"
typedef enum {
  CURLWC_INIT = 0,
  CURLWC_MATCHING,

  CURLWC_DOWNLOADING,
  CURLWC_CLEAN,
  CURLWC_SKIP,
  CURLWC_ERROR,
  CURLWC_DONE

} curl_wildcard_states;

typedef void (*curl_wildcard_tmp_dtor)(void *ptr);


struct WildcardData {
  curl_wildcard_states state;
  char *path;
  char *pattern;
  struct curl_llist *filelist;
  void *tmp;
  curl_wildcard_tmp_dtor tmp_dtor;
  void *customptr;
};

CURLcode Curl_wildcard_init(struct WildcardData *wc);
void Curl_wildcard_dtor(struct WildcardData *wc);

struct SessionHandle;
# 199 "../lib/urldata.h" 2
# 1 "../lib/multihandle.h" 1
# 25 "../lib/multihandle.h"
struct Curl_message {

  struct CURLMsg extmsg;
};




typedef enum {
  CURLM_STATE_INIT,
  CURLM_STATE_CONNECT_PEND,
  CURLM_STATE_CONNECT,
  CURLM_STATE_WAITRESOLVE,
  CURLM_STATE_WAITCONNECT,
  CURLM_STATE_WAITPROXYCONNECT,
  CURLM_STATE_PROTOCONNECT,

  CURLM_STATE_WAITDO,
  CURLM_STATE_DO,
  CURLM_STATE_DOING,
  CURLM_STATE_DO_MORE,
  CURLM_STATE_DO_DONE,
  CURLM_STATE_WAITPERFORM,
  CURLM_STATE_PERFORM,
  CURLM_STATE_TOOFAST,
  CURLM_STATE_DONE,
  CURLM_STATE_COMPLETED,
  CURLM_STATE_MSGSENT,
  CURLM_STATE_LAST
} CURLMstate;
# 63 "../lib/multihandle.h"
struct Curl_multi {


  long type;


  struct SessionHandle *easyp;
  struct SessionHandle *easylp;

  int num_easy;
  int num_alive;


  struct curl_llist *msglist;

  struct curl_llist *pending;



  curl_socket_callback socket_cb;
  void *socket_userp;


  struct curl_hash *hostcache;



  struct Curl_tree *timetree;




  struct curl_hash *sockhash;


  _Bool pipelining_enabled;


  struct conncache *conn_cache;



  struct SessionHandle *closure_handle;

  long maxconnects;


  long max_host_connections;


  long max_total_connections;


  long max_pipeline_length;


  long content_length_penalty_size;




  long chunk_length_penalty_size;



  struct curl_llist *pipelining_site_bl;


  struct curl_llist *pipelining_server_bl;



  curl_multi_timer_callback timer_cb;
  void *timer_userp;
  struct timeval timer_lastcall;

};
# 200 "../lib/urldata.h" 2
# 269 "../lib/urldata.h"
typedef enum {
  ssl_connect_1,
  ssl_connect_2,
  ssl_connect_2_reading,
  ssl_connect_2_writing,
  ssl_connect_3,
  ssl_connect_done
} ssl_connect_state;

typedef enum {
  ssl_connection_none,
  ssl_connection_negotiating,
  ssl_connection_complete
} ssl_connection_state;


struct ssl_connect_data {



  _Bool use;
  ssl_connection_state state;
# 361 "../lib/urldata.h"
};

struct ssl_config_data {
  long version;
  long certverifyresult;

  _Bool verifypeer;
  _Bool verifyhost;
  _Bool verifystatus;
  char *CApath;
  char *CAfile;
  const char *CRLfile;
  const char *issuercert;
  char *random_file;
  char *egdsocket;
  char *cipher_list;
  size_t max_ssl_sessions;
  curl_ssl_ctx_callback fsslctx;
  void *fsslctxp;
  _Bool sessionid;
  _Bool certinfo;


  char *username;
  char *password;
  enum CURL_TLSAUTH authtype;

};


struct curl_ssl_session {
  char *name;
  void *sessionid;
  size_t idsize;
  long age;
  int remote_port;
  struct ssl_config_data ssl_config;
};


struct digestdata {




  char *nonce;
  char *cnonce;
  char *realm;
  int algo;
  _Bool stale;
  char *opaque;
  char *qop;
  char *algorithm;
  int nc;

};

typedef enum {
  NTLMSTATE_NONE,
  NTLMSTATE_TYPE1,
  NTLMSTATE_TYPE2,
  NTLMSTATE_TYPE3,
  NTLMSTATE_LAST
} curlntlm;
# 504 "../lib/urldata.h"
struct ConnectBits {

  _Bool close;
  _Bool reuse;
  _Bool proxy;
  _Bool httpproxy;
  _Bool user_passwd;
  _Bool proxy_user_passwd;
  _Bool ipv6_ip;

  _Bool ipv6;

  _Bool do_more;

  _Bool tcpconnect[2];

  _Bool protoconnstart;


  _Bool retry;

  _Bool tunnel_proxy;



  _Bool authneg;



  _Bool rewindaftersend;



  _Bool ftp_use_epsv;



  _Bool ftp_use_eprt;


  _Bool netrc;
  _Bool userpwd_in_url;

  _Bool done;



  _Bool stream_was_rewound;


  _Bool proxy_connect_closed;


  _Bool bound;

  _Bool type_set;
};

struct hostname {
  char *rawalloc;
  char *encalloc;
  char *name;
  const char *dispname;
};
# 588 "../lib/urldata.h"
typedef enum {
  ZLIB_UNINIT,
  ZLIB_INIT,
  ZLIB_GZIP_HEADER,
  ZLIB_GZIP_INFLATING,
  ZLIB_INIT_GZIP
} zlibInitState;
# 614 "../lib/urldata.h"
typedef CURLcode (*Curl_do_more_func)(struct connectdata *, int *);
typedef CURLcode (*Curl_done_func)(struct connectdata *, CURLcode, _Bool);

enum expect100 {
  EXP100_SEND_DATA,
  EXP100_AWAITING_CONTINUE,
  EXP100_SENDING_REQUEST,

  EXP100_FAILED
};

enum upgrade101 {
  UPGR101_INIT,
  UPGR101_REQUESTED,
  UPGR101_RECEIVED,
  UPGR101_WORKING
};

enum negotiatenpn {
  NPN_INIT,
  NPN_HTTP1_1,
  NPN_HTTP2
};
# 645 "../lib/urldata.h"
struct SingleRequest {
  curl_off_t size;
  curl_off_t *bytecountp;

  curl_off_t maxdownload;

  curl_off_t *writebytecountp;

  curl_off_t bytecount;
  curl_off_t writebytecount;

  long headerbytecount;
  long deductheadercount;





  struct timeval start;
  struct timeval now;
  _Bool header;
  enum {
    HEADER_NORMAL,
    HEADER_PARTHEADER,

    HEADER_ALLBAD
  } badheader;

  int headerline;

  char *hbufp;
  size_t hbuflen;
  char *str;
  char *str_start;
  char *end_ptr;
  char *p;
  _Bool content_range;
  curl_off_t offset;

  int httpcode;

  struct timeval start100;
  enum expect100 exp100;
  enum upgrade101 upgr101;

  int auto_decoding;







  zlibInitState zlib_init;

  z_stream z;


  time_t timeofdoc;
  long bodywrites;

  char *buf;
  char *uploadbuf;
  curl_socket_t maxfd;

  int keepon;

  _Bool upload_done;


  _Bool ignorebody;
  _Bool ignorecl;


  char *location;

  char *newurl;




  ssize_t upload_present;





  char *upload_fromhere;

  _Bool chunk;
  _Bool upload_chunky;

  _Bool getheader;

  _Bool forbidchunk;



  void *protop;

};





struct Curl_handler {
  const char * scheme;


  CURLcode (*setup_connection)(struct connectdata *);


  CURLcode (*do_it)(struct connectdata *, _Bool *done);
  Curl_done_func done;





  Curl_do_more_func do_more;







  CURLcode (*connect_it)(struct connectdata *, _Bool *done);


  CURLcode (*connecting)(struct connectdata *, _Bool *done);
  CURLcode (*doing)(struct connectdata *, _Bool *done);



  int (*proto_getsock)(struct connectdata *conn,
                       curl_socket_t *socks,
                       int numsocks);



  int (*doing_getsock)(struct connectdata *conn,
                       curl_socket_t *socks,
                       int numsocks);



  int (*domore_getsock)(struct connectdata *conn,
                        curl_socket_t *socks,
                        int numsocks);




  int (*perform_getsock)(const struct connectdata *conn,
                         curl_socket_t *socks,
                         int numsocks);






  CURLcode (*disconnect)(struct connectdata *, _Bool dead_connection);



  CURLcode (*readwrite)(struct SessionHandle *data, struct connectdata *conn,
                        ssize_t *nread, _Bool *readmore);

  long defport;
  unsigned int protocol;

  unsigned int flags;
};
# 841 "../lib/urldata.h"
typedef ssize_t (Curl_send)(struct connectdata *conn,
                            int sockindex,
                            const void *buf,
                            size_t len,
                            CURLcode *err);


typedef ssize_t (Curl_recv)(struct connectdata *conn,
                            int sockindex,
                            char *buf,
                            size_t len,
                            CURLcode *err);





struct connectdata {



  struct SessionHandle *data;




  struct Curl_chunker chunk;

  curl_closesocket_callback fclosesocket;
  void *closesocket_client;

  _Bool inuse;





  long connection_id;






  struct Curl_dns_entry *dns_entry;




  Curl_addrinfo *ip_addr;
  Curl_addrinfo *tempaddr[2];




  char ip_addr_str[sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")];

  unsigned int scope_id;

  int socktype;

  struct hostname host;
  struct hostname proxy;

  long port;
  int remote_port;
# 915 "../lib/urldata.h"
  char primary_ip[sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")];
  long primary_port;





  char local_ip[sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")];
  long local_port;

  char *user;
  char *passwd;
  char *options;

  char *xoauth2_bearer;

  char *proxyuser;
  char *proxypasswd;
  curl_proxytype proxytype;

  int httpversion;
  int rtspversion;

  struct timeval now;
  struct timeval created;
  curl_socket_t sock[2];

  curl_socket_t tempsock[2];
  _Bool sock_accepted[2];

  Curl_recv *recv[2];
  Curl_send *send[2];

  struct ssl_connect_data ssl[2];
  struct ssl_config_data ssl_config;

  struct ConnectBits bits;




  struct timeval connecttime;

  int num_addr;
  long timeoutms_per_addr;


  const struct Curl_handler *handler;
  const struct Curl_handler *given;

  long ip_version;



  curl_socket_t sockfd;
  curl_socket_t writesockfd;





  struct dynamically_allocated_data {
    char *proxyuserpwd;
    char *uagent;
    char *accept_encoding;
    char *userpwd;
    char *rangeline;
    char *ref;
    char *host;
    char *cookiehost;
    char *rtsp_transport;
    char *te;
  } allocptr;
# 1009 "../lib/urldata.h"
  _Bool readchannel_inuse;

  _Bool writechannel_inuse;

  struct curl_llist *send_pipe;

  struct curl_llist *recv_pipe;

  char* master_buffer;

  size_t read_pos;
  size_t buf_len;


  curl_seek_callback seek_func;
  void *seek_client;




  curl_read_callback fread_func;
  void *fread_in;
# 1047 "../lib/urldata.h"
  char syserr_buf [256];







  char *trailer;
  int trlMax;
  int trlPos;

  union {
    struct ftp_conn ftpc;
    struct http_conn httpc;
    struct ssh_conn sshc;
    struct tftp_state_data *tftpc;
    struct imap_conn imapc;
    struct pop3_conn pop3c;
    struct smtp_conn smtpc;
    struct rtsp_conn rtspc;
    struct smb_conn smbc;
    void *generic;
  } proto;

  int cselect_bits;
  int waitfor;





  _Bool verifypeer;
  _Bool verifyhost;






  char *localdev;
  unsigned short localport;
  int localportrange;


  enum {
    TUNNEL_INIT,
    TUNNEL_CONNECT,
    TUNNEL_COMPLETE
  } tunnel_state[2];
  struct connectbundle *bundle;

  enum negotiatenpn negnpn;
};






struct PureInfo {
  int httpcode;
  int httpproxycode;
  int httpversion;
  long filetime;



  _Bool timecond;

  long header_size;
  long request_size;
  unsigned long proxyauthavail;
  unsigned long httpauthavail;
  long numconnects;
  char *contenttype;
  char *wouldredirect;
# 1133 "../lib/urldata.h"
  char conn_primary_ip[sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")];
  long conn_primary_port;

  char conn_local_ip[sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255")];
  long conn_local_port;

  struct curl_certinfo certs;


};


struct Progress {
  long lastshow;

  curl_off_t size_dl;
  curl_off_t size_ul;
  curl_off_t downloaded;
  curl_off_t uploaded;

  curl_off_t current_speed;

  _Bool callback;
  int width;
  int flags;

  double timespent;

  curl_off_t dlspeed;
  curl_off_t ulspeed;

  double t_nslookup;
  double t_connect;
  double t_appconnect;
  double t_pretransfer;
  double t_starttransfer;
  double t_redirect;

  struct timeval start;
  struct timeval t_startsingle;
  struct timeval t_startop;
  struct timeval t_acceptdata;


  curl_off_t speeder[ (5+1) ];
  struct timeval speeder_time[ (5+1) ];
  int speeder_c;
};

typedef enum {
  HTTPREQ_NONE,
  HTTPREQ_GET,
  HTTPREQ_POST,
  HTTPREQ_POST_FORM,
  HTTPREQ_PUT,
  HTTPREQ_HEAD,
  HTTPREQ_CUSTOM,
  HTTPREQ_LAST
} Curl_HttpReq;

typedef enum {
    RTSPREQ_NONE,
    RTSPREQ_OPTIONS,
    RTSPREQ_DESCRIBE,
    RTSPREQ_ANNOUNCE,
    RTSPREQ_SETUP,
    RTSPREQ_PLAY,
    RTSPREQ_PAUSE,
    RTSPREQ_TEARDOWN,
    RTSPREQ_GET_PARAMETER,
    RTSPREQ_SET_PARAMETER,
    RTSPREQ_RECORD,
    RTSPREQ_RECEIVE,
    RTSPREQ_LAST
} Curl_RtspReq;
# 1220 "../lib/urldata.h"
struct auth {
  unsigned long want;

  unsigned long picked;
  unsigned long avail;

  _Bool done;

  _Bool multi;

  _Bool iestyle;

};

struct UrlState {


  struct conncache *conn_cache;




  _Bool multi_owned_by_easy;


  struct timeval keeps_speed;

  struct connectdata *lastconnect;

  char *headerbuff;
  size_t headersize;

  char buffer[16384 +1];
  char uploadbuffer[16384 +1];
  curl_off_t current_speed;

  _Bool this_is_a_follow;

  char *first_host;




  struct curl_ssl_session *session;
  long sessionage;
  char *tempwrite;

  size_t tempwritesize;
  int tempwritetype;

  char *scratch;
  _Bool errorbuf;


  int os_errno;


  void (*prev_signal)(int sig);

  _Bool allow_port;

  struct digestdata digest;
  struct digestdata proxydigest;






  struct auth authhost;
  struct auth authproxy;

  _Bool authproblem;

  void *resolver;





  struct timeval expiretime;
  struct Curl_tree timenode;
  struct curl_llist *timeoutlist;


  char *most_recent_ftp_entrypath;


  _Bool ftp_trying_alternative;

  int httpversion;

  _Bool expect100header;

  _Bool pipe_broke;







  _Bool prev_block_had_trailing_cr;

  curl_off_t crlf_conversions;

  char *pathbuffer;
  char *path;

  _Bool slash_removed;

  _Bool use_range;
  _Bool rangestringalloc;

  char *range;

  curl_off_t resume_from;


  long rtsp_next_client_CSeq;
  long rtsp_next_server_CSeq;
  long rtsp_CSeq_recv;

  curl_off_t infilesize;

};
# 1355 "../lib/urldata.h"
struct DynamicStatic {
  char *url;
  _Bool url_alloc;
  char *referer;
  _Bool referer_alloc;
  struct curl_slist *cookielist;

  struct curl_slist *resolve;

};
# 1375 "../lib/urldata.h"
struct Curl_multi;

enum dupstring {
  STRING_CERT,
  STRING_CERT_TYPE,
  STRING_COOKIE,
  STRING_COOKIEJAR,
  STRING_CUSTOMREQUEST,
  STRING_DEVICE,
  STRING_ENCODING,
  STRING_FTP_ACCOUNT,
  STRING_FTP_ALTERNATIVE_TO_USER,
  STRING_FTPPORT,
  STRING_KEY,
  STRING_KEY_PASSWD,
  STRING_KEY_TYPE,
  STRING_KRB_LEVEL,
  STRING_NETRC_FILE,

  STRING_PROXY,
  STRING_SET_RANGE,
  STRING_SET_REFERER,
  STRING_SET_URL,
  STRING_SSL_CAPATH,
  STRING_SSL_CAFILE,
  STRING_SSL_PINNEDPUBLICKEY,
  STRING_SSL_CIPHER_LIST,
  STRING_SSL_EGDSOCKET,
  STRING_SSL_RANDOM_FILE,
  STRING_USERAGENT,
  STRING_SSL_CRLFILE,
  STRING_SSL_ISSUERCERT,
  STRING_USERNAME,
  STRING_PASSWORD,
  STRING_OPTIONS,
  STRING_PROXYUSERNAME,
  STRING_PROXYPASSWORD,
  STRING_NOPROXY,

  STRING_RTSP_SESSION_ID,
  STRING_RTSP_STREAM_URI,
  STRING_RTSP_TRANSPORT,
# 1426 "../lib/urldata.h"
  STRING_MAIL_FROM,
  STRING_MAIL_AUTH,


  STRING_TLSAUTH_USERNAME,
  STRING_TLSAUTH_PASSWORD,

  STRING_BEARER,

  STRING_UNIX_SOCKET_PATH,




  STRING_LASTZEROTERMINATED,




  STRING_COPYPOSTFIELDS,

  STRING_LAST
};

struct UserDefined {
  FILE *err;
  void *debugdata;
  char *errorbuffer;
  long proxyport;


  void *out;
  void *in;
  void *writeheader;
  void *rtp_out;
  long use_port;
  unsigned long httpauth;
  unsigned long proxyauth;
  long followlocation;
  long maxredirs;


  int keep_post;

  _Bool free_referer;

  void *postfields;
  curl_seek_callback seek_func;
  curl_off_t postfieldsize;


  unsigned short localport;
  int localportrange;

  curl_write_callback fwrite_func;
  curl_write_callback fwrite_header;
  curl_write_callback fwrite_rtp;
  curl_read_callback fread_func;
  int is_fread_set;
  int is_fwrite_set;
  curl_progress_callback fprogress;
  curl_xferinfo_callback fxferinfo;
  curl_debug_callback fdebug;
  curl_ioctl_callback ioctl_func;
  curl_sockopt_callback fsockopt;
  void *sockopt_client;
  curl_opensocket_callback fopensocket;


  void* opensocket_client;
  curl_closesocket_callback fclosesocket;

  void* closesocket_client;

  void *seek_client;


  curl_conv_callback convfromnetwork;

  curl_conv_callback convtonetwork;

  curl_conv_callback convfromutf8;

  void *progress_client;
  void *ioctl_client;
  long timeout;
  long connecttimeout;
  long accepttimeout;
  long server_response_timeout;
  long tftp_blksize ;
  curl_off_t filesize;
  long low_speed_limit;
  long low_speed_time;
  curl_off_t max_send_speed;
  curl_off_t max_recv_speed;

  curl_off_t set_resume_from;
  struct curl_slist *headers;
  struct curl_slist *proxyheaders;
  struct curl_httppost *httppost;
  _Bool sep_headers;
  _Bool cookiesession;
  _Bool crlf;
  struct curl_slist *quote;
  struct curl_slist *postquote;
  struct curl_slist *prequote;
  struct curl_slist *source_quote;
  struct curl_slist *source_prequote;

  struct curl_slist *source_postquote;

  struct curl_slist *telnet_options;
  struct curl_slist *resolve;

  curl_TimeCond timecondition;
  time_t timevalue;
  Curl_HttpReq httpreq;
  long httpversion;

  struct ssl_config_data ssl;
  curl_proxytype proxytype;
  long dns_cache_timeout;
  long buffer_size;
  void *private_data;

  struct curl_slist *http200aliases;

  long ipver;


  curl_off_t max_filesize;

  curl_ftpfile ftp_filemethod;

  int ftp_create_missing_dirs;



  curl_sshkeycallback ssh_keyfunc;
  void *ssh_keyfunc_userp;





  _Bool printhost;
  _Bool get_filetime;
  _Bool tunnel_thru_httpproxy;
  _Bool prefer_ascii;
  _Bool ftp_append;
  _Bool ftp_list_only;
  _Bool ftp_use_port;
  _Bool hide_progress;
  _Bool http_fail_on_error;
  _Bool http_follow_location;
  _Bool http_transfer_encoding;
  _Bool http_disable_hostname_check_before_authentication;
  _Bool include_header;
  _Bool http_set_referer;
  _Bool http_auto_referer;
  _Bool opt_no_body;
  _Bool set_port;
  _Bool upload;
  enum CURL_NETRC_OPTION
       use_netrc;
  _Bool verbose;
  _Bool krb;
  _Bool reuse_forbid;
  _Bool reuse_fresh;
  _Bool ftp_use_epsv;
  _Bool ftp_use_eprt;
  _Bool ftp_use_pret;

  curl_usessl use_ssl;

  curl_ftpauth ftpsslauth;
  curl_ftpccc ftp_ccc;
  _Bool no_signal;
  _Bool global_dns_cache;
  _Bool tcp_nodelay;
  _Bool ignorecl;
  _Bool ftp_skip_ip;

  _Bool connect_only;
  _Bool ssl_enable_beast;

  long ssh_auth_types;
  _Bool http_te_skip;

  _Bool http_ce_skip;

  long new_file_perms;
  long new_directory_perms;
  _Bool proxy_transfer_mode;

  char *str[STRING_LAST];
  unsigned int scope_id;
  long allowed_protocols;
  long redir_protocols;



  struct curl_slist *mail_rcpt;
  _Bool sasl_ir;

  Curl_RtspReq rtspreq;
  long rtspversion;
  _Bool wildcardmatch;
  curl_chunk_bgn_callback chunk_bgn;

  curl_chunk_end_callback chunk_end;

  curl_fnmatch_callback fnmatch;

  void *fnmatch_data;

  long gssapi_delegation;


  _Bool tcp_keepalive;
  long tcp_keepidle;
  long tcp_keepintvl;

  size_t maxconnects;

  _Bool ssl_enable_npn;
  _Bool ssl_enable_alpn;

  long expect_100_timeout;
};

struct Names {
  struct curl_hash *hostcache;
  enum {
    HCACHE_NONE,
    HCACHE_GLOBAL,
    HCACHE_MULTI,
    HCACHE_SHARED
  } hostcachetype;
};
# 1677 "../lib/urldata.h"
struct SessionHandle {

  struct SessionHandle *next;
  struct SessionHandle *prev;

  struct connectdata *easy_conn;

  CURLMstate mstate;
  CURLcode result;

  struct Curl_message msg;





  curl_socket_t sockets[5];
  int numsocks;

  struct Names dns;
  struct Curl_multi *multi;


  struct Curl_multi *multi_easy;


  struct Curl_share *share;
  struct SingleRequest req;
  struct UserDefined set;
  struct DynamicStatic change;
  struct CookieInfo *cookies;



  struct Progress progress;
  struct UrlState state;

  struct WildcardData wildcard;
  struct PureInfo info;
  struct curl_tlssessioninfo tsi;






  unsigned int magic;
};
# 82 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/netrc.h" 1
# 26 "../lib/netrc.h"
int Curl_parsenetrc(const char *host,
                    char **loginp,
                    char **passwordp,
                    char *filename);
# 83 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2


# 1 "../lib/vtls/vtls.h" 1
# 26 "../lib/vtls/vtls.h"
# 1 "../lib/vtls/openssl.h" 1
# 27 "../lib/vtls/vtls.h" 2
# 1 "../lib/vtls/gtls.h" 1
# 28 "../lib/vtls/vtls.h" 2
# 1 "../lib/vtls/nssg.h" 1
# 29 "../lib/vtls/vtls.h" 2
# 1 "../lib/vtls/gskit.h" 1
# 30 "../lib/vtls/vtls.h" 2
# 1 "../lib/vtls/polarssl.h" 1
# 31 "../lib/vtls/vtls.h" 2
# 1 "../lib/vtls/axtls.h" 1
# 32 "../lib/vtls/vtls.h" 2
# 1 "../lib/vtls/cyassl.h" 1
# 33 "../lib/vtls/vtls.h" 2
# 1 "../lib/vtls/schannel.h" 1
# 34 "../lib/vtls/vtls.h" 2
# 1 "../lib/vtls/darwinssl.h" 1
# 35 "../lib/vtls/vtls.h" 2
# 48 "../lib/vtls/vtls.h"
_Bool Curl_ssl_config_matches(struct ssl_config_data* data,
                             struct ssl_config_data* needle);
_Bool Curl_clone_ssl_config(struct ssl_config_data* source,
                           struct ssl_config_data* dest);
void Curl_free_ssl_config(struct ssl_config_data* sslc);

unsigned int Curl_rand(struct SessionHandle *);

int Curl_ssl_backend(void);
# 86 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2

# 1 "../lib/transfer.h" 1
# 25 "../lib/transfer.h"
CURLcode Curl_pretransfer(struct SessionHandle *data);
CURLcode Curl_second_connect(struct connectdata *conn);
CURLcode Curl_posttransfer(struct SessionHandle *data);

typedef enum {
  FOLLOW_NONE,

  FOLLOW_FAKE,
  FOLLOW_RETRY,

  FOLLOW_REDIR,
  FOLLOW_LAST
} followtype;

CURLcode Curl_follow(struct SessionHandle *data, char *newurl,
                     followtype type);


CURLcode Curl_readwrite(struct connectdata *conn, _Bool *done);
int Curl_single_getsock(const struct connectdata *conn,
                        curl_socket_t *socks,
                        int numsocks);
CURLcode Curl_readrewind(struct connectdata *conn);
CURLcode Curl_fillreadbuffer(struct connectdata *conn, int bytes, int *nreadp);
CURLcode Curl_reconnect_request(struct connectdata **connp);
CURLcode Curl_retry_request(struct connectdata *conn, char **url);
_Bool Curl_meets_timecondition(struct SessionHandle *data, time_t timeofdoc);


void
Curl_setup_transfer (struct connectdata *data,
               int sockindex,
               curl_off_t size,
               _Bool getheader,
               curl_off_t *bytecountp,
               int writesockindex,


               curl_off_t *writecountp
);

long Curl_sleep_time(curl_off_t rate_bps, curl_off_t cur_rate_bps,
                     int pkt_size);
# 88 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/sendf.h" 1
# 27 "../lib/sendf.h"
CURLcode Curl_sendf(curl_socket_t sockfd, struct connectdata *,
                    const char *fmt, ...);
void Curl_infof(struct SessionHandle *, const char *fmt, ...);
void Curl_failf(struct SessionHandle *, const char *fmt, ...);
# 54 "../lib/sendf.h"
CURLcode Curl_client_chop_write(struct connectdata *conn, int type, char *ptr,
                                size_t len) __attribute__((warn_unused_result));
CURLcode Curl_client_write(struct connectdata *conn, int type, char *ptr,
                           size_t len) __attribute__((warn_unused_result));


CURLcode Curl_read_plain(curl_socket_t sockfd,
                         char *buf,
                         size_t bytesfromsocket,
                         ssize_t *n);

ssize_t Curl_recv_plain(struct connectdata *conn, int num, char *buf,
                        size_t len, CURLcode *code);
ssize_t Curl_send_plain(struct connectdata *conn, int num,
                        const void *mem, size_t len, CURLcode *code);


CURLcode Curl_read(struct connectdata *conn, curl_socket_t sockfd,
                   char *buf, size_t buffersize,
                   ssize_t *n);

CURLcode Curl_write(struct connectdata *conn,
                    curl_socket_t sockfd,
                    const void *mem, size_t len,
                    ssize_t *written);


CURLcode Curl_write_plain(struct connectdata *conn,
                          curl_socket_t sockfd,
                          const void *mem, size_t len,
                          ssize_t *written);


int Curl_debug(struct SessionHandle *handle, curl_infotype type,
               char *data, size_t size,
               struct connectdata *conn);
# 89 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/progress.h" 1
# 28 "../lib/progress.h"
typedef enum {
  TIMER_NONE,
  TIMER_STARTOP,
  TIMER_STARTSINGLE,
  TIMER_NAMELOOKUP,
  TIMER_CONNECT,
  TIMER_APPCONNECT,
  TIMER_PRETRANSFER,
  TIMER_STARTTRANSFER,
  TIMER_POSTRANSFER,
  TIMER_STARTACCEPT,
  TIMER_REDIRECT,
  TIMER_LAST
} timerid;

int Curl_pgrsDone(struct connectdata *);
void Curl_pgrsStartNow(struct SessionHandle *data);
void Curl_pgrsSetDownloadSize(struct SessionHandle *data, curl_off_t size);
void Curl_pgrsSetUploadSize(struct SessionHandle *data, curl_off_t size);
void Curl_pgrsSetDownloadCounter(struct SessionHandle *data, curl_off_t size);
void Curl_pgrsSetUploadCounter(struct SessionHandle *data, curl_off_t size);
int Curl_pgrsUpdate(struct connectdata *);
void Curl_pgrsResetTimesSizes(struct SessionHandle *data);
void Curl_pgrsTime(struct SessionHandle *data, timerid timer);
# 90 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2

# 1 "../lib/strequal.h" 1
# 92 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/strerror.h" 1
# 27 "../lib/strerror.h"
const char *Curl_strerror (struct connectdata *conn, int err);
# 93 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/escape.h" 1
# 27 "../lib/escape.h"
CURLcode Curl_urldecode(struct SessionHandle *data,
                        const char *string, size_t length,
                        char **ostring, size_t *olen,
                        _Bool reject_crlf);
# 94 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/strtok.h" 1
# 25 "../lib/strtok.h"
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3
# 26 "../lib/strtok.h" 2
# 95 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/share.h" 1
# 39 "../lib/share.h"
struct Curl_share {
  unsigned int specifier;
  volatile unsigned int dirty;

  curl_lock_function lockfunc;
  curl_unlock_function unlockfunc;
  void *clientdata;

  struct curl_hash *hostcache;

  struct CookieInfo *cookies;


  struct curl_ssl_session *sslsession;
  size_t max_ssl_sessions;
  long sessionage;
};

CURLSHcode Curl_share_lock (struct SessionHandle *, curl_lock_data,
                            curl_lock_access);
CURLSHcode Curl_share_unlock (struct SessionHandle *, curl_lock_data);
# 96 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/content_encoding.h" 1
# 32 "../lib/content_encoding.h"
void Curl_unencode_cleanup(struct connectdata *conn);





CURLcode Curl_unencode_deflate_write(struct connectdata *conn,
                                     struct SingleRequest *req,
                                     ssize_t nread);

CURLcode
Curl_unencode_gzip_write(struct connectdata *conn,
                         struct SingleRequest *k,
                         ssize_t nread);
# 97 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/http_digest.h" 1
# 27 "../lib/http_digest.h"
CURLcode Curl_input_digest(struct connectdata *conn,
                           _Bool proxy, const char *header);


CURLcode Curl_output_digest(struct connectdata *conn,
                            _Bool proxy,
                            const unsigned char *request,
                            const unsigned char *uripath);


void Curl_digest_cleanup(struct SessionHandle *data);
# 98 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/http_negotiate.h" 1
# 99 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/select.h" 1
# 28 "../lib/select.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/poll.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/poll.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/poll.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/poll.h" 2 3 4
# 36 "/usr/include/x86_64-linux-gnu/sys/poll.h" 3 4
typedef unsigned long int nfds_t;


struct pollfd
  {
    int fd;
    short int events;
    short int revents;
  };
# 57 "/usr/include/x86_64-linux-gnu/sys/poll.h" 3 4
extern int poll (struct pollfd *__fds, nfds_t __nfds, int __timeout);
# 29 "../lib/select.h" 2
# 74 "../lib/select.h"
int Curl_socket_check(curl_socket_t readfd, curl_socket_t readfd2,
                      curl_socket_t writefd,
                      long timeout_ms);





int Curl_poll(struct pollfd ufds[], unsigned int nfds, int timeout_ms);





extern int Curl_ack_eintr;

int Curl_wait_ms(int timeout_ms);
# 100 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/multiif.h" 1
# 28 "../lib/multiif.h"
void Curl_expire(struct SessionHandle *data, long milli);
void Curl_expire_latest(struct SessionHandle *data, long milli);

_Bool Curl_multi_pipeline_enabled(const struct Curl_multi* multi);
void Curl_multi_handlePipeBreak(struct SessionHandle *data);



struct Curl_multi *Curl_multi_handle(int hashsize, int chashsize);
# 58 "../lib/multiif.h"
void Curl_multi_process_pending_handles(struct Curl_multi *multi);


size_t Curl_multi_max_host_connections(struct Curl_multi *multi);


size_t Curl_multi_max_pipeline_length(struct Curl_multi *multi);


curl_off_t Curl_multi_content_length_penalty_size(struct Curl_multi *multi);


curl_off_t Curl_multi_chunk_length_penalty_size(struct Curl_multi *multi);


struct curl_llist *Curl_multi_pipelining_site_bl(struct Curl_multi *multi);


struct curl_llist *Curl_multi_pipelining_server_bl(struct Curl_multi *multi);


size_t Curl_multi_max_total_connections(struct Curl_multi *multi);
# 91 "../lib/multiif.h"
void Curl_multi_closed(struct connectdata *conn, curl_socket_t s);
# 101 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/easyif.h" 1
# 102 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/speedcheck.h" 1
# 29 "../lib/speedcheck.h"
void Curl_speedinit(struct SessionHandle *data);
CURLcode Curl_speedcheck(struct SessionHandle *data,
                         struct timeval now);
# 103 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/rawstr.h" 1
# 35 "../lib/rawstr.h"
int Curl_raw_equal(const char *first, const char *second);
int Curl_raw_nequal(const char *first, const char *second, size_t max);

char Curl_raw_toupper(char in);





void Curl_strntoupper(char *dest, const char *src, size_t n);
# 104 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/warnless.h" 1
# 29 "../lib/warnless.h"
unsigned short curlx_ultous(unsigned long ulnum);

unsigned char curlx_ultouc(unsigned long ulnum);

int curlx_ultosi(unsigned long ulnum);

int curlx_uztosi(size_t uznum);

curl_off_t curlx_uztoso(size_t uznum);

unsigned long curlx_uztoul(size_t uznum);

unsigned int curlx_uztoui(size_t uznum);

int curlx_sltosi(long slnum);

unsigned int curlx_sltoui(long slnum);

unsigned short curlx_sltous(long slnum);

ssize_t curlx_uztosz(size_t uznum);

size_t curlx_sotouz(curl_off_t sonum);

int curlx_sztosi(ssize_t sznum);

size_t curlx_sitouz(int sinum);
# 105 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/non-ascii.h" 1
# 106 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/inet_pton.h" 1
# 27 "../lib/inet_pton.h"
int Curl_inet_pton(int, const char *, void *);
# 107 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2



# 1 "../lib/dict.h" 1
# 26 "../lib/dict.h"
extern const struct Curl_handler Curl_handler_dict;
# 111 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/telnet.h" 1
# 25 "../lib/telnet.h"
extern const struct Curl_handler Curl_handler_telnet;
# 112 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/tftp.h" 1
# 25 "../lib/tftp.h"
extern const struct Curl_handler Curl_handler_tftp;
# 113 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2


# 1 "../lib/curl_ldap.h" 1
# 116 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2


# 1 "../lib/url.h" 1
# 30 "../lib/url.h"
CURLcode Curl_open(struct SessionHandle **curl);
CURLcode Curl_init_userdefined(struct UserDefined *set);
CURLcode Curl_setopt(struct SessionHandle *data, CURLoption option,
                     va_list arg);
CURLcode Curl_dupset(struct SessionHandle * dst, struct SessionHandle * src);
void Curl_freeset(struct SessionHandle * data);
CURLcode Curl_close(struct SessionHandle *data);
CURLcode Curl_connect(struct SessionHandle *, struct connectdata **,
                      _Bool *async, _Bool *protocol_connect);
CURLcode Curl_do(struct connectdata **, _Bool *done);
CURLcode Curl_do_more(struct connectdata *, int *completed);
CURLcode Curl_done(struct connectdata **, CURLcode, _Bool premature);
CURLcode Curl_disconnect(struct connectdata *, _Bool dead_connection);
CURLcode Curl_protocol_connect(struct connectdata *conn, _Bool *done);
CURLcode Curl_protocol_connecting(struct connectdata *conn, _Bool *done);
CURLcode Curl_protocol_doing(struct connectdata *conn, _Bool *done);
CURLcode Curl_setup_conn(struct connectdata *conn,
                         _Bool *protocol_done);
void Curl_free_request_state(struct SessionHandle *data);

int Curl_protocol_getsock(struct connectdata *conn,
                          curl_socket_t *socks,
                          int numsocks);
int Curl_doing_getsock(struct connectdata *conn,
                       curl_socket_t *socks,
                       int numsocks);

_Bool Curl_isPipeliningEnabled(const struct SessionHandle *handle);
CURLcode Curl_addHandleToPipeline(struct SessionHandle *handle,
                                  struct curl_llist *pipeline);
int Curl_removeHandleFromPipeline(struct SessionHandle *handle,
                                  struct curl_llist *pipeline);


void Curl_getoff_all_pipelines(struct SessionHandle *data,
                               struct connectdata *conn);

void Curl_close_connections(struct SessionHandle *data);





CURLcode Curl_connected_proxy(struct connectdata *conn, int sockindex);




void Curl_verboseconnect(struct connectdata *conn);
# 119 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/connect.h" 1
# 26 "../lib/connect.h"
# 1 "../lib/nonblock.h" 1
# 27 "../lib/nonblock.h"
int curlx_nonblock(curl_socket_t sockfd,
                   int nonblock );
# 27 "../lib/connect.h" 2
# 1 "../lib/sockaddr.h" 1
# 27 "../lib/sockaddr.h"
struct Curl_sockaddr_storage {
  union {
    struct sockaddr sa;
    struct sockaddr_in sa_in;

    struct sockaddr_in6 sa_in6;


    struct sockaddr_storage sa_stor;



  } buffer;
};
# 28 "../lib/connect.h" 2

CURLcode Curl_is_connected(struct connectdata *conn,
                           int sockindex,
                           _Bool *connected);

CURLcode Curl_connecthost(struct connectdata *conn,
                          const struct Curl_dns_entry *host);



long Curl_timeleft(struct SessionHandle *data,
                   struct timeval *nowp,
                   _Bool duringconnect);
# 52 "../lib/connect.h"
curl_socket_t Curl_getconnectinfo(struct SessionHandle *data,
                                  struct connectdata **connp);
# 70 "../lib/connect.h"
void Curl_updateconninfo(struct connectdata *conn, curl_socket_t sockfd);
void Curl_persistconninfo(struct connectdata *conn);
int Curl_closesocket(struct connectdata *conn, curl_socket_t sock);
# 81 "../lib/connect.h"
struct Curl_sockaddr_ex {
  int family;
  int socktype;
  int protocol;
  unsigned int addrlen;
  union {
    struct sockaddr addr;
    struct Curl_sockaddr_storage buff;
  } _sa_ex_u;
};
# 100 "../lib/connect.h"
CURLcode Curl_socket(struct connectdata *conn,
                     const Curl_addrinfo *ai,
                     struct Curl_sockaddr_ex *addr,
                     curl_socket_t *sockfd);
# 120 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/inet_ntop.h" 1
# 27 "../lib/inet_ntop.h"
char *Curl_inet_ntop(int af, const void *addr, char *buf, size_t size);
# 121 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/curl_ntlm.h" 1
# 122 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/curl_ntlm_wb.h" 1
# 123 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/socks.h" 1
# 38 "../lib/socks.h"
int Curl_blockread_all(struct connectdata *conn,
                       curl_socket_t sockfd,
                       char *buf,
                       ssize_t buffersize,
                       ssize_t *n);





CURLcode Curl_SOCKS4(const char *proxy_name,
                     const char *hostname,
                     int remote_port,
                     int sockindex,
                     struct connectdata *conn,
                     _Bool protocol4a);





CURLcode Curl_SOCKS5(const char *proxy_name,
                     const char *proxy_password,
                     const char *hostname,
                     int remote_port,
                     int sockindex,
                     struct connectdata *conn);
# 124 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/curl_rtmp.h" 1
# 125 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/gopher.h" 1
# 26 "../lib/gopher.h"
extern const struct Curl_handler Curl_handler_gopher;
# 126 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/http_proxy.h" 1
# 27 "../lib/http_proxy.h"
CURLcode Curl_proxyCONNECT(struct connectdata *conn,
                           int tunnelsocket,
                           const char *hostname, int remote_port);




CURLcode Curl_proxy_connect(struct connectdata *conn);
# 127 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/bundles.h" 1
# 25 "../lib/bundles.h"
struct connectbundle {
  _Bool server_supports_pipelining;

  size_t num_connections;
  struct curl_llist *conn_list;
};

CURLcode Curl_bundle_create(struct SessionHandle *data,
                            struct connectbundle **cb_ptr);

void Curl_bundle_destroy(struct connectbundle *cb_ptr);

CURLcode Curl_bundle_add_conn(struct connectbundle *cb_ptr,
                              struct connectdata *conn);

int Curl_bundle_remove_conn(struct connectbundle *cb_ptr,
                            struct connectdata *conn);
# 128 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/conncache.h" 1
# 25 "../lib/conncache.h"
struct conncache {
  struct curl_hash *hash;
  size_t num_connections;
  long next_connection_id;
  struct timeval last_cleanup;
};

struct conncache *Curl_conncache_init(int size);

void Curl_conncache_destroy(struct conncache *connc);

struct connectbundle *Curl_conncache_find_bundle(struct conncache *connc,
                                                 char *hostname);

CURLcode Curl_conncache_add_conn(struct conncache *connc,
                                 struct connectdata *conn);

void Curl_conncache_remove_conn(struct conncache *connc,
                                struct connectdata *conn);

void Curl_conncache_foreach(struct conncache *connc,
                            void *param,
                            int (*func)(struct connectdata *conn,
                                        void *param));

struct connectdata *
Curl_conncache_find_first_connection(struct conncache *connc);

void Curl_conncache_print(struct conncache *connc);
# 129 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2

# 1 "../lib/pipeline.h" 1
# 25 "../lib/pipeline.h"
CURLcode Curl_add_handle_to_pipeline(struct SessionHandle *handle,
                                     struct connectdata *conn);
void Curl_move_handle_from_send_to_recv_pipe(struct SessionHandle *handle,
                                             struct connectdata *conn);
_Bool Curl_pipeline_penalized(struct SessionHandle *data,
                             struct connectdata *conn);

_Bool Curl_pipeline_site_blacklisted(struct SessionHandle *handle,
                                    struct connectdata *conn);

CURLMcode Curl_pipeline_set_site_blacklist(char **sites,
                                           struct curl_llist **list_ptr);

_Bool Curl_pipeline_server_blacklisted(struct SessionHandle *handle,
                                      char *server_name);

CURLMcode Curl_pipeline_set_server_blacklist(char **servers,
                                             struct curl_llist **list_ptr);
# 131 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/dotdot.h" 1
# 24 "../lib/dotdot.h"
char *Curl_dedotdotify(const char *input);
# 132 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2
# 1 "../lib/strdup.h" 1
# 29 "../lib/strdup.h"
char *Curl_memdup(const char *src, size_t buffer_length);
# 133 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2


# 1 "../include/curl/mprintf.h" 1
# 34 "../include/curl/mprintf.h"
__attribute__ ((__visibility__ ("default"))) int curl_mprintf(const char *format, ...);
__attribute__ ((__visibility__ ("default"))) int curl_mfprintf(FILE *fd, const char *format, ...);
__attribute__ ((__visibility__ ("default"))) int curl_msprintf(char *buffer, const char *format, ...);
__attribute__ ((__visibility__ ("default"))) int curl_msnprintf(char *buffer, size_t maxlength,
                               const char *format, ...);
__attribute__ ((__visibility__ ("default"))) int curl_mvprintf(const char *format, va_list args);
__attribute__ ((__visibility__ ("default"))) int curl_mvfprintf(FILE *fd, const char *format, va_list args);
__attribute__ ((__visibility__ ("default"))) int curl_mvsprintf(char *buffer, const char *format, va_list args);
__attribute__ ((__visibility__ ("default"))) int curl_mvsnprintf(char *buffer, size_t maxlength,
                                const char *format, va_list args);
__attribute__ ((__visibility__ ("default"))) char *curl_maprintf(const char *format, ...);
__attribute__ ((__visibility__ ("default"))) char *curl_mvaprintf(const char *format, va_list args);
# 136 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2

# 1 "../lib/curl_memory.h" 1
# 85 "../lib/curl_memory.h"
extern curl_malloc_callback Curl_cmalloc;
extern curl_free_callback Curl_cfree;
extern curl_realloc_callback Curl_crealloc;
extern curl_strdup_callback Curl_cstrdup;
extern curl_calloc_callback Curl_ccalloc;
# 138 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2

# 1 "../lib/memdebug.h" 1
# 140 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c" 2


static struct connectdata *
find_oldest_idle_connection(struct SessionHandle *data);
static struct connectdata *
find_oldest_idle_connection_in_bundle(struct SessionHandle *data,
                                      struct connectbundle *bundle);
static void conn_free(struct connectdata *conn);
static void signalPipeClose(struct curl_llist *pipeline, _Bool pipe_broke);
static CURLcode do_init(struct connectdata *conn);
static CURLcode parse_url_login(struct SessionHandle *data,
                                struct connectdata *conn,
                                char **userptr, char **passwdptr,
                                char **optionsptr);
static CURLcode parse_login_details(const char *login, const size_t len,
                                    char **userptr, char **passwdptr,
                                    char **optionsptr);




static const struct Curl_handler * const protocols[] = {


  &Curl_handler_http,







  &Curl_handler_ftp,







  &Curl_handler_telnet,



  &Curl_handler_dict,
# 197 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  &Curl_handler_file,



  &Curl_handler_tftp,
# 210 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  &Curl_handler_imap,






  &Curl_handler_pop3,
# 233 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  &Curl_handler_smtp,






  &Curl_handler_rtsp,



  &Curl_handler_gopher,
# 256 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  (struct Curl_handler *) ((void*)0)
};





static const struct Curl_handler Curl_handler_dummy = {
  "<no protocol>",
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
};

void Curl_freeset(struct SessionHandle *data)
{

  enum dupstring i;
  for(i=(enum dupstring)0; i < STRING_LAST; i++) {
    do {if((data->set.str[i])) {Curl_cfree((data->set.str[i])); (data->set.str[i]) = ((void*)0);}} while(0);
  }

  if(data->change.referer_alloc) {
    do {if((data->change.referer)) {Curl_cfree((data->change.referer)); (data->change.referer) = ((void*)0);}} while(0);
    data->change.referer_alloc = 0;
  }
  data->change.referer = ((void*)0);
  if(data->change.url_alloc) {
    do {if((data->change.url)) {Curl_cfree((data->change.url)); (data->change.url) = ((void*)0);}} while(0);
    data->change.url_alloc = 0;
  }
  data->change.url = ((void*)0);
}

static CURLcode setstropt(char **charp, char *s)
{



  do {if((*charp)) {Curl_cfree((*charp)); (*charp) = ((void*)0);}} while(0);

  if(s) {
    s = Curl_cstrdup(s);

    if(!s)
      return CURLE_OUT_OF_MEMORY;

    *charp = s;
  }

  return CURLE_OK;
}

static CURLcode setstropt_userpwd(char *option, char **userp, char **passwdp)
{
  CURLcode result = CURLE_OK;
  char *user = ((void*)0);
  char *passwd = ((void*)0);



  if(option) {
    result = parse_login_details(option, strlen(option),
                                 (userp ? &user : ((void*)0)),
                                 (passwdp ? &passwd : ((void*)0)),
                                 ((void*)0));
  }

  if(!result) {

    if(userp) {
      if(!user && option && option[0] == ':') {

        user = Curl_cstrdup("");
        if(!user)
          result = CURLE_OUT_OF_MEMORY;
      }

      do {if((*userp)) {Curl_cfree((*userp)); (*userp) = ((void*)0);}} while(0);
      *userp = user;
    }


    if(passwdp) {
      do {if((*passwdp)) {Curl_cfree((*passwdp)); (*passwdp) = ((void*)0);}} while(0);
      *passwdp = passwd;
    }
  }

  return result;
}

CURLcode Curl_dupset(struct SessionHandle *dst, struct SessionHandle *src)
{
  CURLcode result = CURLE_OK;
  enum dupstring i;



  dst->set = src->set;


  memset(dst->set.str, 0, STRING_LAST * sizeof(char *));


  for(i=(enum dupstring)0; i< STRING_LASTZEROTERMINATED; i++) {
    result = setstropt(&dst->set.str[i], src->set.str[i]);
    if(result)
      return result;
  }


  i = STRING_COPYPOSTFIELDS;
  if(src->set.postfieldsize && src->set.str[i]) {

    dst->set.str[i] = Curl_memdup(src->set.str[i],
                                  curlx_sotouz(src->set.postfieldsize));
    if(!dst->set.str[i])
      return CURLE_OUT_OF_MEMORY;

    dst->set.postfields = dst->set.str[i];
  }

  return CURLE_OK;
}
# 404 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
CURLcode Curl_close(struct SessionHandle *data)
{
  struct Curl_multi *m;

  if(!data)
    return CURLE_OK;

  Curl_expire(data, 0);

  m = data->multi;

  if(m)


    curl_multi_remove_handle(data->multi, data);

  if(data->multi_easy)


    curl_multi_cleanup(data->multi_easy);




  if(data->state.timeoutlist) {
    Curl_llist_destroy(data->state.timeoutlist, ((void*)0));
    data->state.timeoutlist = ((void*)0);
  }

  data->magic = 0;



  if(data->state.rangestringalloc)
    Curl_cfree(data->state.range);


  do {if((data->state.pathbuffer)) {Curl_cfree((data->state.pathbuffer)); (data->state.pathbuffer) = ((void*)0);}} while(0);
  data->state.path = ((void*)0);


  Curl_free_request_state(data);


  do { } while(0);
  do {if((data->state.first_host)) {Curl_cfree((data->state.first_host)); (data->state.first_host) = ((void*)0);}} while(0);
  do {if((data->state.scratch)) {Curl_cfree((data->state.scratch)); (data->state.scratch) = ((void*)0);}} while(0);
  do { } while(0);


  if(data->req.newurl) {
    Curl_cfree(data->req.newurl);
    data->req.newurl = ((void*)0);
  }

  if(data->change.referer_alloc) {
    do {if((data->change.referer)) {Curl_cfree((data->change.referer)); (data->change.referer) = ((void*)0);}} while(0);
    data->change.referer_alloc = 0;
  }
  data->change.referer = ((void*)0);

  if(data->change.url_alloc) {
    do {if((data->change.url)) {Curl_cfree((data->change.url)); (data->change.url) = ((void*)0);}} while(0);
    data->change.url_alloc = 0;
  }
  data->change.url = ((void*)0);

  do {if((data->state.headerbuff)) {Curl_cfree((data->state.headerbuff)); (data->state.headerbuff) = ((void*)0);}} while(0);

  Curl_flush_cookies(data, 1);

  Curl_digest_cleanup(data);

  do {if((data->info.contenttype)) {Curl_cfree((data->info.contenttype)); (data->info.contenttype) = ((void*)0);}} while(0);
  do {if((data->info.wouldredirect)) {Curl_cfree((data->info.wouldredirect)); (data->info.wouldredirect) = ((void*)0);}} while(0);


  do { } while(0);

  do { } while(0);


  if(data->share) {
    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);
    data->share->dirty--;
    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
  }

  Curl_freeset(data);
  Curl_cfree(data);
  return CURLE_OK;
}





CURLcode Curl_init_userdefined(struct UserDefined *set)
{
  CURLcode result = CURLE_OK;

  set->out = stdout;
  set->in = stdin;
  set->err = stderr;


  set->fwrite_func = (curl_write_callback)fwrite;


  set->fread_func = (curl_read_callback)fread;
  set->is_fread_set = 0;
  set->is_fwrite_set = 0;

  set->seek_func = 0;
  set->seek_client = 0;


  set->convfromnetwork = 0;
  set->convtonetwork = 0;
  set->convfromutf8 = 0;

  set->filesize = -1;
  set->postfieldsize = -1;
  set->maxredirs = -1;

  set->httpreq = HTTPREQ_GET;
  set->rtspreq = RTSPREQ_OPTIONS;
  set->ftp_use_epsv = 1;
  set->ftp_use_eprt = 1;
  set->ftp_use_pret = 0;
  set->ftp_filemethod = FTPFILE_MULTICWD;

  set->dns_cache_timeout = 60;


  set->ssl.max_ssl_sessions = 5;

  set->proxyport = 1080;
  set->proxytype = CURLPROXY_HTTP;
  set->httpauth = (((unsigned long)1)<<0);
  set->proxyauth = (((unsigned long)1)<<0);


  set->hide_progress = 1;





  set->ssl.verifypeer = 1;
  set->ssl.verifyhost = 1;

  set->ssl.authtype = CURL_TLSAUTH_NONE;

  set->ssh_auth_types = ~0;

  set->ssl.sessionid = 1;

  set->new_file_perms = 0644;
  set->new_directory_perms = 0755;




  set->allowed_protocols = (~0);
  set->redir_protocols = (~0) &
                          ~((1<<10) | (1<<4) | (1<<26) |
                            (1<<27));
# 588 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  result = setstropt(&set->str[STRING_SSL_CAFILE], (char *) "/etc/ssl/certs/ca-certificates.crt");
  if(result)
    return result;







  set->wildcardmatch = 0;
  set->chunk_bgn = 0;
  set->chunk_end = 0;




  set->tcp_keepalive = 0;
  set->tcp_keepintvl = 60;
  set->tcp_keepidle = 60;

  set->ssl_enable_npn = 1;
  set->ssl_enable_alpn = 1;

  set->expect_100_timeout = 1000L;
  return result;
}
# 624 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
CURLcode Curl_open(struct SessionHandle **curl)
{
  CURLcode result;
  struct SessionHandle *data;


  data = Curl_ccalloc(1, sizeof(struct SessionHandle));
  if(!data) {

    do { } while(0);
    return CURLE_OUT_OF_MEMORY;
  }

  data->magic = 0xc0dedbadU;

  result = CURLE_OK;
  if(result) {
    do { } while(0);
    Curl_cfree(data);
    return result;
  }



  data->state.headerbuff = Curl_cmalloc(256);
  if(!data->state.headerbuff) {
    do { } while(0);
    result = CURLE_OUT_OF_MEMORY;
  }
  else {
    result = Curl_init_userdefined(&data->set);

    data->state.headersize=256;

    do { } while(0);


    data->state.lastconnect = ((void*)0);

    data->progress.flags |= (1<<4);
    data->state.current_speed = -1;

    data->wildcard.state = CURLWC_INIT;
    data->wildcard.filelist = ((void*)0);
    data->set.fnmatch = 0;
    data->set.maxconnects = 5;
  }

  if(result) {
    do { } while(0);
    if(data->state.headerbuff)
      Curl_cfree(data->state.headerbuff);
    Curl_freeset(data);
    Curl_cfree(data);
    data = ((void*)0);
  }
  else
    *curl = data;

  return result;
}

CURLcode Curl_setopt(struct SessionHandle *data, CURLoption option,
                     va_list param)
{
  char *argptr;
  CURLcode result = CURLE_OK;
  long arg;

  curl_off_t bigsize;


  switch(option) {
  case CURLOPT_DNS_CACHE_TIMEOUT:
    data->set.dns_cache_timeout = __builtin_va_arg(param, long);
    break;
  case CURLOPT_DNS_USE_GLOBAL_CACHE:

    arg = __builtin_va_arg(param, long);
    data->set.global_dns_cache = (0 != arg)?1:0;
    break;
  case CURLOPT_SSL_CIPHER_LIST:

    result = setstropt(&data->set.str[STRING_SSL_CIPHER_LIST],
                       __builtin_va_arg(param, char *));
    break;

  case CURLOPT_RANDOM_FILE:




    result = setstropt(&data->set.str[STRING_SSL_RANDOM_FILE],
                       __builtin_va_arg(param, char *));
    break;
  case CURLOPT_EGDSOCKET:



    result = setstropt(&data->set.str[STRING_SSL_EGDSOCKET],
                       __builtin_va_arg(param, char *));
    break;
  case CURLOPT_MAXCONNECTS:




    data->set.maxconnects = __builtin_va_arg(param, long);
    break;
  case CURLOPT_FORBID_REUSE:




    data->set.reuse_forbid = (0 != __builtin_va_arg(param, long))?1:0;
    break;
  case CURLOPT_FRESH_CONNECT:




    data->set.reuse_fresh = (0 != __builtin_va_arg(param, long))?1:0;
    break;
  case CURLOPT_VERBOSE:




    data->set.verbose = (0 != __builtin_va_arg(param, long))?1:0;
    break;
  case CURLOPT_HEADER:



    data->set.include_header = (0 != __builtin_va_arg(param, long))?1:0;
    break;
  case CURLOPT_NOPROGRESS:



    data->set.hide_progress = (0 != __builtin_va_arg(param, long))?1:0;
    if(data->set.hide_progress)
      data->progress.flags |= (1<<4);
    else
      data->progress.flags &= ~(1<<4);
    break;
  case CURLOPT_NOBODY:



    data->set.opt_no_body = (0 != __builtin_va_arg(param, long))?1:0;
    break;
  case CURLOPT_FAILONERROR:




    data->set.http_fail_on_error = (0 != __builtin_va_arg(param, long))?1:0;
    break;
  case CURLOPT_UPLOAD:
  case CURLOPT_PUT:




    data->set.upload = (0 != __builtin_va_arg(param, long))?1:0;
    if(data->set.upload) {

      data->set.httpreq = HTTPREQ_PUT;
      data->set.opt_no_body = 0;
    }
    else


      data->set.httpreq = HTTPREQ_GET;
    break;
  case CURLOPT_FILETIME:




    data->set.get_filetime = (0 != __builtin_va_arg(param, long))?1:0;
    break;
  case CURLOPT_FTP_CREATE_MISSING_DIRS:




    switch(__builtin_va_arg(param, long)) {
    case 0:
      data->set.ftp_create_missing_dirs = 0;
      break;
    case 1:
      data->set.ftp_create_missing_dirs = 1;
      break;
    case 2:
      data->set.ftp_create_missing_dirs = 2;
      break;
    default:

      result = CURLE_UNKNOWN_OPTION;
      break;
    }
    break;
  case CURLOPT_FTP_RESPONSE_TIMEOUT:




    data->set.server_response_timeout = __builtin_va_arg(param, long) * 1000;
    break;
  case CURLOPT_TFTP_BLKSIZE:



    data->set.tftp_blksize = __builtin_va_arg(param, long);
    break;
  case CURLOPT_DIRLISTONLY:




    data->set.ftp_list_only = (0 != __builtin_va_arg(param, long))?1:0;
    break;
  case CURLOPT_APPEND:



    data->set.ftp_append = (0 != __builtin_va_arg(param, long))?1:0;
    break;
  case CURLOPT_FTP_FILEMETHOD:



    data->set.ftp_filemethod = (curl_ftpfile)__builtin_va_arg(param, long);
    break;
  case CURLOPT_NETRC:



    data->set.use_netrc = (enum CURL_NETRC_OPTION)__builtin_va_arg(param, long);
    break;
  case CURLOPT_NETRC_FILE:



    result = setstropt(&data->set.str[STRING_NETRC_FILE],
                       __builtin_va_arg(param, char *));
    break;
  case CURLOPT_TRANSFERTEXT:






    data->set.prefer_ascii = (0 != __builtin_va_arg(param, long))?1:0;
    break;
  case CURLOPT_TIMECONDITION:




    data->set.timecondition = (curl_TimeCond)__builtin_va_arg(param, long);
    break;
  case CURLOPT_TIMEVALUE:




    data->set.timevalue = (time_t)__builtin_va_arg(param, long);
    break;
  case CURLOPT_SSLVERSION:




    data->set.ssl.version = __builtin_va_arg(param, long);
    break;


  case CURLOPT_AUTOREFERER:



    data->set.http_auto_referer = (0 != __builtin_va_arg(param, long))?1:0;
    break;

  case CURLOPT_ACCEPT_ENCODING:
# 922 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
    argptr = __builtin_va_arg(param, char *);
    result = setstropt(&data->set.str[STRING_ENCODING],
                       (argptr && !*argptr)?
                       (char *) "deflate, gzip": argptr);
    break;

  case CURLOPT_TRANSFER_ENCODING:
    data->set.http_transfer_encoding = (0 != __builtin_va_arg(param, long))?1:0;
    break;

  case CURLOPT_FOLLOWLOCATION:



    data->set.http_follow_location = (0 != __builtin_va_arg(param, long))?1:0;
    break;

  case CURLOPT_UNRESTRICTED_AUTH:




    data->set.http_disable_hostname_check_before_authentication =
      (0 != __builtin_va_arg(param, long))?1:0;
    break;

  case CURLOPT_MAXREDIRS:




    data->set.maxredirs = __builtin_va_arg(param, long);
    break;

  case CURLOPT_POSTREDIR:
  {
# 967 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
    int postRedir = curlx_sltosi(__builtin_va_arg(param, long));
    data->set.keep_post = postRedir & (1|2|4);
  }
  break;

  case CURLOPT_POST:



    if(__builtin_va_arg(param, long)) {
      data->set.httpreq = HTTPREQ_POST;
      data->set.opt_no_body = 0;
    }
    else
      data->set.httpreq = HTTPREQ_GET;
    break;

  case CURLOPT_COPYPOSTFIELDS:





    argptr = __builtin_va_arg(param, char *);

    if(!argptr || data->set.postfieldsize == -1)
      result = setstropt(&data->set.str[STRING_COPYPOSTFIELDS], argptr);
    else {




      if((data->set.postfieldsize < 0) ||
         ((sizeof(curl_off_t) != sizeof(size_t)) &&
          (data->set.postfieldsize > (curl_off_t)((size_t)-1))))
        result = CURLE_OUT_OF_MEMORY;
      else {
        char * p;

        (void) setstropt(&data->set.str[STRING_COPYPOSTFIELDS], ((void*)0));






        p = Curl_cmalloc((size_t)(data->set.postfieldsize? data->set.postfieldsize:1));


        if(!p)
          result = CURLE_OUT_OF_MEMORY;
        else {
          if(data->set.postfieldsize)
            memcpy(p, argptr, (size_t)data->set.postfieldsize);

          data->set.str[STRING_COPYPOSTFIELDS] = p;
        }
      }
    }

    data->set.postfields = data->set.str[STRING_COPYPOSTFIELDS];
    data->set.httpreq = HTTPREQ_POST;
    break;

  case CURLOPT_POSTFIELDS:



    data->set.postfields = __builtin_va_arg(param, void *);

    (void) setstropt(&data->set.str[STRING_COPYPOSTFIELDS], ((void*)0));
    data->set.httpreq = HTTPREQ_POST;
    break;

  case CURLOPT_POSTFIELDSIZE:




    bigsize = __builtin_va_arg(param, long);

    if(data->set.postfieldsize < bigsize &&
       data->set.postfields == data->set.str[STRING_COPYPOSTFIELDS]) {

      (void) setstropt(&data->set.str[STRING_COPYPOSTFIELDS], ((void*)0));
      data->set.postfields = ((void*)0);
    }

    data->set.postfieldsize = bigsize;
    break;

  case CURLOPT_POSTFIELDSIZE_LARGE:




    bigsize = __builtin_va_arg(param, curl_off_t);

    if(data->set.postfieldsize < bigsize &&
       data->set.postfields == data->set.str[STRING_COPYPOSTFIELDS]) {

      (void) setstropt(&data->set.str[STRING_COPYPOSTFIELDS], ((void*)0));
      data->set.postfields = ((void*)0);
    }

    data->set.postfieldsize = bigsize;
    break;

  case CURLOPT_HTTPPOST:



    data->set.httppost = __builtin_va_arg(param, struct curl_httppost *);
    data->set.httpreq = HTTPREQ_POST_FORM;
    data->set.opt_no_body = 0;
    break;

  case CURLOPT_REFERER:



    if(data->change.referer_alloc) {
      do {if((data->change.referer)) {Curl_cfree((data->change.referer)); (data->change.referer) = ((void*)0);}} while(0);
      data->change.referer_alloc = 0;
    }
    result = setstropt(&data->set.str[STRING_SET_REFERER],
                       __builtin_va_arg(param, char *));
    data->change.referer = data->set.str[STRING_SET_REFERER];
    break;

  case CURLOPT_USERAGENT:



    result = setstropt(&data->set.str[STRING_USERAGENT],
                       __builtin_va_arg(param, char *));
    break;

  case CURLOPT_HTTPHEADER:



    data->set.headers = __builtin_va_arg(param, struct curl_slist *);
    break;

  case CURLOPT_PROXYHEADER:
# 1123 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
    data->set.proxyheaders = __builtin_va_arg(param, struct curl_slist *);
    break;

  case CURLOPT_HEADEROPT:



    arg = __builtin_va_arg(param, long);
    data->set.sep_headers = (arg & (1<<0))? 1: 0;
    break;

  case CURLOPT_HTTP200ALIASES:



    data->set.http200aliases = __builtin_va_arg(param, struct curl_slist *);
    break;


  case CURLOPT_COOKIE:



    result = setstropt(&data->set.str[STRING_COOKIE],
                       __builtin_va_arg(param, char *));
    break;

  case CURLOPT_COOKIEFILE:



    argptr = (char *)__builtin_va_arg(param, void *);
    if(argptr) {
      struct curl_slist *cl;


      cl = curl_slist_append(data->change.cookielist, argptr);
      if(!cl) {
        curl_slist_free_all(data->change.cookielist);
        data->change.cookielist = ((void*)0);
        return CURLE_OUT_OF_MEMORY;
      }
      data->change.cookielist = cl;
    }
    break;

  case CURLOPT_COOKIEJAR:



  {
    struct CookieInfo *newcookies;
    result = setstropt(&data->set.str[STRING_COOKIEJAR],
                       __builtin_va_arg(param, char *));





    newcookies = Curl_cookie_init(data, ((void*)0), data->cookies,
                                  data->set.cookiesession);
    if(!newcookies)
      result = CURLE_OUT_OF_MEMORY;
    data->cookies = newcookies;
  }
    break;

  case CURLOPT_COOKIESESSION:
# 1206 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
    data->set.cookiesession = (0 != __builtin_va_arg(param, long))?1:0;
    break;

  case CURLOPT_COOKIELIST:
    argptr = __builtin_va_arg(param, char *);

    if(argptr == ((void*)0))
      break;

    if(Curl_raw_equal(argptr, "ALL")) {

      Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);
      Curl_cookie_clearall(data->cookies);
      Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);
    }
    else if(Curl_raw_equal(argptr, "SESS")) {

      Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);
      Curl_cookie_clearsess(data->cookies);
      Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);
    }
    else if(Curl_raw_equal(argptr, "FLUSH")) {

      Curl_flush_cookies(data, 0);
    }
    else if(Curl_raw_equal(argptr, "RELOAD")) {

      Curl_cookie_loadfiles(data);
      break;
    }
    else {
      if(!data->cookies)

        data->cookies = Curl_cookie_init(data, ((void*)0), ((void*)0), 1);

      argptr = Curl_cstrdup(argptr);
      if(!argptr || !data->cookies) {
        result = CURLE_OUT_OF_MEMORY;
        do {if((argptr)) {Curl_cfree((argptr)); (argptr) = ((void*)0);}} while(0);
      }
      else {
        Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);

        if(Curl_raw_nequal("Set-Cookie:",argptr,strlen("Set-Cookie:")))

          Curl_cookie_add(data, data->cookies, 1, argptr + 11, ((void*)0), ((void*)0));

        else

          Curl_cookie_add(data, data->cookies, 0, argptr, ((void*)0), ((void*)0));

        Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);
        Curl_cfree(argptr);
      }
    }

    break;


  case CURLOPT_HTTPGET:



    if(__builtin_va_arg(param, long)) {
      data->set.httpreq = HTTPREQ_GET;
      data->set.upload = 0;
      data->set.opt_no_body = 0;
    }
    break;

  case CURLOPT_HTTP_VERSION:




    arg = __builtin_va_arg(param, long);

    if(arg == CURL_HTTP_VERSION_2_0)
      return CURLE_UNSUPPORTED_PROTOCOL;

    data->set.httpversion = arg;
    break;

  case CURLOPT_HTTPAUTH:



  {
    int bitcheck;
    _Bool authbits;
    unsigned long auth = __builtin_va_arg(param, unsigned long);

    if(auth == ((unsigned long)0)) {
      data->set.httpauth = auth;
      break;
    }



    data->state.authhost.iestyle = (auth & (((unsigned long)1)<<4))?1:0;

    if(auth & (((unsigned long)1)<<4)) {
      auth |= (((unsigned long)1)<<1);
      auth &= ~(((unsigned long)1)<<4);
    }



    auth &= ~(((unsigned long)1)<<3);
    auth &= ~(((unsigned long)1)<<5);




    auth &= ~(((unsigned long)1)<<2);




    bitcheck = 0;
    authbits = 0;
    while(bitcheck < 31) {
      if(auth & (1UL << bitcheck++)) {
        authbits = 1;
        break;
      }
    }
    if(!authbits)
      return CURLE_NOT_BUILT_IN;

    data->set.httpauth = auth;
  }
  break;

  case CURLOPT_EXPECT_100_TIMEOUT_MS:




    data->set.expect_100_timeout = __builtin_va_arg(param, long);
    break;



  case CURLOPT_CUSTOMREQUEST:



    result = setstropt(&data->set.str[STRING_CUSTOMREQUEST],
                       __builtin_va_arg(param, char *));





    break;


  case CURLOPT_HTTPPROXYTUNNEL:



    data->set.tunnel_thru_httpproxy = (0 != __builtin_va_arg(param, long))?1:0;
    break;

  case CURLOPT_PROXYPORT:



    data->set.proxyport = __builtin_va_arg(param, long);
    break;

  case CURLOPT_PROXYAUTH:



  {
    int bitcheck;
    _Bool authbits;
    unsigned long auth = __builtin_va_arg(param, unsigned long);

    if(auth == ((unsigned long)0)) {
      data->set.proxyauth = auth;
      break;
    }



    data->state.authproxy.iestyle = (auth & (((unsigned long)1)<<4))?1:0;

    if(auth & (((unsigned long)1)<<4)) {
      auth |= (((unsigned long)1)<<1);
      auth &= ~(((unsigned long)1)<<4);
    }


    auth &= ~(((unsigned long)1)<<3);
    auth &= ~(((unsigned long)1)<<5);




    auth &= ~(((unsigned long)1)<<2);




    bitcheck = 0;
    authbits = 0;
    while(bitcheck < 31) {
      if(auth & (1UL << bitcheck++)) {
        authbits = 1;
        break;
      }
    }
    if(!authbits)
      return CURLE_NOT_BUILT_IN;

    data->set.proxyauth = auth;
  }
  break;

  case CURLOPT_PROXY:
# 1438 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
    result = setstropt(&data->set.str[STRING_PROXY],
                       __builtin_va_arg(param, char *));
    break;

  case CURLOPT_PROXYTYPE:



    data->set.proxytype = (curl_proxytype)__builtin_va_arg(param, long);
    break;

  case CURLOPT_PROXY_TRANSFER_MODE:



    switch (__builtin_va_arg(param, long)) {
    case 0:
      data->set.proxy_transfer_mode = 0;
      break;
    case 1:
      data->set.proxy_transfer_mode = 1;
      break;
    default:

      result = CURLE_UNKNOWN_OPTION;
      break;
    }
    break;
# 1485 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  case CURLOPT_HEADERDATA:



    data->set.writeheader = (void *)__builtin_va_arg(param, void *);
    break;
  case CURLOPT_ERRORBUFFER:




    data->set.errorbuffer = __builtin_va_arg(param, char *);
    break;
  case CURLOPT_WRITEDATA:




    data->set.out = __builtin_va_arg(param, void *);
    break;
  case CURLOPT_FTPPORT:



    result = setstropt(&data->set.str[STRING_FTPPORT],
                       __builtin_va_arg(param, char *));
    data->set.ftp_use_port = (((void*)0) != data->set.str[STRING_FTPPORT]) ?
                             1:0;
    break;

  case CURLOPT_FTP_USE_EPRT:
    data->set.ftp_use_eprt = (0 != __builtin_va_arg(param, long))?1:0;
    break;

  case CURLOPT_FTP_USE_EPSV:
    data->set.ftp_use_epsv = (0 != __builtin_va_arg(param, long))?1:0;
    break;

  case CURLOPT_FTP_USE_PRET:
    data->set.ftp_use_pret = (0 != __builtin_va_arg(param, long))?1:0;
    break;

  case CURLOPT_FTP_SSL_CCC:
    data->set.ftp_ccc = (curl_ftpccc)__builtin_va_arg(param, long);
    break;

  case CURLOPT_FTP_SKIP_PASV_IP:




    data->set.ftp_skip_ip = (0 != __builtin_va_arg(param, long))?1:0;
    break;

  case CURLOPT_READDATA:




    data->set.in = __builtin_va_arg(param, void *);
    break;
  case CURLOPT_INFILESIZE:




    data->set.filesize = __builtin_va_arg(param, long);
    break;
  case CURLOPT_INFILESIZE_LARGE:




    data->set.filesize = __builtin_va_arg(param, curl_off_t);
    break;
  case CURLOPT_LOW_SPEED_LIMIT:




    data->set.low_speed_limit=__builtin_va_arg(param, long);
    break;
  case CURLOPT_MAX_SEND_SPEED_LARGE:




    data->set.max_send_speed=__builtin_va_arg(param, curl_off_t);
    break;
  case CURLOPT_MAX_RECV_SPEED_LARGE:




    data->set.max_recv_speed=__builtin_va_arg(param, curl_off_t);
    break;
  case CURLOPT_LOW_SPEED_TIME:




    data->set.low_speed_time=__builtin_va_arg(param, long);
    break;
  case CURLOPT_URL:



    if(data->change.url_alloc) {

      do {if((data->change.url)) {Curl_cfree((data->change.url)); (data->change.url) = ((void*)0);}} while(0);
      data->change.url_alloc = 0;
    }
    result = setstropt(&data->set.str[STRING_SET_URL],
                       __builtin_va_arg(param, char *));
    data->change.url = data->set.str[STRING_SET_URL];
    break;
  case CURLOPT_PORT:



    data->set.use_port = __builtin_va_arg(param, long);
    break;
  case CURLOPT_TIMEOUT:




    data->set.timeout = __builtin_va_arg(param, long) * 1000L;
    break;

  case CURLOPT_TIMEOUT_MS:
    data->set.timeout = __builtin_va_arg(param, long);
    break;

  case CURLOPT_CONNECTTIMEOUT:



    data->set.connecttimeout = __builtin_va_arg(param, long) * 1000L;
    break;

  case CURLOPT_CONNECTTIMEOUT_MS:
    data->set.connecttimeout = __builtin_va_arg(param, long);
    break;

  case CURLOPT_ACCEPTTIMEOUT_MS:



    data->set.accepttimeout = __builtin_va_arg(param, long);
    break;

  case CURLOPT_USERPWD:



    result = setstropt_userpwd(__builtin_va_arg(param, char *),
                               &data->set.str[STRING_USERNAME],
                               &data->set.str[STRING_PASSWORD]);
    break;

  case CURLOPT_USERNAME:



    result = setstropt(&data->set.str[STRING_USERNAME],
                       __builtin_va_arg(param, char *));
    break;

  case CURLOPT_PASSWORD:



    result = setstropt(&data->set.str[STRING_PASSWORD],
                       __builtin_va_arg(param, char *));
    break;

  case CURLOPT_LOGIN_OPTIONS:



    result = setstropt(&data->set.str[STRING_OPTIONS],
                       __builtin_va_arg(param, char *));
    break;

  case CURLOPT_XOAUTH2_BEARER:



    result = setstropt(&data->set.str[STRING_BEARER],
                       __builtin_va_arg(param, char *));
    break;

  case CURLOPT_POSTQUOTE:



    data->set.postquote = __builtin_va_arg(param, struct curl_slist *);
    break;
  case CURLOPT_PREQUOTE:



    data->set.prequote = __builtin_va_arg(param, struct curl_slist *);
    break;
  case CURLOPT_QUOTE:



    data->set.quote = __builtin_va_arg(param, struct curl_slist *);
    break;
  case CURLOPT_RESOLVE:
# 1707 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
    data->set.resolve = __builtin_va_arg(param, struct curl_slist *);
    data->change.resolve = data->set.resolve;
    break;
  case CURLOPT_PROGRESSFUNCTION:



    data->set.fprogress = __builtin_va_arg(param, curl_progress_callback);
    if(data->set.fprogress)
      data->progress.callback = 1;
    else
      data->progress.callback = 0;
    break;

  case CURLOPT_XFERINFOFUNCTION:



    data->set.fxferinfo = __builtin_va_arg(param, curl_xferinfo_callback);
    if(data->set.fxferinfo)
      data->progress.callback = 1;
    else
      data->progress.callback = 0;

    break;

  case CURLOPT_PROGRESSDATA:



    data->set.progress_client = __builtin_va_arg(param, void *);
    break;


  case CURLOPT_PROXYUSERPWD:



    result = setstropt_userpwd(__builtin_va_arg(param, char *),
                               &data->set.str[STRING_PROXYUSERNAME],
                               &data->set.str[STRING_PROXYPASSWORD]);
    break;
  case CURLOPT_PROXYUSERNAME:



    result = setstropt(&data->set.str[STRING_PROXYUSERNAME],
                       __builtin_va_arg(param, char *));
    break;
  case CURLOPT_PROXYPASSWORD:



    result = setstropt(&data->set.str[STRING_PROXYPASSWORD],
                       __builtin_va_arg(param, char *));
    break;
  case CURLOPT_NOPROXY:



    result = setstropt(&data->set.str[STRING_NOPROXY],
                       __builtin_va_arg(param, char *));
    break;


  case CURLOPT_RANGE:



    result = setstropt(&data->set.str[STRING_SET_RANGE],
                       __builtin_va_arg(param, char *));
    break;
  case CURLOPT_RESUME_FROM:



    data->set.set_resume_from = __builtin_va_arg(param, long);
    break;
  case CURLOPT_RESUME_FROM_LARGE:



    data->set.set_resume_from = __builtin_va_arg(param, curl_off_t);
    break;
  case CURLOPT_DEBUGFUNCTION:



    data->set.fdebug = __builtin_va_arg(param, curl_debug_callback);



    break;
  case CURLOPT_DEBUGDATA:




    data->set.debugdata = __builtin_va_arg(param, void *);
    break;
  case CURLOPT_STDERR:




    data->set.err = __builtin_va_arg(param, FILE *);
    if(!data->set.err)
      data->set.err = stderr;
    break;
  case CURLOPT_HEADERFUNCTION:



    data->set.fwrite_header = __builtin_va_arg(param, curl_write_callback);
    break;
  case CURLOPT_WRITEFUNCTION:



    data->set.fwrite_func = __builtin_va_arg(param, curl_write_callback);
    if(!data->set.fwrite_func) {
      data->set.is_fwrite_set = 0;

      data->set.fwrite_func = (curl_write_callback)fwrite;
    }
    else
      data->set.is_fwrite_set = 1;
    break;
  case CURLOPT_READFUNCTION:



    data->set.fread_func = __builtin_va_arg(param, curl_read_callback);
    if(!data->set.fread_func) {
      data->set.is_fread_set = 0;

      data->set.fread_func = (curl_read_callback)fread;
    }
    else
      data->set.is_fread_set = 1;
    break;
  case CURLOPT_SEEKFUNCTION:



    data->set.seek_func = __builtin_va_arg(param, curl_seek_callback);
    break;
  case CURLOPT_SEEKDATA:



    data->set.seek_client = __builtin_va_arg(param, void *);
    break;
  case CURLOPT_CONV_FROM_NETWORK_FUNCTION:



    data->set.convfromnetwork = __builtin_va_arg(param, curl_conv_callback);
    break;
  case CURLOPT_CONV_TO_NETWORK_FUNCTION:



    data->set.convtonetwork = __builtin_va_arg(param, curl_conv_callback);
    break;
  case CURLOPT_CONV_FROM_UTF8_FUNCTION:



    data->set.convfromutf8 = __builtin_va_arg(param, curl_conv_callback);
    break;
  case CURLOPT_IOCTLFUNCTION:



    data->set.ioctl_func = __builtin_va_arg(param, curl_ioctl_callback);
    break;
  case CURLOPT_IOCTLDATA:



    data->set.ioctl_client = __builtin_va_arg(param, void *);
    break;
  case CURLOPT_SSLCERT:



    result = setstropt(&data->set.str[STRING_CERT],
                       __builtin_va_arg(param, char *));
    break;
  case CURLOPT_SSLCERTTYPE:



    result = setstropt(&data->set.str[STRING_CERT_TYPE],
                       __builtin_va_arg(param, char *));
    break;
  case CURLOPT_SSLKEY:



    result = setstropt(&data->set.str[STRING_KEY],
                       __builtin_va_arg(param, char *));
    break;
  case CURLOPT_SSLKEYTYPE:



    result = setstropt(&data->set.str[STRING_KEY_TYPE],
                       __builtin_va_arg(param, char *));
    break;
  case CURLOPT_KEYPASSWD:



    result = setstropt(&data->set.str[STRING_KEY_PASSWD],
                       __builtin_va_arg(param, char *));
    break;
  case CURLOPT_SSLENGINE:



    argptr = __builtin_va_arg(param, char *);
    if(argptr && argptr[0])
      result = CURLE_NOT_BUILT_IN;
    break;

  case CURLOPT_SSLENGINE_DEFAULT:



    result = CURLE_NOT_BUILT_IN;
    break;
  case CURLOPT_CRLF:



    data->set.crlf = (0 != __builtin_va_arg(param, long))?1:0;
    break;

  case CURLOPT_INTERFACE:




    result = setstropt(&data->set.str[STRING_DEVICE],
                       __builtin_va_arg(param, char *));
    break;
  case CURLOPT_LOCALPORT:



    data->set.localport = curlx_sltous(__builtin_va_arg(param, long));
    break;
  case CURLOPT_LOCALPORTRANGE:



    data->set.localportrange = curlx_sltosi(__builtin_va_arg(param, long));
    break;
  case CURLOPT_KRBLEVEL:



    result = setstropt(&data->set.str[STRING_KRB_LEVEL],
                       __builtin_va_arg(param, char *));
    data->set.krb = (((void*)0) != data->set.str[STRING_KRB_LEVEL])?1:0;
    break;
  case CURLOPT_GSSAPI_DELEGATION:



    data->set.gssapi_delegation = __builtin_va_arg(param, long);
    break;
  case CURLOPT_SSL_VERIFYPEER:



    data->set.ssl.verifypeer = (0 != __builtin_va_arg(param, long))?1:0;
    break;
  case CURLOPT_SSL_VERIFYHOST:



    arg = __builtin_va_arg(param, long);






    if(1 == arg) {
      Curl_failf(data, "CURLOPT_SSL_VERIFYHOST no longer supports 1 as value!");
      return CURLE_BAD_FUNCTION_ARGUMENT;
    }

    data->set.ssl.verifyhost = (0 != arg)?1:0;
    break;
  case CURLOPT_SSL_VERIFYSTATUS:



    if(!0) {
      result = CURLE_NOT_BUILT_IN;
      break;
    }

    data->set.ssl.verifystatus = (0 != __builtin_va_arg(param, long))?1:0;
    break;
  case CURLOPT_SSL_CTX_FUNCTION:






    result = CURLE_NOT_BUILT_IN;

    break;
  case CURLOPT_SSL_CTX_DATA:






    result = CURLE_NOT_BUILT_IN;

    break;
  case CURLOPT_CERTINFO:



    result = CURLE_NOT_BUILT_IN;

    break;
  case CURLOPT_PINNEDPUBLICKEY:




    result = setstropt(&data->set.str[STRING_SSL_PINNEDPUBLICKEY],
                       __builtin_va_arg(param, char *));
    break;
  case CURLOPT_CAINFO:



    result = setstropt(&data->set.str[STRING_SSL_CAFILE],
                       __builtin_va_arg(param, char *));
    break;
  case CURLOPT_CAPATH:
# 2068 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
    result = CURLE_NOT_BUILT_IN;

    break;
  case CURLOPT_CRLFILE:




    result = setstropt(&data->set.str[STRING_SSL_CRLFILE],
                       __builtin_va_arg(param, char *));
    break;
  case CURLOPT_ISSUERCERT:




    result = setstropt(&data->set.str[STRING_SSL_ISSUERCERT],
                       __builtin_va_arg(param, char *));
    break;
  case CURLOPT_TELNETOPTIONS:



    data->set.telnet_options = __builtin_va_arg(param, struct curl_slist *);
    break;

  case CURLOPT_BUFFERSIZE:




    data->set.buffer_size = __builtin_va_arg(param, long);

    if((data->set.buffer_size> (16384 -1 )) ||
       (data->set.buffer_size < 1))
      data->set.buffer_size = 0;

    break;

  case CURLOPT_NOSIGNAL:




    data->set.no_signal = (0 != __builtin_va_arg(param, long))?1:0;
    break;

  case CURLOPT_SHARE:
  {
    struct Curl_share *set;
    set = __builtin_va_arg(param, struct Curl_share *);


    if(data->share) {
      Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);

      if(data->dns.hostcachetype == HCACHE_SHARED) {
        data->dns.hostcache = ((void*)0);
        data->dns.hostcachetype = HCACHE_NONE;
      }


      if(data->share->cookies == data->cookies)
        data->cookies = ((void*)0);


      if(data->share->sslsession == data->state.session)
        data->state.session = ((void*)0);

      data->share->dirty--;

      Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
      data->share = ((void*)0);
    }


    data->share = set;
    if(data->share) {

      Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);

      data->share->dirty++;

      if(data->share->hostcache) {

        data->dns.hostcache = data->share->hostcache;
        data->dns.hostcachetype = HCACHE_SHARED;
      }

      if(data->share->cookies) {

        if(data->cookies)
          Curl_cookie_cleanup(data->cookies);

        data->cookies = data->share->cookies;
      }

      if(data->share->sslsession) {
        data->set.ssl.max_ssl_sessions = data->share->max_ssl_sessions;
        data->state.session = data->share->sslsession;
      }
      Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);

    }


  }
  break;

  case CURLOPT_PRIVATE:



    data->set.private_data = __builtin_va_arg(param, void *);
    break;

  case CURLOPT_MAXFILESIZE:



    data->set.max_filesize = __builtin_va_arg(param, long);
    break;
# 2205 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  case CURLOPT_FTPSSLAUTH:



    data->set.ftpsslauth = (curl_ftpauth)__builtin_va_arg(param, long);
    break;

  case CURLOPT_IPRESOLVE:
    data->set.ipver = __builtin_va_arg(param, long);
    break;

  case CURLOPT_MAXFILESIZE_LARGE:



    data->set.max_filesize = __builtin_va_arg(param, curl_off_t);
    break;

  case CURLOPT_TCP_NODELAY:




    data->set.tcp_nodelay = (0 != __builtin_va_arg(param, long))?1:0;
    break;

  case CURLOPT_FTP_ACCOUNT:
    result = setstropt(&data->set.str[STRING_FTP_ACCOUNT],
                       __builtin_va_arg(param, char *));
    break;

  case CURLOPT_IGNORE_CONTENT_LENGTH:
    data->set.ignorecl = (0 != __builtin_va_arg(param, long))?1:0;
    break;

  case CURLOPT_CONNECT_ONLY:



    data->set.connect_only = (0 != __builtin_va_arg(param, long))?1:0;
    break;

  case CURLOPT_FTP_ALTERNATIVE_TO_USER:
    result = setstropt(&data->set.str[STRING_FTP_ALTERNATIVE_TO_USER],
                       __builtin_va_arg(param, char *));
    break;

  case CURLOPT_SOCKOPTFUNCTION:



    data->set.fsockopt = __builtin_va_arg(param, curl_sockopt_callback);
    break;

  case CURLOPT_SOCKOPTDATA:



    data->set.sockopt_client = __builtin_va_arg(param, void *);
    break;

  case CURLOPT_OPENSOCKETFUNCTION:




    data->set.fopensocket = __builtin_va_arg(param, curl_opensocket_callback);
    break;

  case CURLOPT_OPENSOCKETDATA:



    data->set.opensocket_client = __builtin_va_arg(param, void *);
    break;

  case CURLOPT_CLOSESOCKETFUNCTION:




    data->set.fclosesocket = __builtin_va_arg(param, curl_closesocket_callback);
    break;

  case CURLOPT_CLOSESOCKETDATA:



    data->set.closesocket_client = __builtin_va_arg(param, void *);
    break;

  case CURLOPT_SSL_SESSIONID_CACHE:
    data->set.ssl.sessionid = (0 != __builtin_va_arg(param, long))?1:0;
    break;
# 2354 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  case CURLOPT_HTTP_TRANSFER_DECODING:



    data->set.http_te_skip = (0 == __builtin_va_arg(param, long))?1:0;
    break;

  case CURLOPT_HTTP_CONTENT_DECODING:



    data->set.http_ce_skip = (0 == __builtin_va_arg(param, long))?1:0;
    break;

  case CURLOPT_NEW_FILE_PERMS:



    data->set.new_file_perms = __builtin_va_arg(param, long);
    break;

  case CURLOPT_NEW_DIRECTORY_PERMS:



    data->set.new_directory_perms = __builtin_va_arg(param, long);
    break;

  case CURLOPT_ADDRESS_SCOPE:





    data->set.scope_id = curlx_sltoui(__builtin_va_arg(param, long));
    break;

  case CURLOPT_PROTOCOLS:




    data->set.allowed_protocols = __builtin_va_arg(param, long);
    break;

  case CURLOPT_REDIR_PROTOCOLS:




    data->set.redir_protocols = __builtin_va_arg(param, long);
    break;

  case CURLOPT_MAIL_FROM:

    result = setstropt(&data->set.str[STRING_MAIL_FROM],
                       __builtin_va_arg(param, char *));
    break;

  case CURLOPT_MAIL_AUTH:

    result = setstropt(&data->set.str[STRING_MAIL_AUTH],
                       __builtin_va_arg(param, char *));
    break;

  case CURLOPT_MAIL_RCPT:

    data->set.mail_rcpt = __builtin_va_arg(param, struct curl_slist *);
    break;

  case CURLOPT_SASL_IR:

    data->set.sasl_ir = (0 != __builtin_va_arg(param, long)) ? 1 : 0;
    break;

  case CURLOPT_RTSP_REQUEST:
    {




      long curl_rtspreq = __builtin_va_arg(param, long);
      Curl_RtspReq rtspreq = RTSPREQ_NONE;
      switch(curl_rtspreq) {
        case CURL_RTSPREQ_OPTIONS:
          rtspreq = RTSPREQ_OPTIONS;
          break;

        case CURL_RTSPREQ_DESCRIBE:
          rtspreq = RTSPREQ_DESCRIBE;
          break;

        case CURL_RTSPREQ_ANNOUNCE:
          rtspreq = RTSPREQ_ANNOUNCE;
          break;

        case CURL_RTSPREQ_SETUP:
          rtspreq = RTSPREQ_SETUP;
          break;

        case CURL_RTSPREQ_PLAY:
          rtspreq = RTSPREQ_PLAY;
          break;

        case CURL_RTSPREQ_PAUSE:
          rtspreq = RTSPREQ_PAUSE;
          break;

        case CURL_RTSPREQ_TEARDOWN:
          rtspreq = RTSPREQ_TEARDOWN;
          break;

        case CURL_RTSPREQ_GET_PARAMETER:
          rtspreq = RTSPREQ_GET_PARAMETER;
          break;

        case CURL_RTSPREQ_SET_PARAMETER:
          rtspreq = RTSPREQ_SET_PARAMETER;
          break;

        case CURL_RTSPREQ_RECORD:
          rtspreq = RTSPREQ_RECORD;
          break;

        case CURL_RTSPREQ_RECEIVE:
          rtspreq = RTSPREQ_RECEIVE;
          break;
        default:
          rtspreq = RTSPREQ_NONE;
      }

      data->set.rtspreq = rtspreq;
    break;
    }


  case CURLOPT_RTSP_SESSION_ID:




    result = setstropt(&data->set.str[STRING_RTSP_SESSION_ID],
                       __builtin_va_arg(param, char *));
    break;

  case CURLOPT_RTSP_STREAM_URI:




    result = setstropt(&data->set.str[STRING_RTSP_STREAM_URI],
                       __builtin_va_arg(param, char *));
    break;

  case CURLOPT_RTSP_TRANSPORT:



    result = setstropt(&data->set.str[STRING_RTSP_TRANSPORT],
                       __builtin_va_arg(param, char *));
    break;

  case CURLOPT_RTSP_CLIENT_CSEQ:





    data->state.rtsp_next_client_CSeq = __builtin_va_arg(param, long);
    break;

  case CURLOPT_RTSP_SERVER_CSEQ:

    data->state.rtsp_next_client_CSeq = __builtin_va_arg(param, long);
    break;

  case CURLOPT_INTERLEAVEDATA:
    data->set.rtp_out = __builtin_va_arg(param, void *);
    break;
  case CURLOPT_INTERLEAVEFUNCTION:

    data->set.fwrite_rtp = __builtin_va_arg(param, curl_write_callback);
    break;

  case CURLOPT_WILDCARDMATCH:
    data->set.wildcardmatch = (0 != __builtin_va_arg(param, long))?1:0;
    break;
  case CURLOPT_CHUNK_BGN_FUNCTION:
    data->set.chunk_bgn = __builtin_va_arg(param, curl_chunk_bgn_callback);
    break;
  case CURLOPT_CHUNK_END_FUNCTION:
    data->set.chunk_end = __builtin_va_arg(param, curl_chunk_end_callback);
    break;
  case CURLOPT_FNMATCH_FUNCTION:
    data->set.fnmatch = __builtin_va_arg(param, curl_fnmatch_callback);
    break;
  case CURLOPT_CHUNK_DATA:
    data->wildcard.customptr = __builtin_va_arg(param, void *);
    break;
  case CURLOPT_FNMATCH_DATA:
    data->set.fnmatch_data = __builtin_va_arg(param, void *);
    break;

  case CURLOPT_TLSAUTH_USERNAME:
    result = setstropt(&data->set.str[STRING_TLSAUTH_USERNAME],
                       __builtin_va_arg(param, char *));
    if(data->set.str[STRING_TLSAUTH_USERNAME] && !data->set.ssl.authtype)
      data->set.ssl.authtype = CURL_TLSAUTH_SRP;
    break;
  case CURLOPT_TLSAUTH_PASSWORD:
    result = setstropt(&data->set.str[STRING_TLSAUTH_PASSWORD],
                       __builtin_va_arg(param, char *));
    if(data->set.str[STRING_TLSAUTH_USERNAME] && !data->set.ssl.authtype)
      data->set.ssl.authtype = CURL_TLSAUTH_SRP;
    break;
  case CURLOPT_TLSAUTH_TYPE:
    if(curl_strnequal((char *)__builtin_va_arg(param, char *),"SRP",strlen("SRP")))
      data->set.ssl.authtype = CURL_TLSAUTH_SRP;
    else
      data->set.ssl.authtype = CURL_TLSAUTH_NONE;
    break;

  case CURLOPT_DNS_SERVERS:
    result = Curl_set_dns_servers(data, __builtin_va_arg(param, char *));
    break;
  case CURLOPT_DNS_INTERFACE:
    result = Curl_set_dns_interface(data, __builtin_va_arg(param, char *));
    break;
  case CURLOPT_DNS_LOCAL_IP4:
    result = Curl_set_dns_local_ip4(data, __builtin_va_arg(param, char *));
    break;
  case CURLOPT_DNS_LOCAL_IP6:
    result = Curl_set_dns_local_ip6(data, __builtin_va_arg(param, char *));
    break;

  case CURLOPT_TCP_KEEPALIVE:
    data->set.tcp_keepalive = (0 != __builtin_va_arg(param, long))?1:0;
    break;
  case CURLOPT_TCP_KEEPIDLE:
    data->set.tcp_keepidle = __builtin_va_arg(param, long);
    break;
  case CURLOPT_TCP_KEEPINTVL:
    data->set.tcp_keepintvl = __builtin_va_arg(param, long);
    break;
  case CURLOPT_SSL_ENABLE_NPN:
    data->set.ssl_enable_npn = (0 != __builtin_va_arg(param, long))?1:0;
    break;
  case CURLOPT_SSL_ENABLE_ALPN:
    data->set.ssl_enable_alpn = (0 != __builtin_va_arg(param, long))?1:0;
    break;


  case CURLOPT_UNIX_SOCKET_PATH:
    result = setstropt(&data->set.str[STRING_UNIX_SOCKET_PATH],
                       __builtin_va_arg(param, char *));
    break;


  default:

    result = CURLE_UNKNOWN_OPTION;
    break;
  }

  return result;
}

static void conn_free(struct connectdata *conn)
{
  if(!conn)
    return;


  do { } while(0);



  do { } while(0);
  do { } while(0);


  if(-1 != conn->sock[1])
    Curl_closesocket(conn, conn->sock[1]);
  if(-1 != conn->sock[0])
    Curl_closesocket(conn, conn->sock[0]);
  if(-1 != conn->tempsock[0])
    Curl_closesocket(conn, conn->tempsock[0]);
  if(-1 != conn->tempsock[1])
    Curl_closesocket(conn, conn->tempsock[1]);






  do {if((conn->user)) {Curl_cfree((conn->user)); (conn->user) = ((void*)0);}} while(0);
  do {if((conn->passwd)) {Curl_cfree((conn->passwd)); (conn->passwd) = ((void*)0);}} while(0);
  do {if((conn->xoauth2_bearer)) {Curl_cfree((conn->xoauth2_bearer)); (conn->xoauth2_bearer) = ((void*)0);}} while(0);
  do {if((conn->options)) {Curl_cfree((conn->options)); (conn->options) = ((void*)0);}} while(0);
  do {if((conn->proxyuser)) {Curl_cfree((conn->proxyuser)); (conn->proxyuser) = ((void*)0);}} while(0);
  do {if((conn->proxypasswd)) {Curl_cfree((conn->proxypasswd)); (conn->proxypasswd) = ((void*)0);}} while(0);
  do {if((conn->allocptr.proxyuserpwd)) {Curl_cfree((conn->allocptr.proxyuserpwd)); (conn->allocptr.proxyuserpwd) = ((void*)0);}} while(0);
  do {if((conn->allocptr.uagent)) {Curl_cfree((conn->allocptr.uagent)); (conn->allocptr.uagent) = ((void*)0);}} while(0);
  do {if((conn->allocptr.userpwd)) {Curl_cfree((conn->allocptr.userpwd)); (conn->allocptr.userpwd) = ((void*)0);}} while(0);
  do {if((conn->allocptr.accept_encoding)) {Curl_cfree((conn->allocptr.accept_encoding)); (conn->allocptr.accept_encoding) = ((void*)0);}} while(0);
  do {if((conn->allocptr.te)) {Curl_cfree((conn->allocptr.te)); (conn->allocptr.te) = ((void*)0);}} while(0);
  do {if((conn->allocptr.rangeline)) {Curl_cfree((conn->allocptr.rangeline)); (conn->allocptr.rangeline) = ((void*)0);}} while(0);
  do {if((conn->allocptr.ref)) {Curl_cfree((conn->allocptr.ref)); (conn->allocptr.ref) = ((void*)0);}} while(0);
  do {if((conn->allocptr.host)) {Curl_cfree((conn->allocptr.host)); (conn->allocptr.host) = ((void*)0);}} while(0);
  do {if((conn->allocptr.cookiehost)) {Curl_cfree((conn->allocptr.cookiehost)); (conn->allocptr.cookiehost) = ((void*)0);}} while(0);
  do {if((conn->allocptr.rtsp_transport)) {Curl_cfree((conn->allocptr.rtsp_transport)); (conn->allocptr.rtsp_transport) = ((void*)0);}} while(0);
  do {if((conn->trailer)) {Curl_cfree((conn->trailer)); (conn->trailer) = ((void*)0);}} while(0);
  do {if((conn->host.rawalloc)) {Curl_cfree((conn->host.rawalloc)); (conn->host.rawalloc) = ((void*)0);}} while(0);
  do {if((conn->proxy.rawalloc)) {Curl_cfree((conn->proxy.rawalloc)); (conn->proxy.rawalloc) = ((void*)0);}} while(0);
  do {if((conn->master_buffer)) {Curl_cfree((conn->master_buffer)); (conn->master_buffer) = ((void*)0);}} while(0);

  Curl_llist_destroy(conn->send_pipe, ((void*)0));
  Curl_llist_destroy(conn->recv_pipe, ((void*)0));

  conn->send_pipe = ((void*)0);
  conn->recv_pipe = ((void*)0);

  do {if((conn->localdev)) {Curl_cfree((conn->localdev)); (conn->localdev) = ((void*)0);}} while(0);
  Curl_free_ssl_config(&conn->ssl_config);

  Curl_cfree(conn);
}
# 2692 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
CURLcode Curl_disconnect(struct connectdata *conn, _Bool dead_connection)
{
  struct SessionHandle *data;
  if(!conn)
    return CURLE_OK;
  data = conn->data;

  if(!data) {
    do { } while(0);
    return CURLE_OK;
  }

  if(conn->dns_entry != ((void*)0)) {
    Curl_resolv_unlock(data, conn->dns_entry);
    conn->dns_entry = ((void*)0);
  }

  Curl_hostcache_prune(data);






  if(conn->handler->disconnect)

    conn->handler->disconnect(conn, dead_connection);


  Curl_infof(data, "Closing connection %ld\n", conn->connection_id);
  Curl_conncache_remove_conn(data->state.conn_cache, conn);
# 2743 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  do { } while(0);


  if(Curl_multi_pipeline_enabled(data->multi)) {
    signalPipeClose(conn->send_pipe, 1);
    signalPipeClose(conn->recv_pipe, 1);
  }

  conn_free(conn);

  return CURLE_OK;
}






static _Bool SocketIsDead(curl_socket_t sock)
{
  int sval;
  _Bool ret_val = 1;

  sval = Curl_socket_check(sock, -1, -1, 0);
  if(sval == 0)

    ret_val = 0;

  return ret_val;
}

static _Bool IsPipeliningPossible(const struct SessionHandle *handle,
                                 const struct connectdata *conn)
{
  if((conn->handler->protocol & ((1<<0)|(1<<1))) &&
     Curl_multi_pipeline_enabled(handle->multi) &&
     (handle->set.httpreq == HTTPREQ_GET ||
      handle->set.httpreq == HTTPREQ_HEAD) &&
     handle->set.httpversion != CURL_HTTP_VERSION_1_0)
    return 1;

  return 0;
}

_Bool Curl_isPipeliningEnabled(const struct SessionHandle *handle)
{
  return Curl_multi_pipeline_enabled(handle->multi);
}

CURLcode Curl_addHandleToPipeline(struct SessionHandle *data,
                                  struct curl_llist *pipeline)
{
  if(!Curl_llist_insert_next(pipeline, pipeline->tail, data))
    return CURLE_OUT_OF_MEMORY;
  return CURLE_OK;
}

int Curl_removeHandleFromPipeline(struct SessionHandle *handle,
                                  struct curl_llist *pipeline)
{
  struct curl_llist_element *curr;

  curr = pipeline->head;
  while(curr) {
    if(curr->ptr == handle) {
      Curl_llist_remove(pipeline, curr, ((void*)0));
      return 1;
    }
    curr = curr->next;
  }

  return 0;
}
# 2831 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
static struct SessionHandle* gethandleathead(struct curl_llist *pipeline)
{
  struct curl_llist_element *curr = pipeline->head;
  if(curr) {
    return (struct SessionHandle *) curr->ptr;
  }

  return ((void*)0);
}



void Curl_getoff_all_pipelines(struct SessionHandle *data,
                               struct connectdata *conn)
{
  _Bool recv_head = (conn->readchannel_inuse &&
    (gethandleathead(conn->recv_pipe) == data)) ? 1 : 0;

  _Bool send_head = (conn->writechannel_inuse &&
    (gethandleathead(conn->send_pipe) == data)) ? 1 : 0;

  if(Curl_removeHandleFromPipeline(data, conn->recv_pipe) && recv_head)
    conn->readchannel_inuse = 0;
  if(Curl_removeHandleFromPipeline(data, conn->send_pipe) && send_head)
    conn->writechannel_inuse = 0;
}

static void signalPipeClose(struct curl_llist *pipeline, _Bool pipe_broke)
{
  struct curl_llist_element *curr;

  if(!pipeline)
    return;

  curr = pipeline->head;
  while(curr) {
    struct curl_llist_element *next = curr->next;
    struct SessionHandle *data = (struct SessionHandle *) curr->ptr;
# 2877 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
    if(pipe_broke)
      data->state.pipe_broke = 1;
    Curl_multi_handlePipeBreak(data);
    Curl_llist_remove(pipeline, curr, ((void*)0));
    curr = next;
  }
}
# 2892 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
static struct connectdata *
find_oldest_idle_connection(struct SessionHandle *data)
{
  struct conncache *bc = data->state.conn_cache;
  struct curl_hash_iterator iter;
  struct curl_llist_element *curr;
  struct curl_hash_element *he;
  long highscore=-1;
  long score;
  struct timeval now;
  struct connectdata *conn_candidate = ((void*)0);
  struct connectbundle *bundle;

  now = curlx_tvnow();

  Curl_hash_start_iterate(bc->hash, &iter);

  he = Curl_hash_next_element(&iter);
  while(he) {
    struct connectdata *conn;

    bundle = he->ptr;

    curr = bundle->conn_list->head;
    while(curr) {
      conn = curr->ptr;

      if(!conn->inuse) {

        score = curlx_tvdiff(now,conn->now);

        if(score > highscore) {
          highscore = score;
          conn_candidate = conn;
        }
      }
      curr = curr->next;
    }

    he = Curl_hash_next_element(&iter);
  }

  return conn_candidate;
}
# 2944 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
static struct connectdata *
find_oldest_idle_connection_in_bundle(struct SessionHandle *data,
                                      struct connectbundle *bundle)
{
  struct curl_llist_element *curr;
  long highscore=-1;
  long score;
  struct timeval now;
  struct connectdata *conn_candidate = ((void*)0);
  struct connectdata *conn;

  (void)data;

  now = curlx_tvnow();

  curr = bundle->conn_list->head;
  while(curr) {
    conn = curr->ptr;

    if(!conn->inuse) {

      score = curlx_tvdiff(now,conn->now);

      if(score > highscore) {
        highscore = score;
        conn_candidate = conn;
      }
    }
    curr = curr->next;
  }

  return conn_candidate;
}







static _Bool disconnect_if_dead(struct connectdata *conn,
                               struct SessionHandle *data)
{
  size_t pipeLen = conn->send_pipe->size + conn->recv_pipe->size;
  if(!pipeLen && !conn->inuse) {



    _Bool dead;
    if(conn->handler->protocol & (1<<18))

      dead = Curl_rtsp_connisdead(conn);
    else
      dead = SocketIsDead(conn->sock[0]);

    if(dead) {
      conn->data = data;
      Curl_infof(data, "Connection %ld seems to be dead!\n", conn->connection_id);


      Curl_disconnect(conn, 1);
      return 1;
    }
  }
  return 0;
}






static int call_disconnect_if_dead(struct connectdata *conn,
                                      void *param)
{
  struct SessionHandle* data = (struct SessionHandle*)param;
  disconnect_if_dead(conn, data);
  return 0;
}






static void prune_dead_connections(struct SessionHandle *data)
{
  struct timeval now = curlx_tvnow();
  long elapsed = curlx_tvdiff(now,data->state.conn_cache->last_cleanup);

  if(elapsed >= 1000L) {
    Curl_conncache_foreach(data->state.conn_cache, data,
                           call_disconnect_if_dead);
    data->state.conn_cache->last_cleanup = now;
  }
}
# 3053 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
static _Bool
ConnectionExists(struct SessionHandle *data,
                 struct connectdata *needle,
                 struct connectdata **usethis,
                 _Bool *force_reuse)
{
  struct connectdata *check;
  struct connectdata *chosen = 0;
  _Bool canPipeline = IsPipeliningPossible(data, needle);
  _Bool wantNTLMhttp = ((data->state.authhost.want & (((unsigned long)1)<<3)) ||
                       (data->state.authhost.want & (((unsigned long)1)<<5))) &&
    (needle->handler->protocol & ((1<<0)|(1<<1))) ? 1 : 0;
  struct connectbundle *bundle;

  *force_reuse = 0;


  if(canPipeline && Curl_pipeline_site_blacklisted(data, needle)) {
    canPipeline = 0;
  }



  bundle = Curl_conncache_find_bundle(data->state.conn_cache,
                                      needle->host.name);
  if(bundle) {
    size_t max_pipe_len = Curl_multi_max_pipeline_length(data->multi);
    size_t best_pipe_len = max_pipe_len;
    struct curl_llist_element *curr;

    Curl_infof(data, "Found bundle for host %s: %p\n",
          needle->host.name, (void *)bundle);


    if(canPipeline && !bundle->server_supports_pipelining) {
      Curl_infof(data, "Server doesn't support pipelining\n");
      canPipeline = 0;
    }

    curr = bundle->conn_list->head;
    while(curr) {
      _Bool match = 0;



      size_t pipeLen;





      check = curr->ptr;
      curr = curr->next;

      if(disconnect_if_dead(check, data))
        continue;

      pipeLen = check->send_pipe->size + check->recv_pipe->size;

      if(canPipeline) {

        struct SessionHandle* sh = gethandleathead(check->send_pipe);
        struct SessionHandle* rh = gethandleathead(check->recv_pipe);
        if(sh) {
          if(!IsPipeliningPossible(sh, check))
            continue;
        }
        else if(rh) {
          if(!IsPipeliningPossible(rh, check))
            continue;
        }
      }
      else {
        if(pipeLen > 0) {


          continue;
        }

        if(0) {


          if(!check->ip_addr_str[0]) {
            Curl_infof(data,
                  "Connection #%ld is still name resolving, can't reuse\n",
                  check->connection_id);
            continue;
          }
        }

        if((check->sock[0] == -1) ||
           check->bits.close) {


          Curl_infof(data, "Connection #%ld isn't open enough, can't reuse\n",
                check->connection_id);







          continue;
        }
      }

      if((needle->handler->flags&(1<<0)) !=
         (check->handler->flags&(1<<0)))

        if(!(needle->handler->protocol & check->handler->protocol))

          continue;

      if(needle->handler->flags&(1<<0)) {
        if((data->set.ssl.verifypeer != check->verifypeer) ||
           (data->set.ssl.verifyhost != check->verifyhost))
          continue;
      }

      if(needle->bits.proxy != check->bits.proxy)

        continue;

      if(!canPipeline && check->inuse)


        continue;

      if(needle->localdev || needle->localport) {
# 3194 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
        if((check->localport != needle->localport) ||
           (check->localportrange != needle->localportrange) ||
           !check->localdev ||
           !needle->localdev ||
           __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (check->localdev) && __builtin_constant_p (needle->localdev) && (__s1_len = __builtin_strlen (check->localdev), __s2_len = __builtin_strlen (needle->localdev), (!((size_t)(const void *)((check->localdev) + 1) - (size_t)(const void *)(check->localdev) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((needle->localdev) + 1) - (size_t)(const void *)(needle->localdev) == 1) || __s2_len >= 4)) ? __builtin_strcmp (check->localdev, needle->localdev) : (__builtin_constant_p (check->localdev) && ((size_t)(const void *)((check->localdev) + 1) - (size_t)(const void *)(check->localdev) == 1) && (__s1_len = __builtin_strlen (check->localdev), __s1_len < 4) ? (__builtin_constant_p (needle->localdev) && ((size_t)(const void *)((needle->localdev) + 1) - (size_t)(const void *)(needle->localdev) == 1) ? __builtin_strcmp (check->localdev, needle->localdev) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (needle->localdev); int __result = (((const unsigned char *) (const char *) (check->localdev))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (check->localdev))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (check->localdev))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (check->localdev))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (needle->localdev) && ((size_t)(const void *)((needle->localdev) + 1) - (size_t)(const void *)(needle->localdev) == 1) && (__s2_len = __builtin_strlen (needle->localdev), __s2_len < 4) ? (__builtin_constant_p (check->localdev) && ((size_t)(const void *)((check->localdev) + 1) - (size_t)(const void *)(check->localdev) == 1) ? __builtin_strcmp (check->localdev, needle->localdev) : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (check->localdev); int __result = (((const unsigned char *) (const char *) (needle->localdev))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (needle->localdev))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (needle->localdev))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (needle->localdev))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (check->localdev, needle->localdev)))); }))
          continue;
      }

      if((!(needle->handler->flags & (1<<7))) ||
         wantNTLMhttp) {


        if(!curl_strequal(needle->user,check->user) ||
           !curl_strequal(needle->passwd,check->passwd)) {

          continue;
        }



      }

      if(!needle->bits.httpproxy || needle->handler->flags&(1<<0) ||
         (needle->bits.httpproxy && check->bits.httpproxy &&
          needle->bits.tunnel_proxy && check->bits.tunnel_proxy &&
          Curl_raw_equal(needle->proxy.name, check->proxy.name) &&
          (needle->port == check->port))) {





        if((Curl_raw_equal(needle->handler->scheme, check->handler->scheme) ||
            needle->handler->protocol & check->handler->protocol) &&
           Curl_raw_equal(needle->host.name, check->host.name) &&
           needle->remote_port == check->remote_port) {
          if(needle->handler->flags & (1<<0)) {


            if(!Curl_ssl_config_matches(&needle->ssl_config,
                                        &check->ssl_config)) {
              do { } while(0);



              continue;
            }
            else if(check->ssl[0].state != ssl_connection_complete) {
              do { } while(0);



              continue;
            }
          }
          match = 1;
        }
      }
      else {

        if(check->bits.proxy &&
           (needle->proxytype == check->proxytype) &&
           (needle->bits.tunnel_proxy == check->bits.tunnel_proxy) &&
           Curl_raw_equal(needle->proxy.name, check->proxy.name) &&
           needle->port == check->port) {

          match = 1;
        }
      }

      if(match) {
# 3286 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
        if(canPipeline) {




          if(pipeLen == 0) {

            chosen = check;
            break;
          }


          if(pipeLen >= max_pipe_len)
            continue;


          if(Curl_pipeline_penalized(data, check))
            continue;

          if(pipeLen < best_pipe_len) {


            chosen = check;
            best_pipe_len = pipeLen;
            continue;
          }
        }
        else {

          chosen = check;
          break;
        }
      }
    }
  }

  if(chosen) {
    *usethis = chosen;
    return 1;
  }

  return 0;
}



static _Bool
ConnectionDone(struct SessionHandle *data, struct connectdata *conn)
{

  size_t maxconnects =
    (data->multi->maxconnects < 0) ? data->multi->num_easy * 4:
    data->multi->maxconnects;
  struct connectdata *conn_candidate = ((void*)0);


  conn->inuse = 0;

  if(maxconnects > 0 &&
     data->state.conn_cache->num_connections > maxconnects) {
    Curl_infof(data, "Connection cache is full, closing the oldest one.\n");

    conn_candidate = find_oldest_idle_connection(data);

    if(conn_candidate) {

      conn_candidate->data = data;


      (void)Curl_disconnect(conn_candidate, 0);
    }
  }

  return (conn_candidate == conn) ? 0 : 1;
}
# 3370 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
static CURLcode ConnectionStore(struct SessionHandle *data,
                                struct connectdata *conn)
{
  return Curl_conncache_add_conn(data->state.conn_cache, conn);
}







CURLcode Curl_connected_proxy(struct connectdata *conn,
                              int sockindex)
{
  if(!conn->bits.proxy || sockindex)


    return CURLE_OK;

  switch(conn->proxytype) {

  case CURLPROXY_SOCKS5:
  case CURLPROXY_SOCKS5_HOSTNAME:
    return Curl_SOCKS5(conn->proxyuser, conn->proxypasswd,
                       conn->host.name, conn->remote_port,
                       0, conn);

  case CURLPROXY_SOCKS4:
    return Curl_SOCKS4(conn->proxyuser, conn->host.name,
                       conn->remote_port, 0, conn, 0);

  case CURLPROXY_SOCKS4A:
    return Curl_SOCKS4(conn->proxyuser, conn->host.name,
                       conn->remote_port, 0, conn, 1);


  case CURLPROXY_HTTP:
  case CURLPROXY_HTTP_1_0:

    break;
  default:
    break;
  }

  return CURLE_OK;
}





void Curl_verboseconnect(struct connectdata *conn)
{
  if(conn->data->set.verbose)
    Curl_infof(conn->data, "Connected to %s (%s) port %ld (#%ld)\n",
          conn->bits.proxy ? conn->proxy.dispname : conn->host.dispname,
          conn->ip_addr_str, conn->port, conn->connection_id);
}


int Curl_protocol_getsock(struct connectdata *conn,
                          curl_socket_t *socks,
                          int numsocks)
{
  if(conn->handler->proto_getsock)
    return conn->handler->proto_getsock(conn, socks, numsocks);
  return 0;
}

int Curl_doing_getsock(struct connectdata *conn,
                       curl_socket_t *socks,
                       int numsocks)
{
  if(conn && conn->handler->doing_getsock)
    return conn->handler->doing_getsock(conn, socks, numsocks);
  return 0;
}







CURLcode Curl_protocol_connecting(struct connectdata *conn,
                                  _Bool *done)
{
  CURLcode result=CURLE_OK;

  if(conn && conn->handler->connecting) {
    *done = 0;
    result = conn->handler->connecting(conn, done);
  }
  else
    *done = 1;

  return result;
}






CURLcode Curl_protocol_doing(struct connectdata *conn, _Bool *done)
{
  CURLcode result=CURLE_OK;

  if(conn && conn->handler->doing) {
    *done = 0;
    result = conn->handler->doing(conn, done);
  }
  else
    *done = 1;

  return result;
}






CURLcode Curl_protocol_connect(struct connectdata *conn,
                               _Bool *protocol_done)
{
  CURLcode result=CURLE_OK;

  *protocol_done = 0;

  if(conn->bits.tcpconnect[0] && conn->bits.protoconnstart) {






    if(!conn->handler->connecting)
      *protocol_done = 1;

    return CURLE_OK;
  }

  if(!conn->bits.protoconnstart) {

    result = Curl_proxy_connect(conn);
    if(result)
      return result;

    if(conn->bits.tunnel_proxy && conn->bits.httpproxy &&
       (conn->tunnel_state[0] != TUNNEL_COMPLETE))


      return CURLE_OK;

    if(conn->handler->connect_it) {



      result = conn->handler->connect_it(conn, protocol_done);
    }
    else
      *protocol_done = 1;



    if(!result)
      conn->bits.protoconnstart = 1;
  }

  return result;
}




static _Bool is_ASCII_name(const char *hostname)
{
  const unsigned char *ch = (const unsigned char*)hostname;

  while(*ch) {
    if(*ch++ & 0x80)
      return 0;
  }
  return 1;
}
# 3605 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
static void fix_hostname(struct SessionHandle *data,
                         struct connectdata *conn, struct hostname *host)
{
  size_t len;


  (void)data;
  (void)conn;





  host->dispname = host->name;

  len = strlen(host->name);
  if(host->name[len-1] == '.')


    host->name[len-1]=0;

  if(!is_ASCII_name(host->name)) {
# 3664 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
    Curl_infof(data, "IDN support not present, can't parse Unicode domains\n");

  }
}

static void llist_dtor(void *user, void *element)
{
  (void)user;
  (void)element;

}




static struct connectdata *allocate_conn(struct SessionHandle *data)
{
  struct connectdata *conn = Curl_ccalloc(1, sizeof(struct connectdata));
  if(!conn)
    return ((void*)0);

  conn->handler = &Curl_handler_dummy;





  conn->sock[0] = -1;
  conn->sock[1] = -1;
  conn->tempsock[0] = -1;
  conn->tempsock[1] = -1;
  conn->connection_id = -1;
  conn->port = -1;
  conn->remote_port = -1;




  (conn)->bits.close = 1;


  conn->created = curlx_tvnow();

  conn->data = data;


  conn->proxytype = data->set.proxytype;
# 3723 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  conn->bits.proxy = (data->set.str[STRING_PROXY] &&
                      *data->set.str[STRING_PROXY])?1:0;
  conn->bits.httpproxy = (conn->bits.proxy &&
                          (conn->proxytype == CURLPROXY_HTTP ||
                           conn->proxytype == CURLPROXY_HTTP_1_0))?1:0;
  conn->bits.proxy_user_passwd =
    (((void*)0) != data->set.str[STRING_PROXYUSERNAME])?1:0;
  conn->bits.tunnel_proxy = data->set.tunnel_thru_httpproxy;



  conn->bits.user_passwd = (((void*)0) != data->set.str[STRING_USERNAME])?1:0;
  conn->bits.ftp_use_epsv = data->set.ftp_use_epsv;
  conn->bits.ftp_use_eprt = data->set.ftp_use_eprt;

  conn->verifypeer = data->set.ssl.verifypeer;
  conn->verifyhost = data->set.ssl.verifyhost;

  conn->ip_version = data->set.ipver;
# 3751 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  if(Curl_multi_pipeline_enabled(data->multi) &&
      !conn->master_buffer) {

    conn->master_buffer = Curl_ccalloc(16384, sizeof (char));
    if(!conn->master_buffer)
      goto error;
  }


  conn->send_pipe = Curl_llist_alloc((curl_llist_dtor) llist_dtor);
  conn->recv_pipe = Curl_llist_alloc((curl_llist_dtor) llist_dtor);
  if(!conn->send_pipe || !conn->recv_pipe)
    goto error;






  if(data->set.str[STRING_DEVICE]) {
    conn->localdev = Curl_cstrdup(data->set.str[STRING_DEVICE]);
    if(!conn->localdev)
      goto error;
  }
  conn->localportrange = data->set.localportrange;
  conn->localport = data->set.localport;



  conn->fclosesocket = data->set.fclosesocket;
  conn->closesocket_client = data->set.closesocket_client;

  return conn;
  error:

  Curl_llist_destroy(conn->send_pipe, ((void*)0));
  Curl_llist_destroy(conn->recv_pipe, ((void*)0));

  conn->send_pipe = ((void*)0);
  conn->recv_pipe = ((void*)0);

  do {if((conn->master_buffer)) {Curl_cfree((conn->master_buffer)); (conn->master_buffer) = ((void*)0);}} while(0);
  do {if((conn->localdev)) {Curl_cfree((conn->localdev)); (conn->localdev) = ((void*)0);}} while(0);
  do {if((conn)) {Curl_cfree((conn)); (conn) = ((void*)0);}} while(0);
  return ((void*)0);
}

static CURLcode findprotocol(struct SessionHandle *data,
                             struct connectdata *conn,
                             const char *protostr)
{
  const struct Curl_handler * const *pp;
  const struct Curl_handler *p;




  for(pp = protocols; (p = *pp) != ((void*)0); pp++) {
    if(Curl_raw_equal(p->scheme, protostr)) {

      if(!(data->set.allowed_protocols & p->protocol))

        break;



      if(data->state.this_is_a_follow &&
         !(data->set.redir_protocols & p->protocol))

        break;


      conn->handler = conn->given = p;


      return CURLE_OK;
    }
  }





  Curl_failf(data, "Protocol \"%s\" not supported or disabled in " "libcurl",
        protostr);

  return CURLE_UNSUPPORTED_PROTOCOL;
}




static CURLcode parseurlandfillconn(struct SessionHandle *data,
                                    struct connectdata *conn,
                                    _Bool *prot_missing,
                                    char **userp, char **passwdp,
                                    char **optionsp)
{
  char *at;
  char *fragment;
  char *path = data->state.path;
  char *query;
  int rc;
  char protobuf[16] = "";
  const char *protop = "";
  CURLcode result;
  _Bool rebuild_url = 0;

  *prot_missing = 0;



  if(__extension__ ({ char __a0, __a1, __a2; (__builtin_constant_p ("\r\n") && ((size_t)(const void *)(("\r\n") + 1) - (size_t)(const void *)("\r\n") == 1) ? ((__builtin_constant_p (data->change.url) && ((size_t)(const void *)((data->change.url) + 1) - (size_t)(const void *)(data->change.url) == 1)) ? __builtin_strpbrk (data->change.url, "\r\n") : ((__a0 = ((const char *) ("\r\n"))[0], __a0 == '\0') ? ((void) (data->change.url), (char *) ((void*)0)) : ((__a1 = ((const char *) ("\r\n"))[1], __a1 == '\0') ? __builtin_strchr (data->change.url, __a0) : ((__a2 = ((const char *) ("\r\n"))[2], __a2 == '\0') ? __strpbrk_c2 (data->change.url, __a0, __a1) : (((const char *) ("\r\n"))[3] == '\0' ? __strpbrk_c3 (data->change.url, __a0, __a1, __a2) : __builtin_strpbrk (data->change.url, "\r\n")))))) : __builtin_strpbrk (data->change.url, "\r\n")); })) {
    Curl_failf(data, "Illegal characters found in URL");
    return CURLE_URL_MALFORMAT;
  }
# 3876 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  if((2 == sscanf(data->change.url, "%15[^:]:%[^\n]",
                  protobuf, path)) &&
     Curl_raw_equal(protobuf, "file")) {
    if(path[0] == '/' && path[1] == '/') {







      memmove(path, path + 2, strlen(path + 2)+1);
    }





    if(path[0] != '/') {


      char *ptr=(__extension__ (__builtin_constant_p ('/') && !__builtin_constant_p (path) && ('/') == '\0' ? (char *) __rawmemchr (path, '/') : __builtin_strchr (path, '/')));
      if(ptr) {
# 3914 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
        if(ptr[1] && ('/' == ptr[1]))


          ptr++;


        memmove(path, ptr, strlen(ptr)+1);
      }
    }

    protop = "file";
  }
  else {

    path[0]=0;

    if(2 > sscanf(data->change.url,
                   "%15[^\n:]://%[^\n/?]%[^\n]",
                   protobuf,
                   conn->host.name, path)) {





      rc = sscanf(data->change.url, "%[^\n/?]%[^\n]", conn->host.name, path);
      if(1 > rc) {
# 3949 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
        {
          Curl_failf(data, "<url> malformed");
          return CURLE_URL_MALFORMAT;
        }
      }
# 3963 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
      if(Curl_raw_nequal("FTP.",conn->host.name,strlen("FTP.")))
        protop = "ftp";
      else if(Curl_raw_nequal("DICT.",conn->host.name,strlen("DICT.")))
        protop = "DICT";
      else if(Curl_raw_nequal("LDAP.",conn->host.name,strlen("LDAP.")))
        protop = "LDAP";
      else if(Curl_raw_nequal("IMAP.",conn->host.name,strlen("IMAP.")))
        protop = "IMAP";
      else if(Curl_raw_nequal("SMTP.",conn->host.name,strlen("SMTP.")))
        protop = "smtp";
      else if(Curl_raw_nequal("POP3.",conn->host.name,strlen("POP3.")))
        protop = "pop3";
      else {
        protop = "http";
      }

      *prot_missing = 1;
    }
    else
      protop = protobuf;
  }





  at = (__extension__ (__builtin_constant_p ('@') && !__builtin_constant_p (conn->host.name) && ('@') == '\0' ? (char *) __rawmemchr (conn->host.name, '@') : __builtin_strchr (conn->host.name, '@')));
  if(at)
    query = (__extension__ (__builtin_constant_p ('?') && !__builtin_constant_p (at+1) && ('?') == '\0' ? (char *) __rawmemchr (at+1, '?') : __builtin_strchr (at+1, '?')));
  else
    query = (__extension__ (__builtin_constant_p ('?') && !__builtin_constant_p (conn->host.name) && ('?') == '\0' ? (char *) __rawmemchr (conn->host.name, '?') : __builtin_strchr (conn->host.name, '?')));

  if(query) {
# 4004 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
    size_t hostlen = strlen(query);
    size_t pathlen = strlen(path);



    memmove(path+hostlen+1, path, pathlen+1);


    memcpy(path+1, query, hostlen);

    path[0]='/';
    rebuild_url = 1;

    *query=0;
  }
  else if(!path[0]) {

    strcpy(path, "/");
    rebuild_url = 1;
  }





  if(path[0] == '?') {



    memmove(&path[1], path, strlen(path)+1);
    path[0] = '/';
    rebuild_url = 1;
  }
  else {

    char *newp = Curl_dedotdotify(path);
    if(!newp)
      return CURLE_OUT_OF_MEMORY;

    if(__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (newp) && __builtin_constant_p (path) && (__s1_len = __builtin_strlen (newp), __s2_len = __builtin_strlen (path), (!((size_t)(const void *)((newp) + 1) - (size_t)(const void *)(newp) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((path) + 1) - (size_t)(const void *)(path) == 1) || __s2_len >= 4)) ? __builtin_strcmp (newp, path) : (__builtin_constant_p (newp) && ((size_t)(const void *)((newp) + 1) - (size_t)(const void *)(newp) == 1) && (__s1_len = __builtin_strlen (newp), __s1_len < 4) ? (__builtin_constant_p (path) && ((size_t)(const void *)((path) + 1) - (size_t)(const void *)(path) == 1) ? __builtin_strcmp (newp, path) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (path); int __result = (((const unsigned char *) (const char *) (newp))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (newp))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (newp))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (newp))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (path) && ((size_t)(const void *)((path) + 1) - (size_t)(const void *)(path) == 1) && (__s2_len = __builtin_strlen (path), __s2_len < 4) ? (__builtin_constant_p (newp) && ((size_t)(const void *)((newp) + 1) - (size_t)(const void *)(newp) == 1) ? __builtin_strcmp (newp, path) : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (newp); int __result = (((const unsigned char *) (const char *) (path))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (path))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (path))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (path))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (newp, path)))); })) {
      rebuild_url = 1;
      Curl_cfree(data->state.pathbuffer);
      data->state.pathbuffer = newp;
      data->state.path = newp;
      path = newp;
    }
    else
      Curl_cfree(newp);
  }







  if(rebuild_url) {
    char *reurl;

    size_t plen = strlen(path);

    size_t urllen = strlen(data->change.url);

    size_t prefixlen = strlen(conn->host.name);

    if(!*prot_missing)
      prefixlen += strlen(protop) + strlen("://");

    reurl = Curl_cmalloc(urllen + 2);
    if(!reurl)
      return CURLE_OUT_OF_MEMORY;


    memcpy(reurl, data->change.url, prefixlen);


    memcpy(&reurl[prefixlen], path, plen + 1);


    if(data->change.url_alloc) {
      do {if((data->change.url)) {Curl_cfree((data->change.url)); (data->change.url) = ((void*)0);}} while(0);
      data->change.url_alloc = 0;
    }

    Curl_infof(data, "Rebuilt URL to: %s\n", reurl);

    data->change.url = reurl;
    data->change.url_alloc = 1;
  }





  result = parse_url_login(data, conn, userp, passwdp, optionsp);
  if(result)
    return result;

  if(conn->host.name[0] == '[') {


    char *percent = (__extension__ (__builtin_constant_p ('%') && !__builtin_constant_p (conn->host.name) && ('%') == '\0' ? (char *) __rawmemchr (conn->host.name, '%') : __builtin_strchr (conn->host.name, '%')));
    if(percent) {
      unsigned int identifier_offset = 3;
      char *endp;
      unsigned long scope;
      if((__extension__ (__builtin_constant_p (3) && ((__builtin_constant_p ("%25") && strlen ("%25") < ((size_t) (3))) || (__builtin_constant_p (percent) && strlen (percent) < ((size_t) (3)))) ? __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p ("%25") && __builtin_constant_p (percent) && (__s1_len = __builtin_strlen ("%25"), __s2_len = __builtin_strlen (percent), (!((size_t)(const void *)(("%25") + 1) - (size_t)(const void *)("%25") == 1) || __s1_len >= 4) && (!((size_t)(const void *)((percent) + 1) - (size_t)(const void *)(percent) == 1) || __s2_len >= 4)) ? __builtin_strcmp ("%25", percent) : (__builtin_constant_p ("%25") && ((size_t)(const void *)(("%25") + 1) - (size_t)(const void *)("%25") == 1) && (__s1_len = __builtin_strlen ("%25"), __s1_len < 4) ? (__builtin_constant_p (percent) && ((size_t)(const void *)((percent) + 1) - (size_t)(const void *)(percent) == 1) ? __builtin_strcmp ("%25", percent) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (percent); int __result = (((const unsigned char *) (const char *) ("%25"))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ("%25"))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ("%25"))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ("%25"))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (percent) && ((size_t)(const void *)((percent) + 1) - (size_t)(const void *)(percent) == 1) && (__s2_len = __builtin_strlen (percent), __s2_len < 4) ? (__builtin_constant_p ("%25") && ((size_t)(const void *)(("%25") + 1) - (size_t)(const void *)("%25") == 1) ? __builtin_strcmp ("%25", percent) : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("%25"); int __result = (((const unsigned char *) (const char *) (percent))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (percent))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (percent))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (percent))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp ("%25", percent)))); }) : strncmp ("%25", percent, 3))) != 0) {
        Curl_infof(data,
              "Please URL encode %% as %%25, see RFC 6874.\n");
        identifier_offset = 1;
      }
      scope = strtoul(percent + identifier_offset, &endp, 10);
      if(*endp == ']') {


        memmove(percent, endp, strlen(endp)+1);
        conn->scope_id = (unsigned int)scope;
      }
      else {


        char ifname[16 + 2];
        char *square_bracket;
        unsigned int scopeidx = 0;
        __builtin_strncpy (ifname, percent + identifier_offset, 16 + 2);

        ifname[16 + 1] = '\0';
        square_bracket = (__extension__ (__builtin_constant_p (']') && !__builtin_constant_p (ifname) && (']') == '\0' ? (char *) __rawmemchr (ifname, ']') : __builtin_strchr (ifname, ']')));
        if(square_bracket) {

          *square_bracket = '\0';
          scopeidx = if_nametoindex(ifname);
          if(scopeidx == 0) {
            Curl_infof(data, "Invalid network interface: %s; %s\n", ifname,
                  strerror((*__errno_location ())));
          }
        }
        if(scopeidx > 0) {
          char *p = percent + identifier_offset + strlen(ifname);


          memmove(percent, p, strlen(p) + 1);
          conn->scope_id = scopeidx;
        }
        else

          Curl_infof(data, "Invalid IPv6 address format\n");
      }
    }
  }

  if(data->set.scope_id)

    conn->scope_id = data->set.scope_id;




  fragment = (__extension__ (__builtin_constant_p ('#') && !__builtin_constant_p (path) && ('#') == '\0' ? (char *) __rawmemchr (path, '#') : __builtin_strchr (path, '#')));
  if(fragment) {
    *fragment = 0;




    fragment = (__extension__ (__builtin_constant_p ('#') && !__builtin_constant_p (data->change.url) && ('#') == '\0' ? (char *) __rawmemchr (data->change.url, '#') : __builtin_strchr (data->change.url, '#')));
    if(fragment)
      *fragment = 0;
  }
# 4181 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  return findprotocol(data, conn, protop);
}





static CURLcode setup_range(struct SessionHandle *data)
{
  struct UrlState *s = &data->state;
  s->resume_from = data->set.set_resume_from;
  if(s->resume_from || data->set.str[STRING_SET_RANGE]) {
    if(s->rangestringalloc)
      Curl_cfree(s->range);

    if(s->resume_from)
      s->range = curl_maprintf("%" "lu" "-", s->resume_from);
    else
      s->range = Curl_cstrdup(data->set.str[STRING_SET_RANGE]);

    s->rangestringalloc = (s->range)?1:0;

    if(!s->range)
      return CURLE_OUT_OF_MEMORY;


    s->use_range = 1;
  }
  else
    s->use_range = 0;

  return CURLE_OK;
}
# 4225 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
static CURLcode setup_connection_internals(struct connectdata *conn)
{
  const struct Curl_handler * p;
  CURLcode result;
  struct SessionHandle *data = conn->data;






  Curl_free_request_state(data);

  memset(&data->req, 0, sizeof(struct SingleRequest));
  data->req.maxdownload = -1;

  conn->socktype = SOCK_STREAM;


  p = conn->handler;

  if(p->setup_connection) {
    result = (*p->setup_connection)(conn);

    if(result)
      return result;

    p = conn->handler;
  }

  if(conn->port < 0)


    conn->port = p->defport;



  if(conn->remote_port < 0)
    conn->remote_port = (unsigned short)conn->given->defport;

  return CURLE_OK;
}






void Curl_free_request_state(struct SessionHandle *data)
{
  do {if((data->req.protop)) {Curl_cfree((data->req.protop)); (data->req.protop) = ((void*)0);}} while(0);
  do {if((data->req.newurl)) {Curl_cfree((data->req.newurl)); (data->req.newurl) = ((void*)0);}} while(0);
}







static _Bool check_noproxy(const char* name, const char* no_proxy)
{





  size_t tok_start;
  size_t tok_end;
  const char* separator = ", ";
  size_t no_proxy_len;
  size_t namelen;
  char *endptr;

  if(no_proxy && no_proxy[0]) {
    if(Curl_raw_equal("*", no_proxy)) {
      return 1;
    }



    no_proxy_len = strlen(no_proxy);
    endptr = (__extension__ (__builtin_constant_p (':') && !__builtin_constant_p (name) && (':') == '\0' ? (char *) __rawmemchr (name, ':') : __builtin_strchr (name, ':')));
    if(endptr)
      namelen = endptr - name;
    else
      namelen = strlen(name);

    for(tok_start = 0; tok_start < no_proxy_len; tok_start = tok_end + 1) {
      while(tok_start < no_proxy_len &&
            (__extension__ (__builtin_constant_p (no_proxy[tok_start]) && !__builtin_constant_p (separator) && (no_proxy[tok_start]) == '\0' ? (char *) __rawmemchr (separator, no_proxy[tok_start]) : __builtin_strchr (separator, no_proxy[tok_start]))) != ((void*)0)) {

        ++tok_start;
      }

      if(tok_start == no_proxy_len)
        break;

      for(tok_end = tok_start; tok_end < no_proxy_len &&
            (__extension__ (__builtin_constant_p (no_proxy[tok_end]) && !__builtin_constant_p (separator) && (no_proxy[tok_end]) == '\0' ? (char *) __rawmemchr (separator, no_proxy[tok_end]) : __builtin_strchr (separator, no_proxy[tok_end]))) == ((void*)0); ++tok_end)

        ;





      if(no_proxy[tok_start] == '.')
        ++tok_start;

      if((tok_end - tok_start) <= namelen) {

        const char *checkn = name + namelen - (tok_end - tok_start);
        if(Curl_raw_nequal(no_proxy + tok_start, checkn,
                           tok_end - tok_start)) {
          if((tok_end - tok_start) == namelen || *(checkn - 1) == '.') {



            return 1;
          }
        }
      }
    }

  }

  return 0;
}






static char *detect_proxy(struct connectdata *conn)
{
  char *proxy = ((void*)0);
# 4382 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  char *no_proxy=((void*)0);
  char proxy_env[128];

  no_proxy=curl_getenv("no_proxy");
  if(!no_proxy)
    no_proxy=curl_getenv("NO_PROXY");

  if(!check_noproxy(conn->host.name, no_proxy)) {

    const char *protop = conn->handler->scheme;
    char *envp = proxy_env;
    char *prox;


    while(*protop)
      *envp++ = (char)(__extension__ ({ int __res; if (sizeof ((int)*protop++) > 1) { if (__builtin_constant_p ((int)*protop++)) { int __c = ((int)*protop++); __res = __c < -128 || __c > 255 ? __c : (*__ctype_tolower_loc ())[__c]; } else __res = tolower ((int)*protop++); } else __res = (*__ctype_tolower_loc ())[(int) ((int)*protop++)]; __res; }));


    strcpy(envp, "_proxy");


    prox=curl_getenv(proxy_env);
# 4417 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
    if(!prox && !Curl_raw_equal("http_proxy", proxy_env)) {

      Curl_strntoupper(proxy_env, proxy_env, sizeof(proxy_env));
      prox=curl_getenv(proxy_env);
    }

    if(prox)
      proxy = prox;
    else {
      proxy = curl_getenv("all_proxy");
      if(!proxy)
        proxy=curl_getenv("ALL_PROXY");
    }
  }

  if(no_proxy)
    Curl_cfree(no_proxy);






  return proxy;
}







static CURLcode parse_proxy(struct SessionHandle *data,
                            struct connectdata *conn, char *proxy)
{
  char *prox_portno;
  char *endofprot;


  char *proxyptr;
  char *portptr;
  char *atsign;






  endofprot = strstr(proxy, "://");
  if(endofprot) {
    proxyptr = endofprot+3;
    if(Curl_raw_nequal("socks5h",proxy,strlen("socks5h")))
      conn->proxytype = CURLPROXY_SOCKS5_HOSTNAME;
    else if(Curl_raw_nequal("socks5",proxy,strlen("socks5")))
      conn->proxytype = CURLPROXY_SOCKS5;
    else if(Curl_raw_nequal("socks4a",proxy,strlen("socks4a")))
      conn->proxytype = CURLPROXY_SOCKS4A;
    else if(Curl_raw_nequal("socks4",proxy,strlen("socks4")) || Curl_raw_nequal("socks",proxy,strlen("socks")))
      conn->proxytype = CURLPROXY_SOCKS4;

  }
  else
    proxyptr = proxy;


  atsign = (__extension__ (__builtin_constant_p ('@') && !__builtin_constant_p (proxyptr) && ('@') == '\0' ? (char *) __rawmemchr (proxyptr, '@') : __builtin_strchr (proxyptr, '@')));
  if(atsign) {
    char *proxyuser = ((void*)0);
    char *proxypasswd = ((void*)0);
    CURLcode result =
      parse_login_details(proxyptr, atsign - proxyptr,
                          &proxyuser, &proxypasswd, ((void*)0));
    if(!result) {




      do {if((conn->proxyuser)) {Curl_cfree((conn->proxyuser)); (conn->proxyuser) = ((void*)0);}} while(0);
      if(proxyuser && strlen(proxyuser) < 256)
        conn->proxyuser = curl_easy_unescape(data, proxyuser, 0, ((void*)0));
      else
        conn->proxyuser = Curl_cstrdup("");

      if(!conn->proxyuser)
        result = CURLE_OUT_OF_MEMORY;
      else {
        do {if((conn->proxypasswd)) {Curl_cfree((conn->proxypasswd)); (conn->proxypasswd) = ((void*)0);}} while(0);
        if(proxypasswd && strlen(proxypasswd) < 256)
          conn->proxypasswd = curl_easy_unescape(data, proxypasswd, 0, ((void*)0));
        else
          conn->proxypasswd = Curl_cstrdup("");

        if(!conn->proxypasswd)
          result = CURLE_OUT_OF_MEMORY;
      }

      if(!result) {
        conn->bits.proxy_user_passwd = 1;
        atsign++;

        proxyptr = atsign;
      }
    }

    do {if((proxyuser)) {Curl_cfree((proxyuser)); (proxyuser) = ((void*)0);}} while(0);
    do {if((proxypasswd)) {Curl_cfree((proxypasswd)); (proxypasswd) = ((void*)0);}} while(0);

    if(result)
      return result;
  }


  portptr = proxyptr;


  if(*proxyptr == '[') {
    char *ptr = ++proxyptr;
    while(*ptr && ((((*__ctype_b_loc ())[(int) (((int) ((unsigned char)*ptr)))] & (unsigned short int) _ISxdigit)) || (*ptr == ':') || (*ptr == '.')))
      ptr++;
    if(*ptr == '%') {

      if((__extension__ (__builtin_constant_p (3) && ((__builtin_constant_p ("%25") && strlen ("%25") < ((size_t) (3))) || (__builtin_constant_p (ptr) && strlen (ptr) < ((size_t) (3)))) ? __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p ("%25") && __builtin_constant_p (ptr) && (__s1_len = __builtin_strlen ("%25"), __s2_len = __builtin_strlen (ptr), (!((size_t)(const void *)(("%25") + 1) - (size_t)(const void *)("%25") == 1) || __s1_len >= 4) && (!((size_t)(const void *)((ptr) + 1) - (size_t)(const void *)(ptr) == 1) || __s2_len >= 4)) ? __builtin_strcmp ("%25", ptr) : (__builtin_constant_p ("%25") && ((size_t)(const void *)(("%25") + 1) - (size_t)(const void *)("%25") == 1) && (__s1_len = __builtin_strlen ("%25"), __s1_len < 4) ? (__builtin_constant_p (ptr) && ((size_t)(const void *)((ptr) + 1) - (size_t)(const void *)(ptr) == 1) ? __builtin_strcmp ("%25", ptr) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (ptr); int __result = (((const unsigned char *) (const char *) ("%25"))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ("%25"))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ("%25"))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ("%25"))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (ptr) && ((size_t)(const void *)((ptr) + 1) - (size_t)(const void *)(ptr) == 1) && (__s2_len = __builtin_strlen (ptr), __s2_len < 4) ? (__builtin_constant_p ("%25") && ((size_t)(const void *)(("%25") + 1) - (size_t)(const void *)("%25") == 1) ? __builtin_strcmp ("%25", ptr) : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("%25"); int __result = (((const unsigned char *) (const char *) (ptr))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (ptr))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (ptr))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (ptr))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp ("%25", ptr)))); }) : strncmp ("%25", ptr, 3))))
        Curl_infof(data, "Please URL encode %% as %%25, see RFC 6874.\n");
      ptr++;

      while(*ptr && ((((*__ctype_b_loc ())[(int) (((int) ((unsigned char)*ptr)))] & (unsigned short int) _ISalpha)) || (((*__ctype_b_loc ())[(int) (((int) ((unsigned char)*ptr)))] & (unsigned short int) _ISxdigit)) || (*ptr == '-') ||
                     (*ptr == '.') || (*ptr == '_') || (*ptr == '~')))
        ptr++;
    }
    if(*ptr == ']')

      *ptr++ = 0;
    else
      Curl_infof(data, "Invalid IPv6 address format\n");
    portptr = ptr;




  }


  prox_portno = (__extension__ (__builtin_constant_p (':') && !__builtin_constant_p (portptr) && (':') == '\0' ? (char *) __rawmemchr (portptr, ':') : __builtin_strchr (portptr, ':')));
  if(prox_portno) {
    *prox_portno = 0x0;
    prox_portno ++;

    conn->port = strtol(prox_portno, ((void*)0), 10);
  }
  else {
    if(proxyptr[0]=='/')



      return CURLE_COULDNT_RESOLVE_PROXY;



    atsign = (__extension__ (__builtin_constant_p ('/') && !__builtin_constant_p (proxyptr) && ('/') == '\0' ? (char *) __rawmemchr (proxyptr, '/') : __builtin_strchr (proxyptr, '/')));
    if(atsign)
      *atsign = 0x0;

    if(data->set.proxyport)


      conn->port = data->set.proxyport;
  }


  conn->proxy.rawalloc = Curl_cstrdup(proxyptr);
  conn->proxy.name = conn->proxy.rawalloc;

  if(!conn->proxy.rawalloc)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}




static CURLcode parse_proxy_auth(struct SessionHandle *data,
                                 struct connectdata *conn)
{
  char proxyuser[256]="";
  char proxypasswd[256]="";

  if(data->set.str[STRING_PROXYUSERNAME] != ((void*)0)) {
    __builtin_strncpy (proxyuser, data->set.str[STRING_PROXYUSERNAME], 256);

    proxyuser[256 -1] = '\0';
  }
  if(data->set.str[STRING_PROXYPASSWORD] != ((void*)0)) {
    __builtin_strncpy (proxypasswd, data->set.str[STRING_PROXYPASSWORD], 256);

    proxypasswd[256 -1] = '\0';
  }

  conn->proxyuser = curl_easy_unescape(data, proxyuser, 0, ((void*)0));
  if(!conn->proxyuser)
    return CURLE_OUT_OF_MEMORY;

  conn->proxypasswd = curl_easy_unescape(data, proxypasswd, 0, ((void*)0));
  if(!conn->proxypasswd)
    return CURLE_OUT_OF_MEMORY;

  return CURLE_OK;
}
# 4643 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
static CURLcode parse_url_login(struct SessionHandle *data,
                                struct connectdata *conn,
                                char **user, char **passwd, char **options)
{
  CURLcode result = CURLE_OK;
  char *userp = ((void*)0);
  char *passwdp = ((void*)0);
  char *optionsp = ((void*)0);
# 4659 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  char *ptr = (__extension__ (__builtin_constant_p ('@') && !__builtin_constant_p (conn->host.name) && ('@') == '\0' ? (char *) __rawmemchr (conn->host.name, '@') : __builtin_strchr (conn->host.name, '@')));
  char *login = conn->host.name;

  do { } while(0);
  do { } while(0);
  do { } while(0);

  if(!ptr)
    goto out;




  conn->host.name = ++ptr;







  if(data->set.use_netrc == CURL_NETRC_REQUIRED)
    goto out;


  result = parse_login_details(login, ptr - login - 1,
                               &userp, &passwdp, &optionsp);
  if(result)
    goto out;

  if(userp) {
    char *newname;


    conn->bits.userpwd_in_url = 1;
    conn->bits.user_passwd = 1;


    newname = curl_easy_unescape(data, userp, 0, ((void*)0));
    if(!newname) {
      result = CURLE_OUT_OF_MEMORY;
      goto out;
    }

    Curl_cfree(*user);
    *user = newname;
  }

  if(passwdp) {

    char *newpasswd = curl_easy_unescape(data, passwdp, 0, ((void*)0));
    if(!newpasswd) {
      result = CURLE_OUT_OF_MEMORY;
      goto out;
    }

    Curl_cfree(*passwd);
    *passwd = newpasswd;
  }

  if(optionsp) {

    char *newoptions = curl_easy_unescape(data, optionsp, 0, ((void*)0));
    if(!newoptions) {
      result = CURLE_OUT_OF_MEMORY;
      goto out;
    }

    Curl_cfree(*options);
    *options = newoptions;
  }


  out:

  do {if((userp)) {Curl_cfree((userp)); (userp) = ((void*)0);}} while(0);
  do {if((passwdp)) {Curl_cfree((passwdp)); (passwdp) = ((void*)0);}} while(0);
  do {if((optionsp)) {Curl_cfree((optionsp)); (optionsp) = ((void*)0);}} while(0);

  return result;
}
# 4770 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
static CURLcode parse_login_details(const char *login, const size_t len,
                                    char **userp, char **passwdp,
                                    char **optionsp)
{
  CURLcode result = CURLE_OK;
  char *ubuf = ((void*)0);
  char *pbuf = ((void*)0);
  char *obuf = ((void*)0);
  const char *psep = ((void*)0);
  const char *osep = ((void*)0);
  size_t ulen;
  size_t plen;
  size_t olen;


  if(passwdp) {
    psep = (__extension__ (__builtin_constant_p (':') && !__builtin_constant_p (login) && (':') == '\0' ? (char *) __rawmemchr (login, ':') : __builtin_strchr (login, ':')));


    if(psep >= login + len)
      psep = ((void*)0);
  }


  if(optionsp) {
    osep = (__extension__ (__builtin_constant_p (';') && !__builtin_constant_p (login) && (';') == '\0' ? (char *) __rawmemchr (login, ';') : __builtin_strchr (login, ';')));


    if(osep >= login + len)
      osep = ((void*)0);
  }


  ulen = (psep ?
          (size_t)(osep && psep > osep ? osep - login : psep - login) :
          (osep ? (size_t)(osep - login) : len));
  plen = (psep ?
          (osep && osep > psep ? (size_t)(osep - psep) :
                                 (size_t)(login + len - psep)) - 1 : 0);
  olen = (osep ?
          (psep && psep > osep ? (size_t)(psep - osep) :
                                 (size_t)(login + len - osep)) - 1 : 0);


  if(userp && ulen) {
    ubuf = Curl_cmalloc(ulen + 1);
    if(!ubuf)
      result = CURLE_OUT_OF_MEMORY;
  }


  if(!result && passwdp && plen) {
    pbuf = Curl_cmalloc(plen + 1);
    if(!pbuf) {
      do {if((ubuf)) {Curl_cfree((ubuf)); (ubuf) = ((void*)0);}} while(0);
      result = CURLE_OUT_OF_MEMORY;
    }
  }


  if(!result && optionsp && olen) {
    obuf = Curl_cmalloc(olen + 1);
    if(!obuf) {
      do {if((pbuf)) {Curl_cfree((pbuf)); (pbuf) = ((void*)0);}} while(0);
      do {if((ubuf)) {Curl_cfree((ubuf)); (ubuf) = ((void*)0);}} while(0);
      result = CURLE_OUT_OF_MEMORY;
    }
  }

  if(!result) {

    if(ubuf) {
      memcpy(ubuf, login, ulen);
      ubuf[ulen] = '\0';
      do {if((*userp)) {Curl_cfree((*userp)); (*userp) = ((void*)0);}} while(0);
      *userp = ubuf;
    }


    if(pbuf) {
      memcpy(pbuf, psep + 1, plen);
      pbuf[plen] = '\0';
      do {if((*passwdp)) {Curl_cfree((*passwdp)); (*passwdp) = ((void*)0);}} while(0);
      *passwdp = pbuf;
    }


    if(obuf) {
      memcpy(obuf, osep + 1, olen);
      obuf[olen] = '\0';
      do {if((*optionsp)) {Curl_cfree((*optionsp)); (*optionsp) = ((void*)0);}} while(0);
      *optionsp = obuf;
    }
  }

  return result;
}
# 4882 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
static CURLcode parse_remote_port(struct SessionHandle *data,
                                  struct connectdata *conn)
{
  char *portptr;
  char endbracket;




  if((1 == sscanf(conn->host.name, "[%*45[0123456789abcdefABCDEF:.]%c",
                  &endbracket)) &&
     (']' == endbracket)) {

    conn->bits.ipv6_ip = 1;

    conn->host.name++;
    portptr = (__extension__ (__builtin_constant_p (']') && !__builtin_constant_p (conn->host.name) && (']') == '\0' ? (char *) __rawmemchr (conn->host.name, ']') : __builtin_strchr (conn->host.name, ']')));
    if(portptr) {
      *portptr++ = '\0';
      if(':' != *portptr)
        portptr = ((void*)0);
    }
  }
  else {

    struct in6_addr in6;
    if(inet_pton(10,conn->host.name,&in6) > 0) {


      Curl_failf(data, "IPv6 numerical address used in URL without brackets");
      return CURLE_URL_MALFORMAT;
    }


    portptr = strrchr(conn->host.name, ':');
  }

  if(data->set.use_port && data->state.allow_port) {

    conn->remote_port = (unsigned short)data->set.use_port;
    if(portptr)
      *portptr = '\0';

    if(conn->bits.httpproxy) {

      char *url;
      char type[12]="";

      if(conn->bits.type_set)
        curl_msnprintf(type, sizeof(type), ";type=%c",
                 data->set.prefer_ascii?'A':
                 (data->set.ftp_list_only?'D':'I'));






      url = curl_maprintf("%s://%s%s%s:%hu%s%s%s", conn->given->scheme,
                    conn->bits.ipv6_ip?"[":"", conn->host.name,
                    conn->bits.ipv6_ip?"]":"", conn->remote_port,
                    data->state.slash_removed?"/":"", data->state.path,
                    type);
      if(!url)
        return CURLE_OUT_OF_MEMORY;

      if(data->change.url_alloc) {
        do {if((data->change.url)) {Curl_cfree((data->change.url)); (data->change.url) = ((void*)0);}} while(0);
        data->change.url_alloc = 0;
      }

      data->change.url = url;
      data->change.url_alloc = 1;
    }
  }
  else if(portptr) {


    char *rest;
    long port;

    port=strtol(portptr+1, &rest, 10);

    if((port < 0) || (port > 0xffff)) {

      Curl_failf(data, "Port number out of range");
      return CURLE_URL_MALFORMAT;
    }

    else if(rest != &portptr[1]) {
      *portptr = '\0';
      conn->remote_port = curlx_ultous(port);
    }
    else



      *portptr = '\0';
  }
  return CURLE_OK;
}





static CURLcode override_login(struct SessionHandle *data,
                               struct connectdata *conn,
                               char **userp, char **passwdp, char **optionsp)
{
  if(data->set.str[STRING_USERNAME]) {
    Curl_cfree(*userp);
    *userp = Curl_cstrdup(data->set.str[STRING_USERNAME]);
    if(!*userp)
      return CURLE_OUT_OF_MEMORY;
  }

  if(data->set.str[STRING_PASSWORD]) {
    Curl_cfree(*passwdp);
    *passwdp = Curl_cstrdup(data->set.str[STRING_PASSWORD]);
    if(!*passwdp)
      return CURLE_OUT_OF_MEMORY;
  }

  if(data->set.str[STRING_OPTIONS]) {
    Curl_cfree(*optionsp);
    *optionsp = Curl_cstrdup(data->set.str[STRING_OPTIONS]);
    if(!*optionsp)
      return CURLE_OUT_OF_MEMORY;
  }

  conn->bits.netrc = 0;
  if(data->set.use_netrc != CURL_NETRC_IGNORED) {
    int ret = Curl_parsenetrc(conn->host.name,
                              userp, passwdp,
                              data->set.str[STRING_NETRC_FILE]);
    if(ret > 0) {
      Curl_infof(data, "Couldn't find host %s in the "
            "." "netrc file; using defaults\n",
            conn->host.name);
    }
    else if(ret < 0 ) {
      return CURLE_OUT_OF_MEMORY;
    }
    else {



      conn->bits.netrc = 1;

      conn->bits.user_passwd = 1;
    }
  }

  return CURLE_OK;
}




static CURLcode set_login(struct connectdata *conn,
                          const char *user, const char *passwd,
                          const char *options)
{
  CURLcode result = CURLE_OK;


  if((conn->handler->flags & (1<<5)) && !conn->bits.user_passwd) {

    conn->user = Curl_cstrdup("anonymous");


    if(conn->user)
      conn->passwd = Curl_cstrdup("ftp@example.com");
    else
      conn->passwd = ((void*)0);


  }
  else {

    conn->user = Curl_cstrdup(user);


    if(conn->user)
      conn->passwd = Curl_cstrdup(passwd);
    else
      conn->passwd = ((void*)0);
  }

  if(!conn->user || !conn->passwd)
    result = CURLE_OUT_OF_MEMORY;


  if(!result && options[0]) {
    conn->options = Curl_cstrdup(options);

    if(!conn->options)
      result = CURLE_OUT_OF_MEMORY;
  }

  return result;
}




static CURLcode resolve_server(struct SessionHandle *data,
                               struct connectdata *conn,
                               _Bool *async)
{
  CURLcode result=CURLE_OK;
  long timeout_ms = Curl_timeleft(data, ((void*)0), 1);




  if(conn->bits.reuse)



    *async = 0;

  else {

    int rc;
    struct Curl_dns_entry *hostaddr;


    fix_hostname(data, conn, &conn->host);


    if(data->set.str[STRING_UNIX_SOCKET_PATH]) {



      const char *path = data->set.str[STRING_UNIX_SOCKET_PATH];

      hostaddr = Curl_ccalloc(1, sizeof(struct Curl_dns_entry));
      if(!hostaddr)
        result = CURLE_OUT_OF_MEMORY;
      else if((hostaddr->addr = Curl_unix2addr(path)) != ((void*)0))
        hostaddr->inuse++;
      else {

        if(strlen(path) >= sizeof(((struct sockaddr_un *)0)->sun_path)) {
          Curl_failf(data, "Unix socket path too long: '%s'", path);
          result = CURLE_COULDNT_RESOLVE_HOST;
        }
        else
          result = CURLE_OUT_OF_MEMORY;
        Curl_cfree(hostaddr);
        hostaddr = ((void*)0);
      }
    }
    else

    if(!conn->proxy.name || !*conn->proxy.name) {


      conn->port = conn->remote_port;


      rc = Curl_resolv_timeout(conn, conn->host.name, (int)conn->port,
                               &hostaddr, timeout_ms);
      if(rc == 1)
        *async = 1;

      else if(rc == -2)
        result = CURLE_OPERATION_TIMEDOUT;

      else if(!hostaddr) {
        Curl_failf(data, "Couldn't resolve host '%s'", conn->host.dispname);
        result = CURLE_COULDNT_RESOLVE_HOST;

      }
    }
    else {



      fix_hostname(data, conn, &conn->proxy);


      rc = Curl_resolv_timeout(conn, conn->proxy.name, (int)conn->port,
                               &hostaddr, timeout_ms);

      if(rc == 1)
        *async = 1;

      else if(rc == -2)
        result = CURLE_OPERATION_TIMEDOUT;

      else if(!hostaddr) {
        Curl_failf(data, "Couldn't resolve proxy '%s'", conn->proxy.dispname);
        result = CURLE_COULDNT_RESOLVE_PROXY;

      }
    }
    do { } while(0);
    conn->dns_entry = hostaddr;
  }

  return result;
}






static void reuse_conn(struct connectdata *old_conn,
                       struct connectdata *conn)
{
  if(old_conn->proxy.rawalloc)
    Curl_cfree(old_conn->proxy.rawalloc);



  Curl_free_ssl_config(&old_conn->ssl_config);

  conn->data = old_conn->data;



  conn->bits.user_passwd = old_conn->bits.user_passwd;
  if(conn->bits.user_passwd) {

    do {if((conn->user)) {Curl_cfree((conn->user)); (conn->user) = ((void*)0);}} while(0);
    do {if((conn->passwd)) {Curl_cfree((conn->passwd)); (conn->passwd) = ((void*)0);}} while(0);
    conn->user = old_conn->user;
    conn->passwd = old_conn->passwd;
    old_conn->user = ((void*)0);
    old_conn->passwd = ((void*)0);
  }

  conn->bits.proxy_user_passwd = old_conn->bits.proxy_user_passwd;
  if(conn->bits.proxy_user_passwd) {

    do {if((conn->proxyuser)) {Curl_cfree((conn->proxyuser)); (conn->proxyuser) = ((void*)0);}} while(0);
    do {if((conn->proxypasswd)) {Curl_cfree((conn->proxypasswd)); (conn->proxypasswd) = ((void*)0);}} while(0);
    conn->proxyuser = old_conn->proxyuser;
    conn->proxypasswd = old_conn->proxypasswd;
    old_conn->proxyuser = ((void*)0);
    old_conn->proxypasswd = ((void*)0);
  }



  do {if((conn->host.rawalloc)) {Curl_cfree((conn->host.rawalloc)); (conn->host.rawalloc) = ((void*)0);}} while(0);
  conn->host=old_conn->host;


  Curl_persistconninfo(conn);


  conn->bits.reuse = 1;

  do {if((old_conn->user)) {Curl_cfree((old_conn->user)); (old_conn->user) = ((void*)0);}} while(0);
  do {if((old_conn->passwd)) {Curl_cfree((old_conn->passwd)); (old_conn->passwd) = ((void*)0);}} while(0);
  do {if((old_conn->proxyuser)) {Curl_cfree((old_conn->proxyuser)); (old_conn->proxyuser) = ((void*)0);}} while(0);
  do {if((old_conn->proxypasswd)) {Curl_cfree((old_conn->proxypasswd)); (old_conn->proxypasswd) = ((void*)0);}} while(0);
  do {if((old_conn->localdev)) {Curl_cfree((old_conn->localdev)); (old_conn->localdev) = ((void*)0);}} while(0);

  Curl_llist_destroy(old_conn->send_pipe, ((void*)0));
  Curl_llist_destroy(old_conn->recv_pipe, ((void*)0));

  old_conn->send_pipe = ((void*)0);
  old_conn->recv_pipe = ((void*)0);

  do {if((old_conn->master_buffer)) {Curl_cfree((old_conn->master_buffer)); (old_conn->master_buffer) = ((void*)0);}} while(0);
}
# 5271 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
static CURLcode create_conn(struct SessionHandle *data,
                            struct connectdata **in_connect,
                            _Bool *async)
{
  CURLcode result = CURLE_OK;
  struct connectdata *conn;
  struct connectdata *conn_temp = ((void*)0);
  size_t urllen;
  char *user = ((void*)0);
  char *passwd = ((void*)0);
  char *options = ((void*)0);
  _Bool reuse;
  char *proxy = ((void*)0);
  _Bool prot_missing = 0;
  _Bool no_connections_available = 0;
  _Bool force_reuse = 0;
  size_t max_host_connections = Curl_multi_max_host_connections(data->multi);
  size_t max_total_connections = Curl_multi_max_total_connections(data->multi);

  *async = 0;





  if(!data->change.url) {
    result = CURLE_URL_MALFORMAT;
    goto out;
  }





  conn = allocate_conn(data);

  if(!conn) {
    result = CURLE_OUT_OF_MEMORY;
    goto out;
  }




  *in_connect = conn;
# 5326 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  urllen=strlen(data->change.url);
  if(urllen < 256)
    urllen=256;







  do {if((data->state.pathbuffer)) {Curl_cfree((data->state.pathbuffer)); (data->state.pathbuffer) = ((void*)0);}} while(0);
  data->state.path = ((void*)0);

  data->state.pathbuffer = Curl_cmalloc(urllen+2);
  if(((void*)0) == data->state.pathbuffer) {
    result = CURLE_OUT_OF_MEMORY;
    goto out;
  }
  data->state.path = data->state.pathbuffer;

  conn->host.rawalloc = Curl_cmalloc(urllen+2);
  if(((void*)0) == conn->host.rawalloc) {
    do {if((data->state.pathbuffer)) {Curl_cfree((data->state.pathbuffer)); (data->state.pathbuffer) = ((void*)0);}} while(0);
    data->state.path = ((void*)0);
    result = CURLE_OUT_OF_MEMORY;
    goto out;
  }

  conn->host.name = conn->host.rawalloc;
  conn->host.name[0] = 0;

  user = Curl_cstrdup("");
  passwd = Curl_cstrdup("");
  options = Curl_cstrdup("");
  if(!user || !passwd || !options) {
    result = CURLE_OUT_OF_MEMORY;
    goto out;
  }

  result = parseurlandfillconn(data, conn, &prot_missing, &user, &passwd,
                               &options);
  if(result)
    goto out;




  if(prot_missing) {



    char *reurl;

    reurl = curl_maprintf("%s://%s", conn->handler->scheme, data->change.url);

    if(!reurl) {
      result = CURLE_OUT_OF_MEMORY;
      goto out;
    }

    if(data->change.url_alloc) {
      do {if((data->change.url)) {Curl_cfree((data->change.url)); (data->change.url) = ((void*)0);}} while(0);
      data->change.url_alloc = 0;
    }

    data->change.url = reurl;
    data->change.url_alloc = 1;
  }





  if((conn->given->flags&(1<<6))) {
    char *path_q_sep = (__extension__ (__builtin_constant_p ('?') && !__builtin_constant_p (conn->data->state.path) && ('?') == '\0' ? (char *) __rawmemchr (conn->data->state.path, '?') : __builtin_strchr (conn->data->state.path, '?')));
    if(path_q_sep) {







      path_q_sep[0] = 0;
    }
  }

  if(data->set.str[STRING_BEARER]) {
    conn->xoauth2_bearer = Curl_cstrdup(data->set.str[STRING_BEARER]);
    if(!conn->xoauth2_bearer) {
      result = CURLE_OUT_OF_MEMORY;
      goto out;
    }
  }





  if(conn->bits.proxy_user_passwd) {
    result = parse_proxy_auth(data, conn);
    if(result)
      goto out;
  }




  if(data->set.str[STRING_PROXY]) {
    proxy = Curl_cstrdup(data->set.str[STRING_PROXY]);

    if(((void*)0) == proxy) {
      Curl_failf(data, "memory shortage");
      result = CURLE_OUT_OF_MEMORY;
      goto out;
    }
  }

  if(data->set.str[STRING_NOPROXY] &&
     check_noproxy(conn->host.name, data->set.str[STRING_NOPROXY])) {
    if(proxy) {
      Curl_cfree(proxy);
      proxy = ((void*)0);
    }
  }
  else if(!proxy)
    proxy = detect_proxy(conn);


  if(proxy && data->set.str[STRING_UNIX_SOCKET_PATH]) {
    Curl_cfree(proxy);
    proxy = ((void*)0);
  }


  if(proxy && (!*proxy || (conn->handler->flags & (1<<4)))) {
    Curl_cfree(proxy);

    proxy = ((void*)0);
  }






  if(proxy) {
    result = parse_proxy(data, conn, proxy);

    do {if((proxy)) {Curl_cfree((proxy)); (proxy) = ((void*)0);}} while(0);

    if(result)
      goto out;

    if((conn->proxytype == CURLPROXY_HTTP) ||
       (conn->proxytype == CURLPROXY_HTTP_1_0)) {







      if(!(conn->handler->protocol & ((1<<0)|(1<<1))) &&
         !conn->bits.tunnel_proxy)
        conn->handler = &Curl_handler_http;

      conn->bits.httpproxy = 1;

    }
    else
      conn->bits.httpproxy = 0;
    conn->bits.proxy = 1;
  }
  else {

    conn->bits.proxy = 0;
    conn->bits.httpproxy = 0;
    conn->bits.proxy_user_passwd = 0;
    conn->bits.tunnel_proxy = 0;
  }







  if((conn->given->flags&(1<<0)) && conn->bits.httpproxy)
    conn->bits.tunnel_proxy = 1;




  result = parse_remote_port(data, conn);
  if(result)
    goto out;



  result = override_login(data, conn, &user, &passwd, &options);
  if(result)
    goto out;
  result = set_login(conn, user, passwd, options);
  if(result)
    goto out;





  result = setup_connection_internals(conn);
  if(result)
    goto out;

  conn->recv[0] = Curl_recv_plain;
  conn->send[0] = Curl_send_plain;
  conn->recv[1] = Curl_recv_plain;
  conn->send[1] = Curl_send_plain;





  if(conn->handler->flags & (1<<4)) {
    _Bool done;


    do { } while(0);
    result = conn->handler->connect_it(conn, &done);


    if(!result) {
      conn->data = data;
      conn->bits.tcpconnect[0] = 1;

      ConnectionStore(data, conn);




      result = setup_range(data);
      if(result) {
        do { } while(0);

        (void)conn->handler->done(conn, result, 0);
        goto out;
      }

      Curl_setup_transfer(conn, -1, -1, 0, ((void*)0),
                          -1, ((void*)0));
    }


    do_init(conn);

    goto out;
  }
# 5595 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  data->set.ssl.CApath = data->set.str[STRING_SSL_CAPATH];
  data->set.ssl.CAfile = data->set.str[STRING_SSL_CAFILE];
  data->set.ssl.CRLfile = data->set.str[STRING_SSL_CRLFILE];
  data->set.ssl.issuercert = data->set.str[STRING_SSL_ISSUERCERT];
  data->set.ssl.random_file = data->set.str[STRING_SSL_RANDOM_FILE];
  data->set.ssl.egdsocket = data->set.str[STRING_SSL_EGDSOCKET];
  data->set.ssl.cipher_list = data->set.str[STRING_SSL_CIPHER_LIST];

  data->set.ssl.username = data->set.str[STRING_TLSAUTH_USERNAME];
  data->set.ssl.password = data->set.str[STRING_TLSAUTH_PASSWORD];


  if(!Curl_clone_ssl_config(&data->set.ssl, &conn->ssl_config)) {
    result = CURLE_OUT_OF_MEMORY;
    goto out;
  }

  prune_dead_connections(data);
# 5624 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  if(data->set.reuse_fresh && !data->state.this_is_a_follow)
    reuse = 0;
  else
    reuse = ConnectionExists(data, conn, &conn_temp, &force_reuse);



  if(reuse && !force_reuse && IsPipeliningPossible(data, conn_temp)) {
    size_t pipelen = conn_temp->send_pipe->size + conn_temp->recv_pipe->size;
    if(pipelen > 0) {
      Curl_infof(data, "Found connection %ld, with requests in the pipe (%zu)\n",
            conn_temp->connection_id, pipelen);

      if(conn_temp->bundle->num_connections < max_host_connections &&
         data->state.conn_cache->num_connections < max_total_connections) {

        reuse = 0;

        Curl_infof(data, "We can reuse, but we want a new connection anyway\n");
      }
    }
  }

  if(reuse) {






    conn_temp->inuse = 1;

    reuse_conn(conn, conn_temp);
    Curl_cfree(conn);
    conn = conn_temp;
    *in_connect = conn;


    fix_hostname(data, conn, &conn->host);

    Curl_infof(data, "Re-using existing connection! (#%ld) with host %s\n",
          conn->connection_id,
          conn->proxy.name?conn->proxy.dispname:conn->host.dispname);
  }
  else {



    struct connectbundle *bundle;

    bundle = Curl_conncache_find_bundle(data->state.conn_cache,
                                        conn->host.name);
    if(max_host_connections > 0 && bundle &&
       (bundle->num_connections >= max_host_connections)) {
      struct connectdata *conn_candidate;


      conn_candidate = find_oldest_idle_connection_in_bundle(data, bundle);

      if(conn_candidate) {

        conn_candidate->data = data;
        (void)Curl_disconnect(conn_candidate, 0);
      }
      else
        no_connections_available = 1;
    }

    if(max_total_connections > 0 &&
       (data->state.conn_cache->num_connections >= max_total_connections)) {
      struct connectdata *conn_candidate;


      conn_candidate = find_oldest_idle_connection(data);

      if(conn_candidate) {

        conn_candidate->data = data;
        (void)Curl_disconnect(conn_candidate, 0);
      }
      else
        no_connections_available = 1;
    }


    if(no_connections_available) {
      Curl_infof(data, "No connections available.\n");

      conn_free(conn);
      *in_connect = ((void*)0);

      result = CURLE_NO_CONNECTION_AVAILABLE;
      goto out;
    }
    else {




      ConnectionStore(data, conn);
    }
# 5742 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  }


  conn->inuse = 1;


  do_init(conn);




  result = setup_range(data);
  if(result)
    goto out;







  conn->fread_func = data->set.fread_func;
  conn->fread_in = data->set.in;
  conn->seek_func = data->set.seek_func;
  conn->seek_client = data->set.seek_client;




  result = resolve_server(data, conn, async);

  out:

  do {if((options)) {Curl_cfree((options)); (options) = ((void*)0);}} while(0);
  do {if((passwd)) {Curl_cfree((passwd)); (passwd) = ((void*)0);}} while(0);
  do {if((user)) {Curl_cfree((user)); (user) = ((void*)0);}} while(0);
  do {if((proxy)) {Curl_cfree((proxy)); (proxy) = ((void*)0);}} while(0);
  return result;
}
# 5790 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
CURLcode Curl_setup_conn(struct connectdata *conn,
                         _Bool *protocol_done)
{
  CURLcode result = CURLE_OK;
  struct SessionHandle *data = conn->data;

  Curl_pgrsTime(data, TIMER_NAMELOOKUP);

  if(conn->handler->flags & (1<<4)) {

    *protocol_done = 1;
    return result;
  }
  *protocol_done = 0;





  conn->bits.proxy_connect_closed = 0;






  if(data->set.str[STRING_USERAGENT]) {
    do {if((conn->allocptr.uagent)) {Curl_cfree((conn->allocptr.uagent)); (conn->allocptr.uagent) = ((void*)0);}} while(0);
    conn->allocptr.uagent =
      curl_maprintf("User-Agent: %s\r\n", data->set.str[STRING_USERAGENT]);
    if(!conn->allocptr.uagent)
      return CURLE_OUT_OF_MEMORY;
  }

  data->req.headerbytecount = 0;


  data->state.crlf_conversions = 0;




  conn->now = curlx_tvnow();

  if(-1 == conn->sock[0]) {
    conn->bits.tcpconnect[0] = 0;
    result = Curl_connecthost(conn, conn->dns_entry);
    if(result)
      return result;
  }
  else {
    Curl_pgrsTime(data, TIMER_CONNECT);
    Curl_pgrsTime(data, TIMER_APPCONNECT);
    conn->bits.tcpconnect[0] = 1;
    *protocol_done = 1;
    Curl_updateconninfo(conn, conn->sock[0]);
    Curl_verboseconnect(conn);
  }

  conn->now = curlx_tvnow();
# 5865 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  return result;
}

CURLcode Curl_connect(struct SessionHandle *data,
                      struct connectdata **in_connect,
                      _Bool *asyncp,
                      _Bool *protocol_done)
{
  CURLcode result;

  *asyncp = 0;


  result = create_conn(data, in_connect, asyncp);

  if(!result) {

    if((*in_connect)->send_pipe->size || (*in_connect)->recv_pipe->size)

      *protocol_done = 1;
    else if(!*asyncp) {



      result = Curl_setup_conn(*in_connect, protocol_done);
    }
  }

  if(result == CURLE_NO_CONNECTION_AVAILABLE) {
    *in_connect = ((void*)0);
    return result;
  }

  if(result && *in_connect) {


    Curl_disconnect(*in_connect, 0);
    *in_connect = ((void*)0);
  }

  return result;
}

CURLcode Curl_done(struct connectdata **connp,
                   CURLcode status,

                   _Bool premature)
{
  CURLcode result;
  struct connectdata *conn;
  struct SessionHandle *data;

  do { } while(0);

  conn = *connp;
  data = conn->data;

  if(conn->bits.done)

    return CURLE_OK;

  Curl_getoff_all_pipelines(data, conn);

  if((conn->send_pipe->size + conn->recv_pipe->size != 0 &&
      !data->set.reuse_forbid &&
      !conn->bits.close))


    return CURLE_OK;

  conn->bits.done = 1;


  if(data->req.newurl) {
    Curl_cfree(data->req.newurl);
    data->req.newurl = ((void*)0);
  }
  if(data->req.location) {
    Curl_cfree(data->req.location);
    data->req.location = ((void*)0);
  }

  do { } while(0);

  if(conn->dns_entry) {
    Curl_resolv_unlock(data, conn->dns_entry);
    conn->dns_entry = ((void*)0);
  }

  switch(status) {
  case CURLE_ABORTED_BY_CALLBACK:
  case CURLE_READ_ERROR:
  case CURLE_WRITE_ERROR:




    premature = 1;
  default:
    break;
  }


  if(conn->handler->done)
    result = conn->handler->done(conn, status, premature);
  else
    result = status;

  if(!result && Curl_pgrsDone(conn))
    result = CURLE_ABORTED_BY_CALLBACK;



  if(data->state.tempwrite) {
    Curl_cfree(data->state.tempwrite);
    data->state.tempwrite = ((void*)0);
  }
# 5998 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
  if((data->set.reuse_forbid




     ) || conn->bits.close || premature) {
    CURLcode res2 = Curl_disconnect(conn, premature);



    if(!result && res2)
      result = res2;
  }
  else {

    if(ConnectionDone(data, conn)) {

      data->state.lastconnect = conn;

      Curl_infof(data, "Connection #%ld to host %s left intact\n",
            conn->connection_id,
            conn->bits.httpproxy?conn->proxy.dispname:conn->host.dispname);
    }
    else
      data->state.lastconnect = ((void*)0);
  }

  *connp = ((void*)0);



  Curl_free_request_state(data);

  return result;
}
# 6042 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
static CURLcode do_init(struct connectdata *conn)
{
  struct SessionHandle *data = conn->data;
  struct SingleRequest *k = &data->req;

  conn->bits.done = 0;
  conn->bits.do_more = 0;
  data->state.expect100header = 0;

  if(data->set.opt_no_body)

    data->set.httpreq = HTTPREQ_HEAD;
  else if(HTTPREQ_HEAD == data->set.httpreq)





    data->set.httpreq = HTTPREQ_GET;

  k->start = curlx_tvnow();
  k->now = k->start;
  k->header = 1;

  k->bytecount = 0;

  k->buf = data->state.buffer;
  k->uploadbuf = data->state.uploadbuffer;
  k->hbufp = data->state.headerbuff;
  k->ignorebody=0;

  Curl_speedinit(data);

  Curl_pgrsSetUploadCounter(data, 0);
  Curl_pgrsSetDownloadCounter(data, 0);

  return CURLE_OK;
}







static void do_complete(struct connectdata *conn)
{
  conn->data->req.chunk=0;
  conn->data->req.maxfd = (conn->sockfd>conn->writesockfd?
                           conn->sockfd:conn->writesockfd)+1;
  Curl_pgrsTime(conn->data, TIMER_PRETRANSFER);
}

CURLcode Curl_do(struct connectdata **connp, _Bool *done)
{
  CURLcode result=CURLE_OK;
  struct connectdata *conn = *connp;
  struct SessionHandle *data = conn->data;

  if(conn->handler->do_it) {

    result = conn->handler->do_it(conn, done);


    if((CURLE_SEND_ERROR == result) && conn->bits.reuse) {





      if(!data->multi) {
        result = Curl_reconnect_request(connp);

        if(!result) {

          conn = *connp;

          result = conn->handler->do_it(conn, done);
        }
      }
      else
        return result;
    }

    if(!result && *done)

      do_complete(conn);
  }
  return result;
}
# 6144 "/home/ubuntu/Workspace/prophet/crawler/__tmp/src2/lib/url.c"
CURLcode Curl_do_more(struct connectdata *conn, int *complete)
{
  CURLcode result=CURLE_OK;

  *complete = 0;

  if(conn->handler->do_more)
    result = conn->handler->do_more(conn, complete);

  if(!result && (*complete == 1))

    do_complete(conn);

  return result;
}
