# 1 "ext/sqlite3/libsqlite/sqlite3.c"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 312 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "ext/sqlite3/libsqlite/sqlite3.c" 2
# 582 "ext/sqlite3/libsqlite/sqlite3.c"
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stdarg.h" 1 3
# 30 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stdarg.h" 3
typedef __builtin_va_list va_list;
# 50 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stdarg.h" 3
typedef __builtin_va_list __gnuc_va_list;
# 583 "ext/sqlite3/libsqlite/sqlite3.c" 2
# 691 "ext/sqlite3/libsqlite/sqlite3.c"
           const char sqlite3_version[] = "3.7.6.3";
           const char *sqlite3_libversion(void);
           const char *sqlite3_sourceid(void);
           int sqlite3_libversion_number(void);
# 719 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_compileoption_used(const char *zOptName);
           const char *sqlite3_compileoption_get(int N);
# 759 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_threadsafe(void);
# 774 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct sqlite3 sqlite3;
# 799 "ext/sqlite3/libsqlite/sqlite3.c"
  typedef long long int sqlite_int64;
  typedef unsigned long long int sqlite_uint64;

typedef sqlite_int64 sqlite3_int64;
typedef sqlite_uint64 sqlite3_uint64;
# 837 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_close(sqlite3 *);






typedef int (*sqlite3_callback)(void*,int,char**, char**);
# 907 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_exec(
  sqlite3*,
  const char *sql,
  int (*callback)(void*,int,char**,char**),
  void *,
  char **errmsg
);
# 1122 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct sqlite3_file sqlite3_file;
struct sqlite3_file {
  const struct sqlite3_io_methods *pMethods;
};
# 1216 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct sqlite3_io_methods sqlite3_io_methods;
struct sqlite3_io_methods {
  int iVersion;
  int (*xClose)(sqlite3_file*);
  int (*xRead)(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
  int (*xWrite)(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst);
  int (*xTruncate)(sqlite3_file*, sqlite3_int64 size);
  int (*xSync)(sqlite3_file*, int flags);
  int (*xFileSize)(sqlite3_file*, sqlite3_int64 *pSize);
  int (*xLock)(sqlite3_file*, int);
  int (*xUnlock)(sqlite3_file*, int);
  int (*xCheckReservedLock)(sqlite3_file*, int *pResOut);
  int (*xFileControl)(sqlite3_file*, int op, void *pArg);
  int (*xSectorSize)(sqlite3_file*);
  int (*xDeviceCharacteristics)(sqlite3_file*);

  int (*xShmMap)(sqlite3_file*, int iPg, int pgsz, int, void volatile**);
  int (*xShmLock)(sqlite3_file*, int offset, int n, int flags);
  void (*xShmBarrier)(sqlite3_file*);
  int (*xShmUnmap)(sqlite3_file*, int deleteFlag);


};
# 1305 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct sqlite3_mutex sqlite3_mutex;
# 1461 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct sqlite3_vfs sqlite3_vfs;
typedef void (*sqlite3_syscall_ptr)(void);
struct sqlite3_vfs {
  int iVersion;
  int szOsFile;
  int mxPathname;
  sqlite3_vfs *pNext;
  const char *zName;
  void *pAppData;
  int (*xOpen)(sqlite3_vfs*, const char *zName, sqlite3_file*,
               int flags, int *pOutFlags);
  int (*xDelete)(sqlite3_vfs*, const char *zName, int syncDir);
  int (*xAccess)(sqlite3_vfs*, const char *zName, int flags, int *pResOut);
  int (*xFullPathname)(sqlite3_vfs*, const char *zName, int nOut, char *zOut);
  void *(*xDlOpen)(sqlite3_vfs*, const char *zFilename);
  void (*xDlError)(sqlite3_vfs*, int nByte, char *zErrMsg);
  void (*(*xDlSym)(sqlite3_vfs*,void*, const char *zSymbol))(void);
  void (*xDlClose)(sqlite3_vfs*, void*);
  int (*xRandomness)(sqlite3_vfs*, int nByte, char *zOut);
  int (*xSleep)(sqlite3_vfs*, int microseconds);
  int (*xCurrentTime)(sqlite3_vfs*, double*);
  int (*xGetLastError)(sqlite3_vfs*, int, char *);




  int (*xCurrentTimeInt64)(sqlite3_vfs*, sqlite3_int64*);




  int (*xSetSystemCall)(sqlite3_vfs*, const char *zName, sqlite3_syscall_ptr);
  sqlite3_syscall_ptr (*xGetSystemCall)(sqlite3_vfs*, const char *zName);
  const char *(*xNextSystemCall)(sqlite3_vfs*, const char *zName);





};
# 1639 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_initialize(void);
           int sqlite3_shutdown(void);
           int sqlite3_os_init(void);
           int sqlite3_os_end(void);
# 1673 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_config(int, ...);
# 1691 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_db_config(sqlite3*, int op, ...);
# 1762 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct sqlite3_mem_methods sqlite3_mem_methods;
struct sqlite3_mem_methods {
  void *(*xMalloc)(int);
  void (*xFree)(void*);
  void *(*xRealloc)(void*,int);
  int (*xSize)(void*);
  int (*xRoundup)(int);
  int (*xInit)(void*);
  void (*xShutdown)(void*);
  void *pAppData;
};
# 2068 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_extended_result_codes(sqlite3*, int onoff);
# 2113 "ext/sqlite3/libsqlite/sqlite3.c"
           sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*);
# 2167 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_changes(sqlite3*);
# 2193 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_total_changes(sqlite3*);
# 2232 "ext/sqlite3/libsqlite/sqlite3.c"
           void sqlite3_interrupt(sqlite3*);
# 2267 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_complete(const char *sql);
           int sqlite3_complete16(const void *sql);
# 2334 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_busy_handler(sqlite3*, int(*)(void*,int), void*);
# 2354 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_busy_timeout(sqlite3*, int ms);
# 2428 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_get_table(
  sqlite3 *db,
  const char *zSql,
  char ***pazResult,
  int *pnRow,
  int *pnColumn,
  char **pzErrmsg
);
           void sqlite3_free_table(char **result);
# 2532 "ext/sqlite3/libsqlite/sqlite3.c"
           char *sqlite3_mprintf(const char*,...);
           char *sqlite3_vmprintf(const char*, va_list);
           char *sqlite3_snprintf(int,char*,const char*, ...);
           char *sqlite3_vsnprintf(int,char*,const char*, va_list);
# 2607 "ext/sqlite3/libsqlite/sqlite3.c"
           void *sqlite3_malloc(int);
           void *sqlite3_realloc(void*, int);
           void sqlite3_free(void*);
# 2634 "ext/sqlite3/libsqlite/sqlite3.c"
           sqlite3_int64 sqlite3_memory_used(void);
           sqlite3_int64 sqlite3_memory_highwater(int resetFlag);
# 2655 "ext/sqlite3/libsqlite/sqlite3.c"
           void sqlite3_randomness(int N, void *P);
# 2737 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_set_authorizer(
  sqlite3*,
  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),
  void *pUserData
);
# 2834 "ext/sqlite3/libsqlite/sqlite3.c"
           void *sqlite3_trace(sqlite3*, void(*xTrace)(void*,const char*), void*);
                               void *sqlite3_profile(sqlite3*,
   void(*xProfile)(void*,const char*,sqlite3_uint64), void*);
# 2868 "ext/sqlite3/libsqlite/sqlite3.c"
           void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*);
# 2959 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_open(
  const char *filename,
  sqlite3 **ppDb
);
           int sqlite3_open16(
  const void *filename,
  sqlite3 **ppDb
);
           int sqlite3_open_v2(
  const char *filename,
  sqlite3 **ppDb,
  int flags,
  const char *zVfs
);
# 3007 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_errcode(sqlite3 *db);
           int sqlite3_extended_errcode(sqlite3 *db);
           const char *sqlite3_errmsg(sqlite3*);
           const void *sqlite3_errmsg16(sqlite3*);
# 3036 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct sqlite3_stmt sqlite3_stmt;
# 3077 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_limit(sqlite3*, int id, int newVal);
# 3221 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_prepare(
  sqlite3 *db,
  const char *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const char **pzTail
);
           int sqlite3_prepare_v2(
  sqlite3 *db,
  const char *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const char **pzTail
);
           int sqlite3_prepare16(
  sqlite3 *db,
  const void *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const void **pzTail
);
           int sqlite3_prepare16_v2(
  sqlite3 *db,
  const void *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const void **pzTail
);
# 3257 "ext/sqlite3/libsqlite/sqlite3.c"
           const char *sqlite3_sql(sqlite3_stmt *pStmt);
# 3288 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_stmt_readonly(sqlite3_stmt *pStmt);
# 3327 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct Mem sqlite3_value;
# 3341 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct sqlite3_context sqlite3_context;
# 3425 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
           int sqlite3_bind_double(sqlite3_stmt*, int, double);
           int sqlite3_bind_int(sqlite3_stmt*, int, int);
           int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);
           int sqlite3_bind_null(sqlite3_stmt*, int);
           int sqlite3_bind_text(sqlite3_stmt*, int, const char*, int n, void(*)(void*));
           int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));
           int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
           int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
# 3453 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_bind_parameter_count(sqlite3_stmt*);
# 3480 "ext/sqlite3/libsqlite/sqlite3.c"
           const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);
# 3496 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);
# 3505 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_clear_bindings(sqlite3_stmt*);
# 3516 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_column_count(sqlite3_stmt *pStmt);
# 3544 "ext/sqlite3/libsqlite/sqlite3.c"
           const char *sqlite3_column_name(sqlite3_stmt*, int N);
           const void *sqlite3_column_name16(sqlite3_stmt*, int N);
# 3592 "ext/sqlite3/libsqlite/sqlite3.c"
           const char *sqlite3_column_database_name(sqlite3_stmt*,int);
           const void *sqlite3_column_database_name16(sqlite3_stmt*,int);
           const char *sqlite3_column_table_name(sqlite3_stmt*,int);
           const void *sqlite3_column_table_name16(sqlite3_stmt*,int);
           const char *sqlite3_column_origin_name(sqlite3_stmt*,int);
           const void *sqlite3_column_origin_name16(sqlite3_stmt*,int);
# 3628 "ext/sqlite3/libsqlite/sqlite3.c"
           const char *sqlite3_column_decltype(sqlite3_stmt*,int);
           const void *sqlite3_column_decltype16(sqlite3_stmt*,int);
# 3708 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_step(sqlite3_stmt*);
# 3722 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_data_count(sqlite3_stmt *pStmt);
# 3918 "ext/sqlite3/libsqlite/sqlite3.c"
           const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);
           int sqlite3_column_bytes(sqlite3_stmt*, int iCol);
           int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
           double sqlite3_column_double(sqlite3_stmt*, int iCol);
           int sqlite3_column_int(sqlite3_stmt*, int iCol);
           sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);
           const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);
           const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);
           int sqlite3_column_type(sqlite3_stmt*, int iCol);
           sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);
# 3954 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_finalize(sqlite3_stmt *pStmt);
# 3980 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_reset(sqlite3_stmt *pStmt);
# 4070 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_create_function(
  sqlite3 *db,
  const char *zFunctionName,
  int nArg,
  int eTextRep,
  void *pApp,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*)
);
           int sqlite3_create_function16(
  sqlite3 *db,
  const void *zFunctionName,
  int nArg,
  int eTextRep,
  void *pApp,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*)
);
           int sqlite3_create_function_v2(
  sqlite3 *db,
  const char *zFunctionName,
  int nArg,
  int eTextRep,
  void *pApp,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*),
  void(*xDestroy)(void*)
);
# 4126 "ext/sqlite3/libsqlite/sqlite3.c"
                             int sqlite3_aggregate_count(sqlite3_context*);
                             int sqlite3_expired(sqlite3_stmt*);
                             int sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*);
                             int sqlite3_global_recover(void);
                             void sqlite3_thread_cleanup(void);
                             int sqlite3_memory_alarm(void(*)(void*,sqlite3_int64,int),void*,sqlite3_int64);
# 4179 "ext/sqlite3/libsqlite/sqlite3.c"
           const void *sqlite3_value_blob(sqlite3_value*);
           int sqlite3_value_bytes(sqlite3_value*);
           int sqlite3_value_bytes16(sqlite3_value*);
           double sqlite3_value_double(sqlite3_value*);
           int sqlite3_value_int(sqlite3_value*);
           sqlite3_int64 sqlite3_value_int64(sqlite3_value*);
           const unsigned char *sqlite3_value_text(sqlite3_value*);
           const void *sqlite3_value_text16(sqlite3_value*);
           const void *sqlite3_value_text16le(sqlite3_value*);
           const void *sqlite3_value_text16be(sqlite3_value*);
           int sqlite3_value_type(sqlite3_value*);
           int sqlite3_value_numeric_type(sqlite3_value*);
# 4231 "ext/sqlite3/libsqlite/sqlite3.c"
           void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);
# 4245 "ext/sqlite3/libsqlite/sqlite3.c"
           void *sqlite3_user_data(sqlite3_context*);
# 4256 "ext/sqlite3/libsqlite/sqlite3.c"
           sqlite3 *sqlite3_context_db_handle(sqlite3_context*);
# 4300 "ext/sqlite3/libsqlite/sqlite3.c"
           void *sqlite3_get_auxdata(sqlite3_context*, int N);
           void sqlite3_set_auxdata(sqlite3_context*, int N, void*, void (*)(void*));
# 4318 "ext/sqlite3/libsqlite/sqlite3.c"
typedef void (*sqlite3_destructor_type)(void*);
# 4427 "ext/sqlite3/libsqlite/sqlite3.c"
           void sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));
           void sqlite3_result_double(sqlite3_context*, double);
           void sqlite3_result_error(sqlite3_context*, const char*, int);
           void sqlite3_result_error16(sqlite3_context*, const void*, int);
           void sqlite3_result_error_toobig(sqlite3_context*);
           void sqlite3_result_error_nomem(sqlite3_context*);
           void sqlite3_result_error_code(sqlite3_context*, int);
           void sqlite3_result_int(sqlite3_context*, int);
           void sqlite3_result_int64(sqlite3_context*, sqlite3_int64);
           void sqlite3_result_null(sqlite3_context*);
           void sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));
           void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*));
           void sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*));
           void sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*));
           void sqlite3_result_value(sqlite3_context*, sqlite3_value*);
           void sqlite3_result_zeroblob(sqlite3_context*, int n);
# 4523 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_create_collation(
  sqlite3*,
  const char *zName,
  int eTextRep,
  void *pArg,
  int(*xCompare)(void*,int,const void*,int,const void*)
);
           int sqlite3_create_collation_v2(
  sqlite3*,
  const char *zName,
  int eTextRep,
  void *pArg,
  int(*xCompare)(void*,int,const void*,int,const void*),
  void(*xDestroy)(void*)
);
           int sqlite3_create_collation16(
  sqlite3*,
  const void *zName,
  int eTextRep,
  void *pArg,
  int(*xCompare)(void*,int,const void*,int,const void*)
);
# 4572 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_collation_needed(
  sqlite3*,
  void*,
  void(*)(void*,sqlite3*,int eTextRep,const char*)
);
           int sqlite3_collation_needed16(
  sqlite3*,
  void*,
  void(*)(void*,sqlite3*,int eTextRep,const void*)
);
# 4645 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_sleep(int);
# 4676 "ext/sqlite3/libsqlite/sqlite3.c"
           char *sqlite3_temp_directory;
# 4699 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_get_autocommit(sqlite3*);
# 4711 "ext/sqlite3/libsqlite/sqlite3.c"
           sqlite3 *sqlite3_db_handle(sqlite3_stmt*);
# 4726 "ext/sqlite3/libsqlite/sqlite3.c"
           sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt);
# 4772 "ext/sqlite3/libsqlite/sqlite3.c"
           void *sqlite3_commit_hook(sqlite3*, int(*)(void*), void*);
           void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);
# 4821 "ext/sqlite3/libsqlite/sqlite3.c"
           void *sqlite3_update_hook(
  sqlite3*,
  void(*)(void *,int ,char const *,char const *,sqlite3_int64),
  void*
);
# 4854 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_enable_shared_cache(int);
# 4868 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_release_memory(int);
# 4919 "ext/sqlite3/libsqlite/sqlite3.c"
           sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 N);
# 4930 "ext/sqlite3/libsqlite/sqlite3.c"
                             void sqlite3_soft_heap_limit(int N);
# 4995 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_table_column_metadata(
  sqlite3 *db,
  const char *zDbName,
  const char *zTableName,
  const char *zColumnName,
  char const **pzDataType,
  char const **pzCollSeq,
  int *pNotNull,
  int *pPrimaryKey,
  int *pAutoinc
);
# 5032 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_load_extension(
  sqlite3 *db,
  const char *zFile,
  const char *zProc,
  char **pzErrMsg
);
# 5052 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_enable_load_extension(sqlite3 *db, int onoff);
# 5089 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_auto_extension(void (*xEntryPoint)(void));







           void sqlite3_reset_auto_extension(void);
# 5111 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct sqlite3_vtab sqlite3_vtab;
typedef struct sqlite3_index_info sqlite3_index_info;
typedef struct sqlite3_vtab_cursor sqlite3_vtab_cursor;
typedef struct sqlite3_module sqlite3_module;
# 5132 "ext/sqlite3/libsqlite/sqlite3.c"
struct sqlite3_module {
  int iVersion;
  int (*xCreate)(sqlite3*, void *pAux,
               int argc, const char *const*argv,
               sqlite3_vtab **ppVTab, char**);
  int (*xConnect)(sqlite3*, void *pAux,
               int argc, const char *const*argv,
               sqlite3_vtab **ppVTab, char**);
  int (*xBestIndex)(sqlite3_vtab *pVTab, sqlite3_index_info*);
  int (*xDisconnect)(sqlite3_vtab *pVTab);
  int (*xDestroy)(sqlite3_vtab *pVTab);
  int (*xOpen)(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor);
  int (*xClose)(sqlite3_vtab_cursor*);
  int (*xFilter)(sqlite3_vtab_cursor*, int idxNum, const char *idxStr,
                int argc, sqlite3_value **argv);
  int (*xNext)(sqlite3_vtab_cursor*);
  int (*xEof)(sqlite3_vtab_cursor*);
  int (*xColumn)(sqlite3_vtab_cursor*, sqlite3_context*, int);
  int (*xRowid)(sqlite3_vtab_cursor*, sqlite3_int64 *pRowid);
  int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *);
  int (*xBegin)(sqlite3_vtab *pVTab);
  int (*xSync)(sqlite3_vtab *pVTab);
  int (*xCommit)(sqlite3_vtab *pVTab);
  int (*xRollback)(sqlite3_vtab *pVTab);
  int (*xFindFunction)(sqlite3_vtab *pVtab, int nArg, const char *zName,
                       void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),
                       void **ppArg);
  int (*xRename)(sqlite3_vtab *pVtab, const char *zNew);
};
# 5215 "ext/sqlite3/libsqlite/sqlite3.c"
struct sqlite3_index_info {

  int nConstraint;
  struct sqlite3_index_constraint {
     int iColumn;
     unsigned char op;
     unsigned char usable;
     int iTermOffset;
  } *aConstraint;
  int nOrderBy;
  struct sqlite3_index_orderby {
     int iColumn;
     unsigned char desc;
  } *aOrderBy;

  struct sqlite3_index_constraint_usage {
    int argvIndex;
    unsigned char omit;
  } *aConstraintUsage;
  int idxNum;
  char *idxStr;
  int needToFreeIdxStr;
  int orderByConsumed;
  double estimatedCost;
};
# 5281 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_create_module(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *p,
  void *pClientData
);
           int sqlite3_create_module_v2(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *p,
  void *pClientData,
  void(*xDestroy)(void*)
);
# 5313 "ext/sqlite3/libsqlite/sqlite3.c"
struct sqlite3_vtab {
  const sqlite3_module *pModule;
  int nRef;
  char *zErrMsg;

};
# 5337 "ext/sqlite3/libsqlite/sqlite3.c"
struct sqlite3_vtab_cursor {
  sqlite3_vtab *pVtab;

};
# 5350 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_declare_vtab(sqlite3*, const char *zSQL);
# 5368 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg);
# 5392 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct sqlite3_blob sqlite3_blob;
# 5450 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_blob_open(
  sqlite3*,
  const char *zDb,
  const char *zTable,
  const char *zColumn,
  sqlite3_int64 iRow,
  int flags,
  sqlite3_blob **ppBlob
);
# 5482 "ext/sqlite3/libsqlite/sqlite3.c"
                               int sqlite3_blob_reopen(sqlite3_blob *, sqlite3_int64);
# 5506 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_blob_close(sqlite3_blob *);
# 5521 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_blob_bytes(sqlite3_blob *);
# 5549 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset);
# 5587 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset);
# 5618 "ext/sqlite3/libsqlite/sqlite3.c"
           sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName);
           int sqlite3_vfs_register(sqlite3_vfs*, int makeDflt);
           int sqlite3_vfs_unregister(sqlite3_vfs*);
# 5736 "ext/sqlite3/libsqlite/sqlite3.c"
           sqlite3_mutex *sqlite3_mutex_alloc(int);
           void sqlite3_mutex_free(sqlite3_mutex*);
           void sqlite3_mutex_enter(sqlite3_mutex*);
           int sqlite3_mutex_try(sqlite3_mutex*);
           void sqlite3_mutex_leave(sqlite3_mutex*);
# 5807 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct sqlite3_mutex_methods sqlite3_mutex_methods;
struct sqlite3_mutex_methods {
  int (*xMutexInit)(void);
  int (*xMutexEnd)(void);
  sqlite3_mutex *(*xMutexAlloc)(int);
  void (*xMutexFree)(sqlite3_mutex *);
  void (*xMutexEnter)(sqlite3_mutex *);
  int (*xMutexTry)(sqlite3_mutex *);
  void (*xMutexLeave)(sqlite3_mutex *);
  int (*xMutexHeld)(sqlite3_mutex *);
  int (*xMutexNotheld)(sqlite3_mutex *);
};
# 5884 "ext/sqlite3/libsqlite/sqlite3.c"
           sqlite3_mutex *sqlite3_db_mutex(sqlite3*);
# 5918 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_file_control(sqlite3*, const char *zDbName, int op, void*);
# 5937 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_test_control(int op, ...);
# 5996 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag);
# 6112 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int resetFlg);
# 6205 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg);
# 6250 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct sqlite3_pcache sqlite3_pcache;
# 6393 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct sqlite3_pcache_methods sqlite3_pcache_methods;
struct sqlite3_pcache_methods {
  void *pArg;
  int (*xInit)(void*);
  void (*xShutdown)(void*);
  sqlite3_pcache *(*xCreate)(int szPage, int bPurgeable);
  void (*xCachesize)(sqlite3_pcache*, int nCachesize);
  int (*xPagecount)(sqlite3_pcache*);
  void *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);
  void (*xUnpin)(sqlite3_pcache*, void*, int discard);
  void (*xRekey)(sqlite3_pcache*, void*, unsigned oldKey, unsigned newKey);
  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);
  void (*xDestroy)(sqlite3_pcache*);
};
# 6418 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct sqlite3_backup sqlite3_backup;
# 6601 "ext/sqlite3/libsqlite/sqlite3.c"
           sqlite3_backup *sqlite3_backup_init(
  sqlite3 *pDest,
  const char *zDestName,
  sqlite3 *pSource,
  const char *zSourceName
);
           int sqlite3_backup_step(sqlite3_backup *p, int nPage);
           int sqlite3_backup_finish(sqlite3_backup *p);
           int sqlite3_backup_remaining(sqlite3_backup *p);
           int sqlite3_backup_pagecount(sqlite3_backup *p);
# 6726 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_unlock_notify(
  sqlite3 *pBlocked,
  void (*xNotify)(void **apArg, int nArg),
  void *pNotifyArg
);
# 6741 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_strnicmp(const char *, const char *, int);
# 6764 "ext/sqlite3/libsqlite/sqlite3.c"
           void sqlite3_log(int iErrCode, const char *zFormat, ...);
# 6801 "ext/sqlite3/libsqlite/sqlite3.c"
           void *sqlite3_wal_hook(
  sqlite3*,
  int(*)(void *,sqlite3*,const char*,int),
  void*
);
# 6832 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_wal_autocheckpoint(sqlite3 *db, int N);
# 6850 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb);
# 6922 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_wal_checkpoint_v2(
  sqlite3 *db,
  const char *zDb,
  int eMode,
  int *pnLog,
  int *pnCkpt
);
# 6977 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct sqlite3_rtree_geometry sqlite3_rtree_geometry;







           int sqlite3_rtree_geometry_callback(
  sqlite3 *db,
  const char *zGeom,
  int (*xGeom)(sqlite3_rtree_geometry *, int nCoord, double *aCoord, int *pRes),
  void *pContext
);






struct sqlite3_rtree_geometry {
  void *pContext;
  int nParam;
  double *aParam;
  void *pUser;
  void (*xDelUser)(void *);
};
# 7035 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct Hash Hash;
typedef struct HashElem HashElem;
# 7059 "ext/sqlite3/libsqlite/sqlite3.c"
struct Hash {
  unsigned int htsize;
  unsigned int count;
  HashElem *first;
  struct _ht {
    int count;
    HashElem *chain;
  } *ht;
};







struct HashElem {
  HashElem *next, *prev;
  void *data;
  const char *pKey; int nKey;
};




static void sqlite3HashInit(Hash*);
static void *sqlite3HashInsert(Hash*, const char *pKey, int nKey, void *pData);
static void *sqlite3HashFind(const Hash*, const char *pKey, int nKey);
static void sqlite3HashClear(Hash*);
# 7278 "ext/sqlite3/libsqlite/sqlite3.c"
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 352 "/usr/include/features.h" 3 4
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 353 "/usr/include/features.h" 2 3 4
# 374 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 385 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 386 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 375 "/usr/include/features.h" 2 3 4
# 398 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 399 "/usr/include/features.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 58 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 121 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 122 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 36 "/usr/include/stdio.h" 2 3 4








struct _IO_FILE;



typedef struct _IO_FILE FILE;
# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 31 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 32 "/usr/include/libio.h" 2 3 4
# 144 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 154 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 177 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 245 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 293 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 302 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 338 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);







extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 434 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ ));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ ));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ ));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ ));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ ));
# 464 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ ));
# 75 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
# 92 "/usr/include/stdio.h" 3 4
typedef __off64_t off_t;




typedef __off64_t off64_t;




typedef __ssize_t ssize_t;
# 112 "/usr/include/stdio.h" 3 4
typedef _G_fpos64_t fpos_t;



typedef _G_fpos64_t fpos64_t;
# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) __attribute__ ((__nothrow__ ));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ ));




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ ));
# 198 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) __asm__ ("" "tmpfile64") ;






extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ )) ;





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ )) ;
# 227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) ;
# 237 "/usr/include/stdio.h" 3 4
extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 262 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 283 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename, const char *__restrict __modes) __asm__ ("" "fopen64")

       ;
extern FILE *freopen (const char *__restrict __filename, const char *__restrict __modes, FILE *__restrict __stream) __asm__ ("" "freopen64")


       ;







extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ )) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ )) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ )) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ )) ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ ));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ ));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ ));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ ));
# 356 "/usr/include/stdio.h" 3 4
extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));
# 425 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ ));
# 471 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ )) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 531 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);
# 550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 573 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);
# 622 "/usr/include/stdio.h" 3 4
extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
          ;
# 649 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
# 665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;
# 689 "/usr/include/stdio.h" 3 4
extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 726 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);
# 749 "/usr/include/stdio.h" 3 4
extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 781 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off64_t __off, int __whence) __asm__ ("" "fseeko64");


extern __off64_t ftello (FILE *__stream) __asm__ ("" "ftello64");
# 806 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos) __asm__ ("" "fgetpos64");

extern int fsetpos (FILE *__stream, const fpos_t *__pos) __asm__ ("" "fsetpos64");
# 818 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);




extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ ));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ )) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ )) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ ));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ )) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ )) ;
# 846 "/usr/include/stdio.h" 3 4
extern void perror (const char *__s);







# 1 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ )) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ )) ;
# 873 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ ));





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ ));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ )) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ ));
# 934 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}



extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return _IO_getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) feof_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x10) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) ferror_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x20) != 0);
}
# 935 "/usr/include/stdio.h" 2 3 4
# 7279 "ext/sqlite3/libsqlite/sqlite3.c" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 86 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 3 4
typedef int wchar_t;
# 33 "/usr/include/stdlib.h" 2 3 4








# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 3 4
typedef enum
{
  P_ALL,
  P_PID,
  P_PGID
} idtype_t;
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4






# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 2 3 4
# 61 "/usr/include/endian.h" 2 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "/usr/include/stdlib.h" 2 3 4
# 67 "/usr/include/stdlib.h" 3 4
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
# 97 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ )) ;




extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 235 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 236 "/usr/include/stdlib.h" 2 3 4



extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3)));





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) atoi (const char *__nptr)
{
  return (int) strtol (__nptr, (char **) ((void*)0), 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__nothrow__ )) atol (const char *__nptr)
{
  return strtol (__nptr, (char **) ((void*)0), 10);
}




__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__nothrow__ )) atoll (const char *__nptr)
{
  return strtoll (__nptr, (char **) ((void*)0), 10);
}
# 305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ )) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;





typedef __ino64_t ino_t;




typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 98 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 115 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 132 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/time.h" 1 3 4
# 59 "/usr/include/time.h" 3 4
typedef __clock_t clock_t;
# 75 "/usr/include/time.h" 3 4
typedef __time_t time_t;
# 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 133 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;






# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 147 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 194 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/select.h" 2 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;






# 1 "/usr/include/time.h" 1 3 4
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
# 44 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 46 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4








typedef long int __fd_mask;
# 64 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 106 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 220 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h" 3 4
__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int
__attribute__ ((__nothrow__ )) gnu_dev_major (unsigned long long int __dev)
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int
__attribute__ ((__nothrow__ )) gnu_dev_minor (unsigned long long int __dev)
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned long long int
__attribute__ ((__nothrow__ )) gnu_dev_makedev (unsigned int __major, unsigned int __minor)
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
   | (((unsigned long long int) (__minor & ~0xff)) << 12)
   | (((unsigned long long int) (__major & ~0xfff)) << 32));
}
# 223 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;
# 248 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt_t;



typedef __fsblkcnt64_t fsblkcnt_t;



typedef __fsfilcnt64_t fsfilcnt_t;





typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;






# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4
# 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;





typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    short __spins;
    short __elision;
    __pthread_list_t __list;
# 124 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
# 211 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 271 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 315 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ ));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ ));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__ ));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ ));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ ));







extern double drand48 (void) __attribute__ ((__nothrow__ ));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ ));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ ));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ ));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
# 466 "/usr/include/stdlib.h" 3 4
extern void *malloc (size_t __size) __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) ;
# 480 "/usr/include/stdlib.h" 3 4
extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__ ));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__ ));




# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ ));
# 493 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) ;




extern void abort (void) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));







extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));







extern void _Exit (int __status) __attribute__ ((__nothrow__ )) __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;





extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ ));
# 606 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 623 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __asm__ ("" "mkstemp64")
     __attribute__ ((__nonnull__ (1))) ;





extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 645 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __asm__ ("" "mkstemps64") __attribute__ ((__nonnull__ (1))) ;






extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 663 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
# 677 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __asm__ ("" "mkostemp64")
     __attribute__ ((__nonnull__ (1))) ;





extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 698 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags) __asm__ ("" "mkostemps64")

     __attribute__ ((__nonnull__ (1))) ;





extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 717 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;






extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
# 734 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ )) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);





extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/stdlib-bsearch.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 return (void *) __p;
    }

  return ((void*)0);
}
# 761 "/usr/include/stdlib.h" 2 3 4




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__)) ;
# 812 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4, 5)));






extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ ));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ ));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ ));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ ));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ ));
# 888 "/usr/include/stdlib.h" 3 4
extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
# 899 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__ ));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ ));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ )) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__nothrow__ )) atof (const char *__nptr)
{
  return strtod (__nptr, (char **) ((void*)0));
}
# 956 "/usr/include/stdlib.h" 2 3 4
# 7280 "ext/sqlite3/libsqlite/sqlite3.c" 2
# 1 "/usr/include/string.h" 1 3 4
# 32 "/usr/include/string.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4
# 46 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 96 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 110 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 121 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
# 166 "/usr/include/string.h" 3 4
extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 236 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 263 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 277 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 315 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 342 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
# 373 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__ ));
# 438 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__ ));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 489 "/usr/include/string.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 517 "/usr/include/string.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern int ffsl (long int __l) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ ));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ )) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 604 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 632 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/string.h" 1 3 4
# 633 "/usr/include/string.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/string2.h" 1 3 4
# 393 "/usr/include/x86_64-linux-gnu/bits/string2.h" 3 4
extern void *__rawmemchr (const void *__s, int __c);
# 945 "/usr/include/x86_64-linux-gnu/bits/string2.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) size_t __strcspn_c1 (const char *__s, int __reject);
extern __inline __attribute__ ((__gnu_inline__)) size_t
__strcspn_c1 (const char *__s, int __reject)
{
  size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject)
    ++__result;
  return __result;
}

extern __inline __attribute__ ((__gnu_inline__)) size_t __strcspn_c2 (const char *__s, int __reject1,
         int __reject2);
extern __inline __attribute__ ((__gnu_inline__)) size_t
__strcspn_c2 (const char *__s, int __reject1, int __reject2)
{
  size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject1
  && __s[__result] != __reject2)
    ++__result;
  return __result;
}

extern __inline __attribute__ ((__gnu_inline__)) size_t __strcspn_c3 (const char *__s, int __reject1,
         int __reject2, int __reject3);
extern __inline __attribute__ ((__gnu_inline__)) size_t
__strcspn_c3 (const char *__s, int __reject1, int __reject2,
       int __reject3)
{
  size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject1
  && __s[__result] != __reject2 && __s[__result] != __reject3)
    ++__result;
  return __result;
}
# 1021 "/usr/include/x86_64-linux-gnu/bits/string2.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) size_t __strspn_c1 (const char *__s, int __accept);
extern __inline __attribute__ ((__gnu_inline__)) size_t
__strspn_c1 (const char *__s, int __accept)
{
  size_t __result = 0;

  while (__s[__result] == __accept)
    ++__result;
  return __result;
}

extern __inline __attribute__ ((__gnu_inline__)) size_t __strspn_c2 (const char *__s, int __accept1,
        int __accept2);
extern __inline __attribute__ ((__gnu_inline__)) size_t
__strspn_c2 (const char *__s, int __accept1, int __accept2)
{
  size_t __result = 0;

  while (__s[__result] == __accept1 || __s[__result] == __accept2)
    ++__result;
  return __result;
}

extern __inline __attribute__ ((__gnu_inline__)) size_t __strspn_c3 (const char *__s, int __accept1,
        int __accept2, int __accept3);
extern __inline __attribute__ ((__gnu_inline__)) size_t
__strspn_c3 (const char *__s, int __accept1, int __accept2, int __accept3)
{
  size_t __result = 0;

  while (__s[__result] == __accept1 || __s[__result] == __accept2
  || __s[__result] == __accept3)
    ++__result;
  return __result;
}
# 1097 "/usr/include/x86_64-linux-gnu/bits/string2.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) char *__strpbrk_c2 (const char *__s, int __accept1,
        int __accept2);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strpbrk_c2 (const char *__s, int __accept1, int __accept2)
{

  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2)
    ++__s;
  return *__s == '\0' ? ((void*)0) : (char *) (size_t) __s;
}

extern __inline __attribute__ ((__gnu_inline__)) char *__strpbrk_c3 (const char *__s, int __accept1,
        int __accept2, int __accept3);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strpbrk_c3 (const char *__s, int __accept1, int __accept2, int __accept3)
{

  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2
  && *__s != __accept3)
    ++__s;
  return *__s == '\0' ? ((void*)0) : (char *) (size_t) __s;
}
# 1147 "/usr/include/x86_64-linux-gnu/bits/string2.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) char *__strtok_r_1c (char *__s, char __sep, char **__nextp);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strtok_r_1c (char *__s, char __sep, char **__nextp)
{
  char *__result;
  if (__s == ((void*)0))
    __s = *__nextp;
  while (*__s == __sep)
    ++__s;
  __result = ((void*)0);
  if (*__s != '\0')
    {
      __result = __s++;
      while (*__s != '\0')
 if (*__s++ == __sep)
   {
     __s[-1] = '\0';
     break;
   }
    }
  *__nextp = __s;
  return __result;
}
# 1179 "/usr/include/x86_64-linux-gnu/bits/string2.h" 3 4
extern char *__strsep_g (char **__stringp, const char *__delim);
# 1197 "/usr/include/x86_64-linux-gnu/bits/string2.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) char *__strsep_1c (char **__s, char __reject);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strsep_1c (char **__s, char __reject)
{
  char *__retval = *__s;
  if (__retval != ((void*)0) && (*__s = (__extension__ (__builtin_constant_p (__reject) && !__builtin_constant_p (__retval) && (__reject) == '\0' ? (char *) __rawmemchr (__retval, __reject) : __builtin_strchr (__retval, __reject)))) != ((void*)0))
    *(*__s)++ = '\0';
  return __retval;
}

extern __inline __attribute__ ((__gnu_inline__)) char *__strsep_2c (char **__s, char __reject1, char __reject2);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strsep_2c (char **__s, char __reject1, char __reject2)
{
  char *__retval = *__s;
  if (__retval != ((void*)0))
    {
      char *__cp = __retval;
      while (1)
 {
   if (*__cp == '\0')
     {
       __cp = ((void*)0);
   break;
     }
   if (*__cp == __reject1 || *__cp == __reject2)
     {
       *__cp++ = '\0';
       break;
     }
   ++__cp;
 }
      *__s = __cp;
    }
  return __retval;
}

extern __inline __attribute__ ((__gnu_inline__)) char *__strsep_3c (char **__s, char __reject1, char __reject2,
       char __reject3);
extern __inline __attribute__ ((__gnu_inline__)) char *
__strsep_3c (char **__s, char __reject1, char __reject2, char __reject3)
{
  char *__retval = *__s;
  if (__retval != ((void*)0))
    {
      char *__cp = __retval;
      while (1)
 {
   if (*__cp == '\0')
     {
       __cp = ((void*)0);
   break;
     }
   if (*__cp == __reject1 || *__cp == __reject2 || *__cp == __reject3)
     {
       *__cp++ = '\0';
       break;
     }
   ++__cp;
 }
      *__s = __cp;
    }
  return __retval;
}
# 1278 "/usr/include/x86_64-linux-gnu/bits/string2.h" 3 4
extern char *__strdup (const char *__string) __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__));
# 1297 "/usr/include/x86_64-linux-gnu/bits/string2.h" 3 4
extern char *__strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ )) __attribute__ ((__malloc__));
# 636 "/usr/include/string.h" 2 3 4
# 7281 "ext/sqlite3/libsqlite/sqlite3.c" 2
# 1 "/usr/include/assert.h" 1 3 4
# 7282 "ext/sqlite3/libsqlite/sqlite3.c" 2
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3
# 47 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 3
typedef long int ptrdiff_t;
# 7283 "ext/sqlite3/libsqlite/sqlite3.c" 2
# 7405 "ext/sqlite3/libsqlite/sqlite3.c"
typedef sqlite_int64 i64;
typedef sqlite_uint64 u64;
typedef unsigned int u32;
typedef unsigned short int u16;
typedef short int i16;
typedef unsigned char u8;
typedef signed char i8;
# 7426 "ext/sqlite3/libsqlite/sqlite3.c"
static const int sqlite3one = 1;
# 7485 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct BusyHandler BusyHandler;
struct BusyHandler {
  int (*xFunc)(void *,int);
  void *pArg;
  int nBusy;
};
# 7570 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct AggInfo AggInfo;
typedef struct AuthContext AuthContext;
typedef struct AutoincInfo AutoincInfo;
typedef struct Bitvec Bitvec;
typedef struct CollSeq CollSeq;
typedef struct Column Column;
typedef struct Db Db;
typedef struct Schema Schema;
typedef struct Expr Expr;
typedef struct ExprList ExprList;
typedef struct ExprSpan ExprSpan;
typedef struct FKey FKey;
typedef struct FuncDestructor FuncDestructor;
typedef struct FuncDef FuncDef;
typedef struct FuncDefHash FuncDefHash;
typedef struct IdList IdList;
typedef struct Index Index;
typedef struct IndexSample IndexSample;
typedef struct KeyClass KeyClass;
typedef struct KeyInfo KeyInfo;
typedef struct Lookaside Lookaside;
typedef struct LookasideSlot LookasideSlot;
typedef struct Module Module;
typedef struct NameContext NameContext;
typedef struct Parse Parse;
typedef struct RowSet RowSet;
typedef struct Savepoint Savepoint;
typedef struct Select Select;
typedef struct SrcList SrcList;
typedef struct StrAccum StrAccum;
typedef struct Table Table;
typedef struct TableLock TableLock;
typedef struct Token Token;
typedef struct Trigger Trigger;
typedef struct TriggerPrg TriggerPrg;
typedef struct TriggerStep TriggerStep;
typedef struct UnpackedRecord UnpackedRecord;
typedef struct VTable VTable;
typedef struct Walker Walker;
typedef struct WherePlan WherePlan;
typedef struct WhereInfo WhereInfo;
typedef struct WhereLevel WhereLevel;
# 7658 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct Btree Btree;
typedef struct BtCursor BtCursor;
typedef struct BtShared BtShared;


static int sqlite3BtreeOpen(
  const char *zFilename,
  sqlite3 *db,
  Btree **ppBtree,
  int flags,
  int vfsFlags
);
# 7683 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeClose(Btree*);
static int sqlite3BtreeSetCacheSize(Btree*,int);
static int sqlite3BtreeSetSafetyLevel(Btree*,int,int,int);
static int sqlite3BtreeSyncDisabled(Btree*);
static int sqlite3BtreeSetPageSize(Btree *p, int nPagesize, int nReserve, int eFix);
static int sqlite3BtreeGetPageSize(Btree*);
static int sqlite3BtreeMaxPageCount(Btree*,int);
static u32 sqlite3BtreeLastPage(Btree*);
static int sqlite3BtreeSecureDelete(Btree*,int);
static int sqlite3BtreeGetReserve(Btree*);
static int sqlite3BtreeSetAutoVacuum(Btree *, int);
static int sqlite3BtreeGetAutoVacuum(Btree *);
static int sqlite3BtreeBeginTrans(Btree*,int);
static int sqlite3BtreeCommitPhaseOne(Btree*, const char *zMaster);
static int sqlite3BtreeCommitPhaseTwo(Btree*, int);
static int sqlite3BtreeCommit(Btree*);
static int sqlite3BtreeRollback(Btree*);
static int sqlite3BtreeBeginStmt(Btree*,int);
static int sqlite3BtreeCreateTable(Btree*, int*, int flags);
static int sqlite3BtreeIsInTrans(Btree*);
static int sqlite3BtreeIsInReadTrans(Btree*);
static int sqlite3BtreeIsInBackup(Btree*);
static void *sqlite3BtreeSchema(Btree *, int, void(*)(void *));
static int sqlite3BtreeSchemaLocked(Btree *pBtree);
static int sqlite3BtreeLockTable(Btree *pBtree, int iTab, u8 isWriteLock);
static int sqlite3BtreeSavepoint(Btree *, int, int);

static const char *sqlite3BtreeGetFilename(Btree *);
static const char *sqlite3BtreeGetJournalname(Btree *);
static int sqlite3BtreeCopyFile(Btree *, Btree *);

static int sqlite3BtreeIncrVacuum(Btree *);
# 7729 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeDropTable(Btree*, int, int*);
static int sqlite3BtreeClearTable(Btree*, int, int*);
static void sqlite3BtreeTripAllCursors(Btree*, int);

static void sqlite3BtreeGetMeta(Btree *pBtree, int idx, u32 *pValue);
static int sqlite3BtreeUpdateMeta(Btree*, int idx, u32 value);
# 7757 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeCursor(
  Btree*,
  int iTable,
  int wrFlag,
  struct KeyInfo*,
  BtCursor *pCursor
);
static int sqlite3BtreeCursorSize(void);
static void sqlite3BtreeCursorZero(BtCursor*);

static int sqlite3BtreeCloseCursor(BtCursor*);
static int sqlite3BtreeMovetoUnpacked(
  BtCursor*,
  UnpackedRecord *pUnKey,
  i64 intKey,
  int bias,
  int *pRes
);
static int sqlite3BtreeCursorHasMoved(BtCursor*, int*);
static int sqlite3BtreeDelete(BtCursor*);
static int sqlite3BtreeInsert(BtCursor*, const void *pKey, i64 nKey,
                                  const void *pData, int nData,
                                  int nZero, int bias, int seekResult);
static int sqlite3BtreeFirst(BtCursor*, int *pRes);
static int sqlite3BtreeLast(BtCursor*, int *pRes);
static int sqlite3BtreeNext(BtCursor*, int *pRes);
static int sqlite3BtreeEof(BtCursor*);
static int sqlite3BtreePrevious(BtCursor*, int *pRes);
static int sqlite3BtreeKeySize(BtCursor*, i64 *pSize);
static int sqlite3BtreeKey(BtCursor*, u32 offset, u32 amt, void*);
static const void *sqlite3BtreeKeyFetch(BtCursor*, int *pAmt);
static const void *sqlite3BtreeDataFetch(BtCursor*, int *pAmt);
static int sqlite3BtreeDataSize(BtCursor*, u32 *pSize);
static int sqlite3BtreeData(BtCursor*, u32 offset, u32 amt, void*);
static void sqlite3BtreeSetCachedRowid(BtCursor*, sqlite3_int64);
static sqlite3_int64 sqlite3BtreeGetCachedRowid(BtCursor*);

static char *sqlite3BtreeIntegrityCheck(Btree*, int *aRoot, int nRoot, int, int*);
static struct Pager *sqlite3BtreePager(Btree*);

static int sqlite3BtreePutData(BtCursor*, u32 offset, u32 amt, void*);
static void sqlite3BtreeCacheOverflow(BtCursor *);
static void sqlite3BtreeClearCursor(BtCursor *);

static int sqlite3BtreeSetVersion(Btree *pBt, int iVersion);






static int sqlite3BtreeCount(BtCursor *, i64 *);
# 7817 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeCheckpoint(Btree*, int, int *, int *);
# 7826 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3BtreeEnter(Btree*);
static void sqlite3BtreeEnterAll(sqlite3*);
# 7890 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct Vdbe Vdbe;





typedef struct VdbeFunc VdbeFunc;
typedef struct Mem Mem;
typedef struct SubProgram SubProgram;






struct VdbeOp {
  u8 opcode;
  signed char p4type;
  u8 opflags;
  u8 p5;
  int p1;
  int p2;
  int p3;
  union {
    int i;
    void *p;
    char *z;
    i64 *pI64;
    double *pReal;
    FuncDef *pFunc;
    VdbeFunc *pVdbeFunc;
    CollSeq *pColl;
    Mem *pMem;
    VTable *pVtab;
    KeyInfo *pKeyInfo;
    int *ai;
    SubProgram *pProgram;
  } p4;







};
typedef struct VdbeOp VdbeOp;





struct SubProgram {
  VdbeOp *aOp;
  int nOp;
  int nMem;
  int nCsr;
  void *token;
  SubProgram *pNext;
};





struct VdbeOpList {
  u8 opcode;
  signed char p1;
  signed char p2;
  signed char p3;
};
typedef struct VdbeOpList VdbeOpList;
# 8216 "ext/sqlite3/libsqlite/sqlite3.c"
static Vdbe *sqlite3VdbeCreate(sqlite3*);
static int sqlite3VdbeAddOp0(Vdbe*,int);
static int sqlite3VdbeAddOp1(Vdbe*,int,int);
static int sqlite3VdbeAddOp2(Vdbe*,int,int,int);
static int sqlite3VdbeAddOp3(Vdbe*,int,int,int,int);
static int sqlite3VdbeAddOp4(Vdbe*,int,int,int,int,const char *zP4,int);
static int sqlite3VdbeAddOp4Int(Vdbe*,int,int,int,int,int);
static int sqlite3VdbeAddOpList(Vdbe*, int nOp, VdbeOpList const *aOp);
static void sqlite3VdbeChangeP1(Vdbe*, int addr, int P1);
static void sqlite3VdbeChangeP2(Vdbe*, int addr, int P2);
static void sqlite3VdbeChangeP3(Vdbe*, int addr, int P3);
static void sqlite3VdbeChangeP5(Vdbe*, u8 P5);
static void sqlite3VdbeJumpHere(Vdbe*, int addr);
static void sqlite3VdbeChangeToNoop(Vdbe*, int addr, int N);
static void sqlite3VdbeChangeP4(Vdbe*, int addr, const char *zP4, int N);
static void sqlite3VdbeUsesBtree(Vdbe*, int);
static VdbeOp *sqlite3VdbeGetOp(Vdbe*, int);
static int sqlite3VdbeMakeLabel(Vdbe*);
static void sqlite3VdbeRunOnlyOnce(Vdbe*);
static void sqlite3VdbeDelete(Vdbe*);
static void sqlite3VdbeDeleteObject(sqlite3*,Vdbe*);
static void sqlite3VdbeMakeReady(Vdbe*,int,int,int,int,int,int);
static int sqlite3VdbeFinalize(Vdbe*);
static void sqlite3VdbeResolveLabel(Vdbe*, int);
static int sqlite3VdbeCurrentAddr(Vdbe*);




static void sqlite3VdbeResetStepResult(Vdbe*);
static int sqlite3VdbeReset(Vdbe*);
static void sqlite3VdbeSetNumCols(Vdbe*,int);
static int sqlite3VdbeSetColName(Vdbe*, int, int, const char *, void(*)(void*));
static void sqlite3VdbeCountChanges(Vdbe*);
static sqlite3 *sqlite3VdbeDb(Vdbe*);
static void sqlite3VdbeSetSql(Vdbe*, const char *z, int n, int);
static void sqlite3VdbeSwap(Vdbe*,Vdbe*);
static VdbeOp *sqlite3VdbeTakeOpArray(Vdbe*, int*, int*);
static sqlite3_value *sqlite3VdbeGetValue(Vdbe*, int, u8);
static void sqlite3VdbeSetVarmask(Vdbe*, int);

static char *sqlite3VdbeExpandSql(Vdbe*, const char*);


static UnpackedRecord *sqlite3VdbeRecordUnpack(KeyInfo*,int,const void*,char*,int);
static void sqlite3VdbeDeleteUnpackedRecord(UnpackedRecord*);
static int sqlite3VdbeRecordCompare(int,const void*,UnpackedRecord*);


static void sqlite3VdbeLinkSubProgram(Vdbe *, SubProgram *);
# 8317 "ext/sqlite3/libsqlite/sqlite3.c"
typedef u32 Pgno;




typedef struct Pager Pager;




typedef struct PgHdr DbPage;
# 8373 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerOpen(
  sqlite3_vfs*,
  Pager **ppPager,
  const char*,
  int,
  int,
  int,
  void(*)(DbPage*)
);
static int sqlite3PagerClose(Pager *pPager);
static int sqlite3PagerReadFileheader(Pager*, int, unsigned char*);


static void sqlite3PagerSetBusyhandler(Pager*, int(*)(void *), void *);
static int sqlite3PagerSetPagesize(Pager*, u32*, int);
static int sqlite3PagerMaxPageCount(Pager*, int);
static void sqlite3PagerSetCachesize(Pager*, int);
static void sqlite3PagerSetSafetyLevel(Pager*,int,int,int);
static int sqlite3PagerLockingMode(Pager *, int);
static int sqlite3PagerSetJournalMode(Pager *, int);
static int sqlite3PagerGetJournalMode(Pager*);
static int sqlite3PagerOkToChangeJournalMode(Pager*);
static i64 sqlite3PagerJournalSizeLimit(Pager *, i64);
static sqlite3_backup **sqlite3PagerBackupPtr(Pager*);


static int sqlite3PagerAcquire(Pager *pPager, Pgno pgno, DbPage **ppPage, int clrFlag);

static DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno);
static void sqlite3PagerRef(DbPage*);
static void sqlite3PagerUnref(DbPage*);


static int sqlite3PagerWrite(DbPage*);
static void sqlite3PagerDontWrite(DbPage*);
static int sqlite3PagerMovepage(Pager*,DbPage*,Pgno,int);
static int sqlite3PagerPageRefcount(DbPage*);
static void *sqlite3PagerGetData(DbPage *);
static void *sqlite3PagerGetExtra(DbPage *);


static void sqlite3PagerPagecount(Pager*, int*);
static int sqlite3PagerBegin(Pager*, int exFlag, int);
static int sqlite3PagerCommitPhaseOne(Pager*,const char *zMaster, int);
static int sqlite3PagerExclusiveLock(Pager*);
static int sqlite3PagerSync(Pager *pPager);
static int sqlite3PagerCommitPhaseTwo(Pager*);
static int sqlite3PagerRollback(Pager*);
static int sqlite3PagerOpenSavepoint(Pager *pPager, int n);
static int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint);
static int sqlite3PagerSharedLock(Pager *pPager);

static int sqlite3PagerCheckpoint(Pager *pPager, int, int*, int*);
static int sqlite3PagerWalSupported(Pager *pPager);
static int sqlite3PagerWalCallback(Pager *pPager);
static int sqlite3PagerOpenWal(Pager *pPager, int *pisOpen);
static int sqlite3PagerCloseWal(Pager *pPager);


static u8 sqlite3PagerIsreadonly(Pager*);
static int sqlite3PagerRefcount(Pager*);
static int sqlite3PagerMemUsed(Pager*);
static const char *sqlite3PagerFilename(Pager*);
static const sqlite3_vfs *sqlite3PagerVfs(Pager*);
static sqlite3_file *sqlite3PagerFile(Pager*);
static const char *sqlite3PagerJournalname(Pager*);
static int sqlite3PagerNosync(Pager*);
static void *sqlite3PagerTempSpace(Pager*);
static int sqlite3PagerIsMemdb(Pager*);


static void sqlite3PagerTruncateImage(Pager*,Pgno);
# 8488 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct PgHdr PgHdr;
typedef struct PCache PCache;





struct PgHdr {
  void *pData;
  void *pExtra;
  PgHdr *pDirty;
  Pgno pgno;
  Pager *pPager;



  u16 flags;





  i16 nRef;
  PCache *pCache;

  PgHdr *pDirtyNext;
  PgHdr *pDirtyPrev;
};
# 8526 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PcacheInitialize(void);
static void sqlite3PcacheShutdown(void);




static void sqlite3PCacheBufferSetup(void *, int sz, int n);





static void sqlite3PcacheOpen(
  int szPage,
  int szExtra,
  int bPurgeable,
  int (*xStress)(void*, PgHdr*),
  void *pStress,
  PCache *pToInit
);


static void sqlite3PcacheSetPageSize(PCache *, int);




static int sqlite3PcacheSize(void);




static int sqlite3PcacheFetch(PCache*, Pgno, int createFlag, PgHdr**);
static void sqlite3PcacheRelease(PgHdr*);

static void sqlite3PcacheDrop(PgHdr*);
static void sqlite3PcacheMakeDirty(PgHdr*);
static void sqlite3PcacheMakeClean(PgHdr*);
static void sqlite3PcacheCleanAll(PCache*);


static void sqlite3PcacheMove(PgHdr*, Pgno);


static void sqlite3PcacheTruncate(PCache*, Pgno x);


static PgHdr *sqlite3PcacheDirtyList(PCache*);


static void sqlite3PcacheClose(PCache*);


static void sqlite3PcacheClearSyncFlags(PCache *);


static void sqlite3PcacheClear(PCache*);


static int sqlite3PcacheRefCount(PCache*);


static void sqlite3PcacheRef(PgHdr*);

static int sqlite3PcachePageRefcount(PgHdr*);


static int sqlite3PcachePagecount(PCache*);
# 8609 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3PcacheSetCachesize(PCache *, int);
# 8623 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3PCacheSetDefault(void);
# 8863 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3OsInit(void);




static int sqlite3OsClose(sqlite3_file*);
static int sqlite3OsRead(sqlite3_file*, void*, int amt, i64 offset);
static int sqlite3OsWrite(sqlite3_file*, const void*, int amt, i64 offset);
static int sqlite3OsTruncate(sqlite3_file*, i64 size);
static int sqlite3OsSync(sqlite3_file*, int);
static int sqlite3OsFileSize(sqlite3_file*, i64 *pSize);
static int sqlite3OsLock(sqlite3_file*, int);
static int sqlite3OsUnlock(sqlite3_file*, int);
static int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut);
static int sqlite3OsFileControl(sqlite3_file*,int,void*);

static int sqlite3OsSectorSize(sqlite3_file *id);
static int sqlite3OsDeviceCharacteristics(sqlite3_file *id);
static int sqlite3OsShmMap(sqlite3_file *,int,int,int,void volatile **);
static int sqlite3OsShmLock(sqlite3_file *id, int, int, int);
static void sqlite3OsShmBarrier(sqlite3_file *id);
static int sqlite3OsShmUnmap(sqlite3_file *id, int);




static int sqlite3OsOpen(sqlite3_vfs *, const char *, sqlite3_file*, int, int *);
static int sqlite3OsDelete(sqlite3_vfs *, const char *, int);
static int sqlite3OsAccess(sqlite3_vfs *, const char *, int, int *pResOut);
static int sqlite3OsFullPathname(sqlite3_vfs *, const char *, int, char *);

static void *sqlite3OsDlOpen(sqlite3_vfs *, const char *);
static void sqlite3OsDlError(sqlite3_vfs *, int, char *);
static void (*sqlite3OsDlSym(sqlite3_vfs *, void *, const char *))(void);
static void sqlite3OsDlClose(sqlite3_vfs *, void *);

static int sqlite3OsRandomness(sqlite3_vfs *, int, char *);
static int sqlite3OsSleep(sqlite3_vfs *, int);
static int sqlite3OsCurrentTimeInt64(sqlite3_vfs *, sqlite3_int64*);





static int sqlite3OsOpenMalloc(sqlite3_vfs *, const char *, sqlite3_file **, int,int*);
static int sqlite3OsCloseFree(sqlite3_file *);
# 8999 "ext/sqlite3/libsqlite/sqlite3.c"
struct Db {
  char *zName;
  Btree *pBt;
  u8 inTrans;
  u8 safety_level;
  Schema *pSchema;
};
# 9024 "ext/sqlite3/libsqlite/sqlite3.c"
struct Schema {
  int schema_cookie;
  int iGeneration;
  Hash tblHash;
  Hash idxHash;
  Hash trigHash;
  Hash fkeyHash;
  Table *pSeqTab;
  u8 file_format;
  u8 enc;
  u16 flags;
  int cache_size;
};
# 9087 "ext/sqlite3/libsqlite/sqlite3.c"
struct Lookaside {
  u16 sz;
  u8 bEnabled;
  u8 bMalloced;
  int nOut;
  int mxOut;
  int anStat[3];
  LookasideSlot *pFree;
  void *pStart;
  void *pEnd;
};
struct LookasideSlot {
  LookasideSlot *pNext;
};







struct FuncDefHash {
  FuncDef *a[23];
};
# 9138 "ext/sqlite3/libsqlite/sqlite3.c"
struct sqlite3 {
  sqlite3_vfs *pVfs;
  int nDb;
  Db *aDb;
  int flags;
  int openFlags;
  int errCode;
  int errMask;
  u8 autoCommit;
  u8 temp_store;
  u8 mallocFailed;
  u8 dfltLockMode;
  signed char nextAutovac;
  u8 suppressErr;
  int nextPagesize;
  int nTable;
  CollSeq *pDfltColl;
  i64 lastRowid;
  u32 magic;
  int nChange;
  int nTotalChange;
  sqlite3_mutex *mutex;
  int aLimit[(10 +1)];
  struct sqlite3InitInfo {
    int iDb;
    int newTnum;
    u8 busy;
    u8 orphanTrigger;
  } init;
  int nExtension;
  void **aExtension;
  struct Vdbe *pVdbe;
  int activeVdbeCnt;
  int writeVdbeCnt;
  int vdbeExecCnt;
  void (*xTrace)(void*,const char*);
  void *pTraceArg;
  void (*xProfile)(void*,const char*,u64);
  void *pProfileArg;
  void *pCommitArg;
  int (*xCommitCallback)(void*);
  void *pRollbackArg;
  void (*xRollbackCallback)(void*);
  void *pUpdateArg;
  void (*xUpdateCallback)(void*,int, const char*,const char*,sqlite_int64);

  int (*xWalCallback)(void *, sqlite3 *, const char *, int);
  void *pWalArg;

  void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*);
  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*);
  void *pCollNeededArg;
  sqlite3_value *pErr;
  char *zErrMsg;
  char *zErrMsg16;
  union {
    volatile int isInterrupted;
    double notUsed1;
  } u1;
  Lookaside lookaside;

  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*);

  void *pAuthArg;


  int (*xProgress)(void *);
  void *pProgressArg;
  int nProgressOps;


  Hash aModule;
  Table *pVTab;
  VTable **aVTrans;
  int nVTrans;
  VTable *pDisconnect;

  FuncDefHash aFunc;
  Hash aCollSeq;
  BusyHandler busyHandler;
  int busyTimeout;
  Db aDbStatic[2];
  Savepoint *pSavepoint;
  int nSavepoint;
  int nStatement;
  u8 isTransactionSavepoint;
  i64 nDeferredCons;
  int *pnBytesFreed;
# 9244 "ext/sqlite3/libsqlite/sqlite3.c"
};
# 9313 "ext/sqlite3/libsqlite/sqlite3.c"
struct FuncDef {
  i16 nArg;
  u8 iPrefEnc;
  u8 flags;
  void *pUserData;
  FuncDef *pNext;
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**);
  void (*xStep)(sqlite3_context*,int,sqlite3_value**);
  void (*xFinalize)(sqlite3_context*);
  char *zName;
  FuncDef *pHash;
  FuncDestructor *pDestructor;
};
# 9341 "ext/sqlite3/libsqlite/sqlite3.c"
struct FuncDestructor {
  int nRef;
  void (*xDestroy)(void *);
  void *pUserData;
};
# 9401 "ext/sqlite3/libsqlite/sqlite3.c"
struct Savepoint {
  char *zName;
  i64 nDeferredCons;
  Savepoint *pNext;
};
# 9421 "ext/sqlite3/libsqlite/sqlite3.c"
struct Module {
  const sqlite3_module *pModule;
  const char *zName;
  void *pAux;
  void (*xDestroy)(void *);
};





struct Column {
  char *zName;
  Expr *pDflt;
  char *zDflt;
  char *zType;
  char *zColl;
  u8 notNull;
  u8 isPrimKey;
  char affinity;

  u8 isHidden;

};
# 9467 "ext/sqlite3/libsqlite/sqlite3.c"
struct CollSeq {
  char *zName;
  u8 enc;
  u8 type;
  void *pUser;
  int (*xCmp)(void*,int, const void*, int, const void*);
  void (*xDel)(void*);
};
# 9568 "ext/sqlite3/libsqlite/sqlite3.c"
struct VTable {
  sqlite3 *db;
  Module *pMod;
  sqlite3_vtab *pVtab;
  int nRef;
  VTable *pNext;
};
# 9606 "ext/sqlite3/libsqlite/sqlite3.c"
struct Table {
  char *zName;
  int iPKey;
  int nCol;
  Column *aCol;
  Index *pIndex;
  int tnum;
  unsigned nRowEst;
  Select *pSelect;
  u16 nRef;
  u8 tabFlags;
  u8 keyConf;
  FKey *pFKey;
  char *zColAff;

  Expr *pCheck;


  int addColOffset;


  VTable *pVTable;
  int nModuleArg;
  char **azModuleArg;

  Trigger *pTrigger;
  Schema *pSchema;
  Table *pNextZombie;
};
# 9680 "ext/sqlite3/libsqlite/sqlite3.c"
struct FKey {
  Table *pFrom;
  FKey *pNextFrom;
  char *zTo;
  FKey *pNextTo;
  FKey *pPrevTo;
  int nCol;

  u8 isDeferred;
  u8 aAction[2];
  Trigger *apTrigger[2];
  struct sColMap {
    int iFrom;
    char *zCol;
  } aCol[1];
};
# 9742 "ext/sqlite3/libsqlite/sqlite3.c"
struct KeyInfo {
  sqlite3 *db;
  u8 enc;
  u16 nField;
  u8 *aSortOrder;
  CollSeq *aColl[1];
};
# 9764 "ext/sqlite3/libsqlite/sqlite3.c"
struct UnpackedRecord {
  KeyInfo *pKeyInfo;
  u16 nField;
  u16 flags;
  i64 rowid;
  Mem *aMem;
};
# 9808 "ext/sqlite3/libsqlite/sqlite3.c"
struct Index {
  char *zName;
  int nColumn;
  int *aiColumn;
  unsigned *aiRowEst;
  Table *pTable;
  int tnum;
  u8 onError;
  u8 autoIndex;
  u8 bUnordered;
  char *zColAff;
  Index *pNext;
  Schema *pSchema;
  u8 *aSortOrder;
  char **azColl;
  IndexSample *aSample;
};





struct IndexSample {
  union {
    char *z;
    double r;
  } u;
  u8 eType;
  u8 nByte;
};
# 9847 "ext/sqlite3/libsqlite/sqlite3.c"
struct Token {
  const char *z;
  unsigned int n;
};
# 9865 "ext/sqlite3/libsqlite/sqlite3.c"
struct AggInfo {
  u8 directMode;

  u8 useSortingIdx;

  int sortingIdx;
  ExprList *pGroupBy;
  int nSortingColumn;
  struct AggInfo_col {
    Table *pTab;
    int iTable;
    int iColumn;
    int iSorterColumn;
    int iMem;
    Expr *pExpr;
  } *aCol;
  int nColumn;
  int nColumnAlloc;
  int nAccumulator;


  struct AggInfo_func {
    Expr *pExpr;
    FuncDef *pFunc;
    int iMem;
    int iDistinct;
  } *aFunc;
  int nFunc;
  int nFuncAlloc;
};
# 9907 "ext/sqlite3/libsqlite/sqlite3.c"
typedef i16 ynVar;
# 9975 "ext/sqlite3/libsqlite/sqlite3.c"
struct Expr {
  u8 op;
  char affinity;
  u16 flags;
  union {
    char *zToken;
    int iValue;
  } u;






  Expr *pLeft;
  Expr *pRight;
  union {
    ExprList *pList;
    Select *pSelect;
  } x;
  CollSeq *pColl;






  int iTable;


  ynVar iColumn;

  i16 iAgg;
  i16 iRightJoinTable;
  u8 flags2;
  u8 op2;
  AggInfo *pAggInfo;
  Table *pTab;

  int nHeight;

};
# 10088 "ext/sqlite3/libsqlite/sqlite3.c"
struct ExprList {
  int nExpr;
  int nAlloc;
  int iECursor;
  struct ExprList_item {
    Expr *pExpr;
    char *zName;
    char *zSpan;
    u8 sortOrder;
    u8 done;
    u16 iCol;
    u16 iAlias;
  } *a;
};






struct ExprSpan {
  Expr *pExpr;
  const char *zStart;
  const char *zEnd;
};
# 10129 "ext/sqlite3/libsqlite/sqlite3.c"
struct IdList {
  struct IdList_item {
    char *zName;
    int idx;
  } *a;
  int nId;
  int nAlloc;
};
# 10145 "ext/sqlite3/libsqlite/sqlite3.c"
typedef u64 Bitmask;
# 10171 "ext/sqlite3/libsqlite/sqlite3.c"
struct SrcList {
  i16 nSrc;
  i16 nAlloc;
  struct SrcList_item {
    char *zDatabase;
    char *zName;
    char *zAlias;
    Table *pTab;
    Select *pSelect;
    u8 isPopulated;
    u8 jointype;
    u8 notIndexed;

    u8 iSelectId;

    int iCursor;
    Expr *pOn;
    IdList *pUsing;
    Bitmask colUsed;
    char *zIndex;
    Index *pIndex;
  } a[1];
};
# 10221 "ext/sqlite3/libsqlite/sqlite3.c"
struct WherePlan {
  u32 wsFlags;
  u32 nEq;
  double nRow;
  union {
    Index *pIdx;
    struct WhereTerm *pTerm;
    sqlite3_index_info *pVtabIdx;
  } u;
};
# 10245 "ext/sqlite3/libsqlite/sqlite3.c"
struct WhereLevel {
  WherePlan plan;
  int iLeftJoin;
  int iTabCur;
  int iIdxCur;
  int addrBrk;
  int addrNxt;
  int addrCont;
  int addrFirst;
  u8 iFrom;
  u8 op, p5;
  int p1, p2;
  union {
    struct {
      int nIn;
      struct InLoop {
        int iCur;
        int addrInTop;
      } *aInLoop;
    } in;
  } u;







  sqlite3_index_info *pIdxInfo;
};
# 10297 "ext/sqlite3/libsqlite/sqlite3.c"
struct WhereInfo {
  Parse *pParse;
  u16 wctrlFlags;
  u8 okOnePass;
  u8 untestedTerms;
  SrcList *pTabList;
  int iTop;
  int iContinue;
  int iBreak;
  int nLevel;
  struct WhereClause *pWC;
  double savedNQueryLoop;
  double nRowOut;
  WhereLevel a[1];
};
# 10334 "ext/sqlite3/libsqlite/sqlite3.c"
struct NameContext {
  Parse *pParse;
  SrcList *pSrcList;
  ExprList *pEList;
  int nRef;
  int nErr;
  u8 allowAgg;
  u8 hasAgg;
  u8 isCheck;
  int nDepth;
  AggInfo *pAggInfo;
  NameContext *pNext;
};
# 10368 "ext/sqlite3/libsqlite/sqlite3.c"
struct Select {
  ExprList *pEList;
  u8 op;
  char affinity;
  u16 selFlags;
  SrcList *pSrc;
  Expr *pWhere;
  ExprList *pGroupBy;
  Expr *pHaving;
  ExprList *pOrderBy;
  Select *pPrior;
  Select *pNext;
  Select *pRightmost;
  Expr *pLimit;
  Expr *pOffset;
  int iLimit, iOffset;
  int addrOpenEphm[3];
  double nSelectRow;
};
# 10423 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct SelectDest SelectDest;
struct SelectDest {
  u8 eDest;
  u8 affinity;
  int iParm;
  int iMem;
  int nMem;
};
# 10441 "ext/sqlite3/libsqlite/sqlite3.c"
struct AutoincInfo {
  AutoincInfo *pNext;
  Table *pTab;
  int iDb;
  int regCtr;
};
# 10473 "ext/sqlite3/libsqlite/sqlite3.c"
struct TriggerPrg {
  Trigger *pTrigger;
  int orconf;
  SubProgram *pProgram;
  u32 aColmask[2];
  TriggerPrg *pNext;
};







  typedef unsigned int yDbMask;
# 10506 "ext/sqlite3/libsqlite/sqlite3.c"
struct Parse {
  sqlite3 *db;
  int rc;
  char *zErrMsg;
  Vdbe *pVdbe;
  u8 colNamesSet;
  u8 nameClash;
  u8 checkSchema;
  u8 nested;
  u8 parseError;
  u8 nTempReg;
  u8 nTempInUse;
  int aTempReg[8];
  int nRangeReg;
  int iRangeReg;
  int nErr;
  int nTab;
  int nMem;
  int nSet;
  int ckBase;
  int iCacheLevel;
  int iCacheCnt;
  u8 nColCache;
  u8 iColCache;
  struct yColCache {
    int iTable;
    int iColumn;
    u8 tempReg;
    int iLevel;
    int iReg;
    int lru;
  } aColCache[10];
  yDbMask writeMask;
  yDbMask cookieMask;
  u8 isMultiWrite;
  u8 mayAbort;
  int cookieGoto;
  int cookieValue[10 +2];

  int nTableLock;
  TableLock *aTableLock;

  int regRowid;
  int regRoot;
  AutoincInfo *pAinc;
  int nMaxArg;


  Parse *pToplevel;
  Table *pTriggerTab;
  u32 oldmask;
  u32 newmask;
  u8 eTriggerOp;
  u8 eOrconf;
  u8 disableTriggers;
  double nQueryLoop;




  int nVar;
  int nVarExpr;
  int nVarExprAlloc;
  Expr **apVarExpr;
  Vdbe *pReprepare;
  int nAlias;
  int nAliasAlloc;
  int *aAlias;
  u8 explain;
  Token sNameToken;
  Token sLastToken;
  const char *zTail;
  Table *pNewTable;
  Trigger *pNewTrigger;
  const char *zAuthContext;

  Token sArg;
  u8 declareVtab;
  int nVtabLock;
  Table **apVtabLock;

  int nHeight;
  Table *pZombieTab;
  TriggerPrg *pTriggerPrg;


  int iSelectId;
  int iNextSelectId;

};
# 10607 "ext/sqlite3/libsqlite/sqlite3.c"
struct AuthContext {
  const char *zAuthContext;
  Parse *pParse;
};
# 10637 "ext/sqlite3/libsqlite/sqlite3.c"
struct Trigger {
  char *zName;
  char *table;
  u8 op;
  u8 tr_tm;
  Expr *pWhen;
  IdList *pColumns;

  Schema *pSchema;
  Schema *pTabSchema;
  TriggerStep *step_list;
  Trigger *pNext;
};
# 10699 "ext/sqlite3/libsqlite/sqlite3.c"
struct TriggerStep {
  u8 op;
  u8 orconf;
  Trigger *pTrig;
  Select *pSelect;
  Token target;
  Expr *pWhere;
  ExprList *pExprList;
  IdList *pIdList;
  TriggerStep *pNext;
  TriggerStep *pLast;
};






typedef struct DbFixer DbFixer;
struct DbFixer {
  Parse *pParse;
  const char *zDb;
  const char *zType;
  const Token *pName;
};





struct StrAccum {
  sqlite3 *db;
  char *zBase;
  char *zText;
  int nChar;
  int nAlloc;
  int mxAlloc;
  u8 mallocFailed;
  u8 useMalloc;
  u8 tooBig;
};





typedef struct {
  sqlite3 *db;
  int iDb;
  char **pzErrMsg;
  int rc;
} InitData;






struct Sqlite3Config {
  int bMemstat;
  int bCoreMutex;
  int bFullMutex;
  int mxStrlen;
  int szLookaside;
  int nLookaside;
  sqlite3_mem_methods m;
  sqlite3_mutex_methods mutex;
  sqlite3_pcache_methods pcache;
  void *pHeap;
  int nHeap;
  int mnReq, mxReq;
  void *pScratch;
  int szScratch;
  int nScratch;
  void *pPage;
  int szPage;
  int nPage;
  int mxParserStack;
  int sharedCacheEnabled;


  int isInit;
  int inProgress;
  int isMutexInit;
  int isMallocInit;
  int isPCacheInit;
  sqlite3_mutex *pInitMutex;
  int nRefInitMutex;
  void (*xLog)(void*,int,const char*);
  void *pLogArg;
};




struct Walker {
  int (*xExprCallback)(Walker*, Expr*);
  int (*xSelectCallback)(Walker*,Select*);
  Parse *pParse;
  union {
    NameContext *pNC;
    int i;
  } u;
};


static int sqlite3WalkExpr(Walker*, Expr*);
static int sqlite3WalkExprList(Walker*, ExprList*);
static int sqlite3WalkSelect(Walker*, Select*);
static int sqlite3WalkSelectExpr(Walker*, Select*);
static int sqlite3WalkSelectFrom(Walker*, Select*);
# 10836 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3CorruptError(int);
static int sqlite3MisuseError(int);
static int sqlite3CantopenError(int);
# 10859 "ext/sqlite3/libsqlite/sqlite3.c"
# 1 "/usr/include/ctype.h" 1 3 4
# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 110 "/usr/include/ctype.h" 3 4
extern int isalnum (int) __attribute__ ((__nothrow__ ));
extern int isalpha (int) __attribute__ ((__nothrow__ ));
extern int iscntrl (int) __attribute__ ((__nothrow__ ));
extern int isdigit (int) __attribute__ ((__nothrow__ ));
extern int islower (int) __attribute__ ((__nothrow__ ));
extern int isgraph (int) __attribute__ ((__nothrow__ ));
extern int isprint (int) __attribute__ ((__nothrow__ ));
extern int ispunct (int) __attribute__ ((__nothrow__ ));
extern int isspace (int) __attribute__ ((__nothrow__ ));
extern int isupper (int) __attribute__ ((__nothrow__ ));
extern int isxdigit (int) __attribute__ ((__nothrow__ ));



extern int tolower (int __c) __attribute__ ((__nothrow__ ));


extern int toupper (int __c) __attribute__ ((__nothrow__ ));
# 136 "/usr/include/ctype.h" 3 4
extern int isblank (int) __attribute__ ((__nothrow__ ));






extern int isctype (int __c, int __mask) __attribute__ ((__nothrow__ ));






extern int isascii (int __c) __attribute__ ((__nothrow__ ));



extern int toascii (int __c) __attribute__ ((__nothrow__ ));



extern int _toupper (int) __attribute__ ((__nothrow__ ));
extern int _tolower (int) __attribute__ ((__nothrow__ ));
# 214 "/usr/include/ctype.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) tolower (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
}

extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) toupper (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
}
# 271 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int isalpha_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int iscntrl_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int isdigit_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int islower_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int isgraph_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int isprint_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int ispunct_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int isspace_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int isupper_l (int, __locale_t) __attribute__ ((__nothrow__ ));
extern int isxdigit_l (int, __locale_t) __attribute__ ((__nothrow__ ));

extern int isblank_l (int, __locale_t) __attribute__ ((__nothrow__ ));



extern int __tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ ));
extern int tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ ));


extern int __toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ ));
extern int toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ ));
# 10860 "ext/sqlite3/libsqlite/sqlite3.c" 2
# 10888 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3StrICmp(const char *, const char *);
static int sqlite3Strlen30(const char*);


static int sqlite3MallocInit(void);
static void sqlite3MallocEnd(void);
static void *sqlite3Malloc(int);
static void *sqlite3MallocZero(int);
static void *sqlite3DbMallocZero(sqlite3*, int);
static void *sqlite3DbMallocRaw(sqlite3*, int);
static char *sqlite3DbStrDup(sqlite3*,const char*);
static char *sqlite3DbStrNDup(sqlite3*,const char*, int);
static void *sqlite3Realloc(void*, int);
static void *sqlite3DbReallocOrFree(sqlite3 *, void *, int);
static void *sqlite3DbRealloc(sqlite3 *, void *, int);
static void sqlite3DbFree(sqlite3*, void*);
static int sqlite3MallocSize(void*);
static int sqlite3DbMallocSize(sqlite3*, void*);
static void *sqlite3ScratchMalloc(int);
static void sqlite3ScratchFree(void*);
static void *sqlite3PageMalloc(int);
static void sqlite3PageFree(void*);
static void sqlite3MemSetDefault(void);
static void sqlite3BenignMallocHooks(void (*)(void), void (*)(void));
static int sqlite3HeapNearlyFull(void);
# 10948 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3StatusValue(int);
static void sqlite3StatusAdd(int, int);
static void sqlite3StatusSet(int, int);


static int sqlite3IsNaN(double);




static void sqlite3VXPrintf(StrAccum*, int, const char*, va_list);

static void sqlite3XPrintf(StrAccum*, const char*, ...);

static char *sqlite3MPrintf(sqlite3*,const char*, ...);
static char *sqlite3VMPrintf(sqlite3*,const char*, va_list);
static char *sqlite3MAppendf(sqlite3*,char*,const char*,...);






static void sqlite3SetString(char **, sqlite3*, const char*, ...);
static void sqlite3ErrorMsg(Parse*, const char*, ...);
static int sqlite3Dequote(char*);
static int sqlite3KeywordCode(const unsigned char*, int);
static int sqlite3RunParser(Parse*, const char*, char **);
static void sqlite3FinishCoding(Parse*);
static int sqlite3GetTempReg(Parse*);
static void sqlite3ReleaseTempReg(Parse*,int);
static int sqlite3GetTempRange(Parse*,int);
static void sqlite3ReleaseTempRange(Parse*,int,int);
static Expr *sqlite3ExprAlloc(sqlite3*,int,const Token*,int);
static Expr *sqlite3Expr(sqlite3*,int,const char*);
static void sqlite3ExprAttachSubtrees(sqlite3*,Expr*,Expr*,Expr*);
static Expr *sqlite3PExpr(Parse*, int, Expr*, Expr*, const Token*);
static Expr *sqlite3ExprAnd(sqlite3*,Expr*, Expr*);
static Expr *sqlite3ExprFunction(Parse*,ExprList*, Token*);
static void sqlite3ExprAssignVarNumber(Parse*, Expr*);
static void sqlite3ExprDelete(sqlite3*, Expr*);
static ExprList *sqlite3ExprListAppend(Parse*,ExprList*,Expr*);
static void sqlite3ExprListSetName(Parse*,ExprList*,Token*,int);
static void sqlite3ExprListSetSpan(Parse*,ExprList*,ExprSpan*);
static void sqlite3ExprListDelete(sqlite3*, ExprList*);
static int sqlite3Init(sqlite3*, char**);
static int sqlite3InitCallback(void*, int, char**, char**);
static void sqlite3Pragma(Parse*,Token*,Token*,Token*,int);
static void sqlite3ResetInternalSchema(sqlite3*, int);
static void sqlite3BeginParse(Parse*,int);
static void sqlite3CommitInternalChanges(sqlite3*);
static Table *sqlite3ResultSetOfSelect(Parse*,Select*);
static void sqlite3OpenMasterTable(Parse *, int);
static void sqlite3StartTable(Parse*,Token*,Token*,int,int,int,int);
static void sqlite3AddColumn(Parse*,Token*);
static void sqlite3AddNotNull(Parse*, int);
static void sqlite3AddPrimaryKey(Parse*, ExprList*, int, int, int);
static void sqlite3AddCheckConstraint(Parse*, Expr*);
static void sqlite3AddColumnType(Parse*,Token*);
static void sqlite3AddDefaultValue(Parse*,ExprSpan*);
static void sqlite3AddCollateType(Parse*, Token*);
static void sqlite3EndTable(Parse*,Token*,Token*,Select*);

static Bitvec *sqlite3BitvecCreate(u32);
static int sqlite3BitvecTest(Bitvec*, u32);
static int sqlite3BitvecSet(Bitvec*, u32);
static void sqlite3BitvecClear(Bitvec*, u32, void*);
static void sqlite3BitvecDestroy(Bitvec*);
static u32 sqlite3BitvecSize(Bitvec*);
static int sqlite3BitvecBuiltinTest(int,int*);

static RowSet *sqlite3RowSetInit(sqlite3*, void*, unsigned int);
static void sqlite3RowSetClear(RowSet*);
static void sqlite3RowSetInsert(RowSet*, i64);
static int sqlite3RowSetTest(RowSet*, u8 iBatch, i64);
static int sqlite3RowSetNext(RowSet*, i64*);

static void sqlite3CreateView(Parse*,Token*,Token*,Token*,Select*,int,int);


static int sqlite3ViewGetColumnNames(Parse*,Table*);




static void sqlite3DropTable(Parse*, SrcList*, int, int);
static void sqlite3DeleteTable(sqlite3*, Table*);

static void sqlite3AutoincrementBegin(Parse *pParse);
static void sqlite3AutoincrementEnd(Parse *pParse);




static void sqlite3Insert(Parse*, SrcList*, ExprList*, Select*, IdList*, int);
static void *sqlite3ArrayAllocate(sqlite3*,void*,int,int,int*,int*,int*);
static IdList *sqlite3IdListAppend(sqlite3*, IdList*, Token*);
static int sqlite3IdListIndex(IdList*,const char*);
static SrcList *sqlite3SrcListEnlarge(sqlite3*, SrcList*, int, int);
static SrcList *sqlite3SrcListAppend(sqlite3*, SrcList*, Token*, Token*);
static SrcList *sqlite3SrcListAppendFromTerm(Parse*, SrcList*, Token*, Token*,
                                      Token*, Select*, Expr*, IdList*);
static void sqlite3SrcListIndexedBy(Parse *, SrcList *, Token *);
static int sqlite3IndexedByLookup(Parse *, struct SrcList_item *);
static void sqlite3SrcListShiftJoinType(SrcList*);
static void sqlite3SrcListAssignCursors(Parse*, SrcList*);
static void sqlite3IdListDelete(sqlite3*, IdList*);
static void sqlite3SrcListDelete(sqlite3*, SrcList*);
static Index *sqlite3CreateIndex(Parse*,Token*,Token*,SrcList*,ExprList*,int,Token*,
                        Token*, int, int);
static void sqlite3DropIndex(Parse*, SrcList*, int);
static int sqlite3Select(Parse*, Select*, SelectDest*);
static Select *sqlite3SelectNew(Parse*,ExprList*,SrcList*,Expr*,ExprList*,
                         Expr*,ExprList*,int,Expr*,Expr*);
static void sqlite3SelectDelete(sqlite3*, Select*);
static Table *sqlite3SrcListLookup(Parse*, SrcList*);
static int sqlite3IsReadOnly(Parse*, Table*, int);
static void sqlite3OpenTable(Parse*, int iCur, int iDb, Table*, int);



static void sqlite3DeleteFrom(Parse*, SrcList*, Expr*);
static void sqlite3Update(Parse*, SrcList*, ExprList*, Expr*, int);
static WhereInfo *sqlite3WhereBegin(Parse*, SrcList*, Expr*, ExprList**, u16);
static void sqlite3WhereEnd(WhereInfo*);
static int sqlite3ExprCodeGetColumn(Parse*, Table*, int, int, int);
static void sqlite3ExprCodeGetColumnOfTable(Vdbe*, Table*, int, int, int);
static void sqlite3ExprCodeMove(Parse*, int, int, int);
static void sqlite3ExprCodeCopy(Parse*, int, int, int);
static void sqlite3ExprCacheStore(Parse*, int, int, int);
static void sqlite3ExprCachePush(Parse*);
static void sqlite3ExprCachePop(Parse*, int);
static void sqlite3ExprCacheRemove(Parse*, int, int);
static void sqlite3ExprCacheClear(Parse*);
static void sqlite3ExprCacheAffinityChange(Parse*, int, int);
static int sqlite3ExprCode(Parse*, Expr*, int);
static int sqlite3ExprCodeTemp(Parse*, Expr*, int*);
static int sqlite3ExprCodeTarget(Parse*, Expr*, int);
static int sqlite3ExprCodeAndCache(Parse*, Expr*, int);
static void sqlite3ExprCodeConstants(Parse*, Expr*);
static int sqlite3ExprCodeExprList(Parse*, ExprList*, int, int);
static void sqlite3ExprIfTrue(Parse*, Expr*, int, int);
static void sqlite3ExprIfFalse(Parse*, Expr*, int, int);
static Table *sqlite3FindTable(sqlite3*,const char*, const char*);
static Table *sqlite3LocateTable(Parse*,int isView,const char*, const char*);
static Index *sqlite3FindIndex(sqlite3*,const char*, const char*);
static void sqlite3UnlinkAndDeleteTable(sqlite3*,int,const char*);
static void sqlite3UnlinkAndDeleteIndex(sqlite3*,int,const char*);
static void sqlite3Vacuum(Parse*);
static int sqlite3RunVacuum(char**, sqlite3*);
static char *sqlite3NameFromToken(sqlite3*, Token*);
static int sqlite3ExprCompare(Expr*, Expr*);
static int sqlite3ExprListCompare(ExprList*, ExprList*);
static void sqlite3ExprAnalyzeAggregates(NameContext*, Expr*);
static void sqlite3ExprAnalyzeAggList(NameContext*,ExprList*);
static Vdbe *sqlite3GetVdbe(Parse*);
static void sqlite3PrngSaveState(void);
static void sqlite3PrngRestoreState(void);
static void sqlite3PrngResetState(void);
static void sqlite3RollbackAll(sqlite3*);
static void sqlite3CodeVerifySchema(Parse*, int);
static void sqlite3CodeVerifyNamedSchema(Parse*, const char *zDb);
static void sqlite3BeginTransaction(Parse*, int);
static void sqlite3CommitTransaction(Parse*);
static void sqlite3RollbackTransaction(Parse*);
static void sqlite3Savepoint(Parse*, int, Token*);
static void sqlite3CloseSavepoints(sqlite3 *);
static int sqlite3ExprIsConstant(Expr*);
static int sqlite3ExprIsConstantNotJoin(Expr*);
static int sqlite3ExprIsConstantOrFunction(Expr*);
static int sqlite3ExprIsInteger(Expr*, int*);
static int sqlite3ExprCanBeNull(const Expr*);
static void sqlite3ExprCodeIsNullJump(Vdbe*, const Expr*, int, int);
static int sqlite3ExprNeedsNoAffinityChange(const Expr*, char);
static int sqlite3IsRowid(const char*);
static void sqlite3GenerateRowDelete(Parse*, Table*, int, int, int, Trigger *, int);
static void sqlite3GenerateRowIndexDelete(Parse*, Table*, int, int*);
static int sqlite3GenerateIndexKey(Parse*, Index*, int, int, int);
static void sqlite3GenerateConstraintChecks(Parse*,Table*,int,int,
                                     int*,int,int,int,int,int*);
static void sqlite3CompleteInsertion(Parse*, Table*, int, int, int*, int, int, int);
static int sqlite3OpenTableAndIndices(Parse*, Table*, int, int);
static void sqlite3BeginWriteOperation(Parse*, int, int);
static void sqlite3MultiWrite(Parse*);
static void sqlite3MayAbort(Parse*);
static void sqlite3HaltConstraint(Parse*, int, char*, int);
static Expr *sqlite3ExprDup(sqlite3*,Expr*,int);
static ExprList *sqlite3ExprListDup(sqlite3*,ExprList*,int);
static SrcList *sqlite3SrcListDup(sqlite3*,SrcList*,int);
static IdList *sqlite3IdListDup(sqlite3*,IdList*);
static Select *sqlite3SelectDup(sqlite3*,Select*,int);
static void sqlite3FuncDefInsert(FuncDefHash*, FuncDef*);
static FuncDef *sqlite3FindFunction(sqlite3*,const char*,int,int,u8,int);
static void sqlite3RegisterBuiltinFunctions(sqlite3*);
static void sqlite3RegisterDateTimeFunctions(void);
static void sqlite3RegisterGlobalFunctions(void);
static int sqlite3SafetyCheckOk(sqlite3*);
static int sqlite3SafetyCheckSickOrOk(sqlite3*);
static void sqlite3ChangeCookie(Parse*, int);


static void sqlite3MaterializeView(Parse*, Table*, Expr*, int);



static void sqlite3BeginTrigger(Parse*, Token*,Token*,int,int,IdList*,SrcList*,
                           Expr*,int, int);
static void sqlite3FinishTrigger(Parse*, TriggerStep*, Token*);
static void sqlite3DropTrigger(Parse*, SrcList*, int);
static void sqlite3DropTriggerPtr(Parse*, Trigger*);
static Trigger *sqlite3TriggersExist(Parse *, Table*, int, ExprList*, int *pMask);
static Trigger *sqlite3TriggerList(Parse *, Table *);
static void sqlite3CodeRowTrigger(Parse*, Trigger *, int, ExprList*, int, Table *,
                            int, int, int);
static void sqlite3CodeRowTriggerDirect(Parse *, Trigger *, Table *, int, int, int);
  void sqliteViewTriggers(Parse*, Table*, Expr*, int, ExprList*);
static void sqlite3DeleteTriggerStep(sqlite3*, TriggerStep*);
static TriggerStep *sqlite3TriggerSelectStep(sqlite3*,Select*);
static TriggerStep *sqlite3TriggerInsertStep(sqlite3*,Token*, IdList*,
                                        ExprList*,Select*,u8);
static TriggerStep *sqlite3TriggerUpdateStep(sqlite3*,Token*,ExprList*, Expr*, u8);
static TriggerStep *sqlite3TriggerDeleteStep(sqlite3*,Token*, Expr*);
static void sqlite3DeleteTrigger(sqlite3*, Trigger*);
static void sqlite3UnlinkAndDeleteTrigger(sqlite3*,int,const char*);
static u32 sqlite3TriggerColmask(Parse*,Trigger*,ExprList*,int,int,Table*,int);
# 11186 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3JoinType(Parse*, Token*, Token*, Token*);
static void sqlite3CreateForeignKey(Parse*, ExprList*, Token*, ExprList*, int);
static void sqlite3DeferForeignKey(Parse*, int);

static void sqlite3AuthRead(Parse*,Expr*,Schema*,SrcList*);
static int sqlite3AuthCheck(Parse*,int, const char*, const char*, const char*);
static void sqlite3AuthContextPush(Parse*, AuthContext*, const char*);
static void sqlite3AuthContextPop(AuthContext*);
static int sqlite3AuthReadCol(Parse*, const char *, const char *, int);






static void sqlite3Attach(Parse*, Expr*, Expr*, Expr*);
static void sqlite3Detach(Parse*, Expr*);
static int sqlite3FixInit(DbFixer*, Parse*, int, const char*, const Token*);
static int sqlite3FixSrcList(DbFixer*, SrcList*);
static int sqlite3FixSelect(DbFixer*, Select*);
static int sqlite3FixExpr(DbFixer*, Expr*);
static int sqlite3FixExprList(DbFixer*, ExprList*);
static int sqlite3FixTriggerStep(DbFixer*, TriggerStep*);
static int sqlite3AtoF(const char *z, double*, int, u8);
static int sqlite3GetInt32(const char *, int*);
static int sqlite3Atoi(const char*);
static int sqlite3Utf16ByteLen(const void *pData, int nChar);
static int sqlite3Utf8CharLen(const char *pData, int nByte);
static int sqlite3Utf8Read(const u8*, const u8**);
# 11223 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PutVarint(unsigned char*, u64);
static int sqlite3PutVarint32(unsigned char*, u32);
static u8 sqlite3GetVarint(const unsigned char *, u64 *);
static u8 sqlite3GetVarint32(const unsigned char *, u32 *);
static int sqlite3VarintLen(u64 v);
# 11252 "ext/sqlite3/libsqlite/sqlite3.c"
static const char *sqlite3IndexAffinityStr(Vdbe *, Index *);
static void sqlite3TableAffinityStr(Vdbe *, Table *);
static char sqlite3CompareAffinity(Expr *pExpr, char aff2);
static int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity);
static char sqlite3ExprAffinity(Expr *pExpr);
static int sqlite3Atoi64(const char*, i64*, int, u8);
static void sqlite3Error(sqlite3*, int, const char*,...);
static void *sqlite3HexToBlob(sqlite3*, const char *z, int n);
static int sqlite3TwoPartName(Parse *, Token *, Token *, Token **);
static const char *sqlite3ErrStr(int);
static int sqlite3ReadSchema(Parse *pParse);
static CollSeq *sqlite3FindCollSeq(sqlite3*,u8 enc, const char*,int);
static CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char*zName);
static CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr);
static Expr *sqlite3ExprSetColl(Expr*, CollSeq*);
static Expr *sqlite3ExprSetCollByToken(Parse *pParse, Expr*, Token*);
static int sqlite3CheckCollSeq(Parse *, CollSeq *);
static int sqlite3CheckObjectName(Parse *, const char *);
static void sqlite3VdbeSetChanges(sqlite3 *, int);
static int sqlite3AddInt64(i64*,i64);
static int sqlite3SubInt64(i64*,i64);
static int sqlite3MulInt64(i64*,i64);
static int sqlite3AbsInt32(int);

static const void *sqlite3ValueText(sqlite3_value*, u8);
static int sqlite3ValueBytes(sqlite3_value*, u8);
static void sqlite3ValueSetStr(sqlite3_value*, int, const void *,u8,
                        void(*)(void*));
static void sqlite3ValueFree(sqlite3_value*);
static sqlite3_value *sqlite3ValueNew(sqlite3 *);
static char *sqlite3Utf16to8(sqlite3 *, const void*, int, u8);



static int sqlite3ValueFromExpr(sqlite3 *, Expr *, u8, u8, sqlite3_value **);
static void sqlite3ValueApplyAffinity(sqlite3_value *, u8, u8);
# 11299 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3RootPageMoved(sqlite3*, int, int, int);
static void sqlite3Reindex(Parse*, Token*, Token*);
static void sqlite3AlterFunctions(void);
static void sqlite3AlterRenameTable(Parse*, SrcList*, Token*);
static int sqlite3GetToken(const unsigned char *, int *);
static void sqlite3NestedParse(Parse*, const char*, ...);
static void sqlite3ExpirePreparedStatements(sqlite3*);
static int sqlite3CodeSubselect(Parse *, Expr *, int, int);
static void sqlite3SelectPrep(Parse*, Select*, NameContext*);
static int sqlite3ResolveExprNames(NameContext*, Expr*);
static void sqlite3ResolveSelectNames(Parse*, Select*, NameContext*);
static int sqlite3ResolveOrderGroupBy(Parse*, Select*, ExprList*, const char*);
static void sqlite3ColumnDefault(Vdbe *, Table *, int, int);
static void sqlite3AlterFinishAddColumn(Parse *, Token *);
static void sqlite3AlterBeginAddColumn(Parse *, SrcList *);
static CollSeq *sqlite3GetCollSeq(sqlite3*, u8, CollSeq *, const char*);
static char sqlite3AffinityType(const char*);
static void sqlite3Analyze(Parse*, Token*, Token*);
static int sqlite3InvokeBusyHandler(BusyHandler*);
static int sqlite3FindDb(sqlite3*, Token*);
static int sqlite3FindDbName(sqlite3 *, const char *);
static int sqlite3AnalysisLoad(sqlite3*,int iDB);
static void sqlite3DeleteIndexSamples(sqlite3*,Index*);
static void sqlite3DefaultRowEst(Index*);
static void sqlite3RegisterLikeFunctions(sqlite3*, int);
static int sqlite3IsLikeFunction(sqlite3*,Expr*,int*,char*);
static void sqlite3MinimumFileFormat(Parse*, int, int);
static void sqlite3SchemaClear(void *);
static Schema *sqlite3SchemaGet(sqlite3 *, Btree *);
static int sqlite3SchemaToIndex(sqlite3 *db, Schema *);
static KeyInfo *sqlite3IndexKeyinfo(Parse *, Index *);
static int sqlite3CreateFunc(sqlite3 *, const char *, int, int, void *,
  void (*)(sqlite3_context*,int,sqlite3_value **),
  void (*)(sqlite3_context*,int,sqlite3_value **), void (*)(sqlite3_context*),
  FuncDestructor *pDestructor
);
static int sqlite3ApiExit(sqlite3 *db, int);
static int sqlite3OpenTempDatabase(Parse *);

static void sqlite3StrAccumInit(StrAccum*, char*, int, int);
static void sqlite3StrAccumAppend(StrAccum*,const char*,int);
static char *sqlite3StrAccumFinish(StrAccum*);
static void sqlite3StrAccumReset(StrAccum*);
static void sqlite3SelectDestInit(SelectDest*,int,int);
static Expr *sqlite3CreateColumnExpr(sqlite3 *, SrcList *, int, int);

static void sqlite3BackupRestart(sqlite3_backup *);
static void sqlite3BackupUpdate(sqlite3_backup *, Pgno, const u8 *);




static void *sqlite3ParserAlloc(void*(*)(size_t));
static void sqlite3ParserFree(void*, void(*)(void*));
static void sqlite3Parser(void*, int, Token, Parse*);




static void sqlite3AutoLoadExtensions(sqlite3*);

static void sqlite3CloseExtensions(sqlite3*);





static void sqlite3TableLock(Parse *, int, int, u8, const char *);
# 11385 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3VtabClear(sqlite3 *db, Table*);
static int sqlite3VtabSync(sqlite3 *db, char **);
static int sqlite3VtabRollback(sqlite3 *db);
static int sqlite3VtabCommit(sqlite3 *db);
static void sqlite3VtabLock(VTable *);
static void sqlite3VtabUnlock(VTable *);
static void sqlite3VtabUnlockList(sqlite3*);


static void sqlite3VtabMakeWritable(Parse*,Table*);
static void sqlite3VtabBeginParse(Parse*, Token*, Token*, Token*);
static void sqlite3VtabFinishParse(Parse*, Token*);
static void sqlite3VtabArgInit(Parse*);
static void sqlite3VtabArgExtend(Parse*, Token*);
static int sqlite3VtabCallCreate(sqlite3*, int, const char *, char **);
static int sqlite3VtabCallConnect(Parse*, Table*);
static int sqlite3VtabCallDestroy(sqlite3*, int, const char *);
static int sqlite3VtabBegin(sqlite3 *, VTable *);
static FuncDef *sqlite3VtabOverloadFunction(sqlite3 *,FuncDef*, int nArg, Expr*);
static void sqlite3InvalidFunction(sqlite3_context*,int,sqlite3_value**);
static int sqlite3VdbeParameterIndex(Vdbe*, const char*, int);
static int sqlite3TransferBindings(sqlite3_stmt *, sqlite3_stmt *);
static int sqlite3Reprepare(Vdbe*);
static void sqlite3ExprListCheckLength(Parse*, ExprList*, const char*);
static CollSeq *sqlite3BinaryCompareCollSeq(Parse *, Expr *, Expr *);
static int sqlite3TempInMemory(const sqlite3*);
static VTable *sqlite3GetVTable(sqlite3*, Table*);
static const char *sqlite3JournalModename(int);
static int sqlite3Checkpoint(sqlite3*, int, int, int*, int*);
static int sqlite3WalDefaultHook(void*,sqlite3*,const char*,int);
# 11424 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3FkCheck(Parse*, Table*, int, int);
static void sqlite3FkDropTable(Parse*, SrcList *, Table*);
static void sqlite3FkActions(Parse*, Table*, ExprList*, int);
static int sqlite3FkRequired(Parse*, Table*, int*, int);
static u32 sqlite3FkOldmask(Parse*, Table*);
static FKey *sqlite3FkReferences(Table *);
# 11438 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3FkDelete(sqlite3 *, Table*);
# 11456 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3BeginBenignMalloc(void);
static void sqlite3EndBenignMalloc(void);
# 11466 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3FindInIndex(Parse *, Expr *, int*);
# 11476 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3MemJournalOpen(sqlite3_file *);
static int sqlite3MemJournalSize(void);
static int sqlite3IsMemJournal(sqlite3_file *);


static void sqlite3ExprSetHeight(Parse *pParse, Expr *p);
static int sqlite3SelectExprHeight(Select *);
static int sqlite3ExprCheckHeight(Parse*, int);






static u32 sqlite3Get4byte(const u8*);
static void sqlite3Put4byte(u8*, u32);
# 11590 "ext/sqlite3/libsqlite/sqlite3.c"
static const unsigned char sqlite3UpperToLower[] = {

      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
     18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
     36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
     54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99,100,101,102,103,
    104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,
    122, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,104,105,106,107,
    108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,
    126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
    144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,
    162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,
    180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,
    198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,
    216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,
    234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,
    252,253,254,255
# 11626 "ext/sqlite3/libsqlite/sqlite3.c"
};
# 11659 "ext/sqlite3/libsqlite/sqlite3.c"
static const unsigned char sqlite3CtypeMap[256] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
  0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x02,
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
  0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x40,
  0x00, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x22,
  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
  0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,

  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40
};
# 11704 "ext/sqlite3/libsqlite/sqlite3.c"
static struct Sqlite3Config sqlite3Config = {
   1,
   1,
   0==1,
   0x7ffffffe,
   100,
   500,
   {0,0,0,0,0,0,0,0},
   {0,0,0,0,0,0,0,0,0},
   {0,0,0,0,0,0,0,0,0,0,0},
   (void*)0,
   0,
   0, 0,
   (void*)0,
   0,
   0,
   (void*)0,
   0,
   0,
   0,
   0,

   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0,
};







static FuncDefHash sqlite3GlobalFunctions;




static const Token sqlite3IntTokens[] = {
   { "0", 1 },
   { "1", 1 }
};
# 11773 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PendingByte = 0x40000000;
# 11782 "ext/sqlite3/libsqlite/sqlite3.c"
static const unsigned char sqlite3OpcodeProperty[] = { 0x00, 0x01, 0x05, 0x04, 0x04, 0x10, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00, 0x24, 0x24, 0x00, 0x00, 0x00, 0x24, 0x04, 0x05, 0x04, 0x00, 0x00, 0x01, 0x05, 0x05, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11, 0x08, 0x11, 0x11, 0x11, 0x11, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x4c, 0x4c, 0x08, 0x00, 0x02, 0x05, 0x05, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x01, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x01, 0x24, 0x02, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x45, 0x15, 0x01, 0x02, 0x00, 0x01, 0x08, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x01, 0x00, 0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x04,};
# 11813 "ext/sqlite3/libsqlite/sqlite3.c"
static const char * const azCompileOpt[] = {
# 11854 "ext/sqlite3/libsqlite/sqlite3.c"
  "ENABLE_COLUMN_METADATA",
# 11866 "ext/sqlite3/libsqlite/sqlite3.c"
  "ENABLE_FTS3",
# 12129 "ext/sqlite3/libsqlite/sqlite3.c"
  "TEMP_STORE=" "1",





  "THREADSAFE=" "0",







};
# 12152 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_compileoption_used(const char *zOptName){
  int i, n;
  if( sqlite3_strnicmp(zOptName, "SQLITE_", 7)==0 ) zOptName += 7;
  n = sqlite3Strlen30(zOptName);



  for(i=0; i<((int)(sizeof(azCompileOpt)/sizeof(azCompileOpt[0]))); i++){
    if( (sqlite3_strnicmp(zOptName, azCompileOpt[i], n)==0)
       && ( (azCompileOpt[i][n]==0) || (azCompileOpt[i][n]=='=') ) ) return 1;
  }
  return 0;
}





           const char *sqlite3_compileoption_get(int N){
  if( N>=0 && N<((int)(sizeof(azCompileOpt)/sizeof(azCompileOpt[0]))) ){
    return azCompileOpt[N];
  }
  return 0;
}
# 12223 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct VdbeOp Op;




typedef unsigned char Bool;
# 12240 "ext/sqlite3/libsqlite/sqlite3.c"
struct VdbeCursor {
  BtCursor *pCursor;
  Btree *pBt;
  KeyInfo *pKeyInfo;
  int iDb;
  int pseudoTableReg;
  int nField;
  Bool zeroed;
  Bool rowidIsValid;
  Bool atFirst;
  Bool useRandomRowid;
  Bool nullRow;
  Bool deferredMoveto;
  Bool isTable;
  Bool isIndex;
  Bool isOrdered;
  sqlite3_vtab_cursor *pVtabCursor;
  const sqlite3_module *pModule;
  i64 seqCount;
  i64 movetoTarget;
  i64 lastRowid;



  int seekResult;
# 12275 "ext/sqlite3/libsqlite/sqlite3.c"
  u32 cacheStatus;
  int payloadSize;
  u32 *aType;
  u32 *aOffset;
  u8 *aRow;
};
typedef struct VdbeCursor VdbeCursor;
# 12304 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct VdbeFrame VdbeFrame;
struct VdbeFrame {
  Vdbe *v;
  int pc;
  Op *aOp;
  int nOp;
  Mem *aMem;
  int nMem;
  VdbeCursor **apCsr;
  u16 nCursor;
  void *token;
  int nChildMem;
  int nChildCsr;
  i64 lastRowid;
  int nChange;
  VdbeFrame *pParent;
};
# 12334 "ext/sqlite3/libsqlite/sqlite3.c"
struct Mem {
  sqlite3 *db;
  char *z;
  double r;
  union {
    i64 i;
    int nZero;
    FuncDef *pDef;
    RowSet *pRowSet;
    VdbeFrame *pFrame;
  } u;
  int n;
  u16 flags;
  u8 type;
  u8 enc;




  void (*xDel)(void *);
  char *zMalloc;
};
# 12419 "ext/sqlite3/libsqlite/sqlite3.c"
struct VdbeFunc {
  FuncDef *pFunc;
  int nAux;
  struct AuxData {
    void *pAux;
    void (*xDelete)(void *);
  } apAux[1];
};
# 12441 "ext/sqlite3/libsqlite/sqlite3.c"
struct sqlite3_context {
  FuncDef *pFunc;
  VdbeFunc *pVdbeFunc;
  Mem s;
  Mem *pMem;
  int isError;
  CollSeq *pColl;
};
# 12465 "ext/sqlite3/libsqlite/sqlite3.c"
struct Vdbe {
  sqlite3 *db;
  Op *aOp;
  Mem *aMem;
  Mem **apArg;
  Mem *aColName;
  Mem *pResultSet;
  int nMem;
  int nOp;
  int nOpAlloc;
  int nLabel;
  int nLabelAlloc;
  int *aLabel;
  u16 nResColumn;
  u16 nCursor;
  u32 magic;
  char *zErrMsg;
  Vdbe *pPrev,*pNext;
  VdbeCursor **apCsr;
  Mem *aVar;
  char **azVar;
  ynVar nVar;
  u32 cacheCtr;
  int pc;
  int rc;
  u8 errorAction;
  u8 okVar;
  u8 explain;
  u8 changeCntOn;
  u8 expired;
  u8 runOnlyOnce;
  u8 minWriteFileFormat;
  u8 inVtabMethod;
  u8 usesStmtJournal;
  u8 readOnly;
  u8 isPrepareV2;
  int nChange;
  yDbMask btreeMask;
  yDbMask lockMask;
  int iStatement;
  int aCounter[3];

  i64 startTime;

  i64 nFkConstraint;
  i64 nStmtDefCons;
  char *zSql;
  void *pFree;



  VdbeFrame *pFrame;
  VdbeFrame *pDelFrame;
  int nFrame;
  u32 expmask;
  SubProgram *pProgram;
};
# 12534 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3VdbeFreeCursor(Vdbe *, VdbeCursor*);
void sqliteVdbePopStack(Vdbe*,int);
static int sqlite3VdbeCursorMoveto(VdbeCursor*);



static u32 sqlite3VdbeSerialTypeLen(u32);
static u32 sqlite3VdbeSerialType(Mem*, int);
static u32 sqlite3VdbeSerialPut(unsigned char*, int, Mem*, int);
static u32 sqlite3VdbeSerialGet(const unsigned char*, u32, Mem*);
static void sqlite3VdbeDeleteAuxData(VdbeFunc*, int);

int sqlite2BtreeKeyCompare(BtCursor *, const void *, int, int, int *);
static int sqlite3VdbeIdxKeyCompare(VdbeCursor*,UnpackedRecord*,int*);
static int sqlite3VdbeIdxRowid(sqlite3*, BtCursor *, i64 *);
static int sqlite3MemCompare(const Mem*, const Mem*, const CollSeq*);
static int sqlite3VdbeExec(Vdbe*);
static int sqlite3VdbeList(Vdbe*);
static int sqlite3VdbeHalt(Vdbe*);
static int sqlite3VdbeChangeEncoding(Mem *, int);
static int sqlite3VdbeMemTooBig(Mem*);
static int sqlite3VdbeMemCopy(Mem*, const Mem*);
static void sqlite3VdbeMemShallowCopy(Mem*, const Mem*, int);
static void sqlite3VdbeMemMove(Mem*, Mem*);
static int sqlite3VdbeMemNulTerminate(Mem*);
static int sqlite3VdbeMemSetStr(Mem*, const char*, int, u8, void(*)(void*));
static void sqlite3VdbeMemSetInt64(Mem*, i64);



static void sqlite3VdbeMemSetDouble(Mem*, double);

static void sqlite3VdbeMemSetNull(Mem*);
static void sqlite3VdbeMemSetZeroBlob(Mem*,int);
static void sqlite3VdbeMemSetRowSet(Mem*);
static int sqlite3VdbeMemMakeWriteable(Mem*);
static int sqlite3VdbeMemStringify(Mem*, int);
static i64 sqlite3VdbeIntValue(Mem*);
static int sqlite3VdbeMemIntegerify(Mem*);
static double sqlite3VdbeRealValue(Mem*);
static void sqlite3VdbeIntegerAffinity(Mem*);
static int sqlite3VdbeMemRealify(Mem*);
static int sqlite3VdbeMemNumerify(Mem*);
static int sqlite3VdbeMemFromBtree(BtCursor*,int,int,int,Mem*);
static void sqlite3VdbeMemRelease(Mem *p);
static void sqlite3VdbeMemReleaseExternal(Mem *p);
static int sqlite3VdbeMemFinalize(Mem*, FuncDef*);
static const char *sqlite3OpcodeName(int);
static int sqlite3VdbeMemGrow(Mem *pMem, int n, int preserve);
static int sqlite3VdbeCloseStatement(Vdbe *, int);
static void sqlite3VdbeFrameDelete(VdbeFrame*);
static int sqlite3VdbeFrameRestore(VdbeFrame *);
static void sqlite3VdbeMemStoreType(Mem *pMem);
# 12601 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeCheckFk(Vdbe *, int);




static int sqlite3VdbeMemTranslate(Mem*, u8);




static int sqlite3VdbeMemHandleBom(Mem *pMem);


static int sqlite3VdbeMemExpandBlob(Mem *);
# 12627 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct sqlite3StatType sqlite3StatType;
static struct sqlite3StatType {
  int nowValue[10];
  int mxValue[10];
} sqlite3Stat = { {0,}, {0,} };
# 12651 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3StatusValue(int op){
             ;
  ((void) (0));
  return sqlite3Stat.nowValue[op];
}





static void sqlite3StatusAdd(int op, int N){
             ;
  ((void) (0));
  sqlite3Stat.nowValue[op] += N;
  if( sqlite3Stat.nowValue[op]>sqlite3Stat.mxValue[op] ){
    sqlite3Stat.mxValue[op] = sqlite3Stat.nowValue[op];
  }
}




static void sqlite3StatusSet(int op, int X){
             ;
  ((void) (0));
  sqlite3Stat.nowValue[op] = X;
  if( sqlite3Stat.nowValue[op]>sqlite3Stat.mxValue[op] ){
    sqlite3Stat.mxValue[op] = sqlite3Stat.nowValue[op];
  }
}
# 12689 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag){
             ;
  if( op<0 || op>=((int)(sizeof(sqlite3Stat.nowValue)/sizeof(sqlite3Stat.nowValue[0]))) ){
    return sqlite3MisuseError(12692);
  }
  *pCurrent = sqlite3Stat.nowValue[op];
  *pHighwater = sqlite3Stat.mxValue[op];
  if( resetFlag ){
    sqlite3Stat.mxValue[op] = sqlite3Stat.nowValue[op];
  }
  return 0;
}




           int sqlite3_db_status(
  sqlite3 *db,
  int op,
  int *pCurrent,
  int *pHighwater,
  int resetFlag
){
  int rc = 0;
                                ;
  switch( op ){
    case 0: {
      *pCurrent = db->lookaside.nOut;
      *pHighwater = db->lookaside.mxOut;
      if( resetFlag ){
        db->lookaside.mxOut = db->lookaside.nOut;
      }
      break;
    }

    case 4:
    case 5:
    case 6: {
                                                   ;
                                                         ;
                                                         ;
      ((void) (0));
      ((void) (0));
      *pCurrent = 0;
      *pHighwater = db->lookaside.anStat[op - 4];
      if( resetFlag ){
        db->lookaside.anStat[op - 4] = 0;
      }
      break;
    }






    case 1: {
      int totalUsed = 0;
      int i;
      sqlite3BtreeEnterAll(db);
      for(i=0; i<db->nDb; i++){
        Btree *pBt = db->aDb[i].pBt;
        if( pBt ){
          Pager *pPager = sqlite3BtreePager(pBt);
          totalUsed += sqlite3PagerMemUsed(pPager);
        }
      }
                              ;
      *pCurrent = totalUsed;
      *pHighwater = 0;
      break;
    }






    case 2: {
      int i;
      int nByte = 0;

      sqlite3BtreeEnterAll(db);
      db->pnBytesFreed = &nByte;
      for(i=0; i<db->nDb; i++){
        Schema *pSchema = db->aDb[i].pSchema;
        if( (pSchema!=0) ){
          HashElem *p;

          nByte += sqlite3Config.m.xRoundup(sizeof(HashElem)) * (
              pSchema->tblHash.count
            + pSchema->trigHash.count
            + pSchema->idxHash.count
            + pSchema->fkeyHash.count
          );
          nByte += sqlite3MallocSize(pSchema->tblHash.ht);
          nByte += sqlite3MallocSize(pSchema->trigHash.ht);
          nByte += sqlite3MallocSize(pSchema->idxHash.ht);
          nByte += sqlite3MallocSize(pSchema->fkeyHash.ht);

          for(p=((&pSchema->trigHash)->first); p; p=((p)->next)){
            sqlite3DeleteTrigger(db, (Trigger*)((p)->data));
          }
          for(p=((&pSchema->tblHash)->first); p; p=((p)->next)){
            sqlite3DeleteTable(db, (Table *)((p)->data));
          }
        }
      }
      db->pnBytesFreed = 0;
                              ;

      *pHighwater = 0;
      *pCurrent = nByte;
      break;
    }






    case 3: {
      struct Vdbe *pVdbe;
      int nByte = 0;

      db->pnBytesFreed = &nByte;
      for(pVdbe=db->pVdbe; pVdbe; pVdbe=pVdbe->pNext){
        sqlite3VdbeDeleteObject(db, pVdbe);
      }
      db->pnBytesFreed = 0;

      *pHighwater = 0;
      *pCurrent = nByte;

      break;
    }

    default: {
      rc = 1;
    }
  }
                                ;
  return rc;
}
# 12881 "ext/sqlite3/libsqlite/sqlite3.c"
# 1 "/usr/include/time.h" 1 3 4
# 37 "/usr/include/time.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 38 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 86 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 87 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4




extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __attribute__ ((__nothrow__ ));
# 42 "/usr/include/time.h" 2 3 4
# 133 "/usr/include/time.h" 3 4
struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 161 "/usr/include/time.h" 3 4
struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
# 189 "/usr/include/time.h" 3 4
extern clock_t clock (void) __attribute__ ((__nothrow__ ));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ ));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ )) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ ));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ ));





extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__ ));







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) __attribute__ ((__nothrow__ ));



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) __attribute__ ((__nothrow__ ));






extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ ));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ ));





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ ));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ ));





extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ ));


extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ ));







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ ));


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ ));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ ));



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) __attribute__ ((__nothrow__ ));
# 319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ ));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ ));


extern int dysize (int __year) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 334 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ ));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ ));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ ));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ ));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ ));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ ));


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ ));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ ));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ ));





extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 403 "/usr/include/time.h" 3 4
extern int getdate_err;
# 412 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 426 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);
# 12882 "ext/sqlite3/libsqlite/sqlite3.c" 2
# 12905 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct DateTime DateTime;
struct DateTime {
  sqlite3_int64 iJD;
  int Y, M, D;
  int h, m;
  int tz;
  double s;
  char validYMD;
  char validHMS;
  char validJD;
  char validTZ;
};
# 12932 "ext/sqlite3/libsqlite/sqlite3.c"
static int getDigits(const char *zDate, ...){
  va_list ap;
  int val;
  int N;
  int min;
  int max;
  int nextC;
  int *pVal;
  int cnt = 0;
  __builtin_va_start(ap, zDate);
  do{
    N = __builtin_va_arg(ap, int);
    min = __builtin_va_arg(ap, int);
    max = __builtin_va_arg(ap, int);
    nextC = __builtin_va_arg(ap, int);
    pVal = __builtin_va_arg(ap, int*);
    val = 0;
    while( N-- ){
      if( !(sqlite3CtypeMap[(unsigned char)(*zDate)]&0x04) ){
        goto end_getDigits;
      }
      val = val*10 + *zDate - '0';
      zDate++;
    }
    if( val<min || val>max || (nextC!=0 && nextC!=*zDate) ){
      goto end_getDigits;
    }
    *pVal = val;
    zDate++;
    cnt++;
  }while( nextC );
end_getDigits:
  __builtin_va_end(ap);
  return cnt;
}
# 12984 "ext/sqlite3/libsqlite/sqlite3.c"
static int parseTimezone(const char *zDate, DateTime *p){
  int sgn = 0;
  int nHr, nMn;
  int c;
  while( (sqlite3CtypeMap[(unsigned char)(*zDate)]&0x01) ){ zDate++; }
  p->tz = 0;
  c = *zDate;
  if( c=='-' ){
    sgn = -1;
  }else if( c=='+' ){
    sgn = +1;
  }else if( c=='Z' || c=='z' ){
    zDate++;
    goto zulu_time;
  }else{
    return c!=0;
  }
  zDate++;
  if( getDigits(zDate, 2, 0, 14, ':', &nHr, 2, 0, 59, 0, &nMn)!=2 ){
    return 1;
  }
  zDate += 5;
  p->tz = sgn*(nMn + nHr*60);
zulu_time:
  while( (sqlite3CtypeMap[(unsigned char)(*zDate)]&0x01) ){ zDate++; }
  return *zDate!=0;
}
# 13019 "ext/sqlite3/libsqlite/sqlite3.c"
static int parseHhMmSs(const char *zDate, DateTime *p){
  int h, m, s;
  double ms = 0.0;
  if( getDigits(zDate, 2, 0, 24, ':', &h, 2, 0, 59, 0, &m)!=2 ){
    return 1;
  }
  zDate += 5;
  if( *zDate==':' ){
    zDate++;
    if( getDigits(zDate, 2, 0, 59, 0, &s)!=1 ){
      return 1;
    }
    zDate += 2;
    if( *zDate=='.' && (sqlite3CtypeMap[(unsigned char)(zDate[1])]&0x04) ){
      double rScale = 1.0;
      zDate++;
      while( (sqlite3CtypeMap[(unsigned char)(*zDate)]&0x04) ){
        ms = ms*10.0 + *zDate - '0';
        rScale *= 10.0;
        zDate++;
      }
      ms /= rScale;
    }
  }else{
    s = 0;
  }
  p->validJD = 0;
  p->validHMS = 1;
  p->h = h;
  p->m = m;
  p->s = s + ms;
  if( parseTimezone(zDate, p) ) return 1;
  p->validTZ = (p->tz!=0)?1:0;
  return 0;
}







static void computeJD(DateTime *p){
  int Y, M, D, A, B, X1, X2;

  if( p->validJD ) return;
  if( p->validYMD ){
    Y = p->Y;
    M = p->M;
    D = p->D;
  }else{
    Y = 2000;
    M = 1;
    D = 1;
  }
  if( M<=2 ){
    Y--;
    M += 12;
  }
  A = Y/100;
  B = 2 - A + (A/4);
  X1 = 36525*(Y+4716)/100;
  X2 = 306001*(M+1)/10000;
  p->iJD = (sqlite3_int64)((X1 + X2 + D + B - 1524.5 ) * 86400000);
  p->validJD = 1;
  if( p->validHMS ){
    p->iJD += p->h*3600000 + p->m*60000 + (sqlite3_int64)(p->s*1000);
    if( p->validTZ ){
      p->iJD -= p->tz*60000;
      p->validYMD = 0;
      p->validHMS = 0;
      p->validTZ = 0;
    }
  }
}
# 13107 "ext/sqlite3/libsqlite/sqlite3.c"
static int parseYyyyMmDd(const char *zDate, DateTime *p){
  int Y, M, D, neg;

  if( zDate[0]=='-' ){
    zDate++;
    neg = 1;
  }else{
    neg = 0;
  }
  if( getDigits(zDate,4,0,9999,'-',&Y,2,1,12,'-',&M,2,1,31,0,&D)!=3 ){
    return 1;
  }
  zDate += 10;
  while( (sqlite3CtypeMap[(unsigned char)(*zDate)]&0x01) || 'T'==*(u8*)zDate ){ zDate++; }
  if( parseHhMmSs(zDate, p)==0 ){

  }else if( *zDate==0 ){
    p->validHMS = 0;
  }else{
    return 1;
  }
  p->validJD = 0;
  p->validYMD = 1;
  p->Y = neg ? -Y : Y;
  p->M = M;
  p->D = D;
  if( p->validTZ ){
    computeJD(p);
  }
  return 0;
}




static void setDateTimeToCurrent(sqlite3_context *context, DateTime *p){
  sqlite3 *db = sqlite3_context_db_handle(context);
  sqlite3OsCurrentTimeInt64(db->pVfs, &p->iJD);
  p->validJD = 1;
}
# 13164 "ext/sqlite3/libsqlite/sqlite3.c"
static int parseDateOrTime(
  sqlite3_context *context,
  const char *zDate,
  DateTime *p
){
  double r;
  if( parseYyyyMmDd(zDate,p)==0 ){
    return 0;
  }else if( parseHhMmSs(zDate, p)==0 ){
    return 0;
  }else if( sqlite3StrICmp(zDate,"now")==0){
    setDateTimeToCurrent(context, p);
    return 0;
  }else if( sqlite3AtoF(zDate, &r, sqlite3Strlen30(zDate), 1) ){
    p->iJD = (sqlite3_int64)(r*86400000.0 + 0.5);
    p->validJD = 1;
    return 0;
  }
  return 1;
}




static void computeYMD(DateTime *p){
  int Z, A, B, C, D, E, X1;
  if( p->validYMD ) return;
  if( !p->validJD ){
    p->Y = 2000;
    p->M = 1;
    p->D = 1;
  }else{
    Z = (int)((p->iJD + 43200000)/86400000);
    A = (int)((Z - 1867216.25)/36524.25);
    A = Z + 1 + A - (A/4);
    B = A + 1524;
    C = (int)((B - 122.1)/365.25);
    D = (36525*C)/100;
    E = (int)((B-D)/30.6001);
    X1 = (int)(30.6001*E);
    p->D = B - D - X1;
    p->M = E<14 ? E-1 : E-13;
    p->Y = p->M>2 ? C - 4716 : C - 4715;
  }
  p->validYMD = 1;
}




static void computeHMS(DateTime *p){
  int s;
  if( p->validHMS ) return;
  computeJD(p);
  s = (int)((p->iJD + 43200000) % 86400000);
  p->s = s/1000.0;
  s = (int)p->s;
  p->s -= s;
  p->h = s/3600;
  s -= p->h*3600;
  p->m = s/60;
  p->s += s - p->m*60;
  p->validHMS = 1;
}




static void computeYMD_HMS(DateTime *p){
  computeYMD(p);
  computeHMS(p);
}




static void clearYMD_HMS_TZ(DateTime *p){
  p->validYMD = 0;
  p->validHMS = 0;
  p->validTZ = 0;
}







static sqlite3_int64 localtimeOffset(DateTime *p){
  DateTime x, y;
  time_t t;
  x = *p;
  computeYMD_HMS(&x);
  if( x.Y<1971 || x.Y>=2038 ){
    x.Y = 2000;
    x.M = 1;
    x.D = 1;
    x.h = 0;
    x.m = 0;
    x.s = 0.0;
  } else {
    int s = (int)(x.s + 0.5);
    x.s = s;
  }
  x.tz = 0;
  x.validJD = 0;
  computeJD(&x);
  t = (time_t)(x.iJD/1000 - 21086676*(i64)10000);
# 13295 "ext/sqlite3/libsqlite/sqlite3.c"
  {
    struct tm *pTm;
                                                                      ;
    pTm = localtime(&t);
    y.Y = pTm->tm_year + 1900;
    y.M = pTm->tm_mon + 1;
    y.D = pTm->tm_mday;
    y.h = pTm->tm_hour;
    y.m = pTm->tm_min;
    y.s = pTm->tm_sec;
                                                                      ;
  }

  y.validYMD = 1;
  y.validHMS = 1;
  y.validJD = 0;
  y.validTZ = 0;
  computeJD(&y);
  return y.iJD - x.iJD;
}
# 13338 "ext/sqlite3/libsqlite/sqlite3.c"
static int parseModifier(const char *zMod, DateTime *p){
  int rc = 1;
  int n;
  double r;
  char *z, zBuf[30];
  z = zBuf;
  for(n=0; n<((int)(sizeof(zBuf)/sizeof(zBuf[0])))-1 && zMod[n]; n++){
    z[n] = (char)sqlite3UpperToLower[(u8)zMod[n]];
  }
  z[n] = 0;
  switch( z[0] ){

    case 'l': {





      if( __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (z) && __builtin_constant_p ("localtime") && (__s1_len = __builtin_strlen (z), __s2_len = __builtin_strlen ("localtime"), (!((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("localtime") + 1) - (size_t)(const void *)("localtime") == 1) || __s2_len >= 4)) ? __builtin_strcmp (z, "localtime") : (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) && (__s1_len = __builtin_strlen (z), __s1_len < 4) ? (__builtin_constant_p ("localtime") && ((size_t)(const void *)(("localtime") + 1) - (size_t)(const void *)("localtime") == 1) ? __builtin_strcmp (z, "localtime") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("localtime"); int __result = (((const unsigned char *) (const char *) (z))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (z))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("localtime") && ((size_t)(const void *)(("localtime") + 1) - (size_t)(const void *)("localtime") == 1) && (__s2_len = __builtin_strlen ("localtime"), __s2_len < 4) ? (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) ? __builtin_strcmp (z, "localtime") : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (z); int __result = (((const unsigned char *) (const char *) ("localtime"))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ("localtime"))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ("localtime"))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ("localtime"))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (z, "localtime")))); })==0 ){
        computeJD(p);
        p->iJD += localtimeOffset(p);
        clearYMD_HMS_TZ(p);
        rc = 0;
      }
      break;
    }

    case 'u': {






      if( __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (z) && __builtin_constant_p ("unixepoch") && (__s1_len = __builtin_strlen (z), __s2_len = __builtin_strlen ("unixepoch"), (!((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("unixepoch") + 1) - (size_t)(const void *)("unixepoch") == 1) || __s2_len >= 4)) ? __builtin_strcmp (z, "unixepoch") : (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) && (__s1_len = __builtin_strlen (z), __s1_len < 4) ? (__builtin_constant_p ("unixepoch") && ((size_t)(const void *)(("unixepoch") + 1) - (size_t)(const void *)("unixepoch") == 1) ? __builtin_strcmp (z, "unixepoch") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("unixepoch"); int __result = (((const unsigned char *) (const char *) (z))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (z))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("unixepoch") && ((size_t)(const void *)(("unixepoch") + 1) - (size_t)(const void *)("unixepoch") == 1) && (__s2_len = __builtin_strlen ("unixepoch"), __s2_len < 4) ? (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) ? __builtin_strcmp (z, "unixepoch") : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (z); int __result = (((const unsigned char *) (const char *) ("unixepoch"))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ("unixepoch"))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ("unixepoch"))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ("unixepoch"))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (z, "unixepoch")))); })==0 && p->validJD ){
        p->iJD = (p->iJD + 43200)/86400 + 21086676*(i64)10000000;
        clearYMD_HMS_TZ(p);
        rc = 0;
      }

      else if( __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (z) && __builtin_constant_p ("utc") && (__s1_len = __builtin_strlen (z), __s2_len = __builtin_strlen ("utc"), (!((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("utc") + 1) - (size_t)(const void *)("utc") == 1) || __s2_len >= 4)) ? __builtin_strcmp (z, "utc") : (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) && (__s1_len = __builtin_strlen (z), __s1_len < 4) ? (__builtin_constant_p ("utc") && ((size_t)(const void *)(("utc") + 1) - (size_t)(const void *)("utc") == 1) ? __builtin_strcmp (z, "utc") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("utc"); int __result = (((const unsigned char *) (const char *) (z))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (z))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("utc") && ((size_t)(const void *)(("utc") + 1) - (size_t)(const void *)("utc") == 1) && (__s2_len = __builtin_strlen ("utc"), __s2_len < 4) ? (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) ? __builtin_strcmp (z, "utc") : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (z); int __result = (((const unsigned char *) (const char *) ("utc"))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ("utc"))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ("utc"))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ("utc"))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (z, "utc")))); })==0 ){
        sqlite3_int64 c1;
        computeJD(p);
        c1 = localtimeOffset(p);
        p->iJD -= c1;
        clearYMD_HMS_TZ(p);
        p->iJD += c1 - localtimeOffset(p);
        rc = 0;
      }

      break;
    }
    case 'w': {







      if( (__extension__ (__builtin_constant_p (8) && ((__builtin_constant_p (z) && strlen (z) < ((size_t) (8))) || (__builtin_constant_p ("weekday ") && strlen ("weekday ") < ((size_t) (8)))) ? __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (z) && __builtin_constant_p ("weekday ") && (__s1_len = __builtin_strlen (z), __s2_len = __builtin_strlen ("weekday "), (!((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("weekday ") + 1) - (size_t)(const void *)("weekday ") == 1) || __s2_len >= 4)) ? __builtin_strcmp (z, "weekday ") : (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) && (__s1_len = __builtin_strlen (z), __s1_len < 4) ? (__builtin_constant_p ("weekday ") && ((size_t)(const void *)(("weekday ") + 1) - (size_t)(const void *)("weekday ") == 1) ? __builtin_strcmp (z, "weekday ") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("weekday "); int __result = (((const unsigned char *) (const char *) (z))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (z))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("weekday ") && ((size_t)(const void *)(("weekday ") + 1) - (size_t)(const void *)("weekday ") == 1) && (__s2_len = __builtin_strlen ("weekday "), __s2_len < 4) ? (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) ? __builtin_strcmp (z, "weekday ") : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (z); int __result = (((const unsigned char *) (const char *) ("weekday "))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ("weekday "))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ("weekday "))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ("weekday "))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (z, "weekday ")))); }) : strncmp (z, "weekday ", 8)))==0
               && sqlite3AtoF(&z[8], &r, sqlite3Strlen30(&z[8]), 1)
               && (n=(int)r)==r && n>=0 && r<7 ){
        sqlite3_int64 Z;
        computeYMD_HMS(p);
        p->validTZ = 0;
        p->validJD = 0;
        computeJD(p);
        Z = ((p->iJD + 129600000)/86400000) % 7;
        if( Z>n ) Z -= 7;
        p->iJD += (n - Z)*86400000;
        clearYMD_HMS_TZ(p);
        rc = 0;
      }
      break;
    }
    case 's': {






      if( (__extension__ (__builtin_constant_p (9) && ((__builtin_constant_p (z) && strlen (z) < ((size_t) (9))) || (__builtin_constant_p ("start of ") && strlen ("start of ") < ((size_t) (9)))) ? __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (z) && __builtin_constant_p ("start of ") && (__s1_len = __builtin_strlen (z), __s2_len = __builtin_strlen ("start of "), (!((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("start of ") + 1) - (size_t)(const void *)("start of ") == 1) || __s2_len >= 4)) ? __builtin_strcmp (z, "start of ") : (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) && (__s1_len = __builtin_strlen (z), __s1_len < 4) ? (__builtin_constant_p ("start of ") && ((size_t)(const void *)(("start of ") + 1) - (size_t)(const void *)("start of ") == 1) ? __builtin_strcmp (z, "start of ") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("start of "); int __result = (((const unsigned char *) (const char *) (z))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (z))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("start of ") && ((size_t)(const void *)(("start of ") + 1) - (size_t)(const void *)("start of ") == 1) && (__s2_len = __builtin_strlen ("start of "), __s2_len < 4) ? (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) ? __builtin_strcmp (z, "start of ") : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (z); int __result = (((const unsigned char *) (const char *) ("start of "))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ("start of "))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ("start of "))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ("start of "))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (z, "start of ")))); }) : strncmp (z, "start of ", 9)))!=0 ) break;
      z += 9;
      computeYMD(p);
      p->validHMS = 1;
      p->h = p->m = 0;
      p->s = 0.0;
      p->validTZ = 0;
      p->validJD = 0;
      if( __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (z) && __builtin_constant_p ("month") && (__s1_len = __builtin_strlen (z), __s2_len = __builtin_strlen ("month"), (!((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("month") + 1) - (size_t)(const void *)("month") == 1) || __s2_len >= 4)) ? __builtin_strcmp (z, "month") : (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) && (__s1_len = __builtin_strlen (z), __s1_len < 4) ? (__builtin_constant_p ("month") && ((size_t)(const void *)(("month") + 1) - (size_t)(const void *)("month") == 1) ? __builtin_strcmp (z, "month") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("month"); int __result = (((const unsigned char *) (const char *) (z))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (z))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("month") && ((size_t)(const void *)(("month") + 1) - (size_t)(const void *)("month") == 1) && (__s2_len = __builtin_strlen ("month"), __s2_len < 4) ? (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) ? __builtin_strcmp (z, "month") : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (z); int __result = (((const unsigned char *) (const char *) ("month"))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ("month"))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ("month"))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ("month"))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (z, "month")))); })==0 ){
        p->D = 1;
        rc = 0;
      }else if( __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (z) && __builtin_constant_p ("year") && (__s1_len = __builtin_strlen (z), __s2_len = __builtin_strlen ("year"), (!((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("year") + 1) - (size_t)(const void *)("year") == 1) || __s2_len >= 4)) ? __builtin_strcmp (z, "year") : (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) && (__s1_len = __builtin_strlen (z), __s1_len < 4) ? (__builtin_constant_p ("year") && ((size_t)(const void *)(("year") + 1) - (size_t)(const void *)("year") == 1) ? __builtin_strcmp (z, "year") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("year"); int __result = (((const unsigned char *) (const char *) (z))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (z))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("year") && ((size_t)(const void *)(("year") + 1) - (size_t)(const void *)("year") == 1) && (__s2_len = __builtin_strlen ("year"), __s2_len < 4) ? (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) ? __builtin_strcmp (z, "year") : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (z); int __result = (((const unsigned char *) (const char *) ("year"))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ("year"))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ("year"))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ("year"))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (z, "year")))); })==0 ){
        computeYMD(p);
        p->M = 1;
        p->D = 1;
        rc = 0;
      }else if( __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (z) && __builtin_constant_p ("day") && (__s1_len = __builtin_strlen (z), __s2_len = __builtin_strlen ("day"), (!((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("day") + 1) - (size_t)(const void *)("day") == 1) || __s2_len >= 4)) ? __builtin_strcmp (z, "day") : (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) && (__s1_len = __builtin_strlen (z), __s1_len < 4) ? (__builtin_constant_p ("day") && ((size_t)(const void *)(("day") + 1) - (size_t)(const void *)("day") == 1) ? __builtin_strcmp (z, "day") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("day"); int __result = (((const unsigned char *) (const char *) (z))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (z))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("day") && ((size_t)(const void *)(("day") + 1) - (size_t)(const void *)("day") == 1) && (__s2_len = __builtin_strlen ("day"), __s2_len < 4) ? (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) ? __builtin_strcmp (z, "day") : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (z); int __result = (((const unsigned char *) (const char *) ("day"))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ("day"))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ("day"))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ("day"))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (z, "day")))); })==0 ){
        rc = 0;
      }
      break;
    }
    case '+':
    case '-':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': {
      double rRounder;
      for(n=1; z[n] && z[n]!=':' && !(sqlite3CtypeMap[(unsigned char)(z[n])]&0x01); n++){}
      if( !sqlite3AtoF(z, &r, n, 1) ){
        rc = 1;
        break;
      }
      if( z[n]==':' ){





        const char *z2 = z;
        DateTime tx;
        sqlite3_int64 day;
        if( !(sqlite3CtypeMap[(unsigned char)(*z2)]&0x04) ) z2++;
        memset(&tx, 0, sizeof(tx));
        if( parseHhMmSs(z2, &tx) ) break;
        computeJD(&tx);
        tx.iJD -= 43200000;
        day = tx.iJD/86400000;
        tx.iJD -= day*86400000;
        if( z[0]=='-' ) tx.iJD = -tx.iJD;
        computeJD(p);
        clearYMD_HMS_TZ(p);
        p->iJD += tx.iJD;
        rc = 0;
        break;
      }
      z += n;
      while( (sqlite3CtypeMap[(unsigned char)(*z)]&0x01) ) z++;
      n = sqlite3Strlen30(z);
      if( n>10 || n<3 ) break;
      if( z[n-1]=='s' ){ z[n-1] = 0; n--; }
      computeJD(p);
      rc = 0;
      rRounder = r<0 ? -0.5 : +0.5;
      if( n==3 && __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (z) && __builtin_constant_p ("day") && (__s1_len = __builtin_strlen (z), __s2_len = __builtin_strlen ("day"), (!((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("day") + 1) - (size_t)(const void *)("day") == 1) || __s2_len >= 4)) ? __builtin_strcmp (z, "day") : (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) && (__s1_len = __builtin_strlen (z), __s1_len < 4) ? (__builtin_constant_p ("day") && ((size_t)(const void *)(("day") + 1) - (size_t)(const void *)("day") == 1) ? __builtin_strcmp (z, "day") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("day"); int __result = (((const unsigned char *) (const char *) (z))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (z))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("day") && ((size_t)(const void *)(("day") + 1) - (size_t)(const void *)("day") == 1) && (__s2_len = __builtin_strlen ("day"), __s2_len < 4) ? (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) ? __builtin_strcmp (z, "day") : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (z); int __result = (((const unsigned char *) (const char *) ("day"))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ("day"))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ("day"))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ("day"))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (z, "day")))); })==0 ){
        p->iJD += (sqlite3_int64)(r*86400000.0 + rRounder);
      }else if( n==4 && __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (z) && __builtin_constant_p ("hour") && (__s1_len = __builtin_strlen (z), __s2_len = __builtin_strlen ("hour"), (!((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("hour") + 1) - (size_t)(const void *)("hour") == 1) || __s2_len >= 4)) ? __builtin_strcmp (z, "hour") : (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) && (__s1_len = __builtin_strlen (z), __s1_len < 4) ? (__builtin_constant_p ("hour") && ((size_t)(const void *)(("hour") + 1) - (size_t)(const void *)("hour") == 1) ? __builtin_strcmp (z, "hour") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("hour"); int __result = (((const unsigned char *) (const char *) (z))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (z))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("hour") && ((size_t)(const void *)(("hour") + 1) - (size_t)(const void *)("hour") == 1) && (__s2_len = __builtin_strlen ("hour"), __s2_len < 4) ? (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) ? __builtin_strcmp (z, "hour") : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (z); int __result = (((const unsigned char *) (const char *) ("hour"))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ("hour"))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ("hour"))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ("hour"))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (z, "hour")))); })==0 ){
        p->iJD += (sqlite3_int64)(r*(86400000.0/24.0) + rRounder);
      }else if( n==6 && __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (z) && __builtin_constant_p ("minute") && (__s1_len = __builtin_strlen (z), __s2_len = __builtin_strlen ("minute"), (!((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("minute") + 1) - (size_t)(const void *)("minute") == 1) || __s2_len >= 4)) ? __builtin_strcmp (z, "minute") : (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) && (__s1_len = __builtin_strlen (z), __s1_len < 4) ? (__builtin_constant_p ("minute") && ((size_t)(const void *)(("minute") + 1) - (size_t)(const void *)("minute") == 1) ? __builtin_strcmp (z, "minute") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("minute"); int __result = (((const unsigned char *) (const char *) (z))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (z))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("minute") && ((size_t)(const void *)(("minute") + 1) - (size_t)(const void *)("minute") == 1) && (__s2_len = __builtin_strlen ("minute"), __s2_len < 4) ? (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) ? __builtin_strcmp (z, "minute") : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (z); int __result = (((const unsigned char *) (const char *) ("minute"))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ("minute"))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ("minute"))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ("minute"))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (z, "minute")))); })==0 ){
        p->iJD += (sqlite3_int64)(r*(86400000.0/(24.0*60.0)) + rRounder);
      }else if( n==6 && __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (z) && __builtin_constant_p ("second") && (__s1_len = __builtin_strlen (z), __s2_len = __builtin_strlen ("second"), (!((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("second") + 1) - (size_t)(const void *)("second") == 1) || __s2_len >= 4)) ? __builtin_strcmp (z, "second") : (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) && (__s1_len = __builtin_strlen (z), __s1_len < 4) ? (__builtin_constant_p ("second") && ((size_t)(const void *)(("second") + 1) - (size_t)(const void *)("second") == 1) ? __builtin_strcmp (z, "second") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("second"); int __result = (((const unsigned char *) (const char *) (z))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (z))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("second") && ((size_t)(const void *)(("second") + 1) - (size_t)(const void *)("second") == 1) && (__s2_len = __builtin_strlen ("second"), __s2_len < 4) ? (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) ? __builtin_strcmp (z, "second") : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (z); int __result = (((const unsigned char *) (const char *) ("second"))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ("second"))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ("second"))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ("second"))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (z, "second")))); })==0 ){
        p->iJD += (sqlite3_int64)(r*(86400000.0/(24.0*60.0*60.0)) + rRounder);
      }else if( n==5 && __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (z) && __builtin_constant_p ("month") && (__s1_len = __builtin_strlen (z), __s2_len = __builtin_strlen ("month"), (!((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("month") + 1) - (size_t)(const void *)("month") == 1) || __s2_len >= 4)) ? __builtin_strcmp (z, "month") : (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) && (__s1_len = __builtin_strlen (z), __s1_len < 4) ? (__builtin_constant_p ("month") && ((size_t)(const void *)(("month") + 1) - (size_t)(const void *)("month") == 1) ? __builtin_strcmp (z, "month") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("month"); int __result = (((const unsigned char *) (const char *) (z))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (z))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("month") && ((size_t)(const void *)(("month") + 1) - (size_t)(const void *)("month") == 1) && (__s2_len = __builtin_strlen ("month"), __s2_len < 4) ? (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) ? __builtin_strcmp (z, "month") : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (z); int __result = (((const unsigned char *) (const char *) ("month"))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ("month"))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ("month"))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ("month"))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (z, "month")))); })==0 ){
        int x, y;
        computeYMD_HMS(p);
        p->M += (int)r;
        x = p->M>0 ? (p->M-1)/12 : (p->M-12)/12;
        p->Y += x;
        p->M -= x*12;
        p->validJD = 0;
        computeJD(p);
        y = (int)r;
        if( y!=r ){
          p->iJD += (sqlite3_int64)((r - y)*30.0*86400000.0 + rRounder);
        }
      }else if( n==4 && __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (z) && __builtin_constant_p ("year") && (__s1_len = __builtin_strlen (z), __s2_len = __builtin_strlen ("year"), (!((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("year") + 1) - (size_t)(const void *)("year") == 1) || __s2_len >= 4)) ? __builtin_strcmp (z, "year") : (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) && (__s1_len = __builtin_strlen (z), __s1_len < 4) ? (__builtin_constant_p ("year") && ((size_t)(const void *)(("year") + 1) - (size_t)(const void *)("year") == 1) ? __builtin_strcmp (z, "year") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("year"); int __result = (((const unsigned char *) (const char *) (z))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (z))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (z))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("year") && ((size_t)(const void *)(("year") + 1) - (size_t)(const void *)("year") == 1) && (__s2_len = __builtin_strlen ("year"), __s2_len < 4) ? (__builtin_constant_p (z) && ((size_t)(const void *)((z) + 1) - (size_t)(const void *)(z) == 1) ? __builtin_strcmp (z, "year") : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (z); int __result = (((const unsigned char *) (const char *) ("year"))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ("year"))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ("year"))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ("year"))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (z, "year")))); })==0 ){
        int y = (int)r;
        computeYMD_HMS(p);
        p->Y += y;
        p->validJD = 0;
        computeJD(p);
        if( y!=r ){
          p->iJD += (sqlite3_int64)((r - y)*365.0*86400000.0 + rRounder);
        }
      }else{
        rc = 1;
      }
      clearYMD_HMS_TZ(p);
      break;
    }
    default: {
      break;
    }
  }
  return rc;
}
# 13543 "ext/sqlite3/libsqlite/sqlite3.c"
static int isDate(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv,
  DateTime *p
){
  int i;
  const unsigned char *z;
  int eType;
  memset(p, 0, sizeof(*p));
  if( argc==0 ){
    setDateTimeToCurrent(context, p);
  }else if( (eType = sqlite3_value_type(argv[0]))==2
                   || eType==1 ){
    p->iJD = (sqlite3_int64)(sqlite3_value_double(argv[0])*86400000.0 + 0.5);
    p->validJD = 1;
  }else{
    z = sqlite3_value_text(argv[0]);
    if( !z || parseDateOrTime(context, (char*)z, p) ){
      return 1;
    }
  }
  for(i=1; i<argc; i++){
    if( (z = sqlite3_value_text(argv[i]))==0 || parseModifier((char*)z, p) ){
      return 1;
    }
  }
  return 0;
}
# 13584 "ext/sqlite3/libsqlite/sqlite3.c"
static void juliandayFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  DateTime x;
  if( isDate(context, argc, argv, &x)==0 ){
    computeJD(&x);
    sqlite3_result_double(context, x.iJD/86400000.0);
  }
}






static void datetimeFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  DateTime x;
  if( isDate(context, argc, argv, &x)==0 ){
    char zBuf[100];
    computeYMD_HMS(&x);
    sqlite3_snprintf(sizeof(zBuf), zBuf, "%04d-%02d-%02d %02d:%02d:%02d",
                     x.Y, x.M, x.D, x.h, x.m, (int)(x.s));
    sqlite3_result_text(context, zBuf, -1, ((sqlite3_destructor_type)-1));
  }
}






static void timeFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  DateTime x;
  if( isDate(context, argc, argv, &x)==0 ){
    char zBuf[100];
    computeHMS(&x);
    sqlite3_snprintf(sizeof(zBuf), zBuf, "%02d:%02d:%02d", x.h, x.m, (int)x.s);
    sqlite3_result_text(context, zBuf, -1, ((sqlite3_destructor_type)-1));
  }
}






static void dateFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  DateTime x;
  if( isDate(context, argc, argv, &x)==0 ){
    char zBuf[100];
    computeYMD(&x);
    sqlite3_snprintf(sizeof(zBuf), zBuf, "%04d-%02d-%02d", x.Y, x.M, x.D);
    sqlite3_result_text(context, zBuf, -1, ((sqlite3_destructor_type)-1));
  }
}
# 13673 "ext/sqlite3/libsqlite/sqlite3.c"
static void strftimeFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  DateTime x;
  u64 n;
  size_t i,j;
  char *z;
  sqlite3 *db;
  const char *zFmt = (const char*)sqlite3_value_text(argv[0]);
  char zBuf[100];
  if( zFmt==0 || isDate(context, argc-1, argv+1, &x) ) return;
  db = sqlite3_context_db_handle(context);
  for(i=0, n=1; zFmt[i]; i++, n++){
    if( zFmt[i]=='%' ){
      switch( zFmt[i+1] ){
        case 'd':
        case 'H':
        case 'm':
        case 'M':
        case 'S':
        case 'W':
          n++;

        case 'w':
        case '%':
          break;
        case 'f':
          n += 8;
          break;
        case 'j':
          n += 3;
          break;
        case 'Y':
          n += 8;
          break;
        case 's':
        case 'J':
          n += 50;
          break;
        default:
          return;
      }
      i++;
    }
  }
                               ;
                             ;
                                                       ;
                                                     ;
  if( n<sizeof(zBuf) ){
    z = zBuf;
  }else if( n>(u64)db->aLimit[0] ){
    sqlite3_result_error_toobig(context);
    return;
  }else{
    z = sqlite3DbMallocRaw(db, (int)n);
    if( z==0 ){
      sqlite3_result_error_nomem(context);
      return;
    }
  }
  computeJD(&x);
  computeYMD_HMS(&x);
  for(i=j=0; zFmt[i]; i++){
    if( zFmt[i]!='%' ){
      z[j++] = zFmt[i];
    }else{
      i++;
      switch( zFmt[i] ){
        case 'd': sqlite3_snprintf(3, &z[j],"%02d",x.D); j+=2; break;
        case 'f': {
          double s = x.s;
          if( s>59.999 ) s = 59.999;
          sqlite3_snprintf(7, &z[j],"%06.3f", s);
          j += sqlite3Strlen30(&z[j]);
          break;
        }
        case 'H': sqlite3_snprintf(3, &z[j],"%02d",x.h); j+=2; break;
        case 'W':
        case 'j': {
          int nDay;
          DateTime y = x;
          y.validJD = 0;
          y.M = 1;
          y.D = 1;
          computeJD(&y);
          nDay = (int)((x.iJD-y.iJD+43200000)/86400000);
          if( zFmt[i]=='W' ){
            int wd;
            wd = (int)(((x.iJD+43200000)/86400000)%7);
            sqlite3_snprintf(3, &z[j],"%02d",(nDay+7-wd)/7);
            j += 2;
          }else{
            sqlite3_snprintf(4, &z[j],"%03d",nDay+1);
            j += 3;
          }
          break;
        }
        case 'J': {
          sqlite3_snprintf(20, &z[j],"%.16g",x.iJD/86400000.0);
          j+=sqlite3Strlen30(&z[j]);
          break;
        }
        case 'm': sqlite3_snprintf(3, &z[j],"%02d",x.M); j+=2; break;
        case 'M': sqlite3_snprintf(3, &z[j],"%02d",x.m); j+=2; break;
        case 's': {
          sqlite3_snprintf(30,&z[j],"%lld",
                           (i64)(x.iJD/1000 - 21086676*(i64)10000));
          j += sqlite3Strlen30(&z[j]);
          break;
        }
        case 'S': sqlite3_snprintf(3,&z[j],"%02d",(int)x.s); j+=2; break;
        case 'w': {
          z[j++] = (char)(((x.iJD+129600000)/86400000) % 7) + '0';
          break;
        }
        case 'Y': {
          sqlite3_snprintf(5,&z[j],"%04d",x.Y); j+=sqlite3Strlen30(&z[j]);
          break;
        }
        default: z[j++] = '%'; break;
      }
    }
  }
  z[j] = 0;
  sqlite3_result_text(context, z, -1,
                      z==zBuf ? ((sqlite3_destructor_type)-1) : ((sqlite3_destructor_type)sqlite3DbFree));
}






static void ctimeFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  (void)(NotUsed),(void)(NotUsed2);
  timeFunc(context, 0, 0);
}






static void cdateFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  (void)(NotUsed),(void)(NotUsed2);
  dateFunc(context, 0, 0);
}






static void ctimestampFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  (void)(NotUsed),(void)(NotUsed2);
  datetimeFunc(context, 0, 0);
}
# 13901 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3RegisterDateTimeFunctions(void){
  static FuncDef aDateTimeFuncs[] = {

    {-1, 1, 0*0x08, ((void*)(long int)(0)), 0, juliandayFunc, 0, 0, "julianday", 0, 0},
    {-1, 1, 0*0x08, ((void*)(long int)(0)), 0, dateFunc, 0, 0, "date", 0, 0},
    {-1, 1, 0*0x08, ((void*)(long int)(0)), 0, timeFunc, 0, 0, "time", 0, 0},
    {-1, 1, 0*0x08, ((void*)(long int)(0)), 0, datetimeFunc, 0, 0, "datetime", 0, 0},
    {-1, 1, 0*0x08, ((void*)(long int)(0)), 0, strftimeFunc, 0, 0, "strftime", 0, 0},
    {0, 1, 0*0x08, ((void*)(long int)(0)), 0, ctimeFunc, 0, 0, "current_time", 0, 0},
    {0, 1, 0*0x08, ((void*)(long int)(0)), 0, ctimestampFunc, 0, 0, "current_timestamp", 0, 0},
    {0, 1, 0*0x08, ((void*)(long int)(0)), 0, cdateFunc, 0, 0, "current_date", 0, 0},





  };
  int i;
  FuncDefHash *pHash = &sqlite3GlobalFunctions;
  FuncDef *aFunc = (FuncDef*)&aDateTimeFuncs;

  for(i=0; i<((int)(sizeof(aDateTimeFuncs)/sizeof(aDateTimeFuncs[0]))); i++){
    sqlite3FuncDefInsert(pHash, &aFunc[i]);
  }
}
# 13982 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3OsClose(sqlite3_file *pId){
  int rc = 0;
  if( pId->pMethods ){
    rc = pId->pMethods->xClose(pId);
    pId->pMethods = 0;
  }
  return rc;
}
static int sqlite3OsRead(sqlite3_file *id, void *pBuf, int amt, i64 offset){
                       ;
  return id->pMethods->xRead(id, pBuf, amt, offset);
}
static int sqlite3OsWrite(sqlite3_file *id, const void *pBuf, int amt, i64 offset){
                       ;
  return id->pMethods->xWrite(id, pBuf, amt, offset);
}
static int sqlite3OsTruncate(sqlite3_file *id, i64 size){
  return id->pMethods->xTruncate(id, size);
}
static int sqlite3OsSync(sqlite3_file *id, int flags){
                       ;
  return id->pMethods->xSync(id, flags);
}
static int sqlite3OsFileSize(sqlite3_file *id, i64 *pSize){
                       ;
  return id->pMethods->xFileSize(id, pSize);
}
static int sqlite3OsLock(sqlite3_file *id, int lockType){
                       ;
  return id->pMethods->xLock(id, lockType);
}
static int sqlite3OsUnlock(sqlite3_file *id, int lockType){
  return id->pMethods->xUnlock(id, lockType);
}
static int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut){
                       ;
  return id->pMethods->xCheckReservedLock(id, pResOut);
}
static int sqlite3OsFileControl(sqlite3_file *id, int op, void *pArg){
  return id->pMethods->xFileControl(id, op, pArg);
}
static int sqlite3OsSectorSize(sqlite3_file *id){
  int (*xSectorSize)(sqlite3_file*) = id->pMethods->xSectorSize;
  return (xSectorSize ? xSectorSize(id) : 512);
}
static int sqlite3OsDeviceCharacteristics(sqlite3_file *id){
  return id->pMethods->xDeviceCharacteristics(id);
}
static int sqlite3OsShmLock(sqlite3_file *id, int offset, int n, int flags){
  return id->pMethods->xShmLock(id, offset, n, flags);
}
static void sqlite3OsShmBarrier(sqlite3_file *id){
  id->pMethods->xShmBarrier(id);
}
static int sqlite3OsShmUnmap(sqlite3_file *id, int deleteFlag){
  return id->pMethods->xShmUnmap(id, deleteFlag);
}
static int sqlite3OsShmMap(
  sqlite3_file *id,
  int iPage,
  int pgsz,
  int bExtend,
  void volatile **pp
){
  return id->pMethods->xShmMap(id, iPage, pgsz, bExtend, pp);
}





static int sqlite3OsOpen(
  sqlite3_vfs *pVfs,
  const char *zPath,
  sqlite3_file *pFile,
  int flags,
  int *pFlagsOut
){
  int rc;
                      ;




  rc = pVfs->xOpen(pVfs, zPath, pFile, flags & 0x87f3f, pFlagsOut);
  ((void) (0));
  return rc;
}
static int sqlite3OsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){
  return pVfs->xDelete(pVfs, zPath, dirSync);
}
static int sqlite3OsAccess(
  sqlite3_vfs *pVfs,
  const char *zPath,
  int flags,
  int *pResOut
){
                      ;
  return pVfs->xAccess(pVfs, zPath, flags, pResOut);
}
static int sqlite3OsFullPathname(
  sqlite3_vfs *pVfs,
  const char *zPath,
  int nPathOut,
  char *zPathOut
){
  zPathOut[0] = 0;
  return pVfs->xFullPathname(pVfs, zPath, nPathOut, zPathOut);
}

static void *sqlite3OsDlOpen(sqlite3_vfs *pVfs, const char *zPath){
  return pVfs->xDlOpen(pVfs, zPath);
}
static void sqlite3OsDlError(sqlite3_vfs *pVfs, int nByte, char *zBufOut){
  pVfs->xDlError(pVfs, nByte, zBufOut);
}
static void (*sqlite3OsDlSym(sqlite3_vfs *pVfs, void *pHdle, const char *zSym))(void){
  return pVfs->xDlSym(pVfs, pHdle, zSym);
}
static void sqlite3OsDlClose(sqlite3_vfs *pVfs, void *pHandle){
  pVfs->xDlClose(pVfs, pHandle);
}

static int sqlite3OsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){
  return pVfs->xRandomness(pVfs, nByte, zBufOut);
}
static int sqlite3OsSleep(sqlite3_vfs *pVfs, int nMicro){
  return pVfs->xSleep(pVfs, nMicro);
}
static int sqlite3OsCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *pTimeOut){
  int rc;






  if( pVfs->iVersion>=2 && pVfs->xCurrentTimeInt64 ){
    rc = pVfs->xCurrentTimeInt64(pVfs, pTimeOut);
  }else{
    double r;
    rc = pVfs->xCurrentTime(pVfs, &r);
    *pTimeOut = (sqlite3_int64)(r*86400000.0);
  }
  return rc;
}

static int sqlite3OsOpenMalloc(
  sqlite3_vfs *pVfs,
  const char *zFile,
  sqlite3_file **ppFile,
  int flags,
  int *pOutFlags
){
  int rc = 7;
  sqlite3_file *pFile;
  pFile = (sqlite3_file *)sqlite3Malloc(pVfs->szOsFile);
  if( pFile ){
    rc = sqlite3OsOpen(pVfs, zFile, pFile, flags, pOutFlags);
    if( rc!=0 ){
      sqlite3_free(pFile);
    }else{
      *ppFile = pFile;
    }
  }
  return rc;
}
static int sqlite3OsCloseFree(sqlite3_file *pFile){
  int rc = 0;
  ((void) (0));
  rc = sqlite3OsClose(pFile);
  sqlite3_free(pFile);
  return rc;
}







static int sqlite3OsInit(void){
  void *p = sqlite3_malloc(10);
  if( p==0 ) return 7;
  sqlite3_free(p);
  return sqlite3_os_init();
}




static sqlite3_vfs * vfsList = 0;






           sqlite3_vfs *sqlite3_vfs_find(const char *zVfs){
  sqlite3_vfs *pVfs = 0;




  int rc = sqlite3_initialize();
  if( rc ) return 0;




                            ;
  for(pVfs = vfsList; pVfs; pVfs=pVfs->pNext){
    if( zVfs==0 ) break;
    if( __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (zVfs) && __builtin_constant_p (pVfs->zName) && (__s1_len = __builtin_strlen (zVfs), __s2_len = __builtin_strlen (pVfs->zName), (!((size_t)(const void *)((zVfs) + 1) - (size_t)(const void *)(zVfs) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((pVfs->zName) + 1) - (size_t)(const void *)(pVfs->zName) == 1) || __s2_len >= 4)) ? __builtin_strcmp (zVfs, pVfs->zName) : (__builtin_constant_p (zVfs) && ((size_t)(const void *)((zVfs) + 1) - (size_t)(const void *)(zVfs) == 1) && (__s1_len = __builtin_strlen (zVfs), __s1_len < 4) ? (__builtin_constant_p (pVfs->zName) && ((size_t)(const void *)((pVfs->zName) + 1) - (size_t)(const void *)(pVfs->zName) == 1) ? __builtin_strcmp (zVfs, pVfs->zName) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (pVfs->zName); int __result = (((const unsigned char *) (const char *) (zVfs))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (zVfs))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (zVfs))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (zVfs))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (pVfs->zName) && ((size_t)(const void *)((pVfs->zName) + 1) - (size_t)(const void *)(pVfs->zName) == 1) && (__s2_len = __builtin_strlen (pVfs->zName), __s2_len < 4) ? (__builtin_constant_p (zVfs) && ((size_t)(const void *)((zVfs) + 1) - (size_t)(const void *)(zVfs) == 1) ? __builtin_strcmp (zVfs, pVfs->zName) : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (zVfs); int __result = (((const unsigned char *) (const char *) (pVfs->zName))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (pVfs->zName))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (pVfs->zName))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (pVfs->zName))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (zVfs, pVfs->zName)))); })==0 ) break;
  }
                            ;
  return pVfs;
}




static void vfsUnlink(sqlite3_vfs *pVfs){
  ((void) (0));
  if( pVfs==0 ){

  }else if( vfsList==pVfs ){
    vfsList = pVfs->pNext;
  }else if( vfsList ){
    sqlite3_vfs *p = vfsList;
    while( p->pNext && p->pNext!=pVfs ){
      p = p->pNext;
    }
    if( p->pNext==pVfs ){
      p->pNext = pVfs->pNext;
    }
  }
}






           int sqlite3_vfs_register(sqlite3_vfs *pVfs, int makeDflt){
  sqlite3_mutex *mutex = 0;

  int rc = sqlite3_initialize();
  if( rc ) return rc;

  mutex = ((sqlite3_mutex*)8);
                            ;
  vfsUnlink(pVfs);
  if( makeDflt || vfsList==0 ){
    pVfs->pNext = vfsList;
    vfsList = pVfs;
  }else{
    pVfs->pNext = vfsList->pNext;
    vfsList->pNext = pVfs;
  }
  ((void) (0));
                            ;
  return 0;
}




           int sqlite3_vfs_unregister(sqlite3_vfs *pVfs){



                            ;
  vfsUnlink(pVfs);
                            ;
  return 0;
}
# 14294 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct BenignMallocHooks BenignMallocHooks;
static struct BenignMallocHooks {
  void (*xBenignBegin)(void);
  void (*xBenignEnd)(void);
} sqlite3Hooks = { 0, 0 };
# 14320 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3BenignMallocHooks(
  void (*xBenignBegin)(void),
  void (*xBenignEnd)(void)
){
              ;
  sqlite3Hooks.xBenignBegin = xBenignBegin;
  sqlite3Hooks.xBenignEnd = xBenignEnd;
}






static void sqlite3BeginBenignMalloc(void){
              ;
  if( sqlite3Hooks.xBenignBegin ){
    sqlite3Hooks.xBenignBegin();
  }
}
static void sqlite3EndBenignMalloc(void){
              ;
  if( sqlite3Hooks.xBenignEnd ){
    sqlite3Hooks.xBenignEnd();
  }
}
# 14447 "ext/sqlite3/libsqlite/sqlite3.c"
static void *sqlite3MemMalloc(int nByte){
  sqlite3_int64 *p;
  ((void) (0));
  nByte = (((nByte)+7)&~7);
  p = malloc( nByte+8 );
  if( p ){
    p[0] = nByte;
    p++;
  }else{
                                           ;
    sqlite3_log(7, "failed to allocate %u bytes of memory", nByte);
  }
  return (void *)p;
}
# 14470 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3MemFree(void *pPrior){
  sqlite3_int64 *p = (sqlite3_int64*)pPrior;
  ((void) (0));
  p--;
  free(p);
}





static int sqlite3MemSize(void *pPrior){
  sqlite3_int64 *p;
  if( pPrior==0 ) return 0;
  p = (sqlite3_int64*)pPrior;
  p--;
  return (int)p[0];
}
# 14499 "ext/sqlite3/libsqlite/sqlite3.c"
static void *sqlite3MemRealloc(void *pPrior, int nByte){
  sqlite3_int64 *p = (sqlite3_int64*)pPrior;
  ((void) (0));
  ((void) (0));
  p--;
  p = realloc(p, nByte+8 );
  if( p ){
    p[0] = nByte;
    p++;
  }else{
                                           ;
    sqlite3_log(7,
      "failed memory resize %u to %u bytes",
      sqlite3MemSize(pPrior), nByte);
  }
  return (void*)p;
}




static int sqlite3MemRoundup(int n){
  return (((n)+7)&~7);
}




static int sqlite3MemInit(void *NotUsed){
  (void)(NotUsed);
  return 0;
}




static void sqlite3MemShutdown(void *NotUsed){
  (void)(NotUsed);
  return;
}







static void sqlite3MemSetDefault(void){
  static const sqlite3_mem_methods defaultMethods = {
     sqlite3MemMalloc,
     sqlite3MemFree,
     sqlite3MemRealloc,
     sqlite3MemSize,
     sqlite3MemRoundup,
     sqlite3MemInit,
     sqlite3MemShutdown,
     0
  };
  sqlite3_config(4, &defaultMethods);
}
# 17711 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_release_memory(int n){






  (void)(n);
  return 0;

}





typedef struct ScratchFreeslot {
  struct ScratchFreeslot *pNext;
} ScratchFreeslot;




static struct Mem0Global {
  sqlite3_mutex *mutex;







  sqlite3_int64 alarmThreshold;
  void (*alarmCallback)(void*, sqlite3_int64,int);
  void *alarmArg;







  void *pScratchEnd;
  ScratchFreeslot *pScratchFree;
  u32 nScratchFree;





  int nearlyFull;
} mem0 = { 0, 0, 0, 0, 0, 0, 0, 0 };
# 17771 "ext/sqlite3/libsqlite/sqlite3.c"
static void softHeapLimitEnforcer(
  void *NotUsed,
  sqlite3_int64 NotUsed2,
  int allocSize
){
  (void)(NotUsed),(void)(NotUsed2);
  sqlite3_release_memory(allocSize);
}




static int sqlite3MemoryAlarm(
  void(*xCallback)(void *pArg, sqlite3_int64 used,int N),
  void *pArg,
  sqlite3_int64 iThreshold
){
  int nUsed;
                                 ;
  mem0.alarmCallback = xCallback;
  mem0.alarmArg = pArg;
  mem0.alarmThreshold = iThreshold;
  nUsed = sqlite3StatusValue(0);
  mem0.nearlyFull = (iThreshold>0 && iThreshold<=nUsed);
                                 ;
  return 0;
}






           int sqlite3_memory_alarm(
  void(*xCallback)(void *pArg, sqlite3_int64 used,int N),
  void *pArg,
  sqlite3_int64 iThreshold
){
  return sqlite3MemoryAlarm(xCallback, pArg, iThreshold);
}






           sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 n){
  sqlite3_int64 priorLimit;
  sqlite3_int64 excess;

  if( sqlite3_initialize() ) return 0;

                                 ;
  priorLimit = mem0.alarmThreshold;
                                 ;
  if( n<0 ) return priorLimit;
  if( n>0 ){
    sqlite3MemoryAlarm(softHeapLimitEnforcer, 0, n);
  }else{
    sqlite3MemoryAlarm(0, 0, 0);
  }
  excess = sqlite3_memory_used() - n;
  if( excess>0 ) sqlite3_release_memory((int)(excess & 0x7fffffff));
  return priorLimit;
}
           void sqlite3_soft_heap_limit(int n){
  if( n<0 ) n = 0;
  sqlite3_soft_heap_limit64(n);
}




static int sqlite3MallocInit(void){
  if( sqlite3Config.m.xMalloc==0 ){
    sqlite3MemSetDefault();
  }
  memset(&mem0, 0, sizeof(mem0));
  if( sqlite3Config.bCoreMutex ){
    mem0.mutex = ((sqlite3_mutex*)8);
  }
  if( sqlite3Config.pScratch && sqlite3Config.szScratch>=100
      && sqlite3Config.nScratch>0 ){
    int i, n, sz;
    ScratchFreeslot *pSlot;
    sz = ((sqlite3Config.szScratch)&~7);
    sqlite3Config.szScratch = sz;
    pSlot = (ScratchFreeslot*)sqlite3Config.pScratch;
    n = sqlite3Config.nScratch;
    mem0.pScratchFree = pSlot;
    mem0.nScratchFree = n;
    for(i=0; i<n-1; i++){
      pSlot->pNext = (ScratchFreeslot*)(sz+(char*)pSlot);
      pSlot = pSlot->pNext;
    }
    pSlot->pNext = 0;
    mem0.pScratchEnd = (void*)&pSlot[1];
  }else{
    mem0.pScratchEnd = 0;
    sqlite3Config.pScratch = 0;
    sqlite3Config.szScratch = 0;
    sqlite3Config.nScratch = 0;
  }
  if( sqlite3Config.pPage==0 || sqlite3Config.szPage<512
      || sqlite3Config.nPage<1 ){
    sqlite3Config.pPage = 0;
    sqlite3Config.szPage = 0;
    sqlite3Config.nPage = 0;
  }
  return sqlite3Config.m.xInit(sqlite3Config.m.pAppData);
}






static int sqlite3HeapNearlyFull(void){
  return mem0.nearlyFull;
}




static void sqlite3MallocEnd(void){
  if( sqlite3Config.m.xShutdown ){
    sqlite3Config.m.xShutdown(sqlite3Config.m.pAppData);
  }
  memset(&mem0, 0, sizeof(mem0));
}




           sqlite3_int64 sqlite3_memory_used(void){
  int n, mx;
  sqlite3_int64 res;
  sqlite3_status(0, &n, &mx, 0);
  res = (sqlite3_int64)n;
  return res;
}






           sqlite3_int64 sqlite3_memory_highwater(int resetFlag){
  int n, mx;
  sqlite3_int64 res;
  sqlite3_status(0, &n, &mx, resetFlag);
  res = (sqlite3_int64)mx;
  return res;
}




static void sqlite3MallocAlarm(int nByte){
  void (*xCallback)(void*,sqlite3_int64,int);
  sqlite3_int64 nowUsed;
  void *pArg;
  if( mem0.alarmCallback==0 ) return;
  xCallback = mem0.alarmCallback;
  nowUsed = sqlite3StatusValue(0);
  pArg = mem0.alarmArg;
  mem0.alarmCallback = 0;
                                 ;
  xCallback(pArg, nowUsed, nByte);
                                 ;
  mem0.alarmCallback = xCallback;
  mem0.alarmArg = pArg;
}





static int mallocWithAlarm(int n, void **pp){
  int nFull;
  void *p;
  ((void) (0));
  nFull = sqlite3Config.m.xRoundup(n);
  sqlite3StatusSet(5, n);
  if( mem0.alarmCallback!=0 ){
    int nUsed = sqlite3StatusValue(0);
    if( nUsed+nFull >= mem0.alarmThreshold ){
      mem0.nearlyFull = 1;
      sqlite3MallocAlarm(nFull);
    }else{
      mem0.nearlyFull = 0;
    }
  }
  p = sqlite3Config.m.xMalloc(nFull);






  if( p ){
    nFull = sqlite3MallocSize(p);
    sqlite3StatusAdd(0, nFull);
    sqlite3StatusAdd(9, 1);
  }
  *pp = p;
  return nFull;
}





static void *sqlite3Malloc(int n){
  void *p;
  if( n<=0
   || n>=0x7fffff00
  ){





    p = 0;
  }else if( sqlite3Config.bMemstat ){
                                   ;
    mallocWithAlarm(n, &p);
                                   ;
  }else{
    p = sqlite3Config.m.xMalloc(n);
  }
  ((void) (0));
  return p;
}






           void *sqlite3_malloc(int n){

  if( sqlite3_initialize() ) return 0;

  return sqlite3Malloc(n);
}
# 18037 "ext/sqlite3/libsqlite/sqlite3.c"
static void *sqlite3ScratchMalloc(int n){
  void *p;
  ((void) (0));

                                 ;
  if( mem0.nScratchFree && sqlite3Config.szScratch>=n ){
    p = mem0.pScratchFree;
    mem0.pScratchFree = mem0.pScratchFree->pNext;
    mem0.nScratchFree--;
    sqlite3StatusAdd(3, 1);
    sqlite3StatusSet(8, n);
                                   ;
  }else{
    if( sqlite3Config.bMemstat ){
      sqlite3StatusSet(8, n);
      n = mallocWithAlarm(n, &p);
      if( p ) sqlite3StatusAdd(4, n);
                                     ;
    }else{
                                     ;
      p = sqlite3Config.m.xMalloc(n);
    }
                                              ;
  }
  ((void) (0));
# 18073 "ext/sqlite3/libsqlite/sqlite3.c"
  return p;
}
static void sqlite3ScratchFree(void *p){
  if( p ){
# 18087 "ext/sqlite3/libsqlite/sqlite3.c"
    if( p>=sqlite3Config.pScratch && p<mem0.pScratchEnd ){

      ScratchFreeslot *pSlot;
      pSlot = (ScratchFreeslot*)p;
                                     ;
      pSlot->pNext = mem0.pScratchFree;
      mem0.pScratchFree = pSlot;
      mem0.nScratchFree++;
      ((void) (0));
      sqlite3StatusAdd(3, -1);
                                     ;
    }else{

      ((void) (0));
      ((void) (0));
                                             ;
      if( sqlite3Config.bMemstat ){
        int iSize = sqlite3MallocSize(p);
                                       ;
        sqlite3StatusAdd(4, -iSize);
        sqlite3StatusAdd(0, -iSize);
        sqlite3StatusAdd(9, -1);
        sqlite3Config.m.xFree(p);
                                       ;
      }else{
        sqlite3Config.m.xFree(p);
      }
    }
  }
}





static int isLookaside(sqlite3 *db, void *p){
  return p && p>=db->lookaside.pStart && p<db->lookaside.pEnd;
}
# 18133 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3MallocSize(void *p){
  ((void) (0));
  ((void) (0));
  return sqlite3Config.m.xSize(p);
}
static int sqlite3DbMallocSize(sqlite3 *db, void *p){
  ((void) (0));
  if( db && isLookaside(db, p) ){
    return db->lookaside.sz;
  }else{
    ((void) (0));
    ((void) (0));
    ((void) (0));
    return sqlite3Config.m.xSize(p);
  }
}




           void sqlite3_free(void *p){
  if( p==0 ) return;
  ((void) (0));
  ((void) (0));
  if( sqlite3Config.bMemstat ){
                                   ;
    sqlite3StatusAdd(0, -sqlite3MallocSize(p));
    sqlite3StatusAdd(9, -1);
    sqlite3Config.m.xFree(p);
                                   ;
  }else{
    sqlite3Config.m.xFree(p);
  }
}





static void sqlite3DbFree(sqlite3 *db, void *p){
  ((void) (0));
  if( db ){
    if( db->pnBytesFreed ){
      *db->pnBytesFreed += sqlite3DbMallocSize(db, p);
      return;
    }
    if( isLookaside(db, p) ){
      LookasideSlot *pBuf = (LookasideSlot*)p;
      pBuf->pNext = db->lookaside.pFree;
      db->lookaside.pFree = pBuf;
      db->lookaside.nOut--;
      return;
    }
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
                                         ;
  sqlite3_free(p);
}




static void *sqlite3Realloc(void *pOld, int nBytes){
  int nOld, nNew;
  void *pNew;
  if( pOld==0 ){
    return sqlite3Malloc(nBytes);
  }
  if( nBytes<=0 ){
    sqlite3_free(pOld);
    return 0;
  }
  if( nBytes>=0x7fffff00 ){

    return 0;
  }
  nOld = sqlite3MallocSize(pOld);



  nNew = sqlite3Config.m.xRoundup(nBytes);
  if( nOld==nNew ){
    pNew = pOld;
  }else if( sqlite3Config.bMemstat ){
                                   ;
    sqlite3StatusSet(5, nBytes);
    if( sqlite3StatusValue(0)+nNew-nOld >=
          mem0.alarmThreshold ){
      sqlite3MallocAlarm(nNew-nOld);
    }
    ((void) (0));
    ((void) (0));
    pNew = sqlite3Config.m.xRealloc(pOld, nNew);
    if( pNew==0 && mem0.alarmCallback ){
      sqlite3MallocAlarm(nBytes);
      pNew = sqlite3Config.m.xRealloc(pOld, nNew);
    }
    if( pNew ){
      nNew = sqlite3MallocSize(pNew);
      sqlite3StatusAdd(0, nNew-nOld);
    }
                                   ;
  }else{
    pNew = sqlite3Config.m.xRealloc(pOld, nNew);
  }
  ((void) (0));
  return pNew;
}





           void *sqlite3_realloc(void *pOld, int n){

  if( sqlite3_initialize() ) return 0;

  return sqlite3Realloc(pOld, n);
}





static void *sqlite3MallocZero(int n){
  void *p = sqlite3Malloc(n);
  if( p ){
    memset(p, 0, n);
  }
  return p;
}





static void *sqlite3DbMallocZero(sqlite3 *db, int n){
  void *p = sqlite3DbMallocRaw(db, n);
  if( p ){
    memset(p, 0, n);
  }
  return p;
}
# 18297 "ext/sqlite3/libsqlite/sqlite3.c"
static void *sqlite3DbMallocRaw(sqlite3 *db, int n){
  void *p;
  ((void) (0));
  ((void) (0));

  if( db ){
    LookasideSlot *pBuf;
    if( db->mallocFailed ){
      return 0;
    }
    if( db->lookaside.bEnabled ){
      if( n>db->lookaside.sz ){
        db->lookaside.anStat[1]++;
      }else if( (pBuf = db->lookaside.pFree)==0 ){
        db->lookaside.anStat[2]++;
      }else{
        db->lookaside.pFree = pBuf->pNext;
        db->lookaside.nOut++;
        db->lookaside.anStat[0]++;
        if( db->lookaside.nOut>db->lookaside.mxOut ){
          db->lookaside.mxOut = db->lookaside.nOut;
        }
        return (void*)pBuf;
      }
    }
  }





  p = sqlite3Malloc(n);
  if( !p && db ){
    db->mallocFailed = 1;
  }

                                                                             ;
  return p;
}





static void *sqlite3DbRealloc(sqlite3 *db, void *p, int n){
  void *pNew = 0;
  ((void) (0));
  ((void) (0));
  if( db->mallocFailed==0 ){
    if( p==0 ){
      return sqlite3DbMallocRaw(db, n);
    }
    if( isLookaside(db, p) ){
      if( n<=db->lookaside.sz ){
        return p;
      }
      pNew = sqlite3DbMallocRaw(db, n);
      if( pNew ){
        memcpy(pNew, p, db->lookaside.sz);
        sqlite3DbFree(db, p);
      }
    }else{
      ((void) (0));
      ((void) (0));
                                             ;
      pNew = sqlite3_realloc(p, n);
      if( !pNew ){
                                                          ;
        db->mallocFailed = 1;
      }

                                                                        ;
    }
  }
  return pNew;
}





static void *sqlite3DbReallocOrFree(sqlite3 *db, void *p, int n){
  void *pNew;
  pNew = sqlite3DbRealloc(db, p, n);
  if( !pNew ){
    sqlite3DbFree(db, p);
  }
  return pNew;
}
# 18394 "ext/sqlite3/libsqlite/sqlite3.c"
static char *sqlite3DbStrDup(sqlite3 *db, const char *z){
  char *zNew;
  size_t n;
  if( z==0 ){
    return 0;
  }
  n = sqlite3Strlen30(z) + 1;
  ((void) (0));
  zNew = sqlite3DbMallocRaw(db, (int)n);
  if( zNew ){
    memcpy(zNew, z, n);
  }
  return zNew;
}
static char *sqlite3DbStrNDup(sqlite3 *db, const char *z, int n){
  char *zNew;
  if( z==0 ){
    return 0;
  }
  ((void) (0));
  zNew = sqlite3DbMallocRaw(db, n+1);
  if( zNew ){
    memcpy(zNew, z, n);
    zNew[n] = 0;
  }
  return zNew;
}






static void sqlite3SetString(char **pz, sqlite3 *db, const char *zFormat, ...){
  va_list ap;
  char *z;

  __builtin_va_start(ap, zFormat);
  z = sqlite3VMPrintf(db, zFormat, ap);
  __builtin_va_end(ap);
  sqlite3DbFree(db, *pz);
  *pz = z;
}
# 18452 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3ApiExit(sqlite3* db, int rc){




  ((void) (0));
  if( db && (db->mallocFailed || rc==(10 | (12<<8))) ){
    sqlite3Error(db, 7, 0);
    db->mallocFailed = 0;
    rc = 7;
  }
  return rc & (db ? db->errMask : 0xff);
}
# 18550 "ext/sqlite3/libsqlite/sqlite3.c"
typedef unsigned char etByte;





typedef struct et_info {
  char fmttype;
  etByte base;
  etByte flags;
  etByte type;
  etByte charset;
  etByte prefix;
} et_info;
# 18577 "ext/sqlite3/libsqlite/sqlite3.c"
static const char aDigits[] = "0123456789ABCDEF0123456789abcdef";
static const char aPrefix[] = "-x0\000X0";
static const et_info fmtinfo[] = {
  { 'd', 10, 1, 1, 0, 0 },
  { 's', 0, 4, 6, 0, 0 },
  { 'g', 0, 1, 4, 30, 0 },
  { 'z', 0, 4, 7, 0, 0 },
  { 'q', 0, 4, 10, 0, 0 },
  { 'Q', 0, 4, 11, 0, 0 },
  { 'w', 0, 4, 15, 0, 0 },
  { 'c', 0, 0, 9, 0, 0 },
  { 'o', 8, 0, 1, 0, 2 },
  { 'u', 10, 0, 1, 0, 0 },
  { 'x', 16, 0, 1, 16, 1 },
  { 'X', 16, 0, 1, 0, 4 },

  { 'f', 0, 1, 2, 0, 0 },
  { 'e', 0, 1, 3, 30, 0 },
  { 'E', 0, 1, 3, 14, 0 },
  { 'G', 0, 1, 4, 14, 0 },

  { 'i', 10, 1, 1, 0, 0 },
  { 'n', 0, 0, 5, 0, 0 },
  { '%', 0, 0, 8, 0, 0 },
  { 'p', 16, 0, 14, 0, 1 },



  { 'T', 0, 2, 12, 0, 0 },
  { 'S', 0, 2, 13, 0, 0 },
  { 'r', 10, 3, 16, 0, 0 },
};
# 18628 "ext/sqlite3/libsqlite/sqlite3.c"
static char et_getdigit(long double *val, int *cnt){
  int digit;
  long double d;
  if( (*cnt)++ >= 16 ) return '0';
  digit = (int)*val;
  d = digit;
  digit += '0';
  *val = (*val - d)*10.0;
  return (char)digit;
}





static void appendSpace(StrAccum *pAccum, int N){
  static const char zSpaces[] = "                             ";
  while( N>=(int)sizeof(zSpaces)-1 ){
    sqlite3StrAccumAppend(pAccum, zSpaces, sizeof(zSpaces)-1);
    N -= sizeof(zSpaces)-1;
  }
  if( N>0 ){
    sqlite3StrAccumAppend(pAccum, zSpaces, N);
  }
}
# 18694 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3VXPrintf(
  StrAccum *pAccum,
  int useExtended,
  const char *fmt,
  va_list ap
){
  int c;
  char *bufpt;
  int precision;
  int length;
  int idx;
  int width;
  etByte flag_leftjustify;
  etByte flag_plussign;
  etByte flag_blanksign;
  etByte flag_alternateform;
  etByte flag_altform2;
  etByte flag_zeropad;
  etByte flag_long;
  etByte flag_longlong;
  etByte done;
  sqlite_uint64 longvalue;
  long double realvalue;
  const et_info *infop;
  char buf[350];
  char prefix;
  etByte xtype = 0;
  char *zExtra;

  int exp, e2;
  double rounder;
  etByte flag_dp;
  etByte flag_rtz;
  etByte flag_exp;
  int nsd;


  length = 0;
  bufpt = 0;
  for(; (c=(*fmt))!=0; ++fmt){
    if( c!='%' ){
      int amt;
      bufpt = (char *)fmt;
      amt = 1;
      while( (c=(*++fmt))!='%' && c!=0 ) amt++;
      sqlite3StrAccumAppend(pAccum, bufpt, amt);
      if( c==0 ) break;
    }
    if( (c=(*++fmt))==0 ){
      sqlite3StrAccumAppend(pAccum, "%", 1);
      break;
    }

    flag_leftjustify = flag_plussign = flag_blanksign =
     flag_alternateform = flag_altform2 = flag_zeropad = 0;
    done = 0;
    do{
      switch( c ){
        case '-': flag_leftjustify = 1; break;
        case '+': flag_plussign = 1; break;
        case ' ': flag_blanksign = 1; break;
        case '#': flag_alternateform = 1; break;
        case '!': flag_altform2 = 1; break;
        case '0': flag_zeropad = 1; break;
        default: done = 1; break;
      }
    }while( !done && (c=(*++fmt))!=0 );

    width = 0;
    if( c=='*' ){
      width = __builtin_va_arg(ap, int);
      if( width<0 ){
        flag_leftjustify = 1;
        width = -width;
      }
      c = *++fmt;
    }else{
      while( c>='0' && c<='9' ){
        width = width*10 + c - '0';
        c = *++fmt;
      }
    }
    if( width > 350 -10 ){
      width = 350 -10;
    }

    if( c=='.' ){
      precision = 0;
      c = *++fmt;
      if( c=='*' ){
        precision = __builtin_va_arg(ap, int);
        if( precision<0 ) precision = -precision;
        c = *++fmt;
      }else{
        while( c>='0' && c<='9' ){
          precision = precision*10 + c - '0';
          c = *++fmt;
        }
      }
    }else{
      precision = -1;
    }

    if( c=='l' ){
      flag_long = 1;
      c = *++fmt;
      if( c=='l' ){
        flag_longlong = 1;
        c = *++fmt;
      }else{
        flag_longlong = 0;
      }
    }else{
      flag_long = flag_longlong = 0;
    }

    infop = &fmtinfo[0];
    xtype = 0;
    for(idx=0; idx<((int)(sizeof(fmtinfo)/sizeof(fmtinfo[0]))); idx++){
      if( c==fmtinfo[idx].fmttype ){
        infop = &fmtinfo[idx];
        if( useExtended || (infop->flags & 2)==0 ){
          xtype = infop->type;
        }else{
          return;
        }
        break;
      }
    }
    zExtra = 0;



    if( precision>350 -40 && (infop->flags & 4)==0 ){
      precision = 350 -40;
    }
# 18852 "ext/sqlite3/libsqlite/sqlite3.c"
    switch( xtype ){
      case 14:
        flag_longlong = sizeof(char*)==sizeof(i64);
        flag_long = sizeof(char*)==sizeof(long int);

      case 16:
      case 1:
        if( infop->flags & 1 ){
          i64 v;
          if( flag_longlong ){
            v = __builtin_va_arg(ap, i64);
          }else if( flag_long ){
            v = __builtin_va_arg(ap, long int);
          }else{
            v = __builtin_va_arg(ap, int);
          }
          if( v<0 ){
            if( v==(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) ){
              longvalue = ((u64)1)<<63;
            }else{
              longvalue = -v;
            }
            prefix = '-';
          }else{
            longvalue = v;
            if( flag_plussign ) prefix = '+';
            else if( flag_blanksign ) prefix = ' ';
            else prefix = 0;
          }
        }else{
          if( flag_longlong ){
            longvalue = __builtin_va_arg(ap, u64);
          }else if( flag_long ){
            longvalue = __builtin_va_arg(ap, unsigned long int);
          }else{
            longvalue = __builtin_va_arg(ap, unsigned int);
          }
          prefix = 0;
        }
        if( longvalue==0 ) flag_alternateform = 0;
        if( flag_zeropad && precision<width-(prefix!=0) ){
          precision = width-(prefix!=0);
        }
        bufpt = &buf[350 -1];
        if( xtype==16 ){
          static const char zOrd[] = "thstndrd";
          int x = (int)(longvalue % 10);
          if( x>=4 || (longvalue/10)%10==1 ){
            x = 0;
          }
          buf[350 -3] = zOrd[x*2];
          buf[350 -2] = zOrd[x*2+1];
          bufpt -= 2;
        }
        {
          register const char *cset;
          register int base;
          cset = &aDigits[infop->charset];
          base = infop->base;
          do{
            *(--bufpt) = cset[longvalue%base];
            longvalue = longvalue/base;
          }while( longvalue>0 );
        }
        length = (int)(&buf[350 -1]-bufpt);
        for(idx=precision-length; idx>0; idx--){
          *(--bufpt) = '0';
        }
        if( prefix ) *(--bufpt) = prefix;
        if( flag_alternateform && infop->prefix ){
          const char *pre;
          char x;
          pre = &aPrefix[infop->prefix];
          for(; (x=(*pre))!=0; pre++) *(--bufpt) = x;
        }
        length = (int)(&buf[350 -1]-bufpt);
        break;
      case 2:
      case 3:
      case 4:
        realvalue = __builtin_va_arg(ap, double);



        if( precision<0 ) precision = 6;
        if( precision>350/2-10 ) precision = 350/2-10;
        if( realvalue<0.0 ){
          realvalue = -realvalue;
          prefix = '-';
        }else{
          if( flag_plussign ) prefix = '+';
          else if( flag_blanksign ) prefix = ' ';
          else prefix = 0;
        }
        if( xtype==4 && precision>0 ) precision--;





        for(idx=precision, rounder=0.5; idx>0; idx--, rounder*=0.1){}

        if( xtype==2 ) realvalue += rounder;

        exp = 0;
        if( sqlite3IsNaN((double)realvalue) ){
          bufpt = "NaN";
          length = 3;
          break;
        }
        if( realvalue>0.0 ){
          while( realvalue>=1e32 && exp<=350 ){ realvalue *= 1e-32; exp+=32; }
          while( realvalue>=1e8 && exp<=350 ){ realvalue *= 1e-8; exp+=8; }
          while( realvalue>=10.0 && exp<=350 ){ realvalue *= 0.1; exp++; }
          while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; }
          while( realvalue<1.0 ){ realvalue *= 10.0; exp--; }
          if( exp>350 ){
            if( prefix=='-' ){
              bufpt = "-Inf";
            }else if( prefix=='+' ){
              bufpt = "+Inf";
            }else{
              bufpt = "Inf";
            }
            length = sqlite3Strlen30(bufpt);
            break;
          }
        }
        bufpt = buf;




        flag_exp = xtype==3;
        if( xtype!=2 ){
          realvalue += rounder;
          if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }
        }
        if( xtype==4 ){
          flag_rtz = !flag_alternateform;
          if( exp<-4 || exp>precision ){
            xtype = 3;
          }else{
            precision = precision - exp;
            xtype = 2;
          }
        }else{
          flag_rtz = 0;
        }
        if( xtype==3 ){
          e2 = 0;
        }else{
          e2 = exp;
        }
        nsd = 0;
        flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2;

        if( prefix ){
          *(bufpt++) = prefix;
        }

        if( e2<0 ){
          *(bufpt++) = '0';
        }else{
          for(; e2>=0; e2--){
            *(bufpt++) = et_getdigit(&realvalue,&nsd);
          }
        }

        if( flag_dp ){
          *(bufpt++) = '.';
        }


        for(e2++; e2<0; precision--, e2++){
          ((void) (0));
          *(bufpt++) = '0';
        }

        while( (precision--)>0 ){
          *(bufpt++) = et_getdigit(&realvalue,&nsd);
        }

        if( flag_rtz && flag_dp ){
          while( bufpt[-1]=='0' ) *(--bufpt) = 0;
          ((void) (0));
          if( bufpt[-1]=='.' ){
            if( flag_altform2 ){
              *(bufpt++) = '0';
            }else{
              *(--bufpt) = 0;
            }
          }
        }

        if( flag_exp || xtype==3 ){
          *(bufpt++) = aDigits[infop->charset];
          if( exp<0 ){
            *(bufpt++) = '-'; exp = -exp;
          }else{
            *(bufpt++) = '+';
          }
          if( exp>=100 ){
            *(bufpt++) = (char)((exp/100)+'0');
            exp %= 100;
          }
          *(bufpt++) = (char)(exp/10+'0');
          *(bufpt++) = (char)(exp%10+'0');
        }
        *bufpt = 0;




        length = (int)(bufpt-buf);
        bufpt = buf;



        if( flag_zeropad && !flag_leftjustify && length < width){
          int i;
          int nPad = width - length;
          for(i=width; i>=nPad; i--){
            bufpt[i] = bufpt[i-nPad];
          }
          i = prefix!=0;
          while( nPad-- ) bufpt[i++] = '0';
          length = width;
        }

        break;
      case 5:
        *(__builtin_va_arg(ap, int*)) = pAccum->nChar;
        length = width = 0;
        break;
      case 8:
        buf[0] = '%';
        bufpt = buf;
        length = 1;
        break;
      case 9:
        c = __builtin_va_arg(ap, int);
        buf[0] = (char)c;
        if( precision>=0 ){
          for(idx=1; idx<precision; idx++) buf[idx] = (char)c;
          length = precision;
        }else{
          length =1;
        }
        bufpt = buf;
        break;
      case 6:
      case 7:
        bufpt = __builtin_va_arg(ap, char*);
        if( bufpt==0 ){
          bufpt = "";
        }else if( xtype==7 ){
          zExtra = bufpt;
        }
        if( precision>=0 ){
          for(length=0; length<precision && bufpt[length]; length++){}
        }else{
          length = sqlite3Strlen30(bufpt);
        }
        break;
      case 10:
      case 11:
      case 15: {
        int i, j, k, n, isnull;
        int needQuote;
        char ch;
        char q = ((xtype==15)?'"':'\'');
        char *escarg = __builtin_va_arg(ap, char*);
        isnull = escarg==0;
        if( isnull ) escarg = (xtype==11 ? "NULL" : "(NULL)");
        k = precision;
        for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){
          if( ch==q ) n++;
        }
        needQuote = !isnull && xtype==11;
        n += i + 1 + needQuote*2;
        if( n>350 ){
          bufpt = zExtra = sqlite3Malloc( n );
          if( bufpt==0 ){
            pAccum->mallocFailed = 1;
            return;
          }
        }else{
          bufpt = buf;
        }
        j = 0;
        if( needQuote ) bufpt[j++] = q;
        k = i;
        for(i=0; i<k; i++){
          bufpt[j++] = ch = escarg[i];
          if( ch==q ) bufpt[j++] = ch;
        }
        if( needQuote ) bufpt[j++] = q;
        bufpt[j] = 0;
        length = j;



        break;
      }
      case 12: {
        Token *pToken = __builtin_va_arg(ap, Token*);
        if( pToken ){
          sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);
        }
        length = width = 0;
        break;
      }
      case 13: {
        SrcList *pSrc = __builtin_va_arg(ap, SrcList*);
        int k = __builtin_va_arg(ap, int);
        struct SrcList_item *pItem = &pSrc->a[k];
        ((void) (0));
        if( pItem->zDatabase ){
          sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);
          sqlite3StrAccumAppend(pAccum, ".", 1);
        }
        sqlite3StrAccumAppend(pAccum, pItem->zName, -1);
        length = width = 0;
        break;
      }
      default: {
        ((void) (0));
        return;
      }
    }





    if( !flag_leftjustify ){
      register int nspace;
      nspace = width-length;
      if( nspace>0 ){
        appendSpace(pAccum, nspace);
      }
    }
    if( length>0 ){
      sqlite3StrAccumAppend(pAccum, bufpt, length);
    }
    if( flag_leftjustify ){
      register int nspace;
      nspace = width-length;
      if( nspace>0 ){
        appendSpace(pAccum, nspace);
      }
    }
    if( zExtra ){
      sqlite3_free(zExtra);
    }
  }
}




static void sqlite3StrAccumAppend(StrAccum *p, const char *z, int N){
  ((void) (0));
  if( p->tooBig | p->mallocFailed ){
                       ;
                             ;
    return;
  }
  if( N<0 ){
    N = sqlite3Strlen30(z);
  }
  if( N==0 || (z==0) ){
    return;
  }
  if( p->nChar+N >= p->nAlloc ){
    char *zNew;
    if( !p->useMalloc ){
      p->tooBig = 1;
      N = p->nAlloc - p->nChar - 1;
      if( N<=0 ){
        return;
      }
    }else{
      char *zOld = (p->zText==p->zBase ? 0 : p->zText);
      i64 szNew = p->nChar;
      szNew += N + 1;
      if( szNew > p->mxAlloc ){
        sqlite3StrAccumReset(p);
        p->tooBig = 1;
        return;
      }else{
        p->nAlloc = (int)szNew;
      }
      if( p->useMalloc==1 ){
        zNew = sqlite3DbRealloc(p->db, zOld, p->nAlloc);
      }else{
        zNew = sqlite3_realloc(zOld, p->nAlloc);
      }
      if( zNew ){
        if( zOld==0 ) memcpy(zNew, p->zText, p->nChar);
        p->zText = zNew;
      }else{
        p->mallocFailed = 1;
        sqlite3StrAccumReset(p);
        return;
      }
    }
  }
  memcpy(&p->zText[p->nChar], z, N);
  p->nChar += N;
}






static char *sqlite3StrAccumFinish(StrAccum *p){
  if( p->zText ){
    p->zText[p->nChar] = 0;
    if( p->useMalloc && p->zText==p->zBase ){
      if( p->useMalloc==1 ){
        p->zText = sqlite3DbMallocRaw(p->db, p->nChar+1 );
      }else{
        p->zText = sqlite3_malloc(p->nChar+1);
      }
      if( p->zText ){
        memcpy(p->zText, p->zBase, p->nChar+1);
      }else{
        p->mallocFailed = 1;
      }
    }
  }
  return p->zText;
}




static void sqlite3StrAccumReset(StrAccum *p){
  if( p->zText!=p->zBase ){
    if( p->useMalloc==1 ){
      sqlite3DbFree(p->db, p->zText);
    }else{
      sqlite3_free(p->zText);
    }
  }
  p->zText = 0;
}




static void sqlite3StrAccumInit(StrAccum *p, char *zBase, int n, int mx){
  p->zText = p->zBase = zBase;
  p->db = 0;
  p->nChar = 0;
  p->nAlloc = n;
  p->mxAlloc = mx;
  p->useMalloc = 1;
  p->tooBig = 0;
  p->mallocFailed = 0;
}





static char *sqlite3VMPrintf(sqlite3 *db, const char *zFormat, va_list ap){
  char *z;
  char zBase[350];
  StrAccum acc;
  ((void) (0));
  sqlite3StrAccumInit(&acc, zBase, sizeof(zBase),
                      db->aLimit[0]);
  acc.db = db;
  sqlite3VXPrintf(&acc, 1, zFormat, ap);
  z = sqlite3StrAccumFinish(&acc);
  if( acc.mallocFailed ){
    db->mallocFailed = 1;
  }
  return z;
}





static char *sqlite3MPrintf(sqlite3 *db, const char *zFormat, ...){
  va_list ap;
  char *z;
  __builtin_va_start(ap, zFormat);
  z = sqlite3VMPrintf(db, zFormat, ap);
  __builtin_va_end(ap);
  return z;
}
# 19358 "ext/sqlite3/libsqlite/sqlite3.c"
static char *sqlite3MAppendf(sqlite3 *db, char *zStr, const char *zFormat, ...){
  va_list ap;
  char *z;
  __builtin_va_start(ap, zFormat);
  z = sqlite3VMPrintf(db, zFormat, ap);
  __builtin_va_end(ap);
  sqlite3DbFree(db, zStr);
  return z;
}





           char *sqlite3_vmprintf(const char *zFormat, va_list ap){
  char *z;
  char zBase[350];
  StrAccum acc;

  if( sqlite3_initialize() ) return 0;

  sqlite3StrAccumInit(&acc, zBase, sizeof(zBase), 1000000000);
  acc.useMalloc = 2;
  sqlite3VXPrintf(&acc, 0, zFormat, ap);
  z = sqlite3StrAccumFinish(&acc);
  return z;
}





           char *sqlite3_mprintf(const char *zFormat, ...){
  va_list ap;
  char *z;

  if( sqlite3_initialize() ) return 0;

  __builtin_va_start(ap, zFormat);
  z = sqlite3_vmprintf(zFormat, ap);
  __builtin_va_end(ap);
  return z;
}
# 19415 "ext/sqlite3/libsqlite/sqlite3.c"
           char *sqlite3_vsnprintf(int n, char *zBuf, const char *zFormat, va_list ap){
  StrAccum acc;
  if( n<=0 ) return zBuf;
  sqlite3StrAccumInit(&acc, zBuf, n, 0);
  acc.useMalloc = 0;
  sqlite3VXPrintf(&acc, 0, zFormat, ap);
  return sqlite3StrAccumFinish(&acc);
}
           char *sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...){
  char *z;
  va_list ap;
  __builtin_va_start(ap, zFormat);
  z = sqlite3_vsnprintf(n, zBuf, zFormat, ap);
  __builtin_va_end(ap);
  return z;
}
# 19441 "ext/sqlite3/libsqlite/sqlite3.c"
static void renderLogMsg(int iErrCode, const char *zFormat, va_list ap){
  StrAccum acc;
  char zMsg[350*3];

  sqlite3StrAccumInit(&acc, zMsg, sizeof(zMsg), 0);
  acc.useMalloc = 0;
  sqlite3VXPrintf(&acc, 0, zFormat, ap);
  sqlite3Config.xLog(sqlite3Config.pLogArg, iErrCode,
                           sqlite3StrAccumFinish(&acc));
}




           void sqlite3_log(int iErrCode, const char *zFormat, ...){
  va_list ap;
  if( sqlite3Config.xLog ){
    __builtin_va_start(ap, zFormat);
    renderLogMsg(iErrCode, zFormat, ap);
    __builtin_va_end(ap);
  }
}
# 19489 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3XPrintf(StrAccum *p, const char *zFormat, ...){
  va_list ap;
  __builtin_va_start(ap, zFormat);
  sqlite3VXPrintf(p, 1, zFormat, ap);
  __builtin_va_end(ap);
}
# 19521 "ext/sqlite3/libsqlite/sqlite3.c"
static struct sqlite3PrngType {
  unsigned char isInit;
  unsigned char i, j;
  unsigned char s[256];
} sqlite3Prng;
# 19543 "ext/sqlite3/libsqlite/sqlite3.c"
static u8 randomByte(void){
  unsigned char t;
# 19570 "ext/sqlite3/libsqlite/sqlite3.c"
  if( !sqlite3Prng.isInit ){
    int i;
    char k[256];
    sqlite3Prng.j = 0;
    sqlite3Prng.i = 0;
    sqlite3OsRandomness(sqlite3_vfs_find(0), 256, k);
    for(i=0; i<256; i++){
      sqlite3Prng.s[i] = (u8)i;
    }
    for(i=0; i<256; i++){
      sqlite3Prng.j += sqlite3Prng.s[i] + k[i];
      t = sqlite3Prng.s[sqlite3Prng.j];
      sqlite3Prng.s[sqlite3Prng.j] = sqlite3Prng.s[i];
      sqlite3Prng.s[i] = t;
    }
    sqlite3Prng.isInit = 1;
  }



  sqlite3Prng.i++;
  t = sqlite3Prng.s[sqlite3Prng.i];
  sqlite3Prng.j += t;
  sqlite3Prng.s[sqlite3Prng.i] = sqlite3Prng.s[sqlite3Prng.j];
  sqlite3Prng.s[sqlite3Prng.j] = t;
  t += sqlite3Prng.s[sqlite3Prng.i];
  return sqlite3Prng.s[t];
}




           void sqlite3_randomness(int N, void *pBuf){
  unsigned char *zBuf = pBuf;



                            ;
  while( N-- ){
    *(zBuf++) = randomByte();
  }
                            ;
}
# 19624 "ext/sqlite3/libsqlite/sqlite3.c"
static struct sqlite3PrngType sqlite3SavedPrng;
static void sqlite3PrngSaveState(void){
  memcpy(
    &sqlite3SavedPrng,
    &sqlite3Prng,
    sizeof(sqlite3Prng)
  );
}
static void sqlite3PrngRestoreState(void){
  memcpy(
    &sqlite3Prng,
    &sqlite3SavedPrng,
    sizeof(sqlite3Prng)
  );
}
static void sqlite3PrngResetState(void){
  sqlite3Prng.isInit = 0;
}
# 19694 "ext/sqlite3/libsqlite/sqlite3.c"
static const unsigned char sqlite3Utf8Trans1[] = {
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,
};
# 19808 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Utf8Read(
  const unsigned char *zIn,
  const unsigned char **pzNext
){
  unsigned int c;




  c = *(zIn++);
  if( c>=0xc0 ){
    c = sqlite3Utf8Trans1[c-0xc0];
    while( (*zIn & 0xc0)==0x80 ){
      c = (c<<6) + (0x3f & *(zIn++));
    }
    if( c<0x80
        || (c&0xFFFFF800)==0xD800
        || (c&0xFFFFFFFE)==0xFFFE ){ c = 0xFFFD; }
  }
  *pzNext = zIn;
  return c;
}
# 19846 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeMemTranslate(Mem *pMem, u8 desiredEnc){
  int len;
  unsigned char *zOut;
  unsigned char *zIn;
  unsigned char *zTerm;
  unsigned char *z;
  unsigned int c;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
# 19872 "ext/sqlite3/libsqlite/sqlite3.c"
  if( pMem->enc!=1 && desiredEnc!=1 ){
    u8 temp;
    int rc;
    rc = sqlite3VdbeMemMakeWriteable(pMem);
    if( rc!=0 ){
      ((void) (0));
      return 7;
    }
    zIn = (u8*)pMem->z;
    zTerm = &zIn[pMem->n&~1];
    while( zIn<zTerm ){
      temp = *zIn;
      *zIn = *(zIn+1);
      zIn++;
      *zIn++ = temp;
    }
    pMem->enc = desiredEnc;
    goto translate_out;
  }


  if( desiredEnc==1 ){





    pMem->n &= ~1;
    len = pMem->n * 2 + 1;
  }else{





    len = pMem->n * 2 + 2;
  }







  zIn = (u8*)pMem->z;
  zTerm = &zIn[pMem->n];
  zOut = sqlite3DbMallocRaw(pMem->db, len);
  if( !zOut ){
    return 7;
  }
  z = zOut;

  if( pMem->enc==1 ){
    if( desiredEnc==2 ){

      while( zIn<zTerm ){

        c = *(zIn++); if( c>=0xc0 ){ c = sqlite3Utf8Trans1[c-0xc0]; while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){ c = (c<<6) + (0x3f & *(zIn++)); } if( c<0x80 || (c&0xFFFFF800)==0xD800 || (c&0xFFFFFFFE)==0xFFFE ){ c = 0xFFFD; } };
        { if( c<=0xFFFF ){ *z++ = (u8)(c&0x00FF); *z++ = (u8)((c>>8)&0x00FF); }else{ *z++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0)); *z++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03)); *z++ = (u8)(c&0x00FF); *z++ = (u8)(0x00DC + ((c>>8)&0x03)); } };
      }
    }else{
      ((void) (0));

      while( zIn<zTerm ){

        c = *(zIn++); if( c>=0xc0 ){ c = sqlite3Utf8Trans1[c-0xc0]; while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){ c = (c<<6) + (0x3f & *(zIn++)); } if( c<0x80 || (c&0xFFFFF800)==0xD800 || (c&0xFFFFFFFE)==0xFFFE ){ c = 0xFFFD; } };
        { if( c<=0xFFFF ){ *z++ = (u8)((c>>8)&0x00FF); *z++ = (u8)(c&0x00FF); }else{ *z++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03)); *z++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0)); *z++ = (u8)(0x00DC + ((c>>8)&0x03)); *z++ = (u8)(c&0x00FF); } };
      }
    }
    pMem->n = (int)(z - zOut);
    *z++ = 0;
  }else{
    ((void) (0));
    if( pMem->enc==2 ){

      while( zIn<zTerm ){
        { c = (*zIn++); c += ((*zIn++)<<8); if( c>=0xD800 && c<0xE000 && zIn<zTerm ){ int c2 = (*zIn++); c2 += ((*zIn++)<<8); c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10); } };
        { if( c<0x00080 ){ *z++ = (u8)(c&0xFF); } else if( c<0x00800 ){ *z++ = 0xC0 + (u8)((c>>6)&0x1F); *z++ = 0x80 + (u8)(c & 0x3F); } else if( c<0x10000 ){ *z++ = 0xE0 + (u8)((c>>12)&0x0F); *z++ = 0x80 + (u8)((c>>6) & 0x3F); *z++ = 0x80 + (u8)(c & 0x3F); }else{ *z++ = 0xF0 + (u8)((c>>18) & 0x07); *z++ = 0x80 + (u8)((c>>12) & 0x3F); *z++ = 0x80 + (u8)((c>>6) & 0x3F); *z++ = 0x80 + (u8)(c & 0x3F); } };
      }
    }else{

      while( zIn<zTerm ){
        { c = ((*zIn++)<<8); c += (*zIn++); if( c>=0xD800 && c<0xE000 && zIn<zTerm ){ int c2 = ((*zIn++)<<8); c2 += (*zIn++); c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10); } };
        { if( c<0x00080 ){ *z++ = (u8)(c&0xFF); } else if( c<0x00800 ){ *z++ = 0xC0 + (u8)((c>>6)&0x1F); *z++ = 0x80 + (u8)(c & 0x3F); } else if( c<0x10000 ){ *z++ = 0xE0 + (u8)((c>>12)&0x0F); *z++ = 0x80 + (u8)((c>>6) & 0x3F); *z++ = 0x80 + (u8)(c & 0x3F); }else{ *z++ = 0xF0 + (u8)((c>>18) & 0x07); *z++ = 0x80 + (u8)((c>>12) & 0x3F); *z++ = 0x80 + (u8)((c>>6) & 0x3F); *z++ = 0x80 + (u8)(c & 0x3F); } };
      }
    }
    pMem->n = (int)(z - zOut);
  }
  *z = 0;
  ((void) (0));

  sqlite3VdbeMemRelease(pMem);
  pMem->flags &= ~(0x0800|0x0400|0x1000);
  pMem->enc = desiredEnc;
  pMem->flags |= (0x0200|0x0400);
  pMem->z = (char*)zOut;
  pMem->zMalloc = pMem->z;

translate_out:







  return 0;
}
# 19990 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeMemHandleBom(Mem *pMem){
  int rc = 0;
  u8 bom = 0;

  ((void) (0));
  if( pMem->n>1 ){
    u8 b1 = *(u8 *)pMem->z;
    u8 b2 = *(((u8 *)pMem->z) + 1);
    if( b1==0xFE && b2==0xFF ){
      bom = 3;
    }
    if( b1==0xFF && b2==0xFE ){
      bom = 2;
    }
  }

  if( bom ){
    rc = sqlite3VdbeMemMakeWriteable(pMem);
    if( rc==0 ){
      pMem->n -= 2;
      memmove(pMem->z, &pMem->z[2], pMem->n);
      pMem->z[pMem->n] = '\0';
      pMem->z[pMem->n+1] = '\0';
      pMem->flags |= 0x0200;
      pMem->enc = bom;
    }
  }
  return rc;
}
# 20028 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Utf8CharLen(const char *zIn, int nByte){
  int r = 0;
  const u8 *z = (const u8*)zIn;
  const u8 *zTerm;
  if( nByte>=0 ){
    zTerm = &z[nByte];
  }else{
    zTerm = (const u8*)(-1);
  }
  ((void) (0));
  while( *z!=0 && z<zTerm ){
    { if( (*(z++))>=0xc0 ){ while( (*z & 0xc0)==0x80 ){ z++; } } };
    r++;
  }
  return r;
}
# 20082 "ext/sqlite3/libsqlite/sqlite3.c"
static char *sqlite3Utf16to8(sqlite3 *db, const void *z, int nByte, u8 enc){
  Mem m;
  memset(&m, 0, sizeof(m));
  m.db = db;
  sqlite3VdbeMemSetStr(&m, z, nByte, enc, ((sqlite3_destructor_type)0));
  sqlite3VdbeChangeEncoding(&m, 1);
  if( db->mallocFailed ){
    sqlite3VdbeMemRelease(&m);
    m.z = 0;
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  return m.z;
}
# 20130 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Utf16ByteLen(const void *zIn, int nChar){
  int c;
  unsigned char const *z = zIn;
  int n = 0;

  if( 2==3 ){
    while( n<nChar ){
      { c = ((*z++)<<8); c += (*z++); if( c>=0xD800 && c<0xE000 && 1 ){ int c2 = ((*z++)<<8); c2 += (*z++); c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10); } };
      n++;
    }
  }else{
    while( n<nChar ){
      { c = (*z++); c += ((*z++)<<8); if( c>=0xD800 && c<0xE000 && 1 ){ int c2 = (*z++); c2 += ((*z++)<<8); c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10); } };
      n++;
    }
  }
  return (int)(z-(unsigned char const *)zIn);
}
# 20244 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3IsNaN(double x){
  int rc;
# 20273 "ext/sqlite3/libsqlite/sqlite3.c"
  volatile double y = x;
  volatile double z = y;
  rc = (y!=z);



                ;
  return rc;
}
# 20292 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Strlen30(const char *z){
  const char *z2 = z;
  if( z==0 ) return 0;
  while( *z2 ){ z2++; }
  return 0x3fffffff & (int)(z2 - z);
}
# 20320 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3Error(sqlite3 *db, int err_code, const char *zFormat, ...){
  if( db && (db->pErr || (db->pErr = sqlite3ValueNew(db))!=0) ){
    db->errCode = err_code;
    if( zFormat ){
      char *z;
      va_list ap;
      __builtin_va_start(ap, zFormat);
      z = sqlite3VMPrintf(db, zFormat, ap);
      __builtin_va_end(ap);
      sqlite3ValueSetStr(db->pErr, -1, z, 1, ((sqlite3_destructor_type)sqlite3DbFree));
    }else{
      sqlite3ValueSetStr(db->pErr, 0, 0, 1, ((sqlite3_destructor_type)0));
    }
  }
}
# 20353 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3ErrorMsg(Parse *pParse, const char *zFormat, ...){
  char *zMsg;
  va_list ap;
  sqlite3 *db = pParse->db;
  __builtin_va_start(ap, zFormat);
  zMsg = sqlite3VMPrintf(db, zFormat, ap);
  __builtin_va_end(ap);
  if( db->suppressErr ){
    sqlite3DbFree(db, zMsg);
  }else{
    pParse->nErr++;
    sqlite3DbFree(db, pParse->zErrMsg);
    pParse->zErrMsg = zMsg;
    pParse->rc = 1;
  }
}
# 20387 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Dequote(char *z){
  char quote;
  int i, j;
  if( z==0 ) return -1;
  quote = z[0];
  switch( quote ){
    case '\'': break;
    case '"': break;
    case '`': break;
    case '[': quote = ']'; break;
    default: return -1;
  }
  for(i=1, j=0; (z[i]); i++){
    if( z[i]==quote ){
      if( z[i+1]==quote ){
        z[j++] = quote;
        i++;
      }else{
        break;
      }
    }else{
      z[j++] = z[i];
    }
  }
  z[j] = 0;
  return j;
}
# 20428 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3StrICmp(const char *zLeft, const char *zRight){
  register unsigned char *a, *b;
  a = (unsigned char *)zLeft;
  b = (unsigned char *)zRight;
  while( *a!=0 && sqlite3UpperToLower[*a]==sqlite3UpperToLower[*b]){ a++; b++; }
  return sqlite3UpperToLower[*a] - sqlite3UpperToLower[*b];
}
           int sqlite3_strnicmp(const char *zLeft, const char *zRight, int N){
  register unsigned char *a, *b;
  a = (unsigned char *)zLeft;
  b = (unsigned char *)zRight;
  while( N-- > 0 && *a!=0 && sqlite3UpperToLower[*a]==sqlite3UpperToLower[*b]){ a++; b++; }
  return N<0 ? 0 : sqlite3UpperToLower[*a] - sqlite3UpperToLower[*b];
}
# 20465 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3AtoF(const char *z, double *pResult, int length, u8 enc){

  int incr = (enc==1?1:2);
  const char *zEnd = z + length;

  int sign = 1;
  i64 s = 0;
  int d = 0;
  int esign = 1;
  int e = 0;
  int eValid = 1;
  double result;
  int nDigits = 0;

  *pResult = 0.0;

  if( enc==3 ) z++;


  while( z<zEnd && (sqlite3CtypeMap[(unsigned char)(*z)]&0x01) ) z+=incr;
  if( z>=zEnd ) return 0;


  if( *z=='-' ){
    sign = -1;
    z+=incr;
  }else if( *z=='+' ){
    z+=incr;
  }


  while( z<zEnd && z[0]=='0' ) z+=incr, nDigits++;


  while( z<zEnd && (sqlite3CtypeMap[(unsigned char)(*z)]&0x04) && s<(((0xffffffff|(((i64)0x7fffffff)<<32))-9)/10) ){
    s = s*10 + (*z - '0');
    z+=incr, nDigits++;
  }



  while( z<zEnd && (sqlite3CtypeMap[(unsigned char)(*z)]&0x04) ) z+=incr, nDigits++, d++;
  if( z>=zEnd ) goto do_atof_calc;


  if( *z=='.' ){
    z+=incr;


    while( z<zEnd && (sqlite3CtypeMap[(unsigned char)(*z)]&0x04) && s<(((0xffffffff|(((i64)0x7fffffff)<<32))-9)/10) ){
      s = s*10 + (*z - '0');
      z+=incr, nDigits++, d--;
    }

    while( z<zEnd && (sqlite3CtypeMap[(unsigned char)(*z)]&0x04) ) z+=incr, nDigits++;
  }
  if( z>=zEnd ) goto do_atof_calc;


  if( *z=='e' || *z=='E' ){
    z+=incr;
    eValid = 0;
    if( z>=zEnd ) goto do_atof_calc;

    if( *z=='-' ){
      esign = -1;
      z+=incr;
    }else if( *z=='+' ){
      z+=incr;
    }

    while( z<zEnd && (sqlite3CtypeMap[(unsigned char)(*z)]&0x04) ){
      e = e*10 + (*z - '0');
      z+=incr;
      eValid = 1;
    }
  }


  if( nDigits && eValid ){
    while( z<zEnd && (sqlite3CtypeMap[(unsigned char)(*z)]&0x01) ) z+=incr;
  }

do_atof_calc:

  e = (e*esign) + d;
  if( e<0 ) {
    esign = -1;
    e *= -1;
  } else {
    esign = 1;
  }


  if( !s ) {


    result = (sign<0 && nDigits) ? -(double)0 : (double)0;
  } else {

    if( esign>0 ){
      while( s<((0xffffffff|(((i64)0x7fffffff)<<32))/10) && e>0 ) e--,s*=10;
    }else{
      while( !(s%10) && e>0 ) e--,s/=10;
    }


    s = sign<0 ? -s : s;



    if( e ){
      double scale = 1.0;

      if( e>307 && e<342 ){
        while( e%308 ) { scale *= 1.0e+1; e -= 1; }
        if( esign<0 ){
          result = s / scale;
          result /= 1.0e+308;
        }else{
          result = s * scale;
          result *= 1.0e+308;
        }
      }else{


        while( e%22 ) { scale *= 1.0e+1; e -= 1; }
        while( e>0 ) { scale *= 1.0e+22; e -= 22; }
        if( esign<0 ){
          result = s / scale;
        }else{
          result = s * scale;
        }
      }
    } else {
      result = (double)s;
    }
  }


  *pResult = result;


  return z>=zEnd && nDigits>0 && eValid;



}
# 20628 "ext/sqlite3/libsqlite/sqlite3.c"
static int compare2pow63(const char *zNum, int incr){
  int c = 0;
  int i;

  const char *pow63 = "922337203685477580";
  for(i=0; c==0 && i<18; i++){
    c = (zNum[i*incr]-pow63[i])*10;
  }
  if( c==0 ){
    c = zNum[18*incr] - '8';
                       ;
                    ;
                       ;
  }
  return c;
}
# 20663 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Atoi64(const char *zNum, i64 *pNum, int length, u8 enc){
  int incr = (enc==1?1:2);
  u64 u = 0;
  int neg = 0;
  int i;
  int c = 0;
  const char *zStart;
  const char *zEnd = zNum + length;
  if( enc==3 ) zNum++;
  while( zNum<zEnd && (sqlite3CtypeMap[(unsigned char)(*zNum)]&0x01) ) zNum+=incr;
  if( zNum<zEnd ){
    if( *zNum=='-' ){
      neg = 1;
      zNum+=incr;
    }else if( *zNum=='+' ){
      zNum+=incr;
    }
  }
  zStart = zNum;
  while( zNum<zEnd && zNum[0]=='0' ){ zNum+=incr; }
  for(i=0; &zNum[i]<zEnd && (c=zNum[i])>='0' && c<='9'; i+=incr){
    u = u*10 + c - '0';
  }
  if( u>(0xffffffff|(((i64)0x7fffffff)<<32)) ){
    *pNum = (((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32)));
  }else if( neg ){
    *pNum = -(i64)u;
  }else{
    *pNum = (i64)u;
  }
                   ;
                   ;
                   ;
  if( (c!=0 && &zNum[i]<zEnd) || (i==0 && zStart==zNum) || i>19*incr ){


    return 1;
  }else if( i<19*incr ){

    ((void) (0));
    return 0;
  }else{

    c = compare2pow63(zNum, incr);
    if( c<0 ){

      ((void) (0));
      return 0;
    }else if( c>0 ){

      return 1;
    }else{


      ((void) (0));
      ((void) (0));
      return neg ? 0 : 2;
    }
  }
}
# 20732 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3GetInt32(const char *zNum, int *pValue){
  sqlite_int64 v = 0;
  int i, c;
  int neg = 0;
  if( zNum[0]=='-' ){
    neg = 1;
    zNum++;
  }else if( zNum[0]=='+' ){
    zNum++;
  }
  while( zNum[0]=='0' ) zNum++;
  for(i=0; i<11 && (c = zNum[i] - '0')>=0 && c<=9; i++){
    v = v*10 + c;
  }






                   ;
  if( i>10 ){
    return 0;
  }
                               ;
  if( v-neg>2147483647 ){
    return 0;
  }
  if( neg ){
    v = -v;
  }
  *pValue = (int)v;
  return 1;
}





static int sqlite3Atoi(const char *z){
  int x = 0;
  if( z ) sqlite3GetInt32(z, &x);
  return x;
}
# 20806 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PutVarint(unsigned char *p, u64 v){
  int i, j, n;
  u8 buf[10];
  if( v & (((u64)0xff000000)<<32) ){
    p[8] = (u8)v;
    v >>= 8;
    for(i=7; i>=0; i--){
      p[i] = (u8)((v & 0x7f) | 0x80);
      v >>= 7;
    }
    return 9;
  }
  n = 0;
  do{
    buf[n++] = (u8)((v & 0x7f) | 0x80);
    v >>= 7;
  }while( v!=0 );
  buf[0] &= 0x7f;
  ((void) (0));
  for(i=0, j=n-1; j>=0; j--, i++){
    p[i] = buf[j];
  }
  return n;
}
# 20839 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PutVarint32(unsigned char *p, u32 v){






  if( (v & ~0x3fff)==0 ){
    p[0] = (u8)((v>>7) | 0x80);
    p[1] = (u8)(v & 0x7f);
    return 2;
  }
  return sqlite3PutVarint(p, v);
}
# 20871 "ext/sqlite3/libsqlite/sqlite3.c"
static u8 sqlite3GetVarint(const unsigned char *p, u64 *v){
  u32 a,b,s;

  a = *p;

  if (!(a&0x80))
  {
    *v = a;
    return 1;
  }

  p++;
  b = *p;

  if (!(b&0x80))
  {
    a &= 0x7f;
    a = a<<7;
    a |= b;
    *v = a;
    return 2;
  }


  ((void) (0));
  ((void) (0));

  p++;
  a = a<<14;
  a |= *p;

  if (!(a&0x80))
  {
    a &= 0x001fc07f;
    b &= 0x7f;
    b = b<<7;
    a |= b;
    *v = a;
    return 3;
  }


  a &= 0x001fc07f;
  p++;
  b = b<<14;
  b |= *p;

  if (!(b&0x80))
  {
    b &= 0x001fc07f;


    a = a<<7;
    a |= b;
    *v = a;
    return 4;
  }






  b &= 0x001fc07f;
  s = a;


  p++;
  a = a<<14;
  a |= *p;

  if (!(a&0x80))
  {



    b = b<<7;
    a |= b;
    s = s>>18;
    *v = ((u64)s)<<32 | a;
    return 5;
  }


  s = s<<7;
  s |= b;


  p++;
  b = b<<14;
  b |= *p;

  if (!(b&0x80))
  {


    a &= 0x001fc07f;
    a = a<<7;
    a |= b;
    s = s>>18;
    *v = ((u64)s)<<32 | a;
    return 6;
  }

  p++;
  a = a<<14;
  a |= *p;

  if (!(a&0x80))
  {
    a &= 0xf01fc07f;
    b &= 0x001fc07f;
    b = b<<7;
    a |= b;
    s = s>>11;
    *v = ((u64)s)<<32 | a;
    return 7;
  }


  a &= 0x001fc07f;
  p++;
  b = b<<14;
  b |= *p;

  if (!(b&0x80))
  {
    b &= 0xf01fc07f;


    a = a<<7;
    a |= b;
    s = s>>4;
    *v = ((u64)s)<<32 | a;
    return 8;
  }

  p++;
  a = a<<15;
  a |= *p;




  b &= 0x001fc07f;
  b = b<<8;
  a |= b;

  s = s<<4;
  b = p[-4];
  b &= 0x7f;
  b = b>>3;
  s |= b;

  *v = ((u64)s)<<32 | a;

  return 9;
}
# 21041 "ext/sqlite3/libsqlite/sqlite3.c"
static u8 sqlite3GetVarint32(const unsigned char *p, u32 *v){
  u32 a,b;



  a = *p;
# 21058 "ext/sqlite3/libsqlite/sqlite3.c"
  p++;
  b = *p;

  if (!(b&0x80))
  {

    a &= 0x7f;
    a = a<<7;
    *v = a | b;
    return 2;
  }


  p++;
  a = a<<14;
  a |= *p;

  if (!(a&0x80))
  {

    a &= (0x7f<<14)|(0x7f);
    b &= 0x7f;
    b = b<<7;
    *v = a | b;
    return 3;
  }
# 21095 "ext/sqlite3/libsqlite/sqlite3.c"
  {
    u64 v64;
    u8 n;

    p -= 2;
    n = sqlite3GetVarint(p, &v64);
    ((void) (0));
    if( (v64 & ((((u64)1)<<32)-1))!=v64 ){
      *v = 0xffffffff;
    }else{
      *v = (u32)v64;
    }
    return n;
  }
# 21158 "ext/sqlite3/libsqlite/sqlite3.c"
}





static int sqlite3VarintLen(u64 v){
  int i = 0;
  do{
    i++;
    v >>= 7;
  }while( v!=0 && (i<9) );
  return i;
}





static u32 sqlite3Get4byte(const u8 *p){
  return (p[0]<<24) | (p[1]<<16) | (p[2]<<8) | p[3];
}
static void sqlite3Put4byte(unsigned char *p, u32 v){
  p[0] = (u8)(v>>24);
  p[1] = (u8)(v>>16);
  p[2] = (u8)(v>>8);
  p[3] = (u8)v;
}
# 21195 "ext/sqlite3/libsqlite/sqlite3.c"
static u8 hexToInt(int h){
  ((void) (0));

  h += 9*(1&(h>>6));




  return (u8)(h & 0xf);
}
# 21214 "ext/sqlite3/libsqlite/sqlite3.c"
static void *sqlite3HexToBlob(sqlite3 *db, const char *z, int n){
  char *zBlob;
  int i;

  zBlob = (char *)sqlite3DbMallocRaw(db, n/2 + 1);
  n--;
  if( zBlob ){
    for(i=0; i<n; i+=2){
      zBlob[i/2] = (hexToInt(z[i])<<4) | hexToInt(z[i+1]);
    }
    zBlob[i/2] = 0;
  }
  return zBlob;
}







static void logBadConnection(const char *zType){
  sqlite3_log(21,
     "API call with %s database connection pointer",
     zType
  );
}
# 21256 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3SafetyCheckOk(sqlite3 *db){
  u32 magic;
  if( db==0 ){
    logBadConnection("NULL");
    return 0;
  }
  magic = db->magic;
  if( magic!=0xa029a697 ){
    if( sqlite3SafetyCheckSickOrOk(db) ){
                                             ;
      logBadConnection("unopened");
    }
    return 0;
  }else{
    return 1;
  }
}
static int sqlite3SafetyCheckSickOrOk(sqlite3 *db){
  u32 magic;
  magic = db->magic;
  if( magic!=0x4b771290 &&
      magic!=0xa029a697 &&
      magic!=0xf03b7906 ){
                                           ;
    logBadConnection("invalid");
    return 0;
  }else{
    return 1;
  }
}







static int sqlite3AddInt64(i64 *pA, i64 iB){
  i64 iA = *pA;
                   ; ;
                    ; ;
  if( iB>=0 ){
                                                ;
                                                    ;
    if( iA>0 && (0xffffffff|(((i64)0x7fffffff)<<32)) - iA < iB ) return 1;
    *pA += iB;
  }else{
                                                       ;
                                                       ;
    if( iA<0 && -(iA + (0xffffffff|(((i64)0x7fffffff)<<32))) > iB + 1 ) return 1;
    *pA += iB;
  }
  return 0;
}
static int sqlite3SubInt64(i64 *pA, i64 iB){
                                  ;
  if( iB==(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) ){
                           ; ;
    if( (*pA)>=0 ) return 1;
    *pA -= iB;
    return 0;
  }else{
    return sqlite3AddInt64(pA, -iB);
  }
}


static int sqlite3MulInt64(i64 *pA, i64 iB){
  i64 iA = *pA;
  i64 iA1, iA0, iB1, iB0, r;

  iA1 = iA/(((i64)1)<<32);
  iA0 = iA % (((i64)1)<<32);
  iB1 = iB/(((i64)1)<<32);
  iB0 = iB % (((i64)1)<<32);
  if( iA1*iB1 != 0 ) return 1;
  ((void) (0));
  r = iA1*iB0 + iA0*iB1;
                                ;
                              ;
                           ;
                             ;
  if( r<(-(((i64)1)<<31)) || r>=(((i64)1)<<31) ) return 1;
  r *= (((i64)1)<<32);
  if( sqlite3AddInt64(&r, iA0*iB0) ) return 1;
  *pA = r;
  return 0;
}





static int sqlite3AbsInt32(int x){
  if( x>=0 ) return x;
  if( x==(int)0x80000000 ) return 0x7fffffff;
  return -x;
}
# 21377 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3HashInit(Hash *pNew){
  ((void) (0));
  pNew->first = 0;
  pNew->count = 0;
  pNew->htsize = 0;
  pNew->ht = 0;
}





static void sqlite3HashClear(Hash *pH){
  HashElem *elem;

  ((void) (0));
  elem = pH->first;
  pH->first = 0;
  sqlite3_free(pH->ht);
  pH->ht = 0;
  pH->htsize = 0;
  while( elem ){
    HashElem *next_elem = elem->next;
    sqlite3_free(elem);
    elem = next_elem;
  }
  pH->count = 0;
}




static unsigned int strHash(const char *z, int nKey){
  int h = 0;
  ((void) (0));
  while( nKey > 0 ){
    h = (h<<3) ^ h ^ sqlite3UpperToLower[(unsigned char)*z++];
    nKey--;
  }
  return h;
}





static void insertElement(
  Hash *pH,
  struct _ht *pEntry,
  HashElem *pNew
){
  HashElem *pHead;
  if( pEntry ){
    pHead = pEntry->count ? pEntry->chain : 0;
    pEntry->count++;
    pEntry->chain = pNew;
  }else{
    pHead = 0;
  }
  if( pHead ){
    pNew->next = pHead;
    pNew->prev = pHead->prev;
    if( pHead->prev ){ pHead->prev->next = pNew; }
    else { pH->first = pNew; }
    pHead->prev = pNew;
  }else{
    pNew->next = pH->first;
    if( pH->first ){ pH->first->prev = pNew; }
    pNew->prev = 0;
    pH->first = pNew;
  }
}
# 21457 "ext/sqlite3/libsqlite/sqlite3.c"
static int rehash(Hash *pH, unsigned int new_size){
  struct _ht *new_ht;
  HashElem *elem, *next_elem;


  if( new_size*sizeof(struct _ht)>1024 ){
    new_size = 1024/sizeof(struct _ht);
  }
  if( new_size==pH->htsize ) return 0;






  sqlite3BeginBenignMalloc();
  new_ht = (struct _ht *)sqlite3Malloc( new_size*sizeof(struct _ht) );
  sqlite3EndBenignMalloc();

  if( new_ht==0 ) return 0;
  sqlite3_free(pH->ht);
  pH->ht = new_ht;
  pH->htsize = new_size = sqlite3MallocSize(new_ht)/sizeof(struct _ht);
  memset(new_ht, 0, new_size*sizeof(struct _ht));
  for(elem=pH->first, pH->first=0; elem; elem = next_elem){
    unsigned int h = strHash(elem->pKey, elem->nKey) % new_size;
    next_elem = elem->next;
    insertElement(pH, &new_ht[h], elem);
  }
  return 1;
}





static HashElem *findElementGivenHash(
  const Hash *pH,
  const char *pKey,
  int nKey,
  unsigned int h
){
  HashElem *elem;
  int count;

  if( pH->ht ){
    struct _ht *pEntry = &pH->ht[h];
    elem = pEntry->chain;
    count = pEntry->count;
  }else{
    elem = pH->first;
    count = pH->count;
  }
  while( count-- && (elem) ){
    if( elem->nKey==nKey && sqlite3_strnicmp(elem->pKey,pKey,nKey)==0 ){
      return elem;
    }
    elem = elem->next;
  }
  return 0;
}




static void removeElementGivenHash(
  Hash *pH,
  HashElem* elem,
  unsigned int h
){
  struct _ht *pEntry;
  if( elem->prev ){
    elem->prev->next = elem->next;
  }else{
    pH->first = elem->next;
  }
  if( elem->next ){
    elem->next->prev = elem->prev;
  }
  if( pH->ht ){
    pEntry = &pH->ht[h];
    if( pEntry->chain==elem ){
      pEntry->chain = elem->next;
    }
    pEntry->count--;
    ((void) (0));
  }
  sqlite3_free( elem );
  pH->count--;
  if( pH->count<=0 ){
    ((void) (0));
    ((void) (0));
    sqlite3HashClear(pH);
  }
}





static void *sqlite3HashFind(const Hash *pH, const char *pKey, int nKey){
  HashElem *elem;
  unsigned int h;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pH->ht ){
    h = strHash(pKey, nKey) % pH->htsize;
  }else{
    h = 0;
  }
  elem = findElementGivenHash(pH, pKey, nKey, h);
  return elem ? elem->data : 0;
}
# 21587 "ext/sqlite3/libsqlite/sqlite3.c"
static void *sqlite3HashInsert(Hash *pH, const char *pKey, int nKey, void *data){
  unsigned int h;
  HashElem *elem;
  HashElem *new_elem;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pH->htsize ){
    h = strHash(pKey, nKey) % pH->htsize;
  }else{
    h = 0;
  }
  elem = findElementGivenHash(pH,pKey,nKey,h);
  if( elem ){
    void *old_data = elem->data;
    if( data==0 ){
      removeElementGivenHash(pH,elem,h);
    }else{
      elem->data = data;
      elem->pKey = pKey;
      ((void) (0));
    }
    return old_data;
  }
  if( data==0 ) return 0;
  new_elem = (HashElem*)sqlite3Malloc( sizeof(HashElem) );
  if( new_elem==0 ) return data;
  new_elem->pKey = pKey;
  new_elem->nKey = nKey;
  new_elem->data = data;
  pH->count++;
  if( pH->count>=10 && pH->count > 2*pH->htsize ){
    if( rehash(pH, pH->count*2) ){
      ((void) (0));
      h = strHash(pKey, nKey) % pH->htsize;
    }
  }
  if( pH->ht ){
    insertElement(pH, &pH->ht[h], new_elem);
  }else{
    insertElement(pH, 0, new_elem);
  }
  return 0;
}






static const char *sqlite3OpcodeName(int i){
 static const char *const azName[] = { "?",
               "Goto",
               "Gosub",
               "Return",
               "Yield",
               "HaltIfNull",
               "Halt",
               "Integer",
               "Int64",
               "String",
               "Null",
               "Blob",
               "Variable",
               "Move",
               "Copy",
               "SCopy",
               "ResultRow",
               "CollSeq",
               "Function",
               "Not",
               "AddImm",
               "MustBeInt",
               "RealAffinity",
               "Permutation",
               "Compare",
               "Jump",
               "If",
               "IfNot",
               "Column",
               "Affinity",
               "MakeRecord",
               "Count",
               "Savepoint",
               "AutoCommit",
               "Transaction",
               "ReadCookie",
               "SetCookie",
               "VerifyCookie",
               "OpenRead",
               "OpenWrite",
               "OpenAutoindex",
               "OpenEphemeral",
               "OpenPseudo",
               "Close",
               "SeekLt",
               "SeekLe",
               "SeekGe",
               "SeekGt",
               "Seek",
               "NotFound",
               "Found",
               "IsUnique",
               "NotExists",
               "Sequence",
               "NewRowid",
               "Insert",
               "InsertInt",
               "Delete",
               "ResetCount",
               "RowKey",
               "RowData",
               "Rowid",
               "NullRow",
               "Last",
               "Sort",
               "Rewind",
               "Prev",
               "Next",
               "Or",
               "And",
               "IdxInsert",
               "IdxDelete",
               "IdxRowid",
               "IsNull",
               "NotNull",
               "Ne",
               "Eq",
               "Gt",
               "Le",
               "Lt",
               "Ge",
               "IdxLT",
               "BitAnd",
               "BitOr",
               "ShiftLeft",
               "ShiftRight",
               "Add",
               "Subtract",
               "Multiply",
               "Divide",
               "Remainder",
               "Concat",
               "IdxGE",
               "BitNot",
               "String8",
               "Destroy",
               "Clear",
               "CreateIndex",
               "CreateTable",
               "ParseSchema",
               "LoadAnalysis",
               "DropTable",
               "DropIndex",
               "DropTrigger",
               "IntegrityCk",
               "RowSetAdd",
               "RowSetRead",
               "RowSetTest",
               "Program",
               "Param",
               "FkCounter",
               "FkIfZero",
               "MemMax",
               "IfPos",
               "IfNeg",
               "IfZero",
               "AggStep",
               "AggFinal",
               "Checkpoint",
               "JournalMode",
               "Vacuum",
               "IncrVacuum",
               "Expire",
               "TableLock",
               "VBegin",
               "VCreate",
               "VDestroy",
               "VOpen",
               "VFilter",
               "VColumn",
               "Real",
               "VNext",
               "VRename",
               "VUpdate",
               "Pagecount",
               "MaxPgcnt",
               "Trace",
               "Noop",
               "Explain",
               "NotUsed_139",
               "NotUsed_140",
               "ToText",
               "ToBlob",
               "ToNumeric",
               "ToInt",
               "ToReal",
  };
  return azName[i];
}
# 24037 "ext/sqlite3/libsqlite/sqlite3.c"
# 1 "/usr/include/x86_64-linux-gnu/sys/stat.h" 1 3 4
# 105 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
# 91 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 106 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];
# 115 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
  };



struct stat64
  {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 164 "/usr/include/x86_64-linux-gnu/bits/stat.h" 3 4
    __syscall_slong_t __glibc_reserved[3];



  };
# 106 "/usr/include/x86_64-linux-gnu/sys/stat.h" 2 3 4
# 217 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file, struct stat *__restrict __buf) __asm__ ("" "stat64") __attribute__ ((__nothrow__ ))

     __attribute__ ((__nonnull__ (1, 2)));
extern int fstat (int __fd, struct stat *__buf) __asm__ ("" "fstat64") __attribute__ ((__nothrow__ ))
     __attribute__ ((__nonnull__ (2)));






extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));
# 243 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat (int __fd, const char *__restrict __file, struct stat *__restrict __buf, int __flag) __asm__ ("" "fstatat64") __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
# 253 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
# 267 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int lstat (const char *__restrict __file, struct stat *__restrict __buf) __asm__ ("" "lstat64") __attribute__ ((__nothrow__ ))


     __attribute__ ((__nonnull__ (1, 2)));





extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ ));





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ ));




extern __mode_t getumask (void) __attribute__ ((__nothrow__ ));



extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ ));
# 410 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf) __asm__ ("" "__fxstat64") __attribute__ ((__nothrow__ ))

     __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename, struct stat *__stat_buf) __asm__ ("" "__xstat64") __attribute__ ((__nothrow__ ))

     __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename, struct stat *__stat_buf) __asm__ ("" "__lxstat64") __attribute__ ((__nothrow__ ))

     __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename, struct stat *__stat_buf, int __flag) __asm__ ("" "__fxstatat64") __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4)));
# 432 "/usr/include/x86_64-linux-gnu/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, const char *__filename,
        struct stat64 *__stat_buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, const char *__filename,
         struct stat64 *__stat_buf) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (3, 5)));




extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) stat (const char *__path, struct stat *__statbuf)
{
  return __xstat (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) lstat (const char *__path, struct stat *__statbuf)
{
  return __lxstat (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) fstat (int __fd, struct stat *__statbuf)
{
  return __fxstat (1, __fd, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) fstatat (int __fd, const char *__filename, struct stat *__statbuf, int __flag)

{
  return __fxstatat (1, __fd, __filename, __statbuf, __flag);
}



extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) mknod (const char *__path, __mode_t __mode, __dev_t __dev)
{
  return __xmknod (0, __path, __mode, &__dev);
}



extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) mknodat (int __fd, const char *__path, __mode_t __mode, __dev_t __dev)

{
  return __xmknodat (0, __fd, __path, __mode, &__dev);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) stat64 (const char *__path, struct stat64 *__statbuf)
{
  return __xstat64 (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) lstat64 (const char *__path, struct stat64 *__statbuf)
{
  return __lxstat64 (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) fstat64 (int __fd, struct stat64 *__statbuf)
{
  return __fxstat64 (1, __fd, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ )) fstatat64 (int __fd, const char *__filename, struct stat64 *__statbuf, int __flag)

{
  return __fxstatat64 (1, __fd, __filename, __statbuf, __flag);
}
# 24038 "ext/sqlite3/libsqlite/sqlite3.c" 2
# 1 "/usr/include/fcntl.h" 1 3 4
# 35 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;




    __off64_t l_start;
    __off64_t l_len;

    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };




# 1 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uio.h" 1 3 4
# 43 "/usr/include/x86_64-linux-gnu/bits/uio.h" 3 4
struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 39 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 2 3 4
# 241 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 311 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};
# 346 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    __attribute__ ((__nothrow__ ));






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern ssize_t vmsplice (int __fdout, const struct iovec *__iov,
    size_t __count, unsigned int __flags);





extern ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
         __off64_t *__offout, size_t __len,
         unsigned int __flags);





extern ssize_t tee (int __fdin, int __fdout, size_t __len,
      unsigned int __flags);
# 388 "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h" 3 4
extern int fallocate (int __fd, int __mode, __off64_t __offset, __off64_t __len) __asm__ ("" "fallocate64");







extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) __attribute__ ((__nothrow__ ));





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);
# 62 "/usr/include/x86_64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 68 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stat.h" 1 3 4
# 69 "/usr/include/fcntl.h" 2 3 4
# 137 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 149 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __asm__ ("" "open64")
     __attribute__ ((__nonnull__ (1)));





extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 174 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...) __asm__ ("" "openat64") __attribute__ ((__nonnull__ (2)));






extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 195 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __asm__ ("" "creat64") __attribute__ ((__nonnull__ (1)));






extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 224 "/usr/include/fcntl.h" 3 4
extern int lockf (int __fd, int __cmd, __off64_t __len) __asm__ ("" "lockf64");





extern int lockf64 (int __fd, int __cmd, off64_t __len);
# 242 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, __off64_t __offset, __off64_t __len, int __advise) __asm__ ("" "posix_fadvise64") __attribute__ ((__nothrow__ ));







extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) __attribute__ ((__nothrow__ ));
# 263 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, __off64_t __offset, __off64_t __len) __asm__ ("" "posix_fallocate64");







extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);
# 24039 "ext/sqlite3/libsqlite/sqlite3.c" 2
# 1 "/usr/include/unistd.h" 1 3 4
# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 267 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;
# 337 "/usr/include/unistd.h" 3 4
extern __off64_t lseek (int __fd, __off64_t __offset, int __whence) __asm__ ("" "lseek64") __attribute__ ((__nothrow__ ));







extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__ ));






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 388 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pread64") ;


extern ssize_t pwrite (int __fd, const void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pwrite64") ;
# 404 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ )) ;




extern int pipe2 (int __pipedes[2], int __flags) __attribute__ ((__nothrow__ )) ;
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ ));
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ ));






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ )) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ )) ;
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ )) ;





extern char *get_current_dir_name (void) __attribute__ ((__nothrow__ ));







extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__ )) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ ));




extern int dup3 (int __fd, int __fd2, int __flags) __attribute__ ((__nothrow__ ));



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) __attribute__ ((__nothrow__ )) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));






# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ ));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ ));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ ));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ ));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ ));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ ));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ ));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ ));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ ));
# 660 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ ));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ ));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ ));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ ));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ ));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ ));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ ));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ )) ;



extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__ ));






extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ )) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ )) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ )) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ )) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ )) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ )) ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__ ));



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__ ));



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__ )) ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__ )) ;






extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ ));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ ));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__ ));





extern int ttyslot (void) __attribute__ ((__nothrow__ ));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ ));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ ));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));
# 871 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 57 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 71 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 150 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ ));
# 872 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__ )) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__ ));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ ));



extern char *getusershell (void) __attribute__ ((__nothrow__ ));
extern void endusershell (void) __attribute__ ((__nothrow__ ));
extern void setusershell (void) __attribute__ ((__nothrow__ ));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ )) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) __attribute__ ((__nothrow__ ));






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ ));





extern int getpagesize (void) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ ));
# 997 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off64_t __length) __asm__ ("" "truncate64") __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;







extern int truncate64 (const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1))) ;
# 1019 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off64_t __length) __asm__ ("" "ftruncate64") __attribute__ ((__nothrow__ )) ;






extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__ )) ;
# 1037 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ )) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ ));
# 1058 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ ));
# 1112 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__glibc_block, int __edflag)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));






extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 2)));
# 24040 "ext/sqlite3/libsqlite/sqlite3.c" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/time.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/sys/time.h" 2 3 4
# 55 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };

typedef struct timezone *__restrict __timezone_ptr_t;
# 71 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    __timezone_ptr_t __tz) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));




extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     __attribute__ ((__nothrow__ ));





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) __attribute__ ((__nothrow__ ));




enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };




typedef enum __itimer_which __itimer_which_t;






extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) __attribute__ ((__nothrow__ ));




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) __attribute__ ((__nothrow__ ));




extern int utimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));



extern int lutimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) __attribute__ ((__nothrow__ ));






extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) __attribute__ ((__nothrow__ ));
# 24041 "ext/sqlite3/libsqlite/sqlite3.c" 2
# 1 "/usr/include/errno.h" 1 3 4
# 35 "/usr/include/errno.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/errno.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/x86_64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/errno.h" 2 3 4
# 50 "/usr/include/x86_64-linux-gnu/bits/errno.h" 3 4
extern int *__errno_location (void) __attribute__ ((__nothrow__ )) __attribute__ ((__const__));
# 36 "/usr/include/errno.h" 2 3 4
# 54 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;
# 68 "/usr/include/errno.h" 3 4
typedef int error_t;
# 24042 "ext/sqlite3/libsqlite/sqlite3.c" 2

# 1 "/usr/include/x86_64-linux-gnu/sys/mman.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/mman.h" 2 3 4
# 41 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mman.h" 1 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/mman.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mman-linux.h" 1 3 4
# 46 "/usr/include/x86_64-linux-gnu/bits/mman.h" 2 3 4
# 42 "/usr/include/x86_64-linux-gnu/sys/mman.h" 2 3 4
# 61 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
extern void * mmap (void *__addr, size_t __len, int __prot, int __flags, int __fd, __off64_t __offset) __asm__ ("" "mmap64") __attribute__ ((__nothrow__ ));
# 70 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
extern void *mmap64 (void *__addr, size_t __len, int __prot,
       int __flags, int __fd, __off64_t __offset) __attribute__ ((__nothrow__ ));




extern int munmap (void *__addr, size_t __len) __attribute__ ((__nothrow__ ));




extern int mprotect (void *__addr, size_t __len, int __prot) __attribute__ ((__nothrow__ ));







extern int msync (void *__addr, size_t __len, int __flags);




extern int madvise (void *__addr, size_t __len, int __advice) __attribute__ ((__nothrow__ ));



extern int posix_madvise (void *__addr, size_t __len, int __advice) __attribute__ ((__nothrow__ ));




extern int mlock (const void *__addr, size_t __len) __attribute__ ((__nothrow__ ));


extern int munlock (const void *__addr, size_t __len) __attribute__ ((__nothrow__ ));




extern int mlockall (int __flags) __attribute__ ((__nothrow__ ));



extern int munlockall (void) __attribute__ ((__nothrow__ ));







extern int mincore (void *__start, size_t __len, unsigned char *__vec)
     __attribute__ ((__nothrow__ ));
# 133 "/usr/include/x86_64-linux-gnu/sys/mman.h" 3 4
extern void *mremap (void *__addr, size_t __old_len, size_t __new_len,
       int __flags, ...) __attribute__ ((__nothrow__ ));



extern int remap_file_pages (void *__start, size_t __size, int __prot,
        size_t __pgoff, int __flags) __attribute__ ((__nothrow__ ));




extern int shm_open (const char *__name, int __oflag, mode_t __mode);


extern int shm_unlink (const char *__name);
# 24044 "ext/sqlite3/libsqlite/sqlite3.c" 2
# 24100 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct unixShm unixShm;
typedef struct unixShmNode unixShmNode;
typedef struct unixInodeInfo unixInodeInfo;
typedef struct UnixUnusedFd UnixUnusedFd;







struct UnixUnusedFd {
  int fd;
  int flags;
  UnixUnusedFd *pNext;
};





typedef struct unixFile unixFile;
struct unixFile {
  sqlite3_io_methods const *pMethod;
  unixInodeInfo *pInode;
  int h;
  int dirfd;
  unsigned char eFileLock;
  unsigned char ctrlFlags;
  int lastErrno;
  void *lockingContext;
  UnixUnusedFd *pUnused;
  const char *zPath;
  unixShm *pShm;
  int szChunk;
# 24163 "ext/sqlite3/libsqlite/sqlite3.c"
};
# 24414 "ext/sqlite3/libsqlite/sqlite3.c"
static struct unix_syscall {
  const char *zName;
  sqlite3_syscall_ptr pCurrent;
  sqlite3_syscall_ptr pDefault;
} aSyscall[] = {
  { "open", (sqlite3_syscall_ptr)open, 0 },


  { "close", (sqlite3_syscall_ptr)close, 0 },


  { "access", (sqlite3_syscall_ptr)access, 0 },


  { "getcwd", (sqlite3_syscall_ptr)getcwd, 0 },


  { "stat", (sqlite3_syscall_ptr)stat, 0 },
# 24444 "ext/sqlite3/libsqlite/sqlite3.c"
  { "fstat", (sqlite3_syscall_ptr)fstat, 0 },



  { "ftruncate", (sqlite3_syscall_ptr)ftruncate, 0 },


  { "fcntl", (sqlite3_syscall_ptr)fcntl, 0 },


  { "read", (sqlite3_syscall_ptr)read, 0 },



  { "pread", (sqlite3_syscall_ptr)pread, 0 },
# 24467 "ext/sqlite3/libsqlite/sqlite3.c"
  { "pread64", (sqlite3_syscall_ptr)0, 0 },



  { "write", (sqlite3_syscall_ptr)write, 0 },



  { "pwrite", (sqlite3_syscall_ptr)pwrite, 0 },
# 24485 "ext/sqlite3/libsqlite/sqlite3.c"
  { "pwrite64", (sqlite3_syscall_ptr)0, 0 },







  { "fchmod", (sqlite3_syscall_ptr)0, 0 },






  { "fallocate", (sqlite3_syscall_ptr)0, 0 },



};







static int unixSetSystemCall(
  sqlite3_vfs *pNotUsed,
  const char *zName,
  sqlite3_syscall_ptr pNewFunc
){
  unsigned int i;
  int rc = 12;

  (void)(pNotUsed);
  if( zName==0 ){



    rc = 0;
    for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){
      if( aSyscall[i].pDefault ){
        aSyscall[i].pCurrent = aSyscall[i].pDefault;
      }
    }
  }else{



    for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){
      if( __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (zName) && __builtin_constant_p (aSyscall[i].zName) && (__s1_len = __builtin_strlen (zName), __s2_len = __builtin_strlen (aSyscall[i].zName), (!((size_t)(const void *)((zName) + 1) - (size_t)(const void *)(zName) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((aSyscall[i].zName) + 1) - (size_t)(const void *)(aSyscall[i].zName) == 1) || __s2_len >= 4)) ? __builtin_strcmp (zName, aSyscall[i].zName) : (__builtin_constant_p (zName) && ((size_t)(const void *)((zName) + 1) - (size_t)(const void *)(zName) == 1) && (__s1_len = __builtin_strlen (zName), __s1_len < 4) ? (__builtin_constant_p (aSyscall[i].zName) && ((size_t)(const void *)((aSyscall[i].zName) + 1) - (size_t)(const void *)(aSyscall[i].zName) == 1) ? __builtin_strcmp (zName, aSyscall[i].zName) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (aSyscall[i].zName); int __result = (((const unsigned char *) (const char *) (zName))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (zName))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (zName))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (zName))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (aSyscall[i].zName) && ((size_t)(const void *)((aSyscall[i].zName) + 1) - (size_t)(const void *)(aSyscall[i].zName) == 1) && (__s2_len = __builtin_strlen (aSyscall[i].zName), __s2_len < 4) ? (__builtin_constant_p (zName) && ((size_t)(const void *)((zName) + 1) - (size_t)(const void *)(zName) == 1) ? __builtin_strcmp (zName, aSyscall[i].zName) : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (zName); int __result = (((const unsigned char *) (const char *) (aSyscall[i].zName))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (aSyscall[i].zName))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (aSyscall[i].zName))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (aSyscall[i].zName))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (zName, aSyscall[i].zName)))); })==0 ){
        if( aSyscall[i].pDefault==0 ){
          aSyscall[i].pDefault = aSyscall[i].pCurrent;
        }
        rc = 0;
        if( pNewFunc==0 ) pNewFunc = aSyscall[i].pDefault;
        aSyscall[i].pCurrent = pNewFunc;
        break;
      }
    }
  }
  return rc;
}






static sqlite3_syscall_ptr unixGetSystemCall(
  sqlite3_vfs *pNotUsed,
  const char *zName
){
  unsigned int i;

  (void)(pNotUsed);
  for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){
    if( __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (zName) && __builtin_constant_p (aSyscall[i].zName) && (__s1_len = __builtin_strlen (zName), __s2_len = __builtin_strlen (aSyscall[i].zName), (!((size_t)(const void *)((zName) + 1) - (size_t)(const void *)(zName) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((aSyscall[i].zName) + 1) - (size_t)(const void *)(aSyscall[i].zName) == 1) || __s2_len >= 4)) ? __builtin_strcmp (zName, aSyscall[i].zName) : (__builtin_constant_p (zName) && ((size_t)(const void *)((zName) + 1) - (size_t)(const void *)(zName) == 1) && (__s1_len = __builtin_strlen (zName), __s1_len < 4) ? (__builtin_constant_p (aSyscall[i].zName) && ((size_t)(const void *)((aSyscall[i].zName) + 1) - (size_t)(const void *)(aSyscall[i].zName) == 1) ? __builtin_strcmp (zName, aSyscall[i].zName) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (aSyscall[i].zName); int __result = (((const unsigned char *) (const char *) (zName))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (zName))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (zName))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (zName))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (aSyscall[i].zName) && ((size_t)(const void *)((aSyscall[i].zName) + 1) - (size_t)(const void *)(aSyscall[i].zName) == 1) && (__s2_len = __builtin_strlen (aSyscall[i].zName), __s2_len < 4) ? (__builtin_constant_p (zName) && ((size_t)(const void *)((zName) + 1) - (size_t)(const void *)(zName) == 1) ? __builtin_strcmp (zName, aSyscall[i].zName) : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (zName); int __result = (((const unsigned char *) (const char *) (aSyscall[i].zName))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (aSyscall[i].zName))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (aSyscall[i].zName))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (aSyscall[i].zName))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (zName, aSyscall[i].zName)))); })==0 ) return aSyscall[i].pCurrent;
  }
  return 0;
}







static const char *unixNextSystemCall(sqlite3_vfs *p, const char *zName){
  int i = -1;

  (void)(p);
  if( zName ){
    for(i=0; i<((int)(sizeof(aSyscall)/sizeof(aSyscall[0])))-1; i++){
      if( __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (zName) && __builtin_constant_p (aSyscall[i].zName) && (__s1_len = __builtin_strlen (zName), __s2_len = __builtin_strlen (aSyscall[i].zName), (!((size_t)(const void *)((zName) + 1) - (size_t)(const void *)(zName) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((aSyscall[i].zName) + 1) - (size_t)(const void *)(aSyscall[i].zName) == 1) || __s2_len >= 4)) ? __builtin_strcmp (zName, aSyscall[i].zName) : (__builtin_constant_p (zName) && ((size_t)(const void *)((zName) + 1) - (size_t)(const void *)(zName) == 1) && (__s1_len = __builtin_strlen (zName), __s1_len < 4) ? (__builtin_constant_p (aSyscall[i].zName) && ((size_t)(const void *)((aSyscall[i].zName) + 1) - (size_t)(const void *)(aSyscall[i].zName) == 1) ? __builtin_strcmp (zName, aSyscall[i].zName) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (aSyscall[i].zName); int __result = (((const unsigned char *) (const char *) (zName))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (zName))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (zName))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (zName))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (aSyscall[i].zName) && ((size_t)(const void *)((aSyscall[i].zName) + 1) - (size_t)(const void *)(aSyscall[i].zName) == 1) && (__s2_len = __builtin_strlen (aSyscall[i].zName), __s2_len < 4) ? (__builtin_constant_p (zName) && ((size_t)(const void *)((zName) + 1) - (size_t)(const void *)(zName) == 1) ? __builtin_strcmp (zName, aSyscall[i].zName) : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (zName); int __result = (((const unsigned char *) (const char *) (aSyscall[i].zName))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (aSyscall[i].zName))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (aSyscall[i].zName))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (aSyscall[i].zName))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (zName, aSyscall[i].zName)))); })==0 ) break;
    }
  }
  for(i++; i<((int)(sizeof(aSyscall)/sizeof(aSyscall[0]))); i++){
    if( aSyscall[i].pCurrent!=0 ) return aSyscall[i].zName;
  }
  return 0;
}




static int robust_open(const char *z, int f, int m){
  int rc;
  do{ rc = ((int(*)(const char*,int,...))aSyscall[0].pCurrent)(z,f,m); }while( rc<0 && (*__errno_location ())==4 );
  return rc;
}
# 24612 "ext/sqlite3/libsqlite/sqlite3.c"
static void unixEnterMutex(void){
                                                                    ;
}
static void unixLeaveMutex(void){
                                                                    ;
}
# 24706 "ext/sqlite3/libsqlite/sqlite3.c"
static int robust_ftruncate(int h, sqlite3_int64 sz){
  int rc;
  do{ rc = ((int(*)(int,off_t))aSyscall[6].pCurrent)(h,sz); }while( rc<0 && (*__errno_location ())==4 );
  return rc;
}
# 24722 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqliteErrorFromPosixError(int posixError, int sqliteIOErr) {
  switch (posixError) {
# 24740 "ext/sqlite3/libsqlite/sqlite3.c"
  case 11:
  case 110:
  case 16:
  case 4:
  case 37:


    return 5;

  case 13:

    if( (sqliteIOErr == (10 | (15<<8))) ||
 (sqliteIOErr == (10 | (8<<8))) ||
 (sqliteIOErr == (10 | (9<<8))) ||
 (sqliteIOErr == (10 | (14<<8))) ){
      return 5;
    }

  case 1:
    return 3;
# 24777 "ext/sqlite3/libsqlite/sqlite3.c"
  case 95:



  case 5:
  case 9:
  case 22:
  case 107:
  case 19:
  case 6:
  case 2:
  case 116:
  case 38:


  default:
    return sqliteIOErr;
  }
}
# 24816 "ext/sqlite3/libsqlite/sqlite3.c"
struct vxworksFileId {
  struct vxworksFileId *pNext;
  int nRef;
  int nName;
  char *zCanonicalName;
};
# 25031 "ext/sqlite3/libsqlite/sqlite3.c"
struct unixFileId {
  dev_t dev;



  ino_t ino;

};
# 25049 "ext/sqlite3/libsqlite/sqlite3.c"
struct unixInodeInfo {
  struct unixFileId fileId;
  int nShared;
  unsigned char eFileLock;
  unsigned char bProcessLock;
  int nRef;
  unixShmNode *pShmNode;
  int nLock;
  UnixUnusedFd *pUnused;
  unixInodeInfo *pNext;
  unixInodeInfo *pPrev;

  unsigned long long sharedByte;





};




static unixInodeInfo *inodeList = 0;
# 25091 "ext/sqlite3/libsqlite/sqlite3.c"
static int unixLogErrorAtLine(
  int errcode,
  const char *zFunc,
  const char *zPath,
  int iLine
){
  char *zErr;
  int iErrno = (*__errno_location ());
# 25131 "ext/sqlite3/libsqlite/sqlite3.c"
  zErr = strerror(iErrno);


  ((void) (0));
  if( zPath==0 ) zPath = "";
  sqlite3_log(errcode,
      "os_unix.c:%d: (%d) %s(%s) - %s",
      iLine, iErrno, zFunc, zPath, zErr
  );

  return errcode;
}
# 25157 "ext/sqlite3/libsqlite/sqlite3.c"
static void robust_close(unixFile *pFile, int h, int lineno){
  if( ((int(*)(int))aSyscall[1].pCurrent)(h) ){
    unixLogErrorAtLine((10 | (16<<8)), "close",
                       pFile ? pFile->zPath : 0, lineno);
  }
}




static void closePendingFds(unixFile *pFile){
  unixInodeInfo *pInode = pFile->pInode;
  UnixUnusedFd *p;
  UnixUnusedFd *pNext;
  for(p=pInode->pUnused; p; p=pNext){
    pNext = p->pNext;
    robust_close(pFile, p->fd, 25173);
    sqlite3_free(p);
  }
  pInode->pUnused = 0;
}







static void releaseInodeInfo(unixFile *pFile){
  unixInodeInfo *pInode = pFile->pInode;
  ((void) (0));
  if( (pInode) ){
    pInode->nRef--;
    if( pInode->nRef==0 ){
      ((void) (0));
      closePendingFds(pFile);
      if( pInode->pPrev ){
        ((void) (0));
        pInode->pPrev->pNext = pInode->pNext;
      }else{
        ((void) (0));
        inodeList = pInode->pNext;
      }
      if( pInode->pNext ){
        ((void) (0));
        pInode->pNext->pPrev = pInode->pPrev;
      }
      sqlite3_free(pInode);
    }
  }
}
# 25219 "ext/sqlite3/libsqlite/sqlite3.c"
static int findInodeInfo(
  unixFile *pFile,
  unixInodeInfo **ppInode
){
  int rc;
  int fd;
  struct unixFileId fileId;
  struct stat statbuf;
  unixInodeInfo *pInode = 0;

  ((void) (0));




  fd = pFile->h;
  rc = ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(fd, &statbuf);
  if( rc!=0 ){
    pFile->lastErrno = (*__errno_location ());

    if( pFile->lastErrno==75 ) return 22;

    return 10;
  }
# 25269 "ext/sqlite3/libsqlite/sqlite3.c"
  memset(&fileId, 0, sizeof(fileId));
  fileId.dev = statbuf.st_dev;



  fileId.ino = statbuf.st_ino;

  pInode = inodeList;
  while( pInode && memcmp(&fileId, &pInode->fileId, sizeof(fileId)) ){
    pInode = pInode->pNext;
  }
  if( pInode==0 ){
    pInode = sqlite3_malloc( sizeof(*pInode) );
    if( pInode==0 ){
      return 7;
    }
    memset(pInode, 0, sizeof(*pInode));
    memcpy(&pInode->fileId, &fileId, sizeof(fileId));
    pInode->nRef = 1;
    pInode->pNext = inodeList;
    pInode->pPrev = 0;
    if( inodeList ) inodeList->pPrev = pInode;
    inodeList = pInode;
  }else{
    pInode->nRef++;
  }
  *ppInode = pInode;
  return 0;
}
# 25306 "ext/sqlite3/libsqlite/sqlite3.c"
static int unixCheckReservedLock(sqlite3_file *id, int *pResOut){
  int rc = 0;
  int reserved = 0;
  unixFile *pFile = (unixFile*)id;

                                                           ;

  ((void) (0));
  unixEnterMutex();


  if( pFile->pInode->eFileLock>1 ){
    reserved = 1;
  }




  if( !reserved && !pFile->pInode->bProcessLock ){
    struct flock lock;
    lock.l_whence = 0;
    lock.l_start = (sqlite3PendingByte+1);
    lock.l_len = 1;
    lock.l_type = 1;
    if( ((int(*)(int,int,...))aSyscall[7].pCurrent)(pFile->h, 5, &lock) ){
      rc = (10 | (14<<8));
      pFile->lastErrno = (*__errno_location ());
    } else if( lock.l_type!=2 ){
      reserved = 1;
    }
  }


  unixLeaveMutex();
                                                                     ;

  *pResOut = reserved;
  return rc;
}
# 25365 "ext/sqlite3/libsqlite/sqlite3.c"
static int unixFileLock(unixFile *pFile, struct flock *pLock){
  int rc;
  unixInodeInfo *pInode = pFile->pInode;
  ((void) (0));
  ((void) (0));
  if( ((pFile->ctrlFlags & 0x01)!=0 || pInode->bProcessLock)
   && ((pFile->ctrlFlags & 0x02)==0)
  ){
    if( pInode->bProcessLock==0 ){
      struct flock lock;
      ((void) (0));
      lock.l_whence = 0;
      lock.l_start = (sqlite3PendingByte+2);
      lock.l_len = 510;
      lock.l_type = 1;
      rc = ((int(*)(int,int,...))aSyscall[7].pCurrent)(pFile->h, 6, &lock);
      if( rc<0 ) return rc;
      pInode->bProcessLock = 1;
      pInode->nLock++;
    }else{
      rc = 0;
    }
  }else{
    rc = ((int(*)(int,int,...))aSyscall[7].pCurrent)(pFile->h, 6, pLock);
  }
  return rc;
}
# 25417 "ext/sqlite3/libsqlite/sqlite3.c"
static int unixLock(sqlite3_file *id, int eFileLock){
# 25456 "ext/sqlite3/libsqlite/sqlite3.c"
  int rc = 0;
  unixFile *pFile = (unixFile*)id;
  unixInodeInfo *pInode = pFile->pInode;
  struct flock lock;
  int tErrno = 0;

  ((void) (0));


                                                                 ;





  if( pFile->eFileLock>=eFileLock ){

                                   ;
    return 0;
  }






  ((void) (0));
  ((void) (0));
  ((void) (0));



  unixEnterMutex();
  pInode = pFile->pInode;




  if( (pFile->eFileLock!=pInode->eFileLock &&
          (pInode->eFileLock>=3 || eFileLock>1))
  ){
    rc = 5;
    goto end_lock;
  }





  if( eFileLock==1 &&
      (pInode->eFileLock==1 || pInode->eFileLock==2) ){
    ((void) (0));
    ((void) (0));
    ((void) (0));
    pFile->eFileLock = 1;
    pInode->nShared++;
    pInode->nLock++;
    goto end_lock;
  }






  lock.l_len = 1L;
  lock.l_whence = 0;
  if( eFileLock==1
      || (eFileLock==4 && pFile->eFileLock<3)
  ){
    lock.l_type = (eFileLock==1?0:1);
    lock.l_start = sqlite3PendingByte;
    if( unixFileLock(pFile, &lock) ){
      tErrno = (*__errno_location ());
      rc = sqliteErrorFromPosixError(tErrno, (10 | (15<<8)));
      if( rc!=5 ){
        pFile->lastErrno = tErrno;
      }
      goto end_lock;
    }
  }





  if( eFileLock==1 ){
    ((void) (0));
    ((void) (0));
    ((void) (0));


    lock.l_start = (sqlite3PendingByte+2);
    lock.l_len = 510;
    if( unixFileLock(pFile, &lock) ){
      tErrno = (*__errno_location ());
      rc = sqliteErrorFromPosixError(tErrno, (10 | (15<<8)));
    }


    lock.l_start = sqlite3PendingByte;
    lock.l_len = 1L;
    lock.l_type = 2;
    if( unixFileLock(pFile, &lock) && rc==0 ){

      tErrno = (*__errno_location ());
      rc = (10 | (8<<8));
    }

    if( rc ){
      if( rc!=5 ){
        pFile->lastErrno = tErrno;
      }
      goto end_lock;
    }else{
      pFile->eFileLock = 1;
      pInode->nLock++;
      pInode->nShared = 1;
    }
  }else if( eFileLock==4 && pInode->nShared>1 ){


    rc = 5;
  }else{




    ((void) (0));
    lock.l_type = 1;

    ((void) (0));
    if( eFileLock==2 ){
      lock.l_start = (sqlite3PendingByte+1);
      lock.l_len = 1L;
    }else{
      lock.l_start = (sqlite3PendingByte+2);
      lock.l_len = 510;
    }

    if( unixFileLock(pFile, &lock) ){
      tErrno = (*__errno_location ());
      rc = sqliteErrorFromPosixError(tErrno, (10 | (15<<8)));
      if( rc!=5 ){
        pFile->lastErrno = tErrno;
      }
    }
  }
# 25623 "ext/sqlite3/libsqlite/sqlite3.c"
  if( rc==0 ){
    pFile->eFileLock = eFileLock;
    pInode->eFileLock = eFileLock;
  }else if( eFileLock==4 ){
    pFile->eFileLock = 3;
    pInode->eFileLock = 3;
  }

end_lock:
  unixLeaveMutex();

                                       ;
  return rc;
}





static void setPendingFd(unixFile *pFile){
  unixInodeInfo *pInode = pFile->pInode;
  UnixUnusedFd *p = pFile->pUnused;
  p->pNext = pInode->pUnused;
  pInode->pUnused = p;
  pFile->h = -1;
  pFile->pUnused = 0;
}
# 25664 "ext/sqlite3/libsqlite/sqlite3.c"
static int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock){
  unixFile *pFile = (unixFile*)id;
  unixInodeInfo *pInode;
  struct flock lock;
  int rc = 0;
  int h;

  ((void) (0));


                ;

  ((void) (0));
  if( pFile->eFileLock<=eFileLock ){
    return 0;
  }
  unixEnterMutex();
  h = pFile->h;
  pInode = pFile->pInode;
  ((void) (0));
  if( pFile->eFileLock>1 ){
    ((void) (0));
                            ;

                            ;
# 25716 "ext/sqlite3/libsqlite/sqlite3.c"
    if( eFileLock==1 ){


      (void)handleNFSUnlock;
      ((void) (0));
# 25765 "ext/sqlite3/libsqlite/sqlite3.c"
      {
        lock.l_type = 0;
        lock.l_whence = 0;
        lock.l_start = (sqlite3PendingByte+2);
        lock.l_len = 510;
        if( unixFileLock(pFile, &lock) ){






          rc = (10 | (9<<8));
          pFile->lastErrno = (*__errno_location ());
          goto end_unlock;
        }
      }
    }
    lock.l_type = 2;
    lock.l_whence = 0;
    lock.l_start = sqlite3PendingByte;
    lock.l_len = 2L; ((void) (0));
    if( unixFileLock(pFile, &lock)==0 ){
      pInode->eFileLock = 1;
    }else{
      rc = (10 | (8<<8));
      pFile->lastErrno = (*__errno_location ());
      goto end_unlock;
    }
  }
  if( eFileLock==0 ){




    pInode->nShared--;
    if( pInode->nShared==0 ){
      lock.l_type = 2;
      lock.l_whence = 0;
      lock.l_start = lock.l_len = 0L;
                              ;

                              ;
      if( unixFileLock(pFile, &lock)==0 ){
        pInode->eFileLock = 0;
      }else{
        rc = (10 | (8<<8));
 pFile->lastErrno = (*__errno_location ());
        pInode->eFileLock = 0;
        pFile->eFileLock = 0;
      }
    }





    pInode->nLock--;
    ((void) (0));
    if( pInode->nLock==0 ){
      closePendingFds(pFile);
    }
  }

end_unlock:
  unixLeaveMutex();
  if( rc==0 ) pFile->eFileLock = eFileLock;
  return rc;
}
# 25842 "ext/sqlite3/libsqlite/sqlite3.c"
static int unixUnlock(sqlite3_file *id, int eFileLock){
  return posixUnlock(id, eFileLock, 0);
}
# 25856 "ext/sqlite3/libsqlite/sqlite3.c"
static int closeUnixFile(sqlite3_file *id){
  unixFile *pFile = (unixFile*)id;
  if( pFile->dirfd>=0 ){
    robust_close(pFile, pFile->dirfd, 25859);
    pFile->dirfd=-1;
  }
  if( pFile->h>=0 ){
    robust_close(pFile, pFile->h, 25863);
    pFile->h = -1;
  }
# 25875 "ext/sqlite3/libsqlite/sqlite3.c"
                                       ;
                 ;
  sqlite3_free(pFile->pUnused);
  memset(pFile, 0, sizeof(unixFile));
  return 0;
}




static int unixClose(sqlite3_file *id){
  int rc = 0;
  unixFile *pFile = (unixFile *)id;
  unixUnlock(id, 0);
  unixEnterMutex();




  ((void) (0));
  if( (pFile->pInode) && pFile->pInode->nLock ){





    setPendingFd(pFile);
  }
  releaseInodeInfo(pFile);
  rc = closeUnixFile(id);
  unixLeaveMutex();
  return rc;
}
# 25929 "ext/sqlite3/libsqlite/sqlite3.c"
static int nolockCheckReservedLock(sqlite3_file *NotUsed, int *pResOut){
  (void)(NotUsed);
  *pResOut = 0;
  return 0;
}
static int nolockLock(sqlite3_file *NotUsed, int NotUsed2){
  (void)(NotUsed),(void)(NotUsed2);
  return 0;
}
static int nolockUnlock(sqlite3_file *NotUsed, int NotUsed2){
  (void)(NotUsed),(void)(NotUsed2);
  return 0;
}




static int nolockClose(sqlite3_file *id) {
  return closeUnixFile(id);
}
# 25991 "ext/sqlite3/libsqlite/sqlite3.c"
static int dotlockCheckReservedLock(sqlite3_file *id, int *pResOut) {
  int rc = 0;
  int reserved = 0;
  unixFile *pFile = (unixFile*)id;

                                                           ;

  ((void) (0));


  if( pFile->eFileLock>1 ){


    reserved = 1;
  }else{

    const char *zLockFile = (const char*)pFile->lockingContext;
    reserved = ((int(*)(const char*,int))aSyscall[2].pCurrent)(zLockFile, 0)==0;
  }
                                                                        ;
  *pResOut = reserved;
  return rc;
}
# 26042 "ext/sqlite3/libsqlite/sqlite3.c"
static int dotlockLock(sqlite3_file *id, int eFileLock) {
  unixFile *pFile = (unixFile*)id;
  int fd;
  char *zLockFile = (char *)pFile->lockingContext;
  int rc = 0;





  if( pFile->eFileLock > 0 ){
    pFile->eFileLock = eFileLock;


    utimes(zLockFile, ((void*)0));

    return 0;
  }


  fd = robust_open(zLockFile,00|0100|0200,0600);
  if( fd<0 ){

    int tErrno = (*__errno_location ());
    if( 17 == tErrno ){
      rc = 5;
    } else {
      rc = sqliteErrorFromPosixError(tErrno, (10 | (15<<8)));
      if( ((rc != 0) && (rc != 5)) ){
        pFile->lastErrno = tErrno;
      }
    }
    return rc;
  }
  robust_close(pFile, fd, 26076);


  pFile->eFileLock = eFileLock;
  return rc;
}
# 26092 "ext/sqlite3/libsqlite/sqlite3.c"
static int dotlockUnlock(sqlite3_file *id, int eFileLock) {
  unixFile *pFile = (unixFile*)id;
  char *zLockFile = (char *)pFile->lockingContext;

  ((void) (0));

                                ;
  ((void) (0));


  if( pFile->eFileLock==eFileLock ){
    return 0;
  }




  if( eFileLock==1 ){
    pFile->eFileLock = 1;
    return 0;
  }


  ((void) (0));
  if( unlink(zLockFile) ){
    int rc = 0;
    int tErrno = (*__errno_location ());
    if( 2 != tErrno ){
      rc = (10 | (8<<8));
    }
    if( ((rc != 0) && (rc != 5)) ){
      pFile->lastErrno = tErrno;
    }
    return rc;
  }
  pFile->eFileLock = 0;
  return 0;
}




static int dotlockClose(sqlite3_file *id) {
  int rc;
  if( id ){
    unixFile *pFile = (unixFile*)id;
    dotlockUnlock(id, 0);
    sqlite3_free(pFile->lockingContext);
  }
  rc = closeUnixFile(id);
  return rc;
}
# 27051 "ext/sqlite3/libsqlite/sqlite3.c"
static int seekAndRead(unixFile *id, sqlite3_int64 offset, void *pBuf, int cnt){
  int got;

  i64 newOffset;

             ;







  newOffset = lseek(id->h, offset, 0);
                                ;
  if( newOffset!=offset ){
    if( newOffset == -1 ){
      ((unixFile*)id)->lastErrno = (*__errno_location ());
    }else{
      ((unixFile*)id)->lastErrno = 0;
    }
    return -1;
  }
  do{ got = ((ssize_t(*)(int,void*,size_t))aSyscall[8].pCurrent)(id->h, pBuf, cnt); }while( got<0 && (*__errno_location ())==4 );

           ;
  if( got<0 ){
    ((unixFile*)id)->lastErrno = (*__errno_location ());
  }
                                                                               ;
  return got;
}






static int unixRead(
  sqlite3_file *id,
  void *pBuf,
  int amt,
  sqlite3_int64 offset
){
  unixFile *pFile = (unixFile *)id;
  int got;
  ((void) (0));
# 27108 "ext/sqlite3/libsqlite/sqlite3.c"
  got = seekAndRead(pFile, offset, pBuf, amt);
  if( got==amt ){
    return 0;
  }else if( got<0 ){

    return (10 | (1<<8));
  }else{
    pFile->lastErrno = 0;

    memset(&((char*)pBuf)[got], 0, amt-got);
    return (10 | (2<<8));
  }
}
# 27129 "ext/sqlite3/libsqlite/sqlite3.c"
static int seekAndWrite(unixFile *id, i64 offset, const void *pBuf, int cnt){
  int got;

  i64 newOffset;

             ;





  newOffset = lseek(id->h, offset, 0);
                                ;
  if( newOffset!=offset ){
    if( newOffset == -1 ){
      ((unixFile*)id)->lastErrno = (*__errno_location ());
    }else{
      ((unixFile*)id)->lastErrno = 0;
    }
    return -1;
  }
  do{ got = ((ssize_t(*)(int,const void*,size_t))aSyscall[11].pCurrent)(id->h, pBuf, cnt); }while( got<0 && (*__errno_location ())==4 );

           ;
  if( got<0 ){
    ((unixFile*)id)->lastErrno = (*__errno_location ());
  }

                                                                               ;
  return got;
}






static int unixWrite(
  sqlite3_file *id,
  const void *pBuf,
  int amt,
  sqlite3_int64 offset
){
  unixFile *pFile = (unixFile*)id;
  int wrote = 0;
  ((void) (0));
  ((void) (0));
# 27208 "ext/sqlite3/libsqlite/sqlite3.c"
  while( amt>0 && (wrote = seekAndWrite(pFile, offset, pBuf, amt))>0 ){
    amt -= wrote;
    offset += wrote;
    pBuf = &((char*)pBuf)[wrote];
  }
                                        ;
                                           ;

  if( amt>0 ){
    if( wrote<0 ){

      return (10 | (3<<8));
    }else{
      pFile->lastErrno = 0;
      return 13;
    }
  }

  return 0;
}
# 27284 "ext/sqlite3/libsqlite/sqlite3.c"
static int full_fsync(int fd, int fullSync, int dataOnly){
  int rc;
# 27298 "ext/sqlite3/libsqlite/sqlite3.c"
  (void)(fullSync);
  (void)(dataOnly);
# 27338 "ext/sqlite3/libsqlite/sqlite3.c"
  rc = fdatasync(fd);







  if( 0 && rc!= -1 ){
    rc = 0;
  }
  return rc;
}
# 27367 "ext/sqlite3/libsqlite/sqlite3.c"
static int unixSync(sqlite3_file *id, int flags){
  int rc;
  unixFile *pFile = (unixFile*)id;

  int isDataOnly = (flags&0x00010);
  int isFullsync = (flags&0x0F)==0x00003;


  ((void) (0));






                                             ;

  ((void) (0));
                                       ;
  rc = full_fsync(pFile->h, isFullsync, isDataOnly);
                         ;
  if( rc ){
    pFile->lastErrno = (*__errno_location ());
    return unixLogErrorAtLine((10 | (4<<8)),"full_fsync",pFile->zPath,27390);
  }
  if( pFile->dirfd>=0 ){

                                        ;





    if( (!0 || !isFullsync) && full_fsync(pFile->dirfd,0,0) ){
# 27409 "ext/sqlite3/libsqlite/sqlite3.c"
    }


    robust_close(pFile, pFile->dirfd, 27412);
    pFile->dirfd = -1;
  }
  return rc;
}




static int unixTruncate(sqlite3_file *id, i64 nByte){
  unixFile *pFile = (unixFile *)id;
  int rc;
  ((void) (0));
                                                 ;






  if( pFile->szChunk ){
    nByte = ((nByte + pFile->szChunk - 1)/pFile->szChunk) * pFile->szChunk;
  }

  rc = robust_ftruncate(pFile->h, (off_t)nByte);
  if( rc ){
    pFile->lastErrno = (*__errno_location ());
    return unixLogErrorAtLine((10 | (6<<8)),"ftruncate",pFile->zPath,27439);
  }else{
# 27454 "ext/sqlite3/libsqlite/sqlite3.c"
    return 0;
  }
}




static int unixFileSize(sqlite3_file *id, i64 *pSize){
  int rc;
  struct stat buf;
  ((void) (0));
  rc = ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(((unixFile*)id)->h, &buf);
                         ;
  if( rc!=0 ){
    ((unixFile*)id)->lastErrno = (*__errno_location ());
    return (10 | (7<<8));
  }
  *pSize = buf.st_size;







  if( *pSize==1 ) *pSize = 0;


  return 0;
}
# 27501 "ext/sqlite3/libsqlite/sqlite3.c"
static int fcntlSizeHint(unixFile *pFile, i64 nByte){
  if( pFile->szChunk ){
    i64 nSize;
    struct stat buf;

    if( ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(pFile->h, &buf) ) return (10 | (7<<8));

    nSize = ((nByte+pFile->szChunk-1) / pFile->szChunk) * pFile->szChunk;
    if( nSize>(i64)buf.st_size ){
# 27527 "ext/sqlite3/libsqlite/sqlite3.c"
      int nBlk = buf.st_blksize;
      i64 iWrite;

      if( robust_ftruncate(pFile->h, nSize) ){
        pFile->lastErrno = (*__errno_location ());
        return unixLogErrorAtLine((10 | (6<<8)),"ftruncate",pFile->zPath,27532);
      }
      iWrite = ((buf.st_size + 2*nBlk - 1)/nBlk)*nBlk-1;
      while( iWrite<nSize ){
        int nWrite = seekAndWrite(pFile, iWrite, "", 1);
        if( nWrite!=1 ) return (10 | (3<<8));
        iWrite += nBlk;
      }

    }
  }

  return 0;
}




static int unixFileControl(sqlite3_file *id, int op, void *pArg){
  switch( op ){
    case 1: {
      *(int*)pArg = ((unixFile*)id)->eFileLock;
      return 0;
    }
    case 4: {
      *(int*)pArg = ((unixFile*)id)->lastErrno;
      return 0;
    }
    case 6: {
      ((unixFile*)id)->szChunk = *(int *)pArg;
      return 0;
    }
    case 5: {
      return fcntlSizeHint((unixFile *)id, *(i64 *)pArg);
    }
# 27584 "ext/sqlite3/libsqlite/sqlite3.c"
    case 8: {
      return 0;
    }
  }
  return 12;
}
# 27601 "ext/sqlite3/libsqlite/sqlite3.c"
static int unixSectorSize(sqlite3_file *NotUsed){
  (void)(NotUsed);
  return 512;
}




static int unixDeviceCharacteristics(sqlite3_file *NotUsed){
  (void)(NotUsed);
  return 0;
}
# 27646 "ext/sqlite3/libsqlite/sqlite3.c"
struct unixShmNode {
  unixInodeInfo *pInode;
  sqlite3_mutex *mutex;
  char *zFilename;
  int h;
  int szRegion;
  int nRegion;
  char **apRegion;
  int nRef;
  unixShm *pFirst;





};
# 27676 "ext/sqlite3/libsqlite/sqlite3.c"
struct unixShm {
  unixShmNode *pShmNode;
  unixShm *pNext;
  u8 hasMutex;
  u16 sharedMask;
  u16 exclMask;



};
# 27699 "ext/sqlite3/libsqlite/sqlite3.c"
static int unixShmSystemLock(
  unixShmNode *pShmNode,
  int lockType,
  int ofst,
  int n
){
  struct flock f;
  int rc = 0;


  ((void) (0));


  ((void) (0));


  ((void) (0));

  if( pShmNode->h>=0 ){

    memset(&f, 0, sizeof(f));
    f.l_type = lockType;
    f.l_whence = 0;
    f.l_start = ofst;
    f.l_len = n;

    rc = ((int(*)(int,int,...))aSyscall[7].pCurrent)(pShmNode->h, 6, &f);
    rc = (rc!=(-1)) ? 0 : 5;
  }
# 27764 "ext/sqlite3/libsqlite/sqlite3.c"
  return rc;
}
# 27774 "ext/sqlite3/libsqlite/sqlite3.c"
static void unixShmPurge(unixFile *pFd){
  unixShmNode *p = pFd->pInode->pShmNode;
  ((void) (0));
  if( p && p->nRef==0 ){
    int i;
    ((void) (0));
    if( p->mutex ) ;
    for(i=0; i<p->nRegion; i++){
      if( p->h>=0 ){
        munmap(p->apRegion[i], p->szRegion);
      }else{
        sqlite3_free(p->apRegion[i]);
      }
    }
    sqlite3_free(p->apRegion);
    if( p->h>=0 ){
      robust_close(pFd, p->h, 27790);
      p->h = -1;
    }
    p->pInode->pShmNode = 0;
    sqlite3_free(p);
  }
}
# 27833 "ext/sqlite3/libsqlite/sqlite3.c"
static int unixOpenSharedMemory(unixFile *pDbFd){
  struct unixShm *p = 0;
  struct unixShmNode *pShmNode;
  int rc;
  unixInodeInfo *pInode;
  char *zShmFilename;
  int nShmFilename;


  p = sqlite3_malloc( sizeof(*p) );
  if( p==0 ) return 7;
  memset(p, 0, sizeof(*p));
  ((void) (0));




  unixEnterMutex();
  pInode = pDbFd->pInode;
  pShmNode = pInode->pShmNode;
  if( pShmNode==0 ){
    struct stat sStat;






    if( ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(pDbFd->h, &sStat) && pInode->bProcessLock==0 ){
      rc = (10 | (7<<8));
      goto shm_open_err;
    }




    nShmFilename = 5 + (int)strlen(pDbFd->zPath);

    pShmNode = sqlite3_malloc( sizeof(*pShmNode) + nShmFilename );
    if( pShmNode==0 ){
      rc = 7;
      goto shm_open_err;
    }
    memset(pShmNode, 0, sizeof(*pShmNode));
    zShmFilename = pShmNode->zFilename = (char*)&pShmNode[1];





    sqlite3_snprintf(nShmFilename, zShmFilename, "%s-shm", pDbFd->zPath);

    pShmNode->h = -1;
    pDbFd->pInode->pShmNode = pShmNode;
    pShmNode->pInode = pDbFd->pInode;
    pShmNode->mutex = ((sqlite3_mutex*)8);
    if( pShmNode->mutex==0 ){
      rc = 7;
      goto shm_open_err;
    }

    if( pInode->bProcessLock==0 ){
      pShmNode->h = robust_open(zShmFilename, 02|0100,
                               (sStat.st_mode & 0777));
      if( pShmNode->h<0 ){
        rc = unixLogErrorAtLine(sqlite3CantopenError(27898),"open",zShmFilename,27898);
        goto shm_open_err;
      }




      rc = 0;
      if( unixShmSystemLock(pShmNode, 1, (((22+8)*4)+8), 1)==0 ){
        if( robust_ftruncate(pShmNode->h, 0) ){
          rc = unixLogErrorAtLine((10 | (18<<8)),"ftruncate",zShmFilename,27908);
        }
      }
      if( rc==0 ){
        rc = unixShmSystemLock(pShmNode, 0, (((22+8)*4)+8), 1);
      }
      if( rc ) goto shm_open_err;
    }
  }


  p->pShmNode = pShmNode;



  pShmNode->nRef++;
  pDbFd->pShm = p;
  unixLeaveMutex();
# 27934 "ext/sqlite3/libsqlite/sqlite3.c"
                                      ;
  p->pNext = pShmNode->pFirst;
  pShmNode->pFirst = p;
                                      ;
  return 0;


shm_open_err:
  unixShmPurge(pDbFd);
  sqlite3_free(p);
  unixLeaveMutex();
  return rc;
}
# 27967 "ext/sqlite3/libsqlite/sqlite3.c"
static int unixShmMap(
  sqlite3_file *fd,
  int iRegion,
  int szRegion,
  int bExtend,
  void volatile **pp
){
  unixFile *pDbFd = (unixFile*)fd;
  unixShm *p;
  unixShmNode *pShmNode;
  int rc = 0;


  if( pDbFd->pShm==0 ){
    rc = unixOpenSharedMemory(pDbFd);
    if( rc!=0 ) return rc;
  }

  p = pDbFd->pShm;
  pShmNode = p->pShmNode;
                                      ;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( pShmNode->nRegion<=iRegion ){
    char **apNew;
    int nByte = (iRegion+1)*szRegion;
    struct stat sStat;

    pShmNode->szRegion = szRegion;

    if( pShmNode->h>=0 ){




      if( ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(pShmNode->h, &sStat) ){
        rc = (10 | (19<<8));
        goto shmpage_out;
      }

      if( sStat.st_size<nByte ){






        if( !bExtend ) goto shmpage_out;
        if( robust_ftruncate(pShmNode->h, nByte) ){
          rc = unixLogErrorAtLine((10 | (19<<8)),"ftruncate",pShmNode->zFilename,28020);

          goto shmpage_out;
        }
      }
    }


    apNew = (char **)sqlite3_realloc(
        pShmNode->apRegion, (iRegion+1)*sizeof(char *)
    );
    if( !apNew ){
      rc = (10 | (12<<8));
      goto shmpage_out;
    }
    pShmNode->apRegion = apNew;
    while(pShmNode->nRegion<=iRegion){
      void *pMem;
      if( pShmNode->h>=0 ){
        pMem = mmap(0, szRegion, 0x1|0x2,
            0x01, pShmNode->h, pShmNode->nRegion*szRegion
        );
        if( pMem==((void *) -1) ){
          rc = 10;
          goto shmpage_out;
        }
      }else{
        pMem = sqlite3_malloc(szRegion);
        if( pMem==0 ){
          rc = 7;
          goto shmpage_out;
        }
        memset(pMem, 0, szRegion);
      }
      pShmNode->apRegion[pShmNode->nRegion] = pMem;
      pShmNode->nRegion++;
    }
  }

shmpage_out:
  if( pShmNode->nRegion>iRegion ){
    *pp = pShmNode->apRegion[iRegion];
  }else{
    *pp = 0;
  }
                                      ;
  return rc;
}
# 28076 "ext/sqlite3/libsqlite/sqlite3.c"
static int unixShmLock(
  sqlite3_file *fd,
  int ofst,
  int n,
  int flags
){
  unixFile *pDbFd = (unixFile*)fd;
  unixShm *p = pDbFd->pShm;
  unixShm *pX;
  unixShmNode *pShmNode = p->pShmNode;
  int rc = 0;
  u16 mask;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));



  ((void) (0));
  ((void) (0));
  ((void) (0));

  mask = (1<<(ofst+n)) - (1<<ofst);
  ((void) (0));
                                      ;
  if( flags & 1 ){
    u16 allMask = 0;


    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){
      if( pX==p ) continue;
      ((void) (0));
      allMask |= pX->sharedMask;
    }


    if( (mask & allMask)==0 ){
      rc = unixShmSystemLock(pShmNode, 2, ofst+((22+8)*4), n);
    }else{
      rc = 0;
    }


    if( rc==0 ){
      p->exclMask &= ~mask;
      p->sharedMask &= ~mask;
    }
  }else if( flags & 4 ){
    u16 allShared = 0;





    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){
      if( (pX->exclMask & mask)!=0 ){
        rc = 5;
        break;
      }
      allShared |= pX->sharedMask;
    }


    if( rc==0 ){
      if( (allShared & mask)==0 ){
        rc = unixShmSystemLock(pShmNode, 0, ofst+((22+8)*4), n);
      }else{
        rc = 0;
      }
    }


    if( rc==0 ){
      p->sharedMask |= mask;
    }
  }else{



    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){
      if( (pX->exclMask & mask)!=0 || (pX->sharedMask & mask)!=0 ){
        rc = 5;
        break;
      }
    }




    if( rc==0 ){
      rc = unixShmSystemLock(pShmNode, 1, ofst+((22+8)*4), n);
      if( rc==0 ){
        ((void) (0));
        p->exclMask |= mask;
      }
    }
  }
                                      ;

                                                        ;
  return rc;
}







static void unixShmBarrier(
  sqlite3_file *fd
){
  (void)(fd);
  unixEnterMutex();
  unixLeaveMutex();
}
# 28203 "ext/sqlite3/libsqlite/sqlite3.c"
static int unixShmUnmap(
  sqlite3_file *fd,
  int deleteFlag
){
  unixShm *p;
  unixShmNode *pShmNode;
  unixShm **pp;
  unixFile *pDbFd;

  pDbFd = (unixFile*)fd;
  p = pDbFd->pShm;
  if( p==0 ) return 0;
  pShmNode = p->pShmNode;

  ((void) (0));
  ((void) (0));



                                      ;
  for(pp=&pShmNode->pFirst; (*pp)!=p; pp = &(*pp)->pNext){}
  *pp = p->pNext;


  sqlite3_free(p);
  pDbFd->pShm = 0;
                                      ;



  unixEnterMutex();
  ((void) (0));
  pShmNode->nRef--;
  if( pShmNode->nRef==0 ){
    if( deleteFlag && pShmNode->h>=0 ) unlink(pShmNode->zFilename);
    unixShmPurge(pDbFd);
  }
  unixLeaveMutex();

  return 0;
}
# 28325 "ext/sqlite3/libsqlite/sqlite3.c"
static const sqlite3_io_methods posixIoMethods = { 2, unixClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, unixLock, unixUnlock, unixCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, unixShmMap, unixShmLock, unixShmBarrier, unixShmUnmap }; static const sqlite3_io_methods * posixIoFinderImpl(const char *z, unixFile *p){ (void)(z); (void)(p); return &posixIoMethods; } static const sqlite3_io_methods *(*const posixIoFinder)(const char*,unixFile *p) = posixIoFinderImpl;
# 28334 "ext/sqlite3/libsqlite/sqlite3.c"
static const sqlite3_io_methods nolockIoMethods = { 1, nolockClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, nolockLock, nolockUnlock, nolockCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, unixShmMap, unixShmLock, unixShmBarrier, unixShmUnmap }; static const sqlite3_io_methods * nolockIoFinderImpl(const char *z, unixFile *p){ (void)(z); (void)(p); return &nolockIoMethods; } static const sqlite3_io_methods *(*const nolockIoFinder)(const char*,unixFile *p) = nolockIoFinderImpl;
# 28343 "ext/sqlite3/libsqlite/sqlite3.c"
static const sqlite3_io_methods dotlockIoMethods = { 1, dotlockClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, dotlockLock, dotlockUnlock, dotlockCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, unixShmMap, unixShmLock, unixShmBarrier, unixShmUnmap }; static const sqlite3_io_methods * dotlockIoFinderImpl(const char *z, unixFile *p){ (void)(z); (void)(p); return &dotlockIoMethods; } static const sqlite3_io_methods *(*const dotlockIoFinder)(const char*,unixFile *p) = dotlockIoFinderImpl;
# 28534 "ext/sqlite3/libsqlite/sqlite3.c"
typedef const sqlite3_io_methods *(*finder_type)(const char*,unixFile*);
# 28547 "ext/sqlite3/libsqlite/sqlite3.c"
static int fillInUnixFile(
  sqlite3_vfs *pVfs,
  int h,
  int dirfd,
  sqlite3_file *pId,
  const char *zFilename,
  int noLock,
  int isDelete,
  int isReadOnly
){
  const sqlite3_io_methods *pLockingStyle;
  unixFile *pNew = (unixFile *)pId;
  int rc = 0;

  ((void) (0));




  (void)(isDelete);
# 28576 "ext/sqlite3/libsqlite/sqlite3.c"
  ((void) (0));


                                              ;
  pNew->h = h;
  pNew->dirfd = dirfd;
  pNew->zPath = zFilename;
  if( memcmp(pVfs->zName,"unix-excl",10)==0 ){
    pNew->ctrlFlags = 0x01;
  }else{
    pNew->ctrlFlags = 0;
  }
  if( isReadOnly ){
    pNew->ctrlFlags |= 0x02;
  }
# 28600 "ext/sqlite3/libsqlite/sqlite3.c"
  if( noLock ){
    pLockingStyle = &nolockIoMethods;
  }else{
    pLockingStyle = (**(finder_type*)pVfs->pAppData)(zFilename, pNew);






  }

  if( pLockingStyle == &posixIoMethods



  ){
    unixEnterMutex();
    rc = findInodeInfo(pNew, &pNew->pInode);
    if( rc!=0 ){
# 28638 "ext/sqlite3/libsqlite/sqlite3.c"
      robust_close(pNew, h, 28638);
      h = -1;
    }
    unixLeaveMutex();
  }
# 28672 "ext/sqlite3/libsqlite/sqlite3.c"
  else if( pLockingStyle == &dotlockIoMethods ){



    char *zLockFile;
    int nFilename;
    nFilename = (int)strlen(zFilename) + 6;
    zLockFile = (char *)sqlite3_malloc(nFilename);
    if( zLockFile==0 ){
      rc = 7;
    }else{
      sqlite3_snprintf(nFilename, zLockFile, "%s" ".lock", zFilename);
    }
    pNew->lockingContext = zLockFile;
  }
# 28712 "ext/sqlite3/libsqlite/sqlite3.c"
  pNew->lastErrno = 0;
# 28722 "ext/sqlite3/libsqlite/sqlite3.c"
  if( rc!=0 ){
    if( dirfd>=0 ) robust_close(pNew, dirfd, 28723);
    if( h>=0 ) robust_close(pNew, h, 28724);
  }else{
    pNew->pMethod = pLockingStyle;
                   ;
  }
  return rc;
}
# 28742 "ext/sqlite3/libsqlite/sqlite3.c"
static int openDirectory(const char *zFilename, int *pFd){
  int ii;
  int fd = -1;
  char zDirname[512 +1];

  sqlite3_snprintf(512, zDirname, "%s", zFilename);
  for(ii=(int)strlen(zDirname); ii>1 && zDirname[ii]!='/'; ii--);
  if( ii>0 ){
    zDirname[ii] = '\0';
    fd = robust_open(zDirname, 00|0, 0);
    if( fd>=0 ){

      ((int(*)(int,int,...))aSyscall[7].pCurrent)(fd, 2, ((int(*)(int,int,...))aSyscall[7].pCurrent)(fd, 1, 0) | 1);

                                                  ;
    }
  }
  *pFd = fd;
  return (fd>=0?0:unixLogErrorAtLine(sqlite3CantopenError(28760),"open",zDirname,28760));
}





static const char *unixTempFileDir(void){
  static const char *azDirs[] = {
     0,
     0,
     "/var/tmp",
     "/usr/tmp",
     "/tmp",
     0
  };
  unsigned int i;
  struct stat buf;
  const char *zDir = 0;

  azDirs[0] = sqlite3_temp_directory;
  if( !azDirs[1] ) azDirs[1] = getenv("TMPDIR");
  for(i=0; i<sizeof(azDirs)/sizeof(azDirs[0]); zDir=azDirs[i++]){
    if( zDir==0 ) continue;
    if( ((int(*)(const char*,struct stat*))aSyscall[4].pCurrent)(zDir, &buf) ) continue;
    if( !((((buf.st_mode)) & 0170000) == (0040000)) ) continue;
    if( ((int(*)(const char*,int))aSyscall[2].pCurrent)(zDir, 07) ) continue;
    break;
  }
  return zDir;
}






static int unixGetTempname(int nBuf, char *zBuf){
  static const unsigned char zChars[] =
    "abcdefghijklmnopqrstuvwxyz"
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    "0123456789";
  unsigned int i, j;
  const char *zDir;





                                        ;

  zDir = unixTempFileDir();
  if( zDir==0 ) zDir = ".";




  if( (strlen(zDir) + strlen("etilqs_") + 17) >= (size_t)nBuf ){
    return 1;
  }

  do{
    sqlite3_snprintf(nBuf-17, zBuf, "%s/""etilqs_", zDir);
    j = (int)strlen(zBuf);
    sqlite3_randomness(15, &zBuf[j]);
    for(i=0; i<15; i++, j++){
      zBuf[j] = (char)zChars[ ((unsigned char)zBuf[j])%(sizeof(zChars)-1) ];
    }
    zBuf[j] = 0;
  }while( ((int(*)(const char*,int))aSyscall[2].pCurrent)(zBuf,0)==0 );
  return 0;
}
# 28858 "ext/sqlite3/libsqlite/sqlite3.c"
static UnixUnusedFd *findReusableFd(const char *zPath, int flags){
  UnixUnusedFd *pUnused = 0;







  struct stat sStat;
# 28877 "ext/sqlite3/libsqlite/sqlite3.c"
  if( 0==stat(zPath, &sStat) ){
    unixInodeInfo *pInode;

    unixEnterMutex();
    pInode = inodeList;
    while( pInode && (pInode->fileId.dev!=sStat.st_dev
                     || pInode->fileId.ino!=sStat.st_ino) ){
       pInode = pInode->pNext;
    }
    if( pInode ){
      UnixUnusedFd **pp;
      for(pp=&pInode->pUnused; *pp && (*pp)->flags!=flags; pp=&((*pp)->pNext));
      pUnused = *pp;
      if( pUnused ){
        *pp = pUnused->pNext;
      }
    }
    unixLeaveMutex();
  }

  return pUnused;
}
# 28918 "ext/sqlite3/libsqlite/sqlite3.c"
static int findCreateFileMode(
  const char *zPath,
  int flags,
  mode_t *pMode
){
  int rc = 0;
  if( flags & (0x00080000|0x00000800) ){
    char zDb[512 +1];
    int nDb;
    struct stat sStat;
# 28941 "ext/sqlite3/libsqlite/sqlite3.c"
    nDb = sqlite3Strlen30(zPath) - 1;
    while( nDb>0 && zPath[nDb]!='l' ) nDb--;
    nDb -= ((flags & 0x00080000) ? 3 : 7);
    memcpy(zDb, zPath, nDb);
    zDb[nDb] = '\0';

    if( 0==stat(zDb, &sStat) ){
      *pMode = sStat.st_mode & 0777;
    }else{
      rc = (10 | (7<<8));
    }
  }else if( flags & 0x00000008 ){
    *pMode = 0600;
  }else{
    *pMode = 0644;
  }
  return rc;
}
# 28982 "ext/sqlite3/libsqlite/sqlite3.c"
static int unixOpen(
  sqlite3_vfs *pVfs,
  const char *zPath,
  sqlite3_file *pFile,
  int flags,
  int *pOutFlags
){
  unixFile *p = (unixFile *)pFile;
  int fd = -1;
  int dirfd = -1;
  int openFlags = 0;
  int eType = flags&0xFFFFFF00;
  int noLock;
  int rc = 0;

  int isExclusive = (flags & 0x00000010);
  int isDelete = (flags & 0x00000008);
  int isCreate = (flags & 0x00000004);
  int isReadonly = (flags & 0x00000001);
  int isReadWrite = (flags & 0x00000002);
# 29010 "ext/sqlite3/libsqlite/sqlite3.c"
  int isOpenDirectory = (isCreate && (
        eType==0x00004000
     || eType==0x00000800
     || eType==0x00080000
  ));




  char zTmpname[512 +1];
  const char *zName = zPath;
# 29029 "ext/sqlite3/libsqlite/sqlite3.c"
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));



  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));


  ((void) (0));





  memset(p, 0, sizeof(unixFile));

  if( eType==0x00000100 ){
    UnixUnusedFd *pUnused;
    pUnused = findReusableFd(zName, flags);
    if( pUnused ){
      fd = pUnused->fd;
    }else{
      pUnused = sqlite3_malloc(sizeof(*pUnused));
      if( !pUnused ){
        return 7;
      }
    }
    p->pUnused = pUnused;
  }else if( !zName ){

    ((void) (0));
    rc = unixGetTempname(512 +1, zTmpname);
    if( rc!=0 ){
      return rc;
    }
    zName = zTmpname;
  }





  if( isReadonly ) openFlags |= 00;
  if( isReadWrite ) openFlags |= 02;
  if( isCreate ) openFlags |= 0100;
  if( isExclusive ) openFlags |= (0200|0400000);
  openFlags |= (0|0);

  if( fd<0 ){
    mode_t openMode;
    rc = findCreateFileMode(zName, flags, &openMode);
    if( rc!=0 ){
      ((void) (0));
      ((void) (0));
      return rc;
    }
    fd = robust_open(zName, openFlags, openMode);
                                                            ;
    if( fd<0 && (*__errno_location ())!=21 && isReadWrite && !isExclusive ){

      flags &= ~(0x00000002|0x00000004);
      openFlags &= ~(02|0100);
      flags |= 0x00000001;
      openFlags |= 00;
      isReadonly = 1;
      fd = robust_open(zName, openFlags, openMode);
    }
    if( fd<0 ){
      rc = unixLogErrorAtLine(sqlite3CantopenError(29102),"open",zName,29102);
      goto open_finished;
    }
  }
  ((void) (0));
  if( pOutFlags ){
    *pOutFlags = flags;
  }

  if( p->pUnused ){
    p->pUnused->fd = fd;
    p->pUnused->flags = flags;
  }

  if( isDelete ){



    unlink(zName);

  }






  if( isOpenDirectory ){
    rc = openDirectory(zPath, &dirfd);
    if( rc!=0 ){




      ((void) (0));
      robust_close(p, fd, 29137);
      goto open_finished;
    }
  }


  ((int(*)(int,int,...))aSyscall[7].pCurrent)(fd, 2, ((int(*)(int,int,...))aSyscall[7].pCurrent)(fd, 1, 0) | 1);


  noLock = eType!=0x00000100;
# 29213 "ext/sqlite3/libsqlite/sqlite3.c"
  rc = fillInUnixFile(pVfs, fd, dirfd, pFile, zPath, noLock,
                      isDelete, isReadonly);
open_finished:
  if( rc!=0 ){
    sqlite3_free(p->pUnused);
  }
  return rc;
}






static int unixDelete(
  sqlite3_vfs *NotUsed,
  const char *zPath,
  int dirSync
){
  int rc = 0;
  (void)(NotUsed);
                                             ;
  if( unlink(zPath)==(-1) && (*__errno_location ())!=2 ){
    return unixLogErrorAtLine((10 | (10<<8)),"unlink",zPath,29236);
  }

  if( dirSync ){
    int fd;
    rc = openDirectory(zPath, &fd);
    if( rc==0 ){



      if( fsync(fd) )

      {
        rc = unixLogErrorAtLine((10 | (5<<8)),"fsync",zPath,29249);
      }
      robust_close(0, fd, 29251);
    }
  }

  return rc;
}
# 29268 "ext/sqlite3/libsqlite/sqlite3.c"
static int unixAccess(
  sqlite3_vfs *NotUsed,
  const char *zPath,
  int flags,
  int *pResOut
){
  int amode = 0;
  (void)(NotUsed);
                                                ;
  switch( flags ){
    case 0:
      amode = 0;
      break;
    case 1:
      amode = 2|4;
      break;
    case 2:
      amode = 4;
      break;

    default:
      ((void) (0));
  }
  *pResOut = (((int(*)(const char*,int))aSyscall[2].pCurrent)(zPath, amode)==0);
  if( flags==0 && *pResOut ){
    struct stat buf;
    if( 0==stat(zPath, &buf) && buf.st_size==0 ){
      *pResOut = 0;
    }
  }
  return 0;
}
# 29311 "ext/sqlite3/libsqlite/sqlite3.c"
static int unixFullPathname(
  sqlite3_vfs *pVfs,
  const char *zPath,
  int nOut,
  char *zOut
){






                                        ;

  ((void) (0));
  (void)(pVfs);

  zOut[nOut-1] = '\0';
  if( zPath[0]=='/' ){
    sqlite3_snprintf(nOut, zOut, "%s", zPath);
  }else{
    int nCwd;
    if( ((char*(*)(char*,size_t))aSyscall[3].pCurrent)(zOut, nOut-1)==0 ){
      return unixLogErrorAtLine(sqlite3CantopenError(29334),"getcwd",zPath,29334);
    }
    nCwd = (int)strlen(zOut);
    sqlite3_snprintf(nOut-nCwd, &zOut[nCwd], "/%s", zPath);
  }
  return 0;
}








# 1 "/usr/include/dlfcn.h" 1 3 4
# 24 "/usr/include/dlfcn.h" 3 4
# 1 "/home/ubuntu/Workspace/utils/llvm-build/bin/../lib/clang/3.5.0/include/stddef.h" 1 3 4
# 25 "/usr/include/dlfcn.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/dlfcn.h" 1 3 4
# 60 "/usr/include/x86_64-linux-gnu/bits/dlfcn.h" 3 4
extern void _dl_mcount_wrapper_check (void *__selfpc) __attribute__ ((__nothrow__ ));
# 28 "/usr/include/dlfcn.h" 2 3 4
# 44 "/usr/include/dlfcn.h" 3 4
typedef long int Lmid_t;
# 56 "/usr/include/dlfcn.h" 3 4
extern void *dlopen (const char *__file, int __mode) __attribute__ ((__nothrow__));



extern int dlclose (void *__handle) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern void *dlsym (void *__restrict __handle,
      const char *__restrict __name) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));



extern void *dlmopen (Lmid_t __nsid, const char *__file, int __mode) __attribute__ ((__nothrow__));



extern void *dlvsym (void *__restrict __handle,
       const char *__restrict __name,
       const char *__restrict __version)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2, 3)));





extern char *dlerror (void) __attribute__ ((__nothrow__ ));





typedef struct
{
  const char *dli_fname;
  void *dli_fbase;
  const char *dli_sname;
  void *dli_saddr;
} Dl_info;



extern int dladdr (const void *__address, Dl_info *__info)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));


extern int dladdr1 (const void *__address, Dl_info *__info,
      void **__extra_info, int __flags) __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (2)));




enum
  {

    RTLD_DL_SYMENT = 1,


    RTLD_DL_LINKMAP = 2
  };







extern int dlinfo (void *__restrict __handle,
     int __request, void *__restrict __arg)
     __attribute__ ((__nothrow__ )) __attribute__ ((__nonnull__ (1, 3)));


enum
  {

    RTLD_DI_LMID = 1,



    RTLD_DI_LINKMAP = 2,

    RTLD_DI_CONFIGADDR = 3,






    RTLD_DI_SERINFO = 4,
    RTLD_DI_SERINFOSIZE = 5,



    RTLD_DI_ORIGIN = 6,

    RTLD_DI_PROFILENAME = 7,
    RTLD_DI_PROFILEOUT = 8,




    RTLD_DI_TLS_MODID = 9,





    RTLD_DI_TLS_DATA = 10,

    RTLD_DI_MAX = 10
  };




typedef struct
{
  char *dls_name;
  unsigned int dls_flags;
} Dl_serpath;



typedef struct
{
  size_t dls_size;
  unsigned int dls_cnt;
  Dl_serpath dls_serpath[1];
} Dl_serinfo;
# 29349 "ext/sqlite3/libsqlite/sqlite3.c" 2
static void *unixDlOpen(sqlite3_vfs *NotUsed, const char *zFilename){
  (void)(NotUsed);
  return dlopen(zFilename, 0x00002 | 0x00100);
}
# 29361 "ext/sqlite3/libsqlite/sqlite3.c"
static void unixDlError(sqlite3_vfs *NotUsed, int nBuf, char *zBufOut){
  const char *zErr;
  (void)(NotUsed);
  unixEnterMutex();
  zErr = dlerror();
  if( zErr ){
    sqlite3_snprintf(nBuf, zBufOut, "%s", zErr);
  }
  unixLeaveMutex();
}
static void (*unixDlSym(sqlite3_vfs *NotUsed, void *p, const char*zSym))(void){
# 29389 "ext/sqlite3/libsqlite/sqlite3.c"
  void (*(*x)(void*,const char*))(void);
  (void)(NotUsed);
  x = (void(*(*)(void*,const char*))(void))dlsym;
  return (*x)(p, zSym);
}
static void unixDlClose(sqlite3_vfs *NotUsed, void *pHandle){
  (void)(NotUsed);
  dlclose(pHandle);
}
# 29408 "ext/sqlite3/libsqlite/sqlite3.c"
static int unixRandomness(sqlite3_vfs *NotUsed, int nBuf, char *zBuf){
  (void)(NotUsed);
  ((void) (0));
# 29424 "ext/sqlite3/libsqlite/sqlite3.c"
  memset(zBuf, 0, nBuf);

  {
    int pid, fd;
    fd = robust_open("/dev/urandom", 00, 0);
    if( fd<0 ){
      time_t t;
      time(&t);
      memcpy(zBuf, &t, sizeof(t));
      pid = getpid();
      memcpy(&zBuf[sizeof(t)], &pid, sizeof(pid));
      ((void) (0));
      nBuf = sizeof(t) + sizeof(pid);
    }else{
      do{ nBuf = ((ssize_t(*)(int,void*,size_t))aSyscall[8].pCurrent)(fd, zBuf, nBuf); }while( nBuf<0 && (*__errno_location ())==4 );
      robust_close(0, fd, 29439);
    }
  }

  return nBuf;
}
# 29455 "ext/sqlite3/libsqlite/sqlite3.c"
static int unixSleep(sqlite3_vfs *NotUsed, int microseconds){
# 29469 "ext/sqlite3/libsqlite/sqlite3.c"
  int seconds = (microseconds+999999)/1000000;
  sleep(seconds);
  (void)(NotUsed);
  return seconds*1000000;

}
# 29494 "ext/sqlite3/libsqlite/sqlite3.c"
static int unixCurrentTimeInt64(sqlite3_vfs *NotUsed, sqlite3_int64 *piNow){
  static const sqlite3_int64 unixEpoch = 24405875*(sqlite3_int64)8640000;
# 29505 "ext/sqlite3/libsqlite/sqlite3.c"
  struct timeval sNow;
  gettimeofday(&sNow, 0);
  *piNow = unixEpoch + 1000*(sqlite3_int64)sNow.tv_sec + sNow.tv_usec/1000;







  (void)(NotUsed);
  return 0;
}






static int unixCurrentTime(sqlite3_vfs *NotUsed, double *prNow){
  sqlite3_int64 i;
  (void)(NotUsed);
  unixCurrentTimeInt64(0, &i);
  *prNow = i/86400000.0;
  return 0;
}
# 29539 "ext/sqlite3/libsqlite/sqlite3.c"
static int unixGetLastError(sqlite3_vfs *NotUsed, int NotUsed2, char *NotUsed3){
  (void)(NotUsed);
  (void)(NotUsed2);
  (void)(NotUsed3);
  return 0;
}
# 30734 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_os_init(void){
# 30787 "ext/sqlite3/libsqlite/sqlite3.c"
  static sqlite3_vfs aVfs[] = {



    { 3, sizeof(unixFile), 512, 0, "unix", (void*)&posixIoFinder, unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall, },

    { 3, sizeof(unixFile), 512, 0, "unix-none", (void*)&nolockIoFinder, unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall, },
    { 3, sizeof(unixFile), 512, 0, "unix-dotfile", (void*)&dotlockIoFinder, unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall, },
    { 3, sizeof(unixFile), 512, 0, "unix-excl", (void*)&posixIoFinder, unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall, },
# 30810 "ext/sqlite3/libsqlite/sqlite3.c"
  };
  unsigned int i;



  ((void) (0));


  for(i=0; i<(sizeof(aVfs)/sizeof(sqlite3_vfs)); i++){
    sqlite3_vfs_register(&aVfs[i], i==0);
  }
  return 0;
}
# 30831 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_os_end(void){
  return 0;
}
# 33923 "ext/sqlite3/libsqlite/sqlite3.c"
struct Bitvec {
  u32 iSize;
  u32 nSet;


  u32 iDivisor;



  union {
    u8 aBitmap[((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u8))];
    u32 aHash[((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32))];
    Bitvec *apSub[((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(Bitvec *))];
  } u;
};






static Bitvec *sqlite3BitvecCreate(u32 iSize){
  Bitvec *p;
  ((void) (0));
  p = sqlite3MallocZero( sizeof(*p) );
  if( p ){
    p->iSize = iSize;
  }
  return p;
}






static int sqlite3BitvecTest(Bitvec *p, u32 i){
  if( p==0 ) return 0;
  if( i>p->iSize || i==0 ) return 0;
  i--;
  while( p->iDivisor ){
    u32 bin = i/p->iDivisor;
    i = i%p->iDivisor;
    p = p->u.apSub[bin];
    if (!p) {
      return 0;
    }
  }
  if( p->iSize<=(((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u8))*8) ){
    return (p->u.aBitmap[i/8] & (1<<(i&(8 -1))))!=0;
  } else{
    u32 h = (((i++)*1)%((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)));
    while( p->u.aHash[h] ){
      if( p->u.aHash[h]==i ) return 1;
      h = (h+1) % ((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32));
    }
    return 0;
  }
}
# 33995 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BitvecSet(Bitvec *p, u32 i){
  u32 h;
  if( p==0 ) return 0;
  ((void) (0));
  ((void) (0));
  i--;
  while((p->iSize > (((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u8))*8)) && p->iDivisor) {
    u32 bin = i/p->iDivisor;
    i = i%p->iDivisor;
    if( p->u.apSub[bin]==0 ){
      p->u.apSub[bin] = sqlite3BitvecCreate( p->iDivisor );
      if( p->u.apSub[bin]==0 ) return 7;
    }
    p = p->u.apSub[bin];
  }
  if( p->iSize<=(((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u8))*8) ){
    p->u.aBitmap[i/8] |= 1 << (i&(8 -1));
    return 0;
  }
  h = (((i++)*1)%((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)));



  if( !p->u.aHash[h] ){
    if (p->nSet<(((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32))-1)) {
      goto bitvec_set_end;
    } else {
      goto bitvec_set_rehash;
    }
  }


  do {
    if( p->u.aHash[h]==i ) return 0;
    h++;
    if( h>=((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)) ) h = 0;
  } while( p->u.aHash[h] );



bitvec_set_rehash:
  if( p->nSet>=(((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32))/2) ){
    unsigned int j;
    int rc;
    u32 *aiValues = sqlite3DbMallocRaw(0,sizeof(p->u.aHash));
    if( aiValues==0 ){
      return 7;
    }else{
      memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
      memset(p->u.apSub, 0, sizeof(p->u.apSub));
      p->iDivisor = (p->iSize + ((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(Bitvec *)) - 1)/((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(Bitvec *));
      rc = sqlite3BitvecSet(p, i);
      for(j=0; j<((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)); j++){
        if( aiValues[j] ) rc |= sqlite3BitvecSet(p, aiValues[j]);
      }
      sqlite3DbFree(0,aiValues);
      return rc;
    }
  }
bitvec_set_end:
  p->nSet++;
  p->u.aHash[h] = i;
  return 0;
}







static void sqlite3BitvecClear(Bitvec *p, u32 i, void *pBuf){
  if( p==0 ) return;
  ((void) (0));
  i--;
  while( p->iDivisor ){
    u32 bin = i/p->iDivisor;
    i = i%p->iDivisor;
    p = p->u.apSub[bin];
    if (!p) {
      return;
    }
  }
  if( p->iSize<=(((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u8))*8) ){
    p->u.aBitmap[i/8] &= ~(1 << (i&(8 -1)));
  }else{
    unsigned int j;
    u32 *aiValues = pBuf;
    memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
    memset(p->u.aHash, 0, sizeof(p->u.aHash));
    p->nSet = 0;
    for(j=0; j<((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)); j++){
      if( aiValues[j] && aiValues[j]!=(i+1) ){
        u32 h = (((aiValues[j]-1)*1)%((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)));
        p->nSet++;
        while( p->u.aHash[h] ){
          h++;
          if( h>=((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)) ) h = 0;
        }
        p->u.aHash[h] = aiValues[j];
      }
    }
  }
}




static void sqlite3BitvecDestroy(Bitvec *p){
  if( p==0 ) return;
  if( p->iDivisor ){
    unsigned int i;
    for(i=0; i<((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(Bitvec *)); i++){
      sqlite3BitvecDestroy(p->u.apSub[i]);
    }
  }
  sqlite3_free(p);
}





static u32 sqlite3BitvecSize(Bitvec *p){
  return p->iSize;
}
# 34163 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BitvecBuiltinTest(int sz, int *aOp){
  Bitvec *pBitvec = 0;
  unsigned char *pV = 0;
  int rc = -1;
  int i, nx, pc, op;
  void *pTmpSpace;



  pBitvec = sqlite3BitvecCreate( sz );
  pV = sqlite3_malloc( (sz+7)/8 + 1 );
  pTmpSpace = sqlite3_malloc(512);
  if( pBitvec==0 || pV==0 || pTmpSpace==0 ) goto bitvec_end;
  memset(pV, 0, (sz+7)/8 + 1);


  sqlite3BitvecSet(0, 1);
  sqlite3BitvecClear(0, 1, pTmpSpace);


  pc = 0;
  while( (op = aOp[pc])!=0 ){
    switch( op ){
      case 1:
      case 2:
      case 5: {
        nx = 4;
        i = aOp[pc+2] - 1;
        aOp[pc+2] += aOp[pc+3];
        break;
      }
      case 3:
      case 4:
      default: {
        nx = 2;
        sqlite3_randomness(sizeof(i), &i);
        break;
      }
    }
    if( (--aOp[pc+1]) > 0 ) nx = 0;
    pc += nx;
    i = (i & 0x7fffffff)%sz;
    if( (op & 1)!=0 ){
      pV[(i+1)>>3] |= (1<<((i+1)&7));
      if( op!=5 ){
        if( sqlite3BitvecSet(pBitvec, i+1) ) goto bitvec_end;
      }
    }else{
      pV[(i+1)>>3] &= ~(1<<((i+1)&7));
      sqlite3BitvecClear(pBitvec, i+1, pTmpSpace);
    }
  }






  rc = sqlite3BitvecTest(0,0) + sqlite3BitvecTest(pBitvec, sz+1)
          + sqlite3BitvecTest(pBitvec, 0)
          + (sqlite3BitvecSize(pBitvec) - sz);
  for(i=1; i<=sz; i++){
    if( ((pV[i>>3]&(1<<(i&7)))!=0)!=sqlite3BitvecTest(pBitvec,i) ){
      rc = i;
      break;
    }
  }


bitvec_end:
  sqlite3_free(pTmpSpace);
  sqlite3_free(pV);
  sqlite3BitvecDestroy(pBitvec);
  return rc;
}
# 34259 "ext/sqlite3/libsqlite/sqlite3.c"
struct PCache {
  PgHdr *pDirty, *pDirtyTail;
  PgHdr *pSynced;
  int nRef;
  int nMax;
  int szPage;
  int szExtra;
  int bPurgeable;
  int (*xStress)(void*,PgHdr*);
  void *pStress;
  sqlite3_pcache *pCache;
  PgHdr *pPage1;
};
# 34307 "ext/sqlite3/libsqlite/sqlite3.c"
static void pcacheRemoveFromDirtyList(PgHdr *pPage){
  PCache *p = pPage->pCache;

  ((void) (0));
  ((void) (0));


  if( p->pSynced==pPage ){
    PgHdr *pSynced = pPage->pDirtyPrev;
    while( pSynced && (pSynced->flags&0x004) ){
      pSynced = pSynced->pDirtyPrev;
    }
    p->pSynced = pSynced;
  }

  if( pPage->pDirtyNext ){
    pPage->pDirtyNext->pDirtyPrev = pPage->pDirtyPrev;
  }else{
    ((void) (0));
    p->pDirtyTail = pPage->pDirtyPrev;
  }
  if( pPage->pDirtyPrev ){
    pPage->pDirtyPrev->pDirtyNext = pPage->pDirtyNext;
  }else{
    ((void) (0));
    p->pDirty = pPage->pDirtyNext;
  }
  pPage->pDirtyNext = 0;
  pPage->pDirtyPrev = 0;

                                          ;
}





static void pcacheAddToDirtyList(PgHdr *pPage){
  PCache *p = pPage->pCache;

  ((void) (0));

  pPage->pDirtyNext = p->pDirty;
  if( pPage->pDirtyNext ){
    ((void) (0));
    pPage->pDirtyNext->pDirtyPrev = pPage;
  }
  p->pDirty = pPage;
  if( !p->pDirtyTail ){
    p->pDirtyTail = pPage;
  }
  if( !p->pSynced && 0==(pPage->flags&0x004) ){
    p->pSynced = pPage;
  }
                                          ;
}





static void pcacheUnpin(PgHdr *p){
  PCache *pCache = p->pCache;
  if( pCache->bPurgeable ){
    if( p->pgno==1 ){
      pCache->pPage1 = 0;
    }
    sqlite3Config.pcache.xUnpin(pCache->pCache, p, 0);
  }
}






static int sqlite3PcacheInitialize(void){
  if( sqlite3Config.pcache.xInit==0 ){



    sqlite3PCacheSetDefault();
  }
  return sqlite3Config.pcache.xInit(sqlite3Config.pcache.pArg);
}
static void sqlite3PcacheShutdown(void){
  if( sqlite3Config.pcache.xShutdown ){

    sqlite3Config.pcache.xShutdown(sqlite3Config.pcache.pArg);
  }
}




static int sqlite3PcacheSize(void){ return sizeof(PCache); }







static void sqlite3PcacheOpen(
  int szPage,
  int szExtra,
  int bPurgeable,
  int (*xStress)(void*,PgHdr*),
  void *pStress,
  PCache *p
){
  memset(p, 0, sizeof(PCache));
  p->szPage = szPage;
  p->szExtra = szExtra;
  p->bPurgeable = bPurgeable;
  p->xStress = xStress;
  p->pStress = pStress;
  p->nMax = 100;
}





static void sqlite3PcacheSetPageSize(PCache *pCache, int szPage){
  ((void) (0));
  if( pCache->pCache ){
    sqlite3Config.pcache.xDestroy(pCache->pCache);
    pCache->pCache = 0;
    pCache->pPage1 = 0;
  }
  pCache->szPage = szPage;
}




static int sqlite3PcacheFetch(
  PCache *pCache,
  Pgno pgno,
  int createFlag,
  PgHdr **ppPage
){
  PgHdr *pPage = 0;
  int eCreate;

  ((void) (0));
  ((void) (0));
  ((void) (0));




  if( !pCache->pCache && createFlag ){
    sqlite3_pcache *p;
    int nByte;
    nByte = pCache->szPage + pCache->szExtra + sizeof(PgHdr);
    p = sqlite3Config.pcache.xCreate(nByte, pCache->bPurgeable);
    if( !p ){
      return 7;
    }
    sqlite3Config.pcache.xCachesize(p, pCache->nMax);
    pCache->pCache = p;
  }

  eCreate = createFlag * (1 + (!pCache->bPurgeable || !pCache->pDirty));
  if( pCache->pCache ){
    pPage = sqlite3Config.pcache.xFetch(pCache->pCache, pgno, eCreate);
  }

  if( !pPage && eCreate==1 ){
    PgHdr *pPg;






                                                 ;
    for(pPg=pCache->pSynced;
        pPg && (pPg->nRef || (pPg->flags&0x004));
        pPg=pPg->pDirtyPrev
    );
    pCache->pSynced = pPg;
    if( !pPg ){
      for(pPg=pCache->pDirtyTail; pPg && pPg->nRef; pPg=pPg->pDirtyPrev);
    }
    if( pPg ){
      int rc;
      rc = pCache->xStress(pCache->pStress, pPg);
      if( rc!=0 && rc!=5 ){
        return rc;
      }
    }

    pPage = sqlite3Config.pcache.xFetch(pCache->pCache, pgno, 2);
  }

  if( pPage ){
    if( !pPage->pData ){
      memset(pPage, 0, sizeof(PgHdr));
      pPage->pData = (void *)&pPage[1];
      pPage->pExtra = (void*)&((char *)pPage->pData)[pCache->szPage];
      memset(pPage->pExtra, 0, pCache->szExtra);
      pPage->pCache = pCache;
      pPage->pgno = pgno;
    }
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));

    if( 0==pPage->nRef ){
      pCache->nRef++;
    }
    pPage->nRef++;
    if( pgno==1 ){
      pCache->pPage1 = pPage;
    }
  }
  *ppPage = pPage;
  return (pPage==0 && eCreate) ? 7 : 0;
}





static void sqlite3PcacheRelease(PgHdr *p){
  ((void) (0));
  p->nRef--;
  if( p->nRef==0 ){
    PCache *pCache = p->pCache;
    pCache->nRef--;
    if( (p->flags&0x002)==0 ){
      pcacheUnpin(p);
    }else{

      pcacheRemoveFromDirtyList(p);
      pcacheAddToDirtyList(p);
    }
  }
}




static void sqlite3PcacheRef(PgHdr *p){
  ((void) (0));
  p->nRef++;
}






static void sqlite3PcacheDrop(PgHdr *p){
  PCache *pCache;
  ((void) (0));
  if( p->flags&0x002 ){
    pcacheRemoveFromDirtyList(p);
  }
  pCache = p->pCache;
  pCache->nRef--;
  if( p->pgno==1 ){
    pCache->pPage1 = 0;
  }
  sqlite3Config.pcache.xUnpin(pCache->pCache, p, 1);
}





static void sqlite3PcacheMakeDirty(PgHdr *p){
  p->flags &= ~0x020;
  ((void) (0));
  if( 0==(p->flags & 0x002) ){
    p->flags |= 0x002;
    pcacheAddToDirtyList( p);
  }
}





static void sqlite3PcacheMakeClean(PgHdr *p){
  if( (p->flags & 0x002) ){
    pcacheRemoveFromDirtyList(p);
    p->flags &= ~(0x002|0x004);
    if( p->nRef==0 ){
      pcacheUnpin(p);
    }
  }
}




static void sqlite3PcacheCleanAll(PCache *pCache){
  PgHdr *p;
  while( (p = pCache->pDirty)!=0 ){
    sqlite3PcacheMakeClean(p);
  }
}




static void sqlite3PcacheClearSyncFlags(PCache *pCache){
  PgHdr *p;
  for(p=pCache->pDirty; p; p=p->pDirtyNext){
    p->flags &= ~0x004;
  }
  pCache->pSynced = pCache->pDirtyTail;
}




static void sqlite3PcacheMove(PgHdr *p, Pgno newPgno){
  PCache *pCache = p->pCache;
  ((void) (0));
  ((void) (0));
  sqlite3Config.pcache.xRekey(pCache->pCache, p, p->pgno, newPgno);
  p->pgno = newPgno;
  if( (p->flags&0x002) && (p->flags&0x004) ){
    pcacheRemoveFromDirtyList(p);
    pcacheAddToDirtyList(p);
  }
}
# 34650 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3PcacheTruncate(PCache *pCache, Pgno pgno){
  if( pCache->pCache ){
    PgHdr *p;
    PgHdr *pNext;
    for(p=pCache->pDirty; p; p=pNext){
      pNext = p->pDirtyNext;




      ((void) (0));
      if( (p->pgno>pgno) ){
        ((void) (0));
        sqlite3PcacheMakeClean(p);
      }
    }
    if( pgno==0 && pCache->pPage1 ){
      memset(pCache->pPage1->pData, 0, pCache->szPage);
      pgno = 1;
    }
    sqlite3Config.pcache.xTruncate(pCache->pCache, pgno+1);
  }
}




static void sqlite3PcacheClose(PCache *pCache){
  if( pCache->pCache ){
    sqlite3Config.pcache.xDestroy(pCache->pCache);
  }
}




static void sqlite3PcacheClear(PCache *pCache){
  sqlite3PcacheTruncate(pCache, 0);
}





static PgHdr *pcacheMergeDirtyList(PgHdr *pA, PgHdr *pB){
  PgHdr result, *pTail;
  pTail = &result;
  while( pA && pB ){
    if( pA->pgno<pB->pgno ){
      pTail->pDirty = pA;
      pTail = pA;
      pA = pA->pDirty;
    }else{
      pTail->pDirty = pB;
      pTail = pB;
      pB = pB->pDirty;
    }
  }
  if( pA ){
    pTail->pDirty = pA;
  }else if( pB ){
    pTail->pDirty = pB;
  }else{
    pTail->pDirty = 0;
  }
  return result.pDirty;
}
# 34729 "ext/sqlite3/libsqlite/sqlite3.c"
static PgHdr *pcacheSortDirtyList(PgHdr *pIn){
  PgHdr *a[32], *p;
  int i;
  memset(a, 0, sizeof(a));
  while( pIn ){
    p = pIn;
    pIn = p->pDirty;
    p->pDirty = 0;
    for(i=0; (i<32 -1); i++){
      if( a[i]==0 ){
        a[i] = p;
        break;
      }else{
        p = pcacheMergeDirtyList(a[i], p);
        a[i] = 0;
      }
    }
    if( (i==32 -1) ){



      a[i] = pcacheMergeDirtyList(a[i], p);
    }
  }
  p = a[0];
  for(i=1; i<32; i++){
    p = pcacheMergeDirtyList(p, a[i]);
  }
  return p;
}




static PgHdr *sqlite3PcacheDirtyList(PCache *pCache){
  PgHdr *p;
  for(p=pCache->pDirty; p; p=p->pDirtyNext){
    p->pDirty = p->pDirtyNext;
  }
  return pcacheSortDirtyList(pCache->pDirty);
}




static int sqlite3PcacheRefCount(PCache *pCache){
  return pCache->nRef;
}




static int sqlite3PcachePageRefcount(PgHdr *p){
  return p->nRef;
}




static int sqlite3PcachePagecount(PCache *pCache){
  int nPage = 0;
  if( pCache->pCache ){
    nPage = sqlite3Config.pcache.xPagecount(pCache->pCache);
  }
  return nPage;
}
# 34808 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3PcacheSetCachesize(PCache *pCache, int mxPage){
  pCache->nMax = mxPage;
  if( pCache->pCache ){
    sqlite3Config.pcache.xCachesize(pCache->pCache, mxPage);
  }
}
# 34851 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct PCache1 PCache1;
typedef struct PgHdr1 PgHdr1;
typedef struct PgFreeslot PgFreeslot;
typedef struct PGroup PGroup;
# 34878 "ext/sqlite3/libsqlite/sqlite3.c"
struct PGroup {
  sqlite3_mutex *mutex;
  int nMaxPage;
  int nMinPage;
  int mxPinned;
  int nCurrentPage;
  PgHdr1 *pLruHead, *pLruTail;
};
# 34895 "ext/sqlite3/libsqlite/sqlite3.c"
struct PCache1 {





  PGroup *pGroup;
  int szPage;
  int bPurgeable;
  unsigned int nMin;
  unsigned int nMax;
  unsigned int n90pct;




  unsigned int nRecyclable;
  unsigned int nPage;
  unsigned int nHash;
  PgHdr1 **apHash;

  unsigned int iMaxKey;
};







struct PgHdr1 {
  unsigned int iKey;
  PgHdr1 *pNext;
  PCache1 *pCache;
  PgHdr1 *pLruNext;
  PgHdr1 *pLruPrev;
};





struct PgFreeslot {
  PgFreeslot *pNext;
};




static struct PCacheGlobal {
  PGroup grp;






  int isInit;
  int szSlot;
  int nSlot;
  int nReserve;
  void *pStart, *pEnd;

  sqlite3_mutex *mutex;
  int nFreeSlot;
  PgFreeslot *pFree;




  int bUnderPressure;
} pcache1_g;
# 35008 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3PCacheBufferSetup(void *pBuf, int sz, int n){
  if( (pcache1_g).isInit ){
    PgFreeslot *p;
    sz = ((sz)&~7);
    (pcache1_g).szSlot = sz;
    (pcache1_g).nSlot = (pcache1_g).nFreeSlot = n;
    (pcache1_g).nReserve = n>90 ? 10 : (n/10 + 1);
    (pcache1_g).pStart = pBuf;
    (pcache1_g).pFree = 0;
    (pcache1_g).bUnderPressure = 0;
    while( n-- ){
      p = (PgFreeslot*)pBuf;
      p->pNext = (pcache1_g).pFree;
      (pcache1_g).pFree = p;
      pBuf = (void*)&((char*)pBuf)[sz];
    }
    (pcache1_g).pEnd = pBuf;
  }
}
# 35037 "ext/sqlite3/libsqlite/sqlite3.c"
static void *pcache1Alloc(int nByte){
  void *p = 0;
  ((void) (0));
  sqlite3StatusSet(7, nByte);
  if( nByte<=(pcache1_g).szSlot ){
                                      ;
    p = (PgHdr1 *)(pcache1_g).pFree;
    if( p ){
      (pcache1_g).pFree = (pcache1_g).pFree->pNext;
      (pcache1_g).nFreeSlot--;
      (pcache1_g).bUnderPressure = (pcache1_g).nFreeSlot<(pcache1_g).nReserve;
      ((void) (0));
      sqlite3StatusAdd(1, 1);
    }
                                      ;
  }
  if( p==0 ){



    p = sqlite3Malloc(nByte);
    if( p ){
      int sz = sqlite3MallocSize(p);
                                        ;
      sqlite3StatusAdd(2, sz);
                                        ;
    }
                                             ;
  }
  return p;
}




static void pcache1Free(void *p){
  if( p==0 ) return;
  if( p>=(pcache1_g).pStart && p<(pcache1_g).pEnd ){
    PgFreeslot *pSlot;
                                      ;
    sqlite3StatusAdd(1, -1);
    pSlot = (PgFreeslot*)p;
    pSlot->pNext = (pcache1_g).pFree;
    (pcache1_g).pFree = pSlot;
    (pcache1_g).nFreeSlot++;
    (pcache1_g).bUnderPressure = (pcache1_g).nFreeSlot<(pcache1_g).nReserve;
    ((void) (0));
                                      ;
  }else{
    int iSize;
    ((void) (0));
                                           ;
    iSize = sqlite3MallocSize(p);
                                      ;
    sqlite3StatusAdd(2, -iSize);
                                      ;
    sqlite3_free(p);
  }
}
# 35118 "ext/sqlite3/libsqlite/sqlite3.c"
static PgHdr1 *pcache1AllocPage(PCache1 *pCache){
  int nByte = sizeof(PgHdr1) + pCache->szPage;
  void *pPg = pcache1Alloc(nByte);
  PgHdr1 *p;
  if( pPg ){
    p = (PgHdr1*)(((char*)pPg) + pCache->szPage);
    if( pCache->bPurgeable ){
      pCache->pGroup->nCurrentPage++;
    }
  }else{
    p = 0;
  }
  return p;
}
# 35140 "ext/sqlite3/libsqlite/sqlite3.c"
static void pcache1FreePage(PgHdr1 *p){
  if( (p) ){
    PCache1 *pCache = p->pCache;
    if( pCache->bPurgeable ){
      pCache->pGroup->nCurrentPage--;
    }
    pcache1Free((void*)(((char*)p) - p->pCache->szPage));
  }
}






static void *sqlite3PageMalloc(int sz){
  return pcache1Alloc(sz);
}




static void sqlite3PageFree(void *p){
  pcache1Free(p);
}
# 35183 "ext/sqlite3/libsqlite/sqlite3.c"
static int pcache1UnderMemoryPressure(PCache1 *pCache){
  if( (pcache1_g).nSlot && pCache->szPage<=(pcache1_g).szSlot ){
    return (pcache1_g).bUnderPressure;
  }else{
    return sqlite3HeapNearlyFull();
  }
}
# 35200 "ext/sqlite3/libsqlite/sqlite3.c"
static int pcache1ResizeHash(PCache1 *p){
  PgHdr1 **apNew;
  unsigned int nNew;
  unsigned int i;

  ((void) (0));

  nNew = p->nHash*2;
  if( nNew<256 ){
    nNew = 256;
  }

                              ;
  if( p->nHash ){ sqlite3BeginBenignMalloc(); }
  apNew = (PgHdr1 **)sqlite3_malloc(sizeof(PgHdr1 *)*nNew);
  if( p->nHash ){ sqlite3EndBenignMalloc(); }
                              ;
  if( apNew ){
    memset(apNew, 0, sizeof(PgHdr1 *)*nNew);
    for(i=0; i<p->nHash; i++){
      PgHdr1 *pPage;
      PgHdr1 *pNext = p->apHash[i];
      while( (pPage = pNext)!=0 ){
        unsigned int h = pPage->iKey % nNew;
        pNext = pPage->pNext;
        pPage->pNext = apNew[h];
        apNew[h] = pPage;
      }
    }
    sqlite3_free(p->apHash);
    p->apHash = apNew;
    p->nHash = nNew;
  }

  return (p->apHash ? 0 : 7);
}
# 35246 "ext/sqlite3/libsqlite/sqlite3.c"
static void pcache1PinPage(PgHdr1 *pPage){
  PCache1 *pCache;
  PGroup *pGroup;

  if( pPage==0 ) return;
  pCache = pPage->pCache;
  pGroup = pCache->pGroup;
  ((void) (0));
  if( pPage->pLruNext || pPage==pGroup->pLruTail ){
    if( pPage->pLruPrev ){
      pPage->pLruPrev->pLruNext = pPage->pLruNext;
    }
    if( pPage->pLruNext ){
      pPage->pLruNext->pLruPrev = pPage->pLruPrev;
    }
    if( pGroup->pLruHead==pPage ){
      pGroup->pLruHead = pPage->pLruNext;
    }
    if( pGroup->pLruTail==pPage ){
      pGroup->pLruTail = pPage->pLruPrev;
    }
    pPage->pLruNext = 0;
    pPage->pLruPrev = 0;
    pPage->pCache->nRecyclable--;
  }
}
# 35280 "ext/sqlite3/libsqlite/sqlite3.c"
static void pcache1RemoveFromHash(PgHdr1 *pPage){
  unsigned int h;
  PCache1 *pCache = pPage->pCache;
  PgHdr1 **pp;

  ((void) (0));
  h = pPage->iKey % pCache->nHash;
  for(pp=&pCache->apHash[h]; (*pp)!=pPage; pp=&(*pp)->pNext);
  *pp = (*pp)->pNext;

  pCache->nPage--;
}





static void pcache1EnforceMaxPage(PGroup *pGroup){
  ((void) (0));
  while( pGroup->nCurrentPage>pGroup->nMaxPage && pGroup->pLruTail ){
    PgHdr1 *p = pGroup->pLruTail;
    ((void) (0));
    pcache1PinPage(p);
    pcache1RemoveFromHash(p);
    pcache1FreePage(p);
  }
}
# 35315 "ext/sqlite3/libsqlite/sqlite3.c"
static void pcache1TruncateUnsafe(
  PCache1 *pCache,
  unsigned int iLimit
){

  unsigned int h;
  ((void) (0));
  for(h=0; h<pCache->nHash; h++){
    PgHdr1 **pp = &pCache->apHash[h];
    PgHdr1 *pPage;
    while( (pPage = *pp)!=0 ){
      if( pPage->iKey>=iLimit ){
        pCache->nPage--;
        *pp = pPage->pNext;
        pcache1PinPage(pPage);
        pcache1FreePage(pPage);
      }else{
        pp = &pPage->pNext;

      }
    }
  }
  ((void) (0));
}







static int pcache1Init(void *NotUsed){
  (void)(NotUsed);
  ((void) (0));
  memset(&(pcache1_g), 0, sizeof((pcache1_g)));
  if( sqlite3Config.bCoreMutex ){
    (pcache1_g).grp.mutex = ((sqlite3_mutex*)8);
    (pcache1_g).mutex = ((sqlite3_mutex*)8);
  }
  (pcache1_g).grp.mxPinned = 10;
  (pcache1_g).isInit = 1;
  return 0;
}






static void pcache1Shutdown(void *NotUsed){
  (void)(NotUsed);
  ((void) (0));
  memset(&(pcache1_g), 0, sizeof((pcache1_g)));
}






static sqlite3_pcache *pcache1Create(int szPage, int bPurgeable){
  PCache1 *pCache;
  PGroup *pGroup;
  int sz;
# 35393 "ext/sqlite3/libsqlite/sqlite3.c"
  const int separateCache = 0;




  sz = sizeof(PCache1) + sizeof(PGroup)*separateCache;
  pCache = (PCache1 *)sqlite3_malloc(sz);
  if( pCache ){
    memset(pCache, 0, sz);
    if( separateCache ){
      pGroup = (PGroup*)&pCache[1];
      pGroup->mxPinned = 10;
    }else{
      pGroup = &pcache1_g.grp;
    }
    pCache->pGroup = pGroup;
    pCache->szPage = szPage;
    pCache->bPurgeable = (bPurgeable ? 1 : 0);
    if( bPurgeable ){
      pCache->nMin = 10;
                               ;
      pGroup->nMinPage += pCache->nMin;
      pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;
                               ;
    }
  }
  return (sqlite3_pcache *)pCache;
}






static void pcache1Cachesize(sqlite3_pcache *p, int nMax){
  PCache1 *pCache = (PCache1 *)p;
  if( pCache->bPurgeable ){
    PGroup *pGroup = pCache->pGroup;
                             ;
    pGroup->nMaxPage += (nMax - pCache->nMax);
    pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;
    pCache->nMax = nMax;
    pCache->n90pct = pCache->nMax*9/10;
    pcache1EnforceMaxPage(pGroup);
                             ;
  }
}




static int pcache1Pagecount(sqlite3_pcache *p){
  int n;
  PCache1 *pCache = (PCache1*)p;
                                   ;
  n = pCache->nPage;
                                   ;
  return n;
}
# 35507 "ext/sqlite3/libsqlite/sqlite3.c"
static void *pcache1Fetch(sqlite3_pcache *p, unsigned int iKey, int createFlag){
  int nPinned;
  PCache1 *pCache = (PCache1 *)p;
  PGroup *pGroup;
  PgHdr1 *pPage = 0;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
                                            ;


  if( pCache->nHash>0 ){
    unsigned int h = iKey % pCache->nHash;
    for(pPage=pCache->apHash[h]; pPage&&pPage->iKey!=iKey; pPage=pPage->pNext);
  }


  if( pPage || createFlag==0 ){
    pcache1PinPage(pPage);
    goto fetch_out;
  }
# 35539 "ext/sqlite3/libsqlite/sqlite3.c"
  pGroup = pCache->pGroup;




  nPinned = pCache->nPage - pCache->nRecyclable;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( createFlag==1 && (
        nPinned>=pGroup->mxPinned
     || nPinned>=(int)pCache->n90pct
     || pcache1UnderMemoryPressure(pCache)
  )){
    goto fetch_out;
  }

  if( pCache->nPage>=pCache->nHash && pcache1ResizeHash(pCache) ){
    goto fetch_out;
  }


  if( pCache->bPurgeable && pGroup->pLruTail && (
         (pCache->nPage+1>=pCache->nMax)
      || pGroup->nCurrentPage>=pGroup->nMaxPage
      || pcache1UnderMemoryPressure(pCache)
  )){
    PCache1 *pOtherCache;
    pPage = pGroup->pLruTail;
    pcache1RemoveFromHash(pPage);
    pcache1PinPage(pPage);
    if( (pOtherCache = pPage->pCache)->szPage!=pCache->szPage ){
      pcache1FreePage(pPage);
      pPage = 0;
    }else{
      pGroup->nCurrentPage -=
               (pOtherCache->bPurgeable - pCache->bPurgeable);
    }
  }




  if( !pPage ){
    if( createFlag==1 ) sqlite3BeginBenignMalloc();
                             ;
    pPage = pcache1AllocPage(pCache);
                             ;
    if( createFlag==1 ) sqlite3EndBenignMalloc();
  }

  if( pPage ){
    unsigned int h = iKey % pCache->nHash;
    pCache->nPage++;
    pPage->iKey = iKey;
    pPage->pNext = pCache->apHash[h];
    pPage->pCache = pCache;
    pPage->pLruPrev = 0;
    pPage->pLruNext = 0;
    *(void **)((void*)(((char*)pPage) - pPage->pCache->szPage)) = 0;
    pCache->apHash[h] = pPage;
  }

fetch_out:
  if( pPage && iKey>pCache->iMaxKey ){
    pCache->iMaxKey = iKey;
  }
                           ;
  return (pPage ? (void*)(((char*)pPage) - pPage->pCache->szPage) : 0);
}







static void pcache1Unpin(sqlite3_pcache *p, void *pPg, int reuseUnlikely){
  PCache1 *pCache = (PCache1 *)p;
  PgHdr1 *pPage = (PgHdr1*)(((char*)pPg) + pCache->szPage);
  PGroup *pGroup = pCache->pGroup;

  ((void) (0));
                           ;




  ((void) (0));
  ((void) (0));

  if( reuseUnlikely || pGroup->nCurrentPage>pGroup->nMaxPage ){
    pcache1RemoveFromHash(pPage);
    pcache1FreePage(pPage);
  }else{

    if( pGroup->pLruHead ){
      pGroup->pLruHead->pLruPrev = pPage;
      pPage->pLruNext = pGroup->pLruHead;
      pGroup->pLruHead = pPage;
    }else{
      pGroup->pLruTail = pPage;
      pGroup->pLruHead = pPage;
    }
    pCache->nRecyclable++;
  }

                                   ;
}




static void pcache1Rekey(
  sqlite3_pcache *p,
  void *pPg,
  unsigned int iOld,
  unsigned int iNew
){
  PCache1 *pCache = (PCache1 *)p;
  PgHdr1 *pPage = (PgHdr1*)(((char*)pPg) + pCache->szPage);
  PgHdr1 **pp;
  unsigned int h;
  ((void) (0));
  ((void) (0));

                                   ;

  h = iOld%pCache->nHash;
  pp = &pCache->apHash[h];
  while( (*pp)!=pPage ){
    pp = &(*pp)->pNext;
  }
  *pp = pPage->pNext;

  h = iNew%pCache->nHash;
  pPage->iKey = iNew;
  pPage->pNext = pCache->apHash[h];
  pCache->apHash[h] = pPage;
  if( iNew>pCache->iMaxKey ){
    pCache->iMaxKey = iNew;
  }

                                   ;
}
# 35692 "ext/sqlite3/libsqlite/sqlite3.c"
static void pcache1Truncate(sqlite3_pcache *p, unsigned int iLimit){
  PCache1 *pCache = (PCache1 *)p;
                                   ;
  if( iLimit<=pCache->iMaxKey ){
    pcache1TruncateUnsafe(pCache, iLimit);
    pCache->iMaxKey = iLimit-1;
  }
                                   ;
}






static void pcache1Destroy(sqlite3_pcache *p){
  PCache1 *pCache = (PCache1 *)p;
  PGroup *pGroup = pCache->pGroup;
  ((void) (0));
                           ;
  pcache1TruncateUnsafe(pCache, 0);
  pGroup->nMaxPage -= pCache->nMax;
  pGroup->nMinPage -= pCache->nMin;
  pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;
  pcache1EnforceMaxPage(pGroup);
                           ;
  sqlite3_free(pCache->apHash);
  sqlite3_free(pCache);
}






static void sqlite3PCacheSetDefault(void){
  static const sqlite3_pcache_methods defaultMethods = {
    0,
    pcache1Init,
    pcache1Shutdown,
    pcache1Create,
    pcache1Cachesize,
    pcache1Pagecount,
    pcache1Fetch,
    pcache1Unpin,
    pcache1Rekey,
    pcache1Truncate,
    pcache1Destroy
  };
  sqlite3_config(14, &defaultMethods);
}
# 35876 "ext/sqlite3/libsqlite/sqlite3.c"
struct RowSetEntry {
  i64 v;
  struct RowSetEntry *pRight;
  struct RowSetEntry *pLeft;
};







struct RowSetChunk {
  struct RowSetChunk *pNextChunk;
  struct RowSetEntry aEntry[((1024 -8)/sizeof(struct RowSetEntry))];
};






struct RowSet {
  struct RowSetChunk *pChunk;
  sqlite3 *db;
  struct RowSetEntry *pEntry;
  struct RowSetEntry *pLast;
  struct RowSetEntry *pFresh;
  struct RowSetEntry *pTree;
  u16 nFresh;
  u8 isSorted;
  u8 iBatch;
};
# 35922 "ext/sqlite3/libsqlite/sqlite3.c"
static RowSet *sqlite3RowSetInit(sqlite3 *db, void *pSpace, unsigned int N){
  RowSet *p;
  ((void) (0));
  p = pSpace;
  p->pChunk = 0;
  p->db = db;
  p->pEntry = 0;
  p->pLast = 0;
  p->pTree = 0;
  p->pFresh = (struct RowSetEntry*)((((sizeof(*p))+7)&~7) + (char*)p);
  p->nFresh = (u16)((N - (((sizeof(*p))+7)&~7))/sizeof(struct RowSetEntry));
  p->isSorted = 1;
  p->iBatch = 0;
  return p;
}






static void sqlite3RowSetClear(RowSet *p){
  struct RowSetChunk *pChunk, *pNextChunk;
  for(pChunk=p->pChunk; pChunk; pChunk = pNextChunk){
    pNextChunk = pChunk->pNextChunk;
    sqlite3DbFree(p->db, pChunk);
  }
  p->pChunk = 0;
  p->nFresh = 0;
  p->pEntry = 0;
  p->pLast = 0;
  p->pTree = 0;
  p->isSorted = 1;
}







static void sqlite3RowSetInsert(RowSet *p, i64 rowid){
  struct RowSetEntry *pEntry;
  struct RowSetEntry *pLast;
  ((void) (0));
  if( p->nFresh==0 ){
    struct RowSetChunk *pNew;
    pNew = sqlite3DbMallocRaw(p->db, sizeof(*pNew));
    if( pNew==0 ){
      return;
    }
    pNew->pNextChunk = p->pChunk;
    p->pChunk = pNew;
    p->pFresh = pNew->aEntry;
    p->nFresh = ((1024 -8)/sizeof(struct RowSetEntry));
  }
  pEntry = p->pFresh++;
  p->nFresh--;
  pEntry->v = rowid;
  pEntry->pRight = 0;
  pLast = p->pLast;
  if( pLast ){
    if( p->isSorted && rowid<=pLast->v ){
      p->isSorted = 0;
    }
    pLast->pRight = pEntry;
  }else{
    ((void) (0));
    p->pEntry = pEntry;
  }
  p->pLast = pEntry;
}







static struct RowSetEntry *rowSetMerge(
  struct RowSetEntry *pA,
  struct RowSetEntry *pB
){
  struct RowSetEntry head;
  struct RowSetEntry *pTail;

  pTail = &head;
  while( pA && pB ){
    ((void) (0));
    ((void) (0));
    if( pA->v<pB->v ){
      pTail->pRight = pA;
      pA = pA->pRight;
      pTail = pTail->pRight;
    }else if( pB->v<pA->v ){
      pTail->pRight = pB;
      pB = pB->pRight;
      pTail = pTail->pRight;
    }else{
      pA = pA->pRight;
    }
  }
  if( pA ){
    ((void) (0));
    pTail->pRight = pA;
  }else{
    ((void) (0));
    pTail->pRight = pB;
  }
  return head.pRight;
}




static void rowSetSort(RowSet *p){
  unsigned int i;
  struct RowSetEntry *pEntry;
  struct RowSetEntry *aBucket[40];

  ((void) (0));
  memset(aBucket, 0, sizeof(aBucket));
  while( p->pEntry ){
    pEntry = p->pEntry;
    p->pEntry = pEntry->pRight;
    pEntry->pRight = 0;
    for(i=0; aBucket[i]; i++){
      pEntry = rowSetMerge(aBucket[i], pEntry);
      aBucket[i] = 0;
    }
    aBucket[i] = pEntry;
  }
  pEntry = 0;
  for(i=0; i<sizeof(aBucket)/sizeof(aBucket[0]); i++){
    pEntry = rowSetMerge(pEntry, aBucket[i]);
  }
  p->pEntry = pEntry;
  p->pLast = 0;
  p->isSorted = 1;
}







static void rowSetTreeToList(
  struct RowSetEntry *pIn,
  struct RowSetEntry **ppFirst,
  struct RowSetEntry **ppLast
){
  ((void) (0));
  if( pIn->pLeft ){
    struct RowSetEntry *p;
    rowSetTreeToList(pIn->pLeft, ppFirst, &p);
    p->pRight = pIn;
  }else{
    *ppFirst = pIn;
  }
  if( pIn->pRight ){
    rowSetTreeToList(pIn->pRight, &pIn->pRight, ppLast);
  }else{
    *ppLast = pIn;
  }
  ((void) (0));
}
# 36104 "ext/sqlite3/libsqlite/sqlite3.c"
static struct RowSetEntry *rowSetNDeepTree(
  struct RowSetEntry **ppList,
  int iDepth
){
  struct RowSetEntry *p;
  struct RowSetEntry *pLeft;
  if( *ppList==0 ){
    return 0;
  }
  if( iDepth==1 ){
    p = *ppList;
    *ppList = p->pRight;
    p->pLeft = p->pRight = 0;
    return p;
  }
  pLeft = rowSetNDeepTree(ppList, iDepth-1);
  p = *ppList;
  if( p==0 ){
    return pLeft;
  }
  p->pLeft = pLeft;
  *ppList = p->pRight;
  p->pRight = rowSetNDeepTree(ppList, iDepth-1);
  return p;
}





static struct RowSetEntry *rowSetListToTree(struct RowSetEntry *pList){
  int iDepth;
  struct RowSetEntry *p;
  struct RowSetEntry *pLeft;

  ((void) (0));
  p = pList;
  pList = p->pRight;
  p->pLeft = p->pRight = 0;
  for(iDepth=1; pList; iDepth++){
    pLeft = p;
    p = pList;
    pList = p->pRight;
    p->pLeft = pLeft;
    p->pRight = rowSetNDeepTree(&pList, iDepth);
  }
  return p;
}






static void rowSetToList(RowSet *p){
  if( !p->isSorted ){
    rowSetSort(p);
  }
  if( p->pTree ){
    struct RowSetEntry *pHead, *pTail;
    rowSetTreeToList(p->pTree, &pHead, &pTail);
    p->pTree = 0;
    p->pEntry = rowSetMerge(p->pEntry, pHead);
  }
}
# 36178 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3RowSetNext(RowSet *p, i64 *pRowid){
  rowSetToList(p);
  if( p->pEntry ){
    *pRowid = p->pEntry->v;
    p->pEntry = p->pEntry->pRight;
    if( p->pEntry==0 ){
      sqlite3RowSetClear(p);
    }
    return 1;
  }else{
    return 0;
  }
}





static int sqlite3RowSetTest(RowSet *pRowSet, u8 iBatch, sqlite3_int64 iRowid){
  struct RowSetEntry *p;
  if( iBatch!=pRowSet->iBatch ){
    if( pRowSet->pEntry ){
      rowSetToList(pRowSet);
      pRowSet->pTree = rowSetListToTree(pRowSet->pEntry);
      pRowSet->pEntry = 0;
      pRowSet->pLast = 0;
    }
    pRowSet->iBatch = iBatch;
  }
  p = pRowSet->pTree;
  while( p ){
    if( p->v<iRowid ){
      p = p->pRight;
    }else if( p->v>iRowid ){
      p = p->pLeft;
    }else{
      return 1;
    }
  }
  return 0;
}
# 36289 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct Wal Wal;


static int sqlite3WalOpen(sqlite3_vfs*, sqlite3_file*, const char *zName, int, Wal**);
static int sqlite3WalClose(Wal *pWal, int sync_flags, int, u8 *);
# 36302 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3WalBeginReadTransaction(Wal *pWal, int *);
static void sqlite3WalEndReadTransaction(Wal *pWal);


static int sqlite3WalRead(Wal *pWal, Pgno pgno, int *pInWal, int nOut, u8 *pOut);


static Pgno sqlite3WalDbsize(Wal *pWal);


static int sqlite3WalBeginWriteTransaction(Wal *pWal);
static int sqlite3WalEndWriteTransaction(Wal *pWal);


static int sqlite3WalUndo(Wal *pWal, int (*xUndo)(void *, Pgno), void *pUndoCtx);



static void sqlite3WalSavepoint(Wal *pWal, u32 *aWalData);



static int sqlite3WalSavepointUndo(Wal *pWal, u32 *aWalData);


static int sqlite3WalFrames(Wal *pWal, int, PgHdr *, Pgno, int, int);


static int sqlite3WalCheckpoint(
  Wal *pWal,
  int eMode,
  int (*xBusy)(void*),
  void *pBusyArg,
  int sync_flags,
  int nBuf,
  u8 *zBuf,
  int *pnLog,
  int *pnCkpt
);






static int sqlite3WalCallback(Wal *pWal);




static int sqlite3WalExclusiveMode(Wal *pWal, int op);





static int sqlite3WalHeapMemory(Wal *pWal);
# 36785 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct PagerSavepoint PagerSavepoint;
struct PagerSavepoint {
  i64 iOffset;
  i64 iHdrOffset;
  Bitvec *pInSavepoint;
  Pgno nOrig;
  Pgno iSubRec;

  u32 aWalData[4];

};
# 36951 "ext/sqlite3/libsqlite/sqlite3.c"
struct Pager {
  sqlite3_vfs *pVfs;
  u8 exclusiveMode;
  u8 journalMode;
  u8 useJournal;
  u8 noReadlock;
  u8 noSync;
  u8 fullSync;
  u8 ckptSyncFlags;
  u8 syncFlags;
  u8 tempFile;
  u8 readOnly;
  u8 memDb;
# 36974 "ext/sqlite3/libsqlite/sqlite3.c"
  u8 eState;
  u8 eLock;
  u8 changeCountDone;
  u8 setMaster;
  u8 doNotSpill;
  u8 doNotSyncSpill;
  u8 subjInMemory;
  Pgno dbSize;
  Pgno dbOrigSize;
  Pgno dbFileSize;
  Pgno dbHintSize;
  int errCode;
  int nRec;
  u32 cksumInit;
  u32 nSubRec;
  Bitvec *pInJournal;
  sqlite3_file *fd;
  sqlite3_file *jfd;
  sqlite3_file *sjfd;
  i64 journalOff;
  i64 journalHdr;
  sqlite3_backup *pBackup;
  PagerSavepoint *aSavepoint;
  int nSavepoint;
  char dbFileVers[16];




  u16 nExtra;
  i16 nReserve;
  u32 vfsFlags;
  u32 sectorSize;
  int pageSize;
  Pgno mxPgno;
  i64 journalSizeLimit;
  char *zFilename;
  char *zJournal;
  int (*xBusyHandler)(void*);
  void *pBusyHandlerArg;




  void (*xReiniter)(DbPage*);






  char *pTmpSpace;
  PCache *pPCache;

  Wal *pWal;
  char *zWal;

};
# 37072 "ext/sqlite3/libsqlite/sqlite3.c"
static const unsigned char aJournalMagic[] = {
  0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7,
};
# 37124 "ext/sqlite3/libsqlite/sqlite3.c"
static int pagerUseWal(Pager *pPager){
  return (pPager->pWal!=0);
}
# 37333 "ext/sqlite3/libsqlite/sqlite3.c"
static int subjRequiresPage(PgHdr *pPg){
  Pgno pgno = pPg->pgno;
  Pager *pPager = pPg->pPager;
  int i;
  for(i=0; i<pPager->nSavepoint; i++){
    PagerSavepoint *p = &pPager->aSavepoint[i];
    if( p->nOrig>=pgno && 0==sqlite3BitvecTest(p->pInSavepoint, pgno) ){
      return 1;
    }
  }
  return 0;
}




static int pageInJournal(PgHdr *pPg){
  return sqlite3BitvecTest(pPg->pPager->pInJournal, pPg->pgno);
}
# 37360 "ext/sqlite3/libsqlite/sqlite3.c"
static int read32bits(sqlite3_file *fd, i64 offset, u32 *pRes){
  unsigned char ac[4];
  int rc = sqlite3OsRead(fd, ac, sizeof(ac), offset);
  if( rc==0 ){
    *pRes = sqlite3Get4byte(ac);
  }
  return rc;
}
# 37379 "ext/sqlite3/libsqlite/sqlite3.c"
static int write32bits(sqlite3_file *fd, i64 offset, u32 val){
  char ac[4];
  sqlite3Put4byte((u8*)ac,val);
  return sqlite3OsWrite(fd, ac, 4, offset);
}
# 37394 "ext/sqlite3/libsqlite/sqlite3.c"
static int pagerUnlockDb(Pager *pPager, int eLock){
  int rc = 0;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( ((pPager->fd)->pMethods) ){
    ((void) (0));
    rc = sqlite3OsUnlock(pPager->fd, eLock);
    if( pPager->eLock!=(4 +1) ){
      pPager->eLock = (u8)eLock;
    }

  }
  return rc;
}
# 37421 "ext/sqlite3/libsqlite/sqlite3.c"
static int pagerLockDb(Pager *pPager, int eLock){
  int rc = 0;

  ((void) (0));
  if( pPager->eLock<eLock || pPager->eLock==(4 +1) ){
    rc = sqlite3OsLock(pPager->fd, eLock);
    if( rc==0 && (pPager->eLock!=(4 +1)||eLock==4) ){
      pPager->eLock = (u8)eLock;

    }
  }
  return rc;
}
# 37544 "ext/sqlite3/libsqlite/sqlite3.c"
static int readMasterJournal(sqlite3_file *pJrnl, char *zMaster, u32 nMaster){
  int rc;
  u32 len;
  i64 szJ;
  u32 cksum;
  u32 u;
  unsigned char aMagic[8];
  zMaster[0] = '\0';

  if( 0!=(rc = sqlite3OsFileSize(pJrnl, &szJ))
   || szJ<16
   || 0!=(rc = read32bits(pJrnl, szJ-16, &len))
   || len>=nMaster
   || 0!=(rc = read32bits(pJrnl, szJ-12, &cksum))
   || 0!=(rc = sqlite3OsRead(pJrnl, aMagic, 8, szJ-8))
   || memcmp(aMagic, aJournalMagic, 8)
   || 0!=(rc = sqlite3OsRead(pJrnl, zMaster, len, szJ-16-len))
  ){
    return rc;
  }


  for(u=0; u<len; u++){
    cksum -= zMaster[u];
  }
  if( cksum ){





    len = 0;
  }
  zMaster[len] = '\0';

  return 0;
}
# 37597 "ext/sqlite3/libsqlite/sqlite3.c"
static i64 journalHdrOffset(Pager *pPager){
  i64 offset = 0;
  i64 c = pPager->journalOff;
  if( c ){
    offset = ((c-1)/(pPager->sectorSize) + 1) * (pPager->sectorSize);
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
  return offset;
}
# 37630 "ext/sqlite3/libsqlite/sqlite3.c"
static int zeroJournalHdr(Pager *pPager, int doTruncate){
  int rc = 0;
  ((void) (0));
  if( pPager->journalOff ){
    const i64 iLimit = pPager->journalSizeLimit;


    if( doTruncate || iLimit==0 ){
      rc = sqlite3OsTruncate(pPager->jfd, 0);
    }else{
      static const char zeroHdr[28] = {0};
      rc = sqlite3OsWrite(pPager->jfd, zeroHdr, sizeof(zeroHdr), 0);
    }
    if( rc==0 && !pPager->noSync ){
      rc = sqlite3OsSync(pPager->jfd, 0x00010|pPager->syncFlags);
    }







    if( rc==0 && iLimit>0 ){
      i64 sz;
      rc = sqlite3OsFileSize(pPager->jfd, &sz);
      if( rc==0 && sz>iLimit ){
        rc = sqlite3OsTruncate(pPager->jfd, iLimit);
      }
    }
  }
  return rc;
}
# 37679 "ext/sqlite3/libsqlite/sqlite3.c"
static int writeJournalHdr(Pager *pPager){
  int rc = 0;
  char *zHeader = pPager->pTmpSpace;
  u32 nHeader = (u32)pPager->pageSize;
  u32 nWrite;
  int ii;

  ((void) (0));

  if( nHeader>(pPager->sectorSize) ){
    nHeader = (pPager->sectorSize);
  }





  for(ii=0; ii<pPager->nSavepoint; ii++){
    if( pPager->aSavepoint[ii].iHdrOffset==0 ){
      pPager->aSavepoint[ii].iHdrOffset = pPager->journalOff;
    }
  }

  pPager->journalHdr = pPager->journalOff = journalHdrOffset(pPager);
# 37724 "ext/sqlite3/libsqlite/sqlite3.c"
  ((void) (0));
  if( pPager->noSync || (pPager->journalMode==4)
   || (sqlite3OsDeviceCharacteristics(pPager->fd)&0x00000200)
  ){
    memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
    sqlite3Put4byte((u8*)&zHeader[sizeof(aJournalMagic)],0xffffffff);
  }else{
    memset(zHeader, 0, sizeof(aJournalMagic)+4);
  }


  sqlite3_randomness(sizeof(pPager->cksumInit), &pPager->cksumInit);
  sqlite3Put4byte((u8*)&zHeader[sizeof(aJournalMagic)+4],pPager->cksumInit);

  sqlite3Put4byte((u8*)&zHeader[sizeof(aJournalMagic)+8],pPager->dbOrigSize);

  sqlite3Put4byte((u8*)&zHeader[sizeof(aJournalMagic)+12],pPager->sectorSize);


  sqlite3Put4byte((u8*)&zHeader[sizeof(aJournalMagic)+16],pPager->pageSize);






  memset(&zHeader[sizeof(aJournalMagic)+20], 0,
         nHeader-(sizeof(aJournalMagic)+20));
# 37770 "ext/sqlite3/libsqlite/sqlite3.c"
  for(nWrite=0; rc==0&&nWrite<(pPager->sectorSize); nWrite+=nHeader){

    rc = sqlite3OsWrite(pPager->jfd, zHeader, nHeader, pPager->journalOff);
    ((void) (0));
    pPager->journalOff += nHeader;
  }

  return rc;
}
# 37797 "ext/sqlite3/libsqlite/sqlite3.c"
static int readJournalHdr(
  Pager *pPager,
  int isHot,
  i64 journalSize,
  u32 *pNRec,
  u32 *pDbSize
){
  int rc;
  unsigned char aMagic[8];
  i64 iHdrOff;

  ((void) (0));





  pPager->journalOff = journalHdrOffset(pPager);
  if( pPager->journalOff+(pPager->sectorSize) > journalSize ){
    return 101;
  }
  iHdrOff = pPager->journalOff;






  if( isHot || iHdrOff!=pPager->journalHdr ){
    rc = sqlite3OsRead(pPager->jfd, aMagic, sizeof(aMagic), iHdrOff);
    if( rc ){
      return rc;
    }
    if( memcmp(aMagic, aJournalMagic, sizeof(aMagic))!=0 ){
      return 101;
    }
  }





  if( 0!=(rc = read32bits(pPager->jfd, iHdrOff+8, pNRec))
   || 0!=(rc = read32bits(pPager->jfd, iHdrOff+12, &pPager->cksumInit))
   || 0!=(rc = read32bits(pPager->jfd, iHdrOff+16, pDbSize))
  ){
    return rc;
  }

  if( pPager->journalOff==0 ){
    u32 iPageSize;
    u32 iSectorSize;


    if( 0!=(rc = read32bits(pPager->jfd, iHdrOff+20, &iSectorSize))
     || 0!=(rc = read32bits(pPager->jfd, iHdrOff+24, &iPageSize))
    ){
      return rc;
    }





    if( iPageSize==0 ){
      iPageSize = pPager->pageSize;
    }






    if( iPageSize<512 || iSectorSize<32
     || iPageSize>65536 || iSectorSize>0x10000
     || ((iPageSize-1)&iPageSize)!=0 || ((iSectorSize-1)&iSectorSize)!=0
    ){





      return 101;
    }





    rc = sqlite3PagerSetPagesize(pPager, &iPageSize, -1);
                             ;







    pPager->sectorSize = iSectorSize;
  }

  pPager->journalOff += (pPager->sectorSize);
  return rc;
}
# 37922 "ext/sqlite3/libsqlite/sqlite3.c"
static int writeMasterJournal(Pager *pPager, const char *zMaster){
  int rc;
  int nMaster;
  i64 iHdrOff;
  i64 jrnlSize;
  u32 cksum = 0;

  ((void) (0));
  ((void) (0));

  if( !zMaster
   || pPager->journalMode==4
   || pPager->journalMode==2
  ){
    return 0;
  }
  pPager->setMaster = 1;
  ((void) (0));
  ((void) (0));


  for(nMaster=0; zMaster[nMaster]; nMaster++){
    cksum += zMaster[nMaster];
  }





  if( pPager->fullSync ){
    pPager->journalOff = journalHdrOffset(pPager);
  }
  iHdrOff = pPager->journalOff;




  if( (0 != (rc = write32bits(pPager->jfd, iHdrOff, ((Pgno)((sqlite3PendingByte/((pPager)->pageSize))+1)))))
   || (0 != (rc = sqlite3OsWrite(pPager->jfd, zMaster, nMaster, iHdrOff+4)))
   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nMaster, nMaster)))
   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nMaster+4, cksum)))
   || (0 != (rc = sqlite3OsWrite(pPager->jfd, aJournalMagic, 8, iHdrOff+4+nMaster+8)))
  ){
    return rc;
  }
  pPager->journalOff += (nMaster+20);
# 37979 "ext/sqlite3/libsqlite/sqlite3.c"
  if( 0==(rc = sqlite3OsFileSize(pPager->jfd, &jrnlSize))
   && jrnlSize>pPager->journalOff
  ){
    rc = sqlite3OsTruncate(pPager->jfd, pPager->journalOff);
  }
  return rc;
}






static PgHdr *pager_lookup(Pager *pPager, Pgno pgno){
  PgHdr *p;




  (void)sqlite3PcacheFetch(pPager->pPCache, pgno, 0, &p);
  return p;
}




static void pager_reset(Pager *pPager){
  sqlite3BackupRestart(pPager->pBackup);
  sqlite3PcacheClear(pPager->pPCache);
}






static void releaseAllSavepoints(Pager *pPager){
  int ii;
  for(ii=0; ii<pPager->nSavepoint; ii++){
    sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);
  }
  if( !pPager->exclusiveMode || sqlite3IsMemJournal(pPager->sjfd) ){
    sqlite3OsClose(pPager->sjfd);
  }
  sqlite3_free(pPager->aSavepoint);
  pPager->aSavepoint = 0;
  pPager->nSavepoint = 0;
  pPager->nSubRec = 0;
}






static int addToSavepointBitvecs(Pager *pPager, Pgno pgno){
  int ii;
  int rc = 0;

  for(ii=0; ii<pPager->nSavepoint; ii++){
    PagerSavepoint *p = &pPager->aSavepoint[ii];
    if( pgno<=p->nOrig ){
      rc |= sqlite3BitvecSet(p->pInSavepoint, pgno);
                                  ;
      ((void) (0));
    }
  }
  return rc;
}
# 38066 "ext/sqlite3/libsqlite/sqlite3.c"
static void pager_unlock(Pager *pPager){

  ((void) (0));




  sqlite3BitvecDestroy(pPager->pInJournal);
  pPager->pInJournal = 0;
  releaseAllSavepoints(pPager);

  if( pagerUseWal(pPager) ){
    ((void) (0));
    sqlite3WalEndReadTransaction(pPager->pWal);
    pPager->eState = 0;
  }else if( !pPager->exclusiveMode ){
    int rc;
    int iDc = ((pPager->fd)->pMethods)?sqlite3OsDeviceCharacteristics(pPager->fd):0;






    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    if( 0==(iDc & 0x00000800)
     || 1!=(pPager->journalMode & 5)
    ){
      sqlite3OsClose(pPager->jfd);
    }






    rc = pagerUnlockDb(pPager, 0);
    if( rc!=0 && pPager->eState==6 ){
      pPager->eLock = (4 +1);
    }





    ((void) (0));
    pPager->changeCountDone = 0;
    pPager->eState = 0;
  }






  if( pPager->errCode ){
    ((void) (0));
    pager_reset(pPager);
    pPager->changeCountDone = pPager->tempFile;
    pPager->eState = 0;
    pPager->errCode = 0;
  }

  pPager->journalOff = 0;
  pPager->journalHdr = 0;
  pPager->setMaster = 0;
}
# 38158 "ext/sqlite3/libsqlite/sqlite3.c"
static int pager_error(Pager *pPager, int rc){
  int rc2 = rc & 0xff;
  ((void) (0));
  ((void) (0));




  if( rc2==13 || rc2==10 ){
    pPager->errCode = rc;
    pPager->eState = 6;
  }
  return rc;
}
# 38226 "ext/sqlite3/libsqlite/sqlite3.c"
static int pager_end_transaction(Pager *pPager, int hasMaster){
  int rc = 0;
  int rc2 = 0;
# 38243 "ext/sqlite3/libsqlite/sqlite3.c"
  ((void) (0));
  ((void) (0));
  if( pPager->eState<2 && pPager->eLock<2 ){
    return 0;
  }

  releaseAllSavepoints(pPager);
  ((void) (0));
  if( ((pPager->jfd)->pMethods) ){
    ((void) (0));


    if( sqlite3IsMemJournal(pPager->jfd) ){
      ((void) (0));
      sqlite3OsClose(pPager->jfd);
    }else if( pPager->journalMode==3 ){
      if( pPager->journalOff==0 ){
        rc = 0;
      }else{
        rc = sqlite3OsTruncate(pPager->jfd, 0);
      }
      pPager->journalOff = 0;
    }else if( pPager->journalMode==1
      || (pPager->exclusiveMode && pPager->journalMode!=5)
    ){
      rc = zeroJournalHdr(pPager, hasMaster);
      pPager->journalOff = 0;
    }else{





      ((void) (0));



      sqlite3OsClose(pPager->jfd);
      if( !pPager->tempFile ){
        rc = sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);
      }
    }
  }
# 38298 "ext/sqlite3/libsqlite/sqlite3.c"
  sqlite3BitvecDestroy(pPager->pInJournal);
  pPager->pInJournal = 0;
  pPager->nRec = 0;
  sqlite3PcacheCleanAll(pPager->pPCache);
  sqlite3PcacheTruncate(pPager->pPCache, pPager->dbSize);

  if( pagerUseWal(pPager) ){




    rc2 = sqlite3WalEndWriteTransaction(pPager->pWal);
    ((void) (0));
  }
  if( !pPager->exclusiveMode
   && (!pagerUseWal(pPager) || sqlite3WalExclusiveMode(pPager->pWal, 0))
  ){
    rc2 = pagerUnlockDb(pPager, 1);
    pPager->changeCountDone = 0;
  }
  pPager->eState = 1;
  pPager->setMaster = 0;

  return (rc==0?rc2:rc);
}
# 38341 "ext/sqlite3/libsqlite/sqlite3.c"
static void pagerUnlockAndRollback(Pager *pPager){
  if( pPager->eState!=6 && pPager->eState!=0 ){
    ((void) (0));
    if( pPager->eState>=2 ){
      sqlite3BeginBenignMalloc();
      sqlite3PagerRollback(pPager);
      sqlite3EndBenignMalloc();
    }else if( !pPager->exclusiveMode ){
      ((void) (0));
      pager_end_transaction(pPager, 0);
    }
  }
  pager_unlock(pPager);
}
# 38375 "ext/sqlite3/libsqlite/sqlite3.c"
static u32 pager_cksum(Pager *pPager, const u8 *aData){
  u32 cksum = pPager->cksumInit;
  int i = pPager->pageSize-200;
  while( i>0 ){
    cksum += aData[i];
    i -= 200;
  }
  return cksum;
}
# 38437 "ext/sqlite3/libsqlite/sqlite3.c"
static int pager_playback_one_page(
  Pager *pPager,
  i64 *pOffset,
  Bitvec *pDone,
  int isMainJrnl,
  int isSavepnt
){
  int rc;
  PgHdr *pPg;
  Pgno pgno;
  u32 cksum;
  char *aData;
  sqlite3_file *jfd;
  int isSynced;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  aData = pPager->pTmpSpace;
  ((void) (0));
  ((void) (0));







  ((void) (0));


  ((void) (0));




  jfd = isMainJrnl ? pPager->jfd : pPager->sjfd;
  rc = read32bits(jfd, *pOffset, &pgno);
  if( rc!=0 ) return rc;
  rc = sqlite3OsRead(jfd, (u8*)aData, pPager->pageSize, (*pOffset)+4);
  if( rc!=0 ) return rc;
  *pOffset += pPager->pageSize + 4 + isMainJrnl*4;






  if( pgno==0 || pgno==((Pgno)((sqlite3PendingByte/((pPager)->pageSize))+1)) ){
    ((void) (0));
    return 101;
  }
  if( pgno>(Pgno)pPager->dbSize || sqlite3BitvecTest(pDone, pgno) ){
    return 0;
  }
  if( isMainJrnl ){
    rc = read32bits(jfd, (*pOffset)-4, &cksum);
    if( rc ) return rc;
    if( !isSavepnt && pager_cksum(pPager, (u8*)aData)!=cksum ){
      return 101;
    }
  }




  if( pDone && (rc = sqlite3BitvecSet(pDone, pgno))!=0 ){
    return rc;
  }



  if( pgno==1 && pPager->nReserve!=((u8*)aData)[20] ){
    pPager->nReserve = ((u8*)aData)[20];
                           ;
  }
# 38551 "ext/sqlite3/libsqlite/sqlite3.c"
  if( pagerUseWal(pPager) ){
    pPg = 0;
  }else{
    pPg = pager_lookup(pPager, pgno);
  }
  ((void) (0));
  ((void) (0));



    ;
  if( isMainJrnl ){
    isSynced = pPager->noSync || (*pOffset <= pPager->journalHdr);
  }else{
    isSynced = (pPg==0 || 0==(pPg->flags & 0x004));
  }
  if( ((pPager->fd)->pMethods)
   && (pPager->eState>=4 || pPager->eState==0)
   && isSynced
  ){
    i64 ofst = (pgno-1)*(i64)pPager->pageSize;
                                                                       ;
    ((void) (0));
    rc = sqlite3OsWrite(pPager->fd, (u8*)aData, pPager->pageSize, ofst);
    if( pgno>pPager->dbFileSize ){
      pPager->dbFileSize = pgno;
    }
    if( pPager->pBackup ){
                                                     ;
      sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)aData);
      aData=(char*)aData;
    }
  }else if( !isMainJrnl && pPg==0 ){
# 38600 "ext/sqlite3/libsqlite/sqlite3.c"
    ((void) (0));
    ((void) (0));
    pPager->doNotSpill++;
    rc = sqlite3PagerAcquire(pPager, pgno, &pPg, 1);
    ((void) (0));
    pPager->doNotSpill--;
    if( rc!=0 ) return rc;
    pPg->flags &= ~0x008;
    sqlite3PcacheMakeDirty(pPg);
  }
  if( pPg ){






    void *pData;
    pData = pPg->pData;
    memcpy(pData, (u8*)aData, pPager->pageSize);
    pPager->xReiniter(pPg);
    if( isMainJrnl && (!isSavepnt || *pOffset<=pPager->journalHdr) ){
# 38641 "ext/sqlite3/libsqlite/sqlite3.c"
      ((void) (0));
      sqlite3PcacheMakeClean(pPg);
    }
                           ;



    if( pgno==1 ){
      memcpy(&pPager->dbFileVers, &((u8*)pData)[24],sizeof(pPager->dbFileVers));
    }


                                                        ;
    sqlite3PcacheRelease(pPg);
  }
  return rc;
}
# 38702 "ext/sqlite3/libsqlite/sqlite3.c"
static int pager_delmaster(Pager *pPager, const char *zMaster){
  sqlite3_vfs *pVfs = pPager->pVfs;
  int rc;
  sqlite3_file *pMaster;
  sqlite3_file *pJournal;
  char *zMasterJournal = 0;
  i64 nMasterJournal;
  char *zJournal;
  char *zMasterPtr;
  int nMasterPtr;




  pMaster = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile * 2);
  pJournal = (sqlite3_file *)(((u8 *)pMaster) + pVfs->szOsFile);
  if( !pMaster ){
    rc = 7;
  }else{
    const int flags = (0x00000001|0x00004000);
    rc = sqlite3OsOpen(pVfs, zMaster, pMaster, flags, 0);
  }
  if( rc!=0 ) goto delmaster_out;






  rc = sqlite3OsFileSize(pMaster, &nMasterJournal);
  if( rc!=0 ) goto delmaster_out;
  nMasterPtr = pVfs->mxPathname+1;
  zMasterJournal = sqlite3Malloc((int)nMasterJournal + nMasterPtr + 1);
  if( !zMasterJournal ){
    rc = 7;
    goto delmaster_out;
  }
  zMasterPtr = &zMasterJournal[nMasterJournal+1];
  rc = sqlite3OsRead(pMaster, zMasterJournal, (int)nMasterJournal, 0);
  if( rc!=0 ) goto delmaster_out;
  zMasterJournal[nMasterJournal] = 0;

  zJournal = zMasterJournal;
  while( (zJournal-zMasterJournal)<nMasterJournal ){
    int exists;
    rc = sqlite3OsAccess(pVfs, zJournal, 0, &exists);
    if( rc!=0 ){
      goto delmaster_out;
    }
    if( exists ){




      int c;
      int flags = (0x00000001|0x00000800);
      rc = sqlite3OsOpen(pVfs, zJournal, pJournal, flags, 0);
      if( rc!=0 ){
        goto delmaster_out;
      }

      rc = readMasterJournal(pJournal, zMasterPtr, nMasterPtr);
      sqlite3OsClose(pJournal);
      if( rc!=0 ){
        goto delmaster_out;
      }

      c = zMasterPtr[0]!=0 && __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (zMasterPtr) && __builtin_constant_p (zMaster) && (__s1_len = __builtin_strlen (zMasterPtr), __s2_len = __builtin_strlen (zMaster), (!((size_t)(const void *)((zMasterPtr) + 1) - (size_t)(const void *)(zMasterPtr) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((zMaster) + 1) - (size_t)(const void *)(zMaster) == 1) || __s2_len >= 4)) ? __builtin_strcmp (zMasterPtr, zMaster) : (__builtin_constant_p (zMasterPtr) && ((size_t)(const void *)((zMasterPtr) + 1) - (size_t)(const void *)(zMasterPtr) == 1) && (__s1_len = __builtin_strlen (zMasterPtr), __s1_len < 4) ? (__builtin_constant_p (zMaster) && ((size_t)(const void *)((zMaster) + 1) - (size_t)(const void *)(zMaster) == 1) ? __builtin_strcmp (zMasterPtr, zMaster) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (zMaster); int __result = (((const unsigned char *) (const char *) (zMasterPtr))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (zMasterPtr))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (zMasterPtr))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (zMasterPtr))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (zMaster) && ((size_t)(const void *)((zMaster) + 1) - (size_t)(const void *)(zMaster) == 1) && (__s2_len = __builtin_strlen (zMaster), __s2_len < 4) ? (__builtin_constant_p (zMasterPtr) && ((size_t)(const void *)((zMasterPtr) + 1) - (size_t)(const void *)(zMasterPtr) == 1) ? __builtin_strcmp (zMasterPtr, zMaster) : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (zMasterPtr); int __result = (((const unsigned char *) (const char *) (zMaster))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (zMaster))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (zMaster))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (zMaster))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (zMasterPtr, zMaster)))); })==0;
      if( c ){

        goto delmaster_out;
      }
    }
    zJournal += (sqlite3Strlen30(zJournal)+1);
  }

  sqlite3OsClose(pMaster);
  rc = sqlite3OsDelete(pVfs, zMaster, 0);

delmaster_out:
  sqlite3_free(zMasterJournal);
  if( pMaster ){
    sqlite3OsClose(pMaster);
    ((void) (0));
    sqlite3_free(pMaster);
  }
  return rc;
}
# 38812 "ext/sqlite3/libsqlite/sqlite3.c"
static int pager_truncate(Pager *pPager, Pgno nPage){
  int rc = 0;
  ((void) (0));
  ((void) (0));

  if( ((pPager->fd)->pMethods)
   && (pPager->eState>=4 || pPager->eState==0)
  ){
    i64 currentSize, newSize;
    int szPage = pPager->pageSize;
    ((void) (0));

    rc = sqlite3OsFileSize(pPager->fd, &currentSize);
    newSize = szPage*(i64)nPage;
    if( rc==0 && currentSize!=newSize ){
      if( currentSize>newSize ){
        rc = sqlite3OsTruncate(pPager->fd, newSize);
      }else{
        char *pTmp = pPager->pTmpSpace;
        memset(pTmp, 0, szPage);
                                                   ;
                                                   ;
                                                   ;
        rc = sqlite3OsWrite(pPager->fd, pTmp, szPage, newSize-szPage);
      }
      if( rc==0 ){
        pPager->dbFileSize = nPage;
      }
    }
  }
  return rc;
}
# 38859 "ext/sqlite3/libsqlite/sqlite3.c"
static void setSectorSize(Pager *pPager){
  ((void) (0));

  if( !pPager->tempFile ){




    pPager->sectorSize = sqlite3OsSectorSize(pPager->fd);
  }
  if( pPager->sectorSize<32 ){
    pPager->sectorSize = 512;
  }
  if( pPager->sectorSize>0x10000 ){
    ((void) (0));
    pPager->sectorSize = 0x10000;
  }
}
# 38935 "ext/sqlite3/libsqlite/sqlite3.c"
static int pager_playback(Pager *pPager, int isHot){
  sqlite3_vfs *pVfs = pPager->pVfs;
  i64 szJ;
  u32 nRec;
  u32 u;
  Pgno mxPg = 0;
  int rc;
  int res = 1;
  char *zMaster = 0;
  int needPagerReset;




  ((void) (0));
  rc = sqlite3OsFileSize(pPager->jfd, &szJ);
  if( rc!=0 ){
    goto end_playback;
  }
# 38966 "ext/sqlite3/libsqlite/sqlite3.c"
  zMaster = pPager->pTmpSpace;
  rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname+1);
  if( rc==0 && zMaster[0] ){
    rc = sqlite3OsAccess(pVfs, zMaster, 0, &res);
  }
  zMaster = 0;
  if( rc!=0 || !res ){
    goto end_playback;
  }
  pPager->journalOff = 0;
  needPagerReset = isHot;





  while( 1 ){





    rc = readJournalHdr(pPager, isHot, szJ, &nRec, &mxPg);
    if( rc!=0 ){
      if( rc==101 ){
        rc = 0;
      }
      goto end_playback;
    }






    if( nRec==0xffffffff ){
      ((void) (0));
      nRec = (int)((szJ - (pPager->sectorSize))/((pPager->pageSize) + 8));
    }
# 39020 "ext/sqlite3/libsqlite/sqlite3.c"
    if( nRec==0 && !isHot &&
        pPager->journalHdr+(pPager->sectorSize)==pPager->journalOff ){
      nRec = (int)((szJ - pPager->journalOff) / ((pPager->pageSize) + 8));
    }




    if( pPager->journalOff==(pPager->sectorSize) ){
      rc = pager_truncate(pPager, mxPg);
      if( rc!=0 ){
        goto end_playback;
      }
      pPager->dbSize = mxPg;
    }




    for(u=0; u<nRec; u++){
      if( needPagerReset ){
        pager_reset(pPager);
        needPagerReset = 0;
      }
      rc = pager_playback_one_page(pPager,&pPager->journalOff,0,1,0);
      if( rc!=0 ){
        if( rc==101 ){
          rc = 0;
          pPager->journalOff = szJ;
          break;
        }else if( rc==(10 | (2<<8)) ){





          rc = 0;
          goto end_playback;
        }else{





          goto end_playback;
        }
      }
    }
  }

  ((void) (0));

end_playback:





  ((void) (0));
# 39092 "ext/sqlite3/libsqlite/sqlite3.c"
  pPager->changeCountDone = pPager->tempFile;

  if( rc==0 ){
    zMaster = pPager->pTmpSpace;
    rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname+1);
                             ;
  }
  if( rc==0
   && (pPager->eState>=4 || pPager->eState==0)
  ){
    rc = sqlite3PagerSync(pPager);
  }
  if( rc==0 ){
    rc = pager_end_transaction(pPager, zMaster[0]!='\0');
                             ;
  }
  if( rc==0 && zMaster[0] && res ){



    rc = pager_delmaster(pPager, zMaster);
                             ;
  }





  setSectorSize(pPager);
  return rc;
}
# 39136 "ext/sqlite3/libsqlite/sqlite3.c"
static int readDbPage(PgHdr *pPg){
  Pager *pPager = pPg->pPager;
  Pgno pgno = pPg->pgno;
  int rc = 0;
  int isInWal = 0;
  int pgsz = pPager->pageSize;

  ((void) (0));
  ((void) (0));

  if( (!((pPager->fd)->pMethods)) ){
    ((void) (0));
    memset(pPg->pData, 0, pPager->pageSize);
    return 0;
  }

  if( pagerUseWal(pPager) ){

    rc = sqlite3WalRead(pPager->pWal, pgno, &isInWal, pgsz, pPg->pData);
  }
  if( rc==0 && !isInWal ){
    i64 iOffset = (pgno-1)*(i64)pPager->pageSize;
    rc = sqlite3OsRead(pPager->fd, pPg->pData, pgsz, iOffset);
    if( rc==(10 | (2<<8)) ){
      rc = 0;
    }
  }

  if( pgno==1 ){
    if( rc ){
# 39178 "ext/sqlite3/libsqlite/sqlite3.c"
      memset(pPager->dbFileVers, 0xff, sizeof(pPager->dbFileVers));
    }else{
      u8 *dbFileVers = &((u8*)pPg->pData)[24];
      memcpy(&pPager->dbFileVers, dbFileVers, sizeof(pPager->dbFileVers));
    }
  }
                                                        ;

                                        ;
                           ;
                                         ;

                                                           ;

  return rc;
}
# 39203 "ext/sqlite3/libsqlite/sqlite3.c"
static void pager_write_changecounter(PgHdr *pPg){
  u32 change_counter;


  change_counter = sqlite3Get4byte((u8*)pPg->pPager->dbFileVers)+1;
  sqlite3Put4byte((u8*)((char*)pPg->pData)+24,change_counter);




  sqlite3Put4byte((u8*)((char*)pPg->pData)+92,change_counter);
  sqlite3Put4byte((u8*)((char*)pPg->pData)+96,3007006);
}
# 39230 "ext/sqlite3/libsqlite/sqlite3.c"
static int pagerUndoCallback(void *pCtx, Pgno iPg){
  int rc = 0;
  Pager *pPager = (Pager *)pCtx;
  PgHdr *pPg;

  pPg = sqlite3PagerLookup(pPager, iPg);
  if( pPg ){
    if( sqlite3PcachePageRefcount(pPg)==1 ){
      sqlite3PcacheDrop(pPg);
    }else{
      rc = readDbPage(pPg);
      if( rc==0 ){
        pPager->xReiniter(pPg);
      }
      sqlite3PagerUnref(pPg);
    }
  }
# 39256 "ext/sqlite3/libsqlite/sqlite3.c"
  sqlite3BackupRestart(pPager->pBackup);

  return rc;
}




static int pagerRollbackWal(Pager *pPager){
  int rc;
  PgHdr *pList;
# 39275 "ext/sqlite3/libsqlite/sqlite3.c"
  pPager->dbSize = pPager->dbOrigSize;
  rc = sqlite3WalUndo(pPager->pWal, pagerUndoCallback, (void *)pPager);
  pList = sqlite3PcacheDirtyList(pPager->pPCache);
  while( pList && rc==0 ){
    PgHdr *pNext = pList->pDirty;
    rc = pagerUndoCallback((void *)pPager, pList->pgno);
    pList = pNext;
  }

  return rc;
}
# 39296 "ext/sqlite3/libsqlite/sqlite3.c"
static int pagerWalFrames(
  Pager *pPager,
  PgHdr *pList,
  Pgno nTruncate,
  int isCommit,
  int syncFlags
){
  int rc;




  ((void) (0));







  if( isCommit ){




    PgHdr *p;
    PgHdr **ppNext = &pList;
    for(p=pList; (*ppNext = p); p=p->pDirty){
      if( p->pgno<=nTruncate ) ppNext = &p->pDirty;
    }
    ((void) (0));
  }

  if( pList->pgno==1 ) pager_write_changecounter(pList);
  rc = sqlite3WalFrames(pPager->pWal,
      pPager->pageSize, pList, nTruncate, isCommit, syncFlags
  );
  if( rc==0 && pPager->pBackup ){
    PgHdr *p;
    for(p=pList; p; p=p->pDirty){
      sqlite3BackupUpdate(pPager->pBackup, p->pgno, (u8 *)p->pData);
    }
  }
# 39347 "ext/sqlite3/libsqlite/sqlite3.c"
  return rc;
}
# 39358 "ext/sqlite3/libsqlite/sqlite3.c"
static int pagerBeginReadTransaction(Pager *pPager){
  int rc;
  int changed = 0;

  ((void) (0));
  ((void) (0));






  sqlite3WalEndReadTransaction(pPager->pWal);

  rc = sqlite3WalBeginReadTransaction(pPager->pWal, &changed);
  if( rc!=0 || changed ){
    pager_reset(pPager);
  }

  return rc;
}
# 39390 "ext/sqlite3/libsqlite/sqlite3.c"
static int pagerPagecount(Pager *pPager, Pgno *pnPage){
  Pgno nPage;







  ((void) (0));
  ((void) (0));
  nPage = sqlite3WalDbsize(pPager->pWal);







  if( nPage==0 ){
    i64 n = 0;
    ((void) (0));
    if( ((pPager->fd)->pMethods) ){
      int rc = sqlite3OsFileSize(pPager->fd, &n);
      if( rc!=0 ){
        return rc;
      }
    }
    nPage = (Pgno)(n / pPager->pageSize);
    if( nPage==0 && n>0 ){
      nPage = 1;
    }
  }





  if( nPage>pPager->mxPgno ){
    pPager->mxPgno = (Pgno)nPage;
  }

  *pnPage = nPage;
  return 0;
}
# 39455 "ext/sqlite3/libsqlite/sqlite3.c"
static int pagerOpenWalIfPresent(Pager *pPager){
  int rc = 0;
  ((void) (0));
  ((void) (0));

  if( !pPager->tempFile ){
    int isWal;
    Pgno nPage;

    rc = pagerPagecount(pPager, &nPage);
    if( rc ) return rc;
    if( nPage==0 ){
      rc = sqlite3OsDelete(pPager->pVfs, pPager->zWal, 0);
      isWal = 0;
    }else{
      rc = sqlite3OsAccess(
          pPager->pVfs, pPager->zWal, 0, &isWal
      );
    }
    if( rc==0 ){
      if( isWal ){
                                                              ;
        rc = sqlite3PagerOpenWal(pPager, 0);
      }else if( pPager->journalMode==5 ){
        pPager->journalMode = 0;
      }
    }
  }
  return rc;
}
# 39523 "ext/sqlite3/libsqlite/sqlite3.c"
static int pagerPlaybackSavepoint(Pager *pPager, PagerSavepoint *pSavepoint){
  i64 szJ;
  i64 iHdrOff;
  int rc = 0;
  Bitvec *pDone = 0;

  ((void) (0));
  ((void) (0));


  if( pSavepoint ){
    pDone = sqlite3BitvecCreate(pSavepoint->nOrig);
    if( !pDone ){
      return 7;
    }
  }




  pPager->dbSize = pSavepoint ? pSavepoint->nOrig : pPager->dbOrigSize;
  pPager->changeCountDone = pPager->tempFile;

  if( !pSavepoint && pagerUseWal(pPager) ){
    return pagerRollbackWal(pPager);
  }






  szJ = pPager->journalOff;
  ((void) (0));
# 39565 "ext/sqlite3/libsqlite/sqlite3.c"
  if( pSavepoint && !pagerUseWal(pPager) ){
    iHdrOff = pSavepoint->iHdrOffset ? pSavepoint->iHdrOffset : szJ;
    pPager->journalOff = pSavepoint->iOffset;
    while( rc==0 && pPager->journalOff<iHdrOff ){
      rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);
    }
    ((void) (0));
  }else{
    pPager->journalOff = 0;
  }






  while( rc==0 && pPager->journalOff<szJ ){
    u32 ii;
    u32 nJRec = 0;
    u32 dummy;
    rc = readJournalHdr(pPager, 0, szJ, &nJRec, &dummy);
    ((void) (0));






    if( nJRec==0
     && pPager->journalHdr+(pPager->sectorSize)==pPager->journalOff
    ){
      nJRec = (u32)((szJ - pPager->journalOff)/((pPager->pageSize) + 8));
    }
    for(ii=0; rc==0 && ii<nJRec && pPager->journalOff<szJ; ii++){
      rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);
    }
    ((void) (0));
  }
  ((void) (0));





  if( pSavepoint ){
    u32 ii;
    i64 offset = pSavepoint->iSubRec*(4+pPager->pageSize);

    if( pagerUseWal(pPager) ){
      rc = sqlite3WalSavepointUndo(pPager->pWal, pSavepoint->aWalData);
    }
    for(ii=pSavepoint->iSubRec; rc==0 && ii<pPager->nSubRec; ii++){
      ((void) (0));
      rc = pager_playback_one_page(pPager, &offset, pDone, 0, 1);
    }
    ((void) (0));
  }

  sqlite3BitvecDestroy(pDone);
  if( rc==0 ){
    pPager->journalOff = szJ;
  }

  return rc;
}




static void sqlite3PagerSetCachesize(Pager *pPager, int mxPage){
  sqlite3PcacheSetCachesize(pPager->pPCache, mxPage);
}
# 39682 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3PagerSetSafetyLevel(
  Pager *pPager,
  int level,
  int bFullFsync,
  int bCkptFullFsync
){
  ((void) (0));
  pPager->noSync = (level==1 || pPager->tempFile) ?1:0;
  pPager->fullSync = (level==3 && !pPager->tempFile) ?1:0;
  if( pPager->noSync ){
    pPager->syncFlags = 0;
    pPager->ckptSyncFlags = 0;
  }else if( bFullFsync ){
    pPager->syncFlags = 0x00003;
    pPager->ckptSyncFlags = 0x00003;
  }else if( bCkptFullFsync ){
    pPager->syncFlags = 0x00002;
    pPager->ckptSyncFlags = 0x00003;
  }else{
    pPager->syncFlags = 0x00002;
    pPager->ckptSyncFlags = 0x00002;
  }
}
# 39731 "ext/sqlite3/libsqlite/sqlite3.c"
static int pagerOpentemp(
  Pager *pPager,
  sqlite3_file *pFile,
  int vfsFlags
){
  int rc;





  vfsFlags |= 0x00000002 | 0x00000004 |
            0x00000010 | 0x00000008;
  rc = sqlite3OsOpen(pPager->pVfs, 0, pFile, vfsFlags, 0);
  ((void) (0));
  return rc;
}
# 39770 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3PagerSetBusyhandler(
  Pager *pPager,
  int (*xBusyHandler)(void *),
  void *pBusyHandlerArg
){
  pPager->xBusyHandler = xBusyHandler;
  pPager->pBusyHandlerArg = pBusyHandlerArg;
}
# 39809 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerSetPagesize(Pager *pPager, u32 *pPageSize, int nReserve){
  int rc = 0;
# 39822 "ext/sqlite3/libsqlite/sqlite3.c"
  u32 pageSize = *pPageSize;
  ((void) (0));
  if( (pPager->memDb==0 || pPager->dbSize==0)
   && sqlite3PcacheRefCount(pPager->pPCache)==0
   && pageSize && pageSize!=(u32)pPager->pageSize
  ){
    char *pNew = ((void*)0);
    i64 nByte = 0;

    if( pPager->eState>0 && ((pPager->fd)->pMethods) ){
      rc = sqlite3OsFileSize(pPager->fd, &nByte);
    }
    if( rc==0 ){
      pNew = (char *)sqlite3PageMalloc(pageSize);
      if( !pNew ) rc = 7;
    }

    if( rc==0 ){
      pager_reset(pPager);
      pPager->dbSize = (Pgno)(nByte/pageSize);
      pPager->pageSize = pageSize;
      sqlite3PageFree(pPager->pTmpSpace);
      pPager->pTmpSpace = pNew;
      sqlite3PcacheSetPageSize(pPager->pPCache, pageSize);
    }
  }

  *pPageSize = pPager->pageSize;
  if( rc==0 ){
    if( nReserve<0 ) nReserve = pPager->nReserve;
    ((void) (0));
    pPager->nReserve = (i16)nReserve;
                           ;
  }
  return rc;
}
# 39867 "ext/sqlite3/libsqlite/sqlite3.c"
static void *sqlite3PagerTempSpace(Pager *pPager){
  return pPager->pTmpSpace;
}
# 39878 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerMaxPageCount(Pager *pPager, int mxPage){
  if( mxPage>0 ){
    pPager->mxPgno = mxPage;
  }
  ((void) (0));
  ((void) (0));
  return pPager->mxPgno;
}
# 39925 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerReadFileheader(Pager *pPager, int N, unsigned char *pDest){
  int rc = 0;
  memset(pDest, 0, N);
  ((void) (0));





  ((void) (0));

  if( ((pPager->fd)->pMethods) ){

    rc = sqlite3OsRead(pPager->fd, pDest, N, 0);
    if( rc==(10 | (2<<8)) ){
      rc = 0;
    }
  }
  return rc;
}
# 39953 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3PagerPagecount(Pager *pPager, int *pnPage){
  ((void) (0));
  ((void) (0));
  *pnPage = (int)pPager->dbSize;
}
# 39974 "ext/sqlite3/libsqlite/sqlite3.c"
static int pager_wait_on_lock(Pager *pPager, int locktype){
  int rc;






  ((void) (0));




  do {
    rc = pagerLockDb(pPager, locktype);
  }while( rc==5 && pPager->xBusyHandler(pPager->pBusyHandlerArg) );
  return rc;
}
# 40033 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3PagerTruncateImage(Pager *pPager, Pgno nPage){
  ((void) (0));
  ((void) (0));
  pPager->dbSize = nPage;
                                  ;
}
# 40055 "ext/sqlite3/libsqlite/sqlite3.c"
static int pagerSyncHotJournal(Pager *pPager){
  int rc = 0;
  if( !pPager->noSync ){
    rc = sqlite3OsSync(pPager->jfd, 0x00002);
  }
  if( rc==0 ){
    rc = sqlite3OsFileSize(pPager->jfd, &pPager->journalHdr);
  }
  return rc;
}
# 40080 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerClose(Pager *pPager){
  u8 *pTmp = (u8 *)pPager->pTmpSpace;

                               ;
  sqlite3BeginBenignMalloc();

  pPager->exclusiveMode = 0;

  sqlite3WalClose(pPager->pWal, pPager->ckptSyncFlags, pPager->pageSize, pTmp);
  pPager->pWal = 0;

  pager_reset(pPager);
  if( pPager->memDb ){
    pager_unlock(pPager);
  }else{
# 40106 "ext/sqlite3/libsqlite/sqlite3.c"
    if( ((pPager->jfd)->pMethods) ){
      pager_error(pPager, pagerSyncHotJournal(pPager));
    }
    pagerUnlockAndRollback(pPager);
  }
  sqlite3EndBenignMalloc();
                              ;
                                             ;

  sqlite3OsClose(pPager->jfd);
  sqlite3OsClose(pPager->fd);
  sqlite3PageFree(pTmp);
  sqlite3PcacheClose(pPager->pPCache);





  ((void) (0));
  ((void) (0));

  sqlite3_free(pPager);
  return 0;
}
# 40143 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3PagerRef(DbPage *pPg){
  sqlite3PcacheRef(pPg);
}
# 40182 "ext/sqlite3/libsqlite/sqlite3.c"
static int syncJournal(Pager *pPager, int newHdr){
  int rc;

  ((void) (0));


  ((void) (0));
  ((void) (0));

  rc = sqlite3PagerExclusiveLock(pPager);
  if( rc!=0 ) return rc;

  if( !pPager->noSync ){
    ((void) (0));
    if( ((pPager->jfd)->pMethods) && pPager->journalMode!=4 ){
      const int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);
      ((void) (0));

      if( 0==(iDc&0x00000200) ){
# 40223 "ext/sqlite3/libsqlite/sqlite3.c"
        i64 iNextHdrOffset;
        u8 aMagic[8];
        u8 zHeader[sizeof(aJournalMagic)+4];

        memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
        sqlite3Put4byte((u8*)&zHeader[sizeof(aJournalMagic)],pPager->nRec);

        iNextHdrOffset = journalHdrOffset(pPager);
        rc = sqlite3OsRead(pPager->jfd, aMagic, 8, iNextHdrOffset);
        if( rc==0 && 0==memcmp(aMagic, aJournalMagic, 8) ){
          static const u8 zerobyte = 0;
          rc = sqlite3OsWrite(pPager->jfd, &zerobyte, 1, iNextHdrOffset);
        }
        if( rc!=0 && rc!=(10 | (2<<8)) ){
          return rc;
        }
# 40251 "ext/sqlite3/libsqlite/sqlite3.c"
        if( pPager->fullSync && 0==(iDc&0x00000400) ){
                                                               ;

          rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);
          if( rc!=0 ) return rc;
        }
                                                               ;
        rc = sqlite3OsWrite(
            pPager->jfd, zHeader, sizeof(zHeader), pPager->journalHdr
        );
        if( rc!=0 ) return rc;
      }
      if( 0==(iDc&0x00000400) ){
                                                             ;

        rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags|
          (pPager->syncFlags==0x00003?0x00010:0)
        );
        if( rc!=0 ) return rc;
      }

      pPager->journalHdr = pPager->journalOff;
      if( newHdr && 0==(iDc&0x00000200) ){
        pPager->nRec = 0;
        rc = writeJournalHdr(pPager);
        if( rc!=0 ) return rc;
      }
    }else{
      pPager->journalHdr = pPager->journalOff;
    }
  }





  sqlite3PcacheClearSyncFlags(pPager->pPCache);
  pPager->eState = 4;
  ((void) (0));
  return 0;
}
# 40325 "ext/sqlite3/libsqlite/sqlite3.c"
static int pager_write_pagelist(Pager *pPager, PgHdr *pList){
  int rc = 0;


  ((void) (0));
  ((void) (0));
  ((void) (0));





  if( !((pPager->fd)->pMethods) ){
    ((void) (0));
    rc = pagerOpentemp(pPager, pPager->fd, pPager->vfsFlags);
  }




  ((void) (0));
  if( rc==0 && pPager->dbSize>pPager->dbHintSize ){
    sqlite3_int64 szFile = pPager->pageSize * (sqlite3_int64)pPager->dbSize;
    sqlite3OsFileControl(pPager->fd, 5, &szFile);
    pPager->dbHintSize = pPager->dbSize;
  }

  while( rc==0 && pList ){
    Pgno pgno = pList->pgno;
# 40363 "ext/sqlite3/libsqlite/sqlite3.c"
    if( pgno<=pPager->dbSize && 0==(pList->flags&0x020) ){
      i64 offset = (pgno-1)*(i64)pPager->pageSize;
      char *pData;

      ((void) (0));
      if( pList->pgno==1 ) pager_write_changecounter(pList);


      pData=(char*)pList->pData;


      rc = sqlite3OsWrite(pPager->fd, pData, pPager->pageSize, offset);





      if( pgno==1 ){
        memcpy(&pPager->dbFileVers, &pData[24], sizeof(pPager->dbFileVers));
      }
      if( pgno>pPager->dbFileSize ){
        pPager->dbFileSize = pgno;
      }


      sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)pList->pData);


                                                                 ;
                                              ;
                                             ;
                                ;
    }else{
                                                                 ;
    }
                             ;
    pList = pList->pDirty;
  }

  return rc;
}
# 40413 "ext/sqlite3/libsqlite/sqlite3.c"
static int openSubJournal(Pager *pPager){
  int rc = 0;
  if( !((pPager->sjfd)->pMethods) ){
    if( pPager->journalMode==4 || pPager->subjInMemory ){
      sqlite3MemJournalOpen(pPager->sjfd);
    }else{
      rc = pagerOpentemp(pPager, pPager->sjfd, 0x00002000);
    }
  }
  return rc;
}
# 40438 "ext/sqlite3/libsqlite/sqlite3.c"
static int subjournalPage(PgHdr *pPg){
  int rc = 0;
  Pager *pPager = pPg->pPager;
  if( pPager->journalMode!=2 ){


    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));



    rc = openSubJournal(pPager);



    if( rc==0 ){
      void *pData = pPg->pData;
      i64 offset = pPager->nSubRec*(4+pPager->pageSize);
      char *pData2;

      pData2=(char*)pData;
                                                                           ;
      rc = write32bits(pPager->sjfd, offset, pPg->pgno);
      if( rc==0 ){
        rc = sqlite3OsWrite(pPager->sjfd, pData2, pPager->pageSize, offset+4);
      }
    }
  }
  if( rc==0 ){
    pPager->nSubRec++;
    ((void) (0));
    rc = addToSavepointBitvecs(pPager, pPg->pgno);
  }
  return rc;
}
# 40495 "ext/sqlite3/libsqlite/sqlite3.c"
static int pagerStress(void *p, PgHdr *pPg){
  Pager *pPager = (Pager *)p;
  int rc = 0;

  ((void) (0));
  ((void) (0));
# 40517 "ext/sqlite3/libsqlite/sqlite3.c"
  if( (pPager->errCode) ) return 0;
  if( pPager->doNotSpill ) return 0;
  if( pPager->doNotSyncSpill && (pPg->flags & 0x004)!=0 ){
    return 0;
  }

  pPg->pDirty = 0;
  if( pagerUseWal(pPager) ){

    if( subjRequiresPage(pPg) ){
      rc = subjournalPage(pPg);
    }
    if( rc==0 ){
      rc = pagerWalFrames(pPager, pPg, 0, 0, 0);
    }
  }else{


    if( pPg->flags&0x004
     || pPager->eState==3
    ){
      rc = syncJournal(pPager, 1);
    }
# 40568 "ext/sqlite3/libsqlite/sqlite3.c"
    if( (rc==0 && pPg->pgno>pPager->dbSize && subjRequiresPage(pPg)) ){


      rc = subjournalPage(pPg);
    }


    if( rc==0 ){
      ((void) (0));
      rc = pager_write_pagelist(pPager, pPg);
    }
  }


  if( rc==0 ){
                                                                   ;
    sqlite3PcacheMakeClean(pPg);
  }

  return pager_error(pPager, rc);
}
# 40621 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerOpen(
  sqlite3_vfs *pVfs,
  Pager **ppPager,
  const char *zFilename,
  int nExtra,
  int flags,
  int vfsFlags,
  void (*xReinit)(DbPage*)
){
  u8 *pPtr;
  Pager *pPager = 0;
  int rc = 0;
  int tempFile = 0;
  int memDb = 0;
  int readOnly = 0;
  int journalFileSize;
  char *zPathname = 0;
  int nPathname = 0;
  int useJournal = (flags & 0x0001)==0;
  int noReadlock = (flags & 0x0002)!=0;
  int pcacheSize = sqlite3PcacheSize();
  u32 szPageDflt = 1024;
# 40652 "ext/sqlite3/libsqlite/sqlite3.c"
  if( ((pVfs)->szOsFile)>sqlite3MemJournalSize() ){
    journalFileSize = (((((pVfs)->szOsFile))+7)&~7);
  }else{
    journalFileSize = (((sqlite3MemJournalSize())+7)&~7);
  }


  *ppPager = 0;


  if( flags & 0x0004 ){
    memDb = 1;
    zFilename = 0;
  }






  if( zFilename && zFilename[0] ){
    nPathname = pVfs->mxPathname+1;
    zPathname = sqlite3Malloc(nPathname*2);
    if( zPathname==0 ){
      return 7;
    }
    zPathname[0] = 0;
    rc = sqlite3OsFullPathname(pVfs, zFilename, nPathname, zPathname);
    nPathname = sqlite3Strlen30(zPathname);
    if( rc==0 && nPathname+8>pVfs->mxPathname ){






      rc = sqlite3CantopenError(40688);
    }
    if( rc!=0 ){
      sqlite3_free(zPathname);
      return rc;
    }
  }
# 40708 "ext/sqlite3/libsqlite/sqlite3.c"
  pPtr = (u8 *)sqlite3MallocZero(
    (((sizeof(*pPager))+7)&~7) +
    (((pcacheSize)+7)&~7) +
    (((pVfs->szOsFile)+7)&~7) +
    journalFileSize * 2 +
    nPathname + 1 +
    nPathname + 8 + 1

    + nPathname + 4 + 1

  );
  ((void) (0));
  if( !pPtr ){
    sqlite3_free(zPathname);
    return 7;
  }
  pPager = (Pager*)(pPtr);
  pPager->pPCache = (PCache*)(pPtr += (((sizeof(*pPager))+7)&~7));
  pPager->fd = (sqlite3_file*)(pPtr += (((pcacheSize)+7)&~7));
  pPager->sjfd = (sqlite3_file*)(pPtr += (((pVfs->szOsFile)+7)&~7));
  pPager->jfd = (sqlite3_file*)(pPtr += journalFileSize);
  pPager->zFilename = (char*)(pPtr += journalFileSize);
  ((void) (0));


  if( zPathname ){
    ((void) (0));
    pPager->zJournal = (char*)(pPtr += nPathname + 1);
    memcpy(pPager->zFilename, zPathname, nPathname);
    memcpy(pPager->zJournal, zPathname, nPathname);
    memcpy(&pPager->zJournal[nPathname], "-journal", 8);

    pPager->zWal = &pPager->zJournal[nPathname+8+1];
    memcpy(pPager->zWal, zPathname, nPathname);
    memcpy(&pPager->zWal[nPathname], "-wal", 4);

    sqlite3_free(zPathname);
  }
  pPager->pVfs = pVfs;
  pPager->vfsFlags = vfsFlags;



  if( zFilename && zFilename[0] ){
    int fout = 0;
    rc = sqlite3OsOpen(pVfs, pPager->zFilename, pPager->fd, vfsFlags, &fout);
    ((void) (0));
    readOnly = (fout&0x00000001);
# 40765 "ext/sqlite3/libsqlite/sqlite3.c"
    if( rc==0 && !readOnly ){
      setSectorSize(pPager);
      ((void) (0));
      if( szPageDflt<pPager->sectorSize ){
        if( pPager->sectorSize>8192 ){
          szPageDflt = 8192;
        }else{
          szPageDflt = (u32)pPager->sectorSize;
        }
      }
# 40789 "ext/sqlite3/libsqlite/sqlite3.c"
    }
  }else{
# 40799 "ext/sqlite3/libsqlite/sqlite3.c"
    tempFile = 1;
    pPager->eState = 1;
    pPager->eLock = 4;
    readOnly = (vfsFlags&0x00000001);
  }




  if( rc==0 ){
    ((void) (0));
    rc = sqlite3PagerSetPagesize(pPager, &szPageDflt, -1);
                             ;
  }




  if( rc!=0 ){
    ((void) (0));
    sqlite3OsClose(pPager->fd);
    sqlite3_free(pPager);
    return rc;
  }


  ((void) (0));
  nExtra = (((nExtra)+7)&~7);
  sqlite3PcacheOpen(szPageDflt, nExtra, !memDb,
                    !memDb?pagerStress:0, (void *)pPager, pPager->pPCache);

                                                                           ;


  pPager->useJournal = (u8)useJournal;
  pPager->noReadlock = (noReadlock && readOnly) ?1:0;






  pPager->mxPgno = 1073741823;





  pPager->tempFile = (u8)tempFile;
  ((void) (0));

  ((void) (0));
  pPager->exclusiveMode = (u8)tempFile;
  pPager->changeCountDone = pPager->tempFile;
  pPager->memDb = (u8)memDb;
  pPager->readOnly = (u8)readOnly;
  ((void) (0));
  pPager->noSync = pPager->tempFile;
  pPager->fullSync = pPager->noSync ?0:1;
  pPager->syncFlags = pPager->noSync ? 0 : 0x00002;
  pPager->ckptSyncFlags = pPager->syncFlags;



  pPager->nExtra = (u16)nExtra;
  pPager->journalSizeLimit = -1;
  ((void) (0));
  setSectorSize(pPager);
  if( !useJournal ){
    pPager->journalMode = 2;
  }else if( memDb ){
    pPager->journalMode = 4;
  }


  pPager->xReiniter = xReinit;


  *ppPager = pPager;
  return 0;
}
# 40914 "ext/sqlite3/libsqlite/sqlite3.c"
static int hasHotJournal(Pager *pPager, int *pExists){
  sqlite3_vfs * const pVfs = pPager->pVfs;
  int rc = 0;
  int exists = 1;
  int jrnlOpen = !!((pPager->jfd)->pMethods);

  ((void) (0));
  ((void) (0));
  ((void) (0));

  ((void) (0));



  *pExists = 0;
  if( !jrnlOpen ){
    rc = sqlite3OsAccess(pVfs, pPager->zJournal, 0, &exists);
  }
  if( rc==0 && exists ){
    int locked = 0;
# 40943 "ext/sqlite3/libsqlite/sqlite3.c"
    rc = sqlite3OsCheckReservedLock(pPager->fd, &locked);
    if( rc==0 && !locked ){
      Pgno nPage;







      rc = pagerPagecount(pPager, &nPage);
      if( rc==0 ){
        if( nPage==0 ){
          sqlite3BeginBenignMalloc();
          if( pagerLockDb(pPager, 2)==0 ){
            sqlite3OsDelete(pVfs, pPager->zJournal, 0);
            if( !pPager->exclusiveMode ) pagerUnlockDb(pPager, 1);
          }
          sqlite3EndBenignMalloc();
        }else{






          if( !jrnlOpen ){
            int f = 0x00000001|0x00000800;
            rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &f);
          }
          if( rc==0 ){
            u8 first = 0;
            rc = sqlite3OsRead(pPager->jfd, (void *)&first, 1, 0);
            if( rc==(10 | (2<<8)) ){
              rc = 0;
            }
            if( !jrnlOpen ){
              sqlite3OsClose(pPager->jfd);
            }
            *pExists = (first!=0);
          }else if( rc==14 ){
# 40993 "ext/sqlite3/libsqlite/sqlite3.c"
            *pExists = 1;
            rc = 0;
          }
        }
      }
    }
  }

  return rc;
}
# 41031 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerSharedLock(Pager *pPager){
  int rc = 0;






  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( (pPager->memDb && pPager->errCode) ){ return pPager->errCode; }

  if( !pagerUseWal(pPager) && pPager->eState==0 ){
    int bHotJournal = 1;

    ((void) (0));
    ((void) (0));

    if( pPager->noReadlock==0 ){
      rc = pager_wait_on_lock(pPager, 1);
      if( rc!=0 ){
        ((void) (0));
        goto failed;
      }
    }




    if( pPager->eLock<=1 ){
      rc = hasHotJournal(pPager, &bHotJournal);
    }
    if( rc!=0 ){
      goto failed;
    }
    if( bHotJournal ){
# 41083 "ext/sqlite3/libsqlite/sqlite3.c"
      rc = pagerLockDb(pPager, 4);
      if( rc!=0 ){
        goto failed;
      }
# 41101 "ext/sqlite3/libsqlite/sqlite3.c"
      if( !((pPager->jfd)->pMethods) ){
        sqlite3_vfs * const pVfs = pPager->pVfs;
        int bExists;
        rc = sqlite3OsAccess(
            pVfs, pPager->zJournal, 0, &bExists);
        if( rc==0 && bExists ){
          int fout = 0;
          int f = 0x00000002|0x00000800;
          ((void) (0));
          rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &fout);
          ((void) (0));
          if( rc==0 && fout&0x00000001 ){
            rc = sqlite3CantopenError(41113);
            sqlite3OsClose(pPager->jfd);
          }
        }
      }
# 41127 "ext/sqlite3/libsqlite/sqlite3.c"
      if( ((pPager->jfd)->pMethods) ){
        ((void) (0));
        rc = pagerSyncHotJournal(pPager);
        if( rc==0 ){
          rc = pager_playback(pPager, 1);
          pPager->eState = 0;
        }
      }else if( !pPager->exclusiveMode ){
        pagerUnlockDb(pPager, 1);
      }

      if( rc!=0 ){
# 41155 "ext/sqlite3/libsqlite/sqlite3.c"
        pager_error(pPager, rc);
        goto failed;
      }

      ((void) (0));
      ((void) (0));


    }

    if( !pPager->tempFile
     && (pPager->pBackup || sqlite3PcachePagecount(pPager->pPCache)>0)
    ){
# 41184 "ext/sqlite3/libsqlite/sqlite3.c"
      Pgno nPage = 0;
      char dbFileVers[sizeof(pPager->dbFileVers)];

      rc = pagerPagecount(pPager, &nPage);
      if( rc ) goto failed;

      if( nPage>0 ){
                                                               ;
        rc = sqlite3OsRead(pPager->fd, &dbFileVers, sizeof(dbFileVers), 24);
        if( rc!=0 ){
          goto failed;
        }
      }else{
        memset(dbFileVers, 0, sizeof(dbFileVers));
      }

      if( memcmp(pPager->dbFileVers, dbFileVers, sizeof(dbFileVers))!=0 ){
        pager_reset(pPager);
      }
    }




    rc = pagerOpenWalIfPresent(pPager);

    ((void) (0));

  }

  if( pagerUseWal(pPager) ){
    ((void) (0));
    rc = pagerBeginReadTransaction(pPager);
  }

  if( pPager->eState==0 && rc==0 ){
    rc = pagerPagecount(pPager, &pPager->dbSize);
  }

 failed:
  if( rc!=0 ){
    ((void) (0));
    pager_unlock(pPager);
    ((void) (0));
  }else{
    pPager->eState = 1;
  }
  return rc;
}
# 41242 "ext/sqlite3/libsqlite/sqlite3.c"
static void pagerUnlockIfUnused(Pager *pPager){
  if( (sqlite3PcacheRefCount(pPager->pPCache)==0) ){
    pagerUnlockAndRollback(pPager);
  }
}
# 41298 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerAcquire(
  Pager *pPager,
  Pgno pgno,
  DbPage **ppPage,
  int noContent
){
  int rc;
  PgHdr *pPg;

  ((void) (0));
  ((void) (0));

  if( pgno==0 ){
    return sqlite3CorruptError(41311);
  }



  if( pPager->errCode!=0 ){
    rc = pPager->errCode;
  }else{
    rc = sqlite3PcacheFetch(pPager->pPCache, pgno, 1, ppPage);
  }

  if( rc!=0 ){



    pPg = 0;
    goto pager_acquire_err;
  }
  ((void) (0));
  ((void) (0));

  if( (*ppPage)->pPager && !noContent ){


    ((void) (0));
                            ;
    return 0;

  }else{



                             ;
    pPg = *ppPage;
    pPg->pPager = pPager;



    if( pgno>2147483647 || pgno==((Pgno)((sqlite3PendingByte/((pPager)->pageSize))+1)) ){
      rc = sqlite3CorruptError(41350);
      goto pager_acquire_err;
    }

    if( pPager->memDb || pPager->dbSize<pgno || noContent || !((pPager->fd)->pMethods) ){
      if( pgno>pPager->mxPgno ){
        rc = 13;
        goto pager_acquire_err;
      }
      if( noContent ){






        sqlite3BeginBenignMalloc();
        if( pgno<=pPager->dbOrigSize ){
                           sqlite3BitvecSet(pPager->pInJournal, pgno);
                                      ;
        }
                         addToSavepointBitvecs(pPager, pgno);
                                    ;
        sqlite3EndBenignMalloc();
      }
      memset(pPg->pData, 0, pPager->pageSize);
                                             ;
    }else{
      ((void) (0));
      rc = readDbPage(pPg);
      if( rc!=0 ){
        goto pager_acquire_err;
      }
    }
                           ;
  }

  return 0;

pager_acquire_err:
  ((void) (0));
  if( pPg ){
    sqlite3PcacheDrop(pPg);
  }
  pagerUnlockIfUnused(pPager);

  *ppPage = 0;
  return rc;
}
# 41411 "ext/sqlite3/libsqlite/sqlite3.c"
static DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno){
  PgHdr *pPg = 0;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  sqlite3PcacheFetch(pPager->pPCache, pgno, 0, &pPg);
  return pPg;
}
# 41429 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3PagerUnref(DbPage *pPg){
  if( pPg ){
    Pager *pPager = pPg->pPager;
    sqlite3PcacheRelease(pPg);
    pagerUnlockIfUnused(pPager);
  }
}
# 41459 "ext/sqlite3/libsqlite/sqlite3.c"
static int pager_open_journal(Pager *pPager){
  int rc = 0;
  sqlite3_vfs * const pVfs = pPager->pVfs;

  ((void) (0));
  ((void) (0));
  ((void) (0));




  if( (pPager->errCode) ) return pPager->errCode;

  if( !pagerUseWal(pPager) && pPager->journalMode!=2 ){
    pPager->pInJournal = sqlite3BitvecCreate(pPager->dbSize);
    if( pPager->pInJournal==0 ){
      return 7;
    }


    if( !((pPager->jfd)->pMethods) ){
      if( pPager->journalMode==4 ){
        sqlite3MemJournalOpen(pPager->jfd);
      }else{
        const int flags =
          0x00000002|0x00000004|
          (pPager->tempFile ?
            (0x00000008|0x00001000):
            (0x00000800)
          );





        rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, flags, 0);

      }
      ((void) (0));
    }





    if( rc==0 ){

      pPager->nRec = 0;
      pPager->journalOff = 0;
      pPager->setMaster = 0;
      pPager->journalHdr = 0;
      rc = writeJournalHdr(pPager);
    }
  }

  if( rc!=0 ){
    sqlite3BitvecDestroy(pPager->pInJournal);
    pPager->pInJournal = 0;
  }else{
    ((void) (0));
    pPager->eState = 3;
  }

  return rc;
}
# 41542 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerBegin(Pager *pPager, int exFlag, int subjInMemory){
  int rc = 0;

  if( pPager->errCode ) return pPager->errCode;
  ((void) (0));
  pPager->subjInMemory = (u8)subjInMemory;

  if( (pPager->eState==1) ){
    ((void) (0));

    if( pagerUseWal(pPager) ){



      if( pPager->exclusiveMode && sqlite3WalExclusiveMode(pPager->pWal, -1) ){
        rc = pagerLockDb(pPager, 4);
        if( rc!=0 ){
          return rc;
        }
        sqlite3WalExclusiveMode(pPager->pWal, 1);
      }






      rc = sqlite3WalBeginWriteTransaction(pPager->pWal);
    }else{





      rc = pagerLockDb(pPager, 2);
      if( rc==0 && exFlag ){
        rc = pager_wait_on_lock(pPager, 4);
      }
    }

    if( rc==0 ){
# 41592 "ext/sqlite3/libsqlite/sqlite3.c"
      pPager->eState = 2;
      pPager->dbHintSize = pPager->dbSize;
      pPager->dbFileSize = pPager->dbSize;
      pPager->dbOrigSize = pPager->dbSize;
      pPager->journalOff = 0;
    }

    ((void) (0));
    ((void) (0));
    ((void) (0));
  }

                                                   ;
  return rc;
}
# 41615 "ext/sqlite3/libsqlite/sqlite3.c"
static int pager_write(PgHdr *pPg){
  void *pData = pPg->pData;
  Pager *pPager = pPg->pPager;
  int rc = 0;





  ((void) (0));



  ((void) (0));



  if( (pPager->errCode) ) return pPager->errCode;



  if( (pPager->readOnly) ) return 3;

                 ;
# 41649 "ext/sqlite3/libsqlite/sqlite3.c"
  if( pPager->eState==2 ){
    rc = pager_open_journal(pPager);
    if( rc!=0 ) return rc;
  }
  ((void) (0));
  ((void) (0));




  sqlite3PcacheMakeDirty(pPg);
  if( pageInJournal(pPg) && !subjRequiresPage(pPg) ){
    ((void) (0));
  }else{





    if( !pageInJournal(pPg) && !pagerUseWal(pPager) ){
      ((void) (0));
      if( pPg->pgno<=pPager->dbOrigSize && ((pPager->jfd)->pMethods) ){
        u32 cksum;
        char *pData2;
        i64 iOff = pPager->journalOff;




        ((void) (0));

        ((void) (0));
        pData2=(char*)pData;
        cksum = pager_cksum(pPager, (u8*)pData2);
# 41691 "ext/sqlite3/libsqlite/sqlite3.c"
        pPg->flags |= 0x004;

        rc = write32bits(pPager->jfd, iOff, pPg->pgno);
        if( rc!=0 ) return rc;
        rc = sqlite3OsWrite(pPager->jfd, pData2, pPager->pageSize, iOff+4);
        if( rc!=0 ) return rc;
        rc = write32bits(pPager->jfd, iOff+pPager->pageSize+4, cksum);
        if( rc!=0 ) return rc;


                                                       ;
                                              ;


                                                                      ;

        pPager->journalOff += 8 + pPager->pageSize;
        pPager->nRec++;
        ((void) (0));
        rc = sqlite3BitvecSet(pPager->pInJournal, pPg->pgno);
                                    ;
        ((void) (0));
        rc |= addToSavepointBitvecs(pPager, pPg->pgno);
        if( rc!=0 ){
          ((void) (0));
          return rc;
        }
      }else{
        if( pPager->eState!=4 ){
          pPg->flags |= 0x004;
        }


                                                   ;
      }
    }






    if( subjRequiresPage(pPg) ){
      rc = subjournalPage(pPg);
    }
  }



  if( pPager->dbSize<pPg->pgno ){
    pPager->dbSize = pPg->pgno;
  }
  return rc;
}
# 41760 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerWrite(DbPage *pDbPage){
  int rc = 0;

  PgHdr *pPg = pDbPage;
  Pager *pPager = pPg->pPager;
  Pgno nPagePerSector = (pPager->sectorSize/pPager->pageSize);

  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( nPagePerSector>1 ){
    Pgno nPageCount;
    Pgno pg1;
    int nPage = 0;
    int ii;
    int needSync = 0;





    ((void) (0));
    ((void) (0));
    pPager->doNotSyncSpill++;





    pg1 = ((pPg->pgno-1) & ~(nPagePerSector-1)) + 1;

    nPageCount = pPager->dbSize;
    if( pPg->pgno>nPageCount ){
      nPage = (pPg->pgno - pg1)+1;
    }else if( (pg1+nPagePerSector-1)>nPageCount ){
      nPage = nPageCount+1-pg1;
    }else{
      nPage = nPagePerSector;
    }
    ((void) (0));
    ((void) (0));
    ((void) (0));

    for(ii=0; ii<nPage && rc==0; ii++){
      Pgno pg = pg1+ii;
      PgHdr *pPage;
      if( pg==pPg->pgno || !sqlite3BitvecTest(pPager->pInJournal, pg) ){
        if( pg!=((Pgno)((sqlite3PendingByte/((pPager)->pageSize))+1)) ){
          rc = sqlite3PagerAcquire(pPager,pg,&pPage,0);
          if( rc==0 ){
            rc = pager_write(pPage);
            if( pPage->flags&0x004 ){
              needSync = 1;
            }
            sqlite3PagerUnref(pPage);
          }
        }
      }else if( (pPage = pager_lookup(pPager, pg))!=0 ){
        if( pPage->flags&0x004 ){
          needSync = 1;
        }
        sqlite3PagerUnref(pPage);
      }
    }







    if( rc==0 && needSync ){
      ((void) (0));
      for(ii=0; ii<nPage; ii++){
        PgHdr *pPage = pager_lookup(pPager, pg1+ii);
        if( pPage ){
          pPage->flags |= 0x004;
          sqlite3PagerUnref(pPage);
        }
      }
    }

    ((void) (0));
    pPager->doNotSyncSpill--;
  }else{
    rc = pager_write(pDbPage);
  }
  return rc;
}
# 41876 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3PagerDontWrite(PgHdr *pPg){
  Pager *pPager = pPg->pPager;
  if( (pPg->flags&0x002) && pPager->nSavepoint==0 ){
                                                                          ;

    pPg->flags |= 0x020;
                           ;
  }
}
# 41908 "ext/sqlite3/libsqlite/sqlite3.c"
static int pager_incr_changecounter(Pager *pPager, int isDirectMode){
  int rc = 0;

  ((void) (0));


  ((void) (0));
# 41928 "ext/sqlite3/libsqlite/sqlite3.c"
  ((void) (0));
  (void)(isDirectMode);




  if( !pPager->changeCountDone && pPager->dbSize>0 ){
    PgHdr *pPgHdr;

    ((void) (0));


    rc = sqlite3PagerAcquire(pPager,1,&pPgHdr,0);
    ((void) (0));






    if( !0 && (rc==0) ){
      rc = sqlite3PagerWrite(pPgHdr);
    }

    if( rc==0 ){

      pager_write_changecounter(pPgHdr);


      if( 0 ){
        const void *zBuf;
        ((void) (0));
        zBuf=(char*)pPgHdr->pData;
        if( rc==0 ){
          rc = sqlite3OsWrite(pPager->fd, zBuf, pPager->pageSize, 0);
        }
        if( rc==0 ){
          pPager->changeCountDone = 1;
        }
      }else{
        pPager->changeCountDone = 1;
      }
    }


    sqlite3PagerUnref(pPgHdr);
  }
  return rc;
}
# 41985 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerSync(Pager *pPager){
  int rc = 0;
  if( !pPager->noSync ){
    ((void) (0));
    rc = sqlite3OsSync(pPager->fd, pPager->syncFlags);
  }else if( ((pPager->fd)->pMethods) ){
    ((void) (0));
    sqlite3OsFileControl(pPager->fd, 8, (void *)&rc);
  }
  return rc;
}
# 42008 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerExclusiveLock(Pager *pPager){
  int rc = 0;
  ((void) (0));



  ((void) (0));
  if( 0==pagerUseWal(pPager) ){
    rc = pager_wait_on_lock(pPager, 4);
  }
  return rc;
}
# 42047 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerCommitPhaseOne(
  Pager *pPager,
  const char *zMaster,
  int noSync
){
  int rc = 0;

  ((void) (0));




  ((void) (0));


  if( (pPager->errCode) ) return pPager->errCode;


                                                  ;


  if( pPager->eState<3 ) return 0;

  if( pPager->memDb ){




    sqlite3BackupRestart(pPager->pBackup);
  }else{
    if( pagerUseWal(pPager) ){
      PgHdr *pList = sqlite3PcacheDirtyList(pPager->pPCache);
      PgHdr *pPageOne = 0;
      if( pList==0 ){


        rc = sqlite3PagerAcquire(pPager,1,&pPageOne,0);
        pList = pPageOne;
        pList->pDirty = 0;
      }
      ((void) (0));
      if( pList ){
        rc = pagerWalFrames(pPager, pList, pPager->dbSize, 1,
            (pPager->fullSync ? pPager->syncFlags : 0)
        );
      }
      sqlite3PagerUnref(pPageOne);
      if( rc==0 ){
        sqlite3PcacheCleanAll(pPager->pPCache);
      }
    }else{
# 42146 "ext/sqlite3/libsqlite/sqlite3.c"
      rc = pager_incr_changecounter(pPager, 0);

      if( rc!=0 ) goto commit_phase_one_exit;
# 42161 "ext/sqlite3/libsqlite/sqlite3.c"
      if( pPager->dbSize<pPager->dbOrigSize
       && pPager->journalMode!=2
      ){
        Pgno i;
        const Pgno iSkip = ((Pgno)((sqlite3PendingByte/((pPager)->pageSize))+1));
        const Pgno dbSize = pPager->dbSize;
        pPager->dbSize = pPager->dbOrigSize;
        for( i=dbSize+1; i<=pPager->dbOrigSize; i++ ){
          if( !sqlite3BitvecTest(pPager->pInJournal, i) && i!=iSkip ){
            PgHdr *pPage;
            rc = sqlite3PagerAcquire(pPager,i,&pPage,0);
            if( rc!=0 ) goto commit_phase_one_exit;
            rc = sqlite3PagerWrite(pPage);
            sqlite3PagerUnref(pPage);
            if( rc!=0 ) goto commit_phase_one_exit;
          }
        }
        pPager->dbSize = dbSize;
      }






      rc = writeMasterJournal(pPager, zMaster);
      if( rc!=0 ) goto commit_phase_one_exit;
# 42200 "ext/sqlite3/libsqlite/sqlite3.c"
      rc = syncJournal(pPager, 0);
      if( rc!=0 ) goto commit_phase_one_exit;

      rc = pager_write_pagelist(pPager,sqlite3PcacheDirtyList(pPager->pPCache));
      if( rc!=0 ){
        ((void) (0));
        goto commit_phase_one_exit;
      }
      sqlite3PcacheCleanAll(pPager->pPCache);




      if( pPager->dbSize!=pPager->dbFileSize ){
        Pgno nNew = pPager->dbSize - (pPager->dbSize==((Pgno)((sqlite3PendingByte/((pPager)->pageSize))+1)));
        ((void) (0));
        rc = pager_truncate(pPager, nNew);
        if( rc!=0 ) goto commit_phase_one_exit;
      }


      if( !noSync ){
        rc = sqlite3PagerSync(pPager);
      }

    }
  }

commit_phase_one_exit:
  if( rc==0 && !pagerUseWal(pPager) ){
    pPager->eState = 5;
  }
  return rc;
}
# 42251 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerCommitPhaseTwo(Pager *pPager){
  int rc = 0;




  if( (pPager->errCode) ) return pPager->errCode;

  ((void) (0));



  ((void) (0));
# 42276 "ext/sqlite3/libsqlite/sqlite3.c"
  if( pPager->eState==2
   && pPager->exclusiveMode
   && pPager->journalMode==1
  ){
    ((void) (0));
    pPager->eState = 1;
    return 0;
  }

                                              ;
  rc = pager_end_transaction(pPager, pPager->setMaster);
  return pager_error(pPager, rc);
}
# 42316 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerRollback(Pager *pPager){
  int rc = 0;
                                                ;





  ((void) (0));
  if( pPager->eState==6 ) return pPager->errCode;
  if( pPager->eState<=1 ) return 0;

  if( pagerUseWal(pPager) ){
    int rc2;
    rc = sqlite3PagerSavepoint(pPager, 2, -1);
    rc2 = pager_end_transaction(pPager, pPager->setMaster);
    if( rc==0 ) rc = rc2;
  }else if( !((pPager->jfd)->pMethods) || pPager->eState==2 ){
    int eState = pPager->eState;
    rc = pager_end_transaction(pPager, 0);
    if( !pPager->memDb && eState>2 ){




      pPager->errCode = 4;
      pPager->eState = 6;
      return rc;
    }
  }else{
    rc = pager_playback(pPager, 0);
  }

  ((void) (0));
  ((void) (0));




  return pager_error(pPager, rc);
}





static u8 sqlite3PagerIsreadonly(Pager *pPager){
  return pPager->readOnly;
}




static int sqlite3PagerRefcount(Pager *pPager){
  return sqlite3PcacheRefCount(pPager->pPCache);
}





static int sqlite3PagerMemUsed(Pager *pPager){
  int perPageSize = pPager->pageSize + pPager->nExtra + sizeof(PgHdr)
                                     + 5*sizeof(void*);
  return perPageSize*sqlite3PcachePagecount(pPager->pPCache)
           + sqlite3MallocSize(pPager)
           + pPager->pageSize;
}




static int sqlite3PagerPageRefcount(DbPage *pPage){
  return sqlite3PcachePageRefcount(pPage);
}
# 42416 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerIsMemdb(Pager *pPager){
  return pPager->memDb;
}
# 42430 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerOpenSavepoint(Pager *pPager, int nSavepoint){
  int rc = 0;
  int nCurrent = pPager->nSavepoint;

  ((void) (0));
  ((void) (0));

  if( nSavepoint>nCurrent && pPager->useJournal ){
    int ii;
    PagerSavepoint *aNew;





    aNew = (PagerSavepoint *)sqlite3Realloc(
        pPager->aSavepoint, sizeof(PagerSavepoint)*nSavepoint
    );
    if( !aNew ){
      return 7;
    }
    memset(&aNew[nCurrent], 0, (nSavepoint-nCurrent) * sizeof(PagerSavepoint));
    pPager->aSavepoint = aNew;


    for(ii=nCurrent; ii<nSavepoint; ii++){
      aNew[ii].nOrig = pPager->dbSize;
      if( ((pPager->jfd)->pMethods) && pPager->journalOff>0 ){
        aNew[ii].iOffset = pPager->journalOff;
      }else{
        aNew[ii].iOffset = (pPager->sectorSize);
      }
      aNew[ii].iSubRec = pPager->nSubRec;
      aNew[ii].pInSavepoint = sqlite3BitvecCreate(pPager->dbSize);
      if( !aNew[ii].pInSavepoint ){
        return 7;
      }
      if( pagerUseWal(pPager) ){
        sqlite3WalSavepoint(pPager->pWal, aNew[ii].aWalData);
      }
      pPager->nSavepoint = ii+1;
    }
    ((void) (0));
                                    ;
  }

  return rc;
}
# 42509 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint){
  int rc = pPager->errCode;

  ((void) (0));
  ((void) (0));

  if( rc==0 && iSavepoint<pPager->nSavepoint ){
    int ii;
    int nNew;





    nNew = iSavepoint + (( op==1 ) ? 0 : 1);
    for(ii=nNew; ii<pPager->nSavepoint; ii++){
      sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);
    }
    pPager->nSavepoint = nNew;



    if( op==1 ){
      if( nNew==0 && ((pPager->sjfd)->pMethods) ){

        if( sqlite3IsMemJournal(pPager->sjfd) ){
          rc = sqlite3OsTruncate(pPager->sjfd, 0);
          ((void) (0));
        }
        pPager->nSubRec = 0;
      }
    }





    else if( pagerUseWal(pPager) || ((pPager->jfd)->pMethods) ){
      PagerSavepoint *pSavepoint = (nNew==0)?0:&pPager->aSavepoint[nNew-1];
      rc = pagerPlaybackSavepoint(pPager, pSavepoint);
      ((void) (0));
    }
  }

  return rc;
}




static const char *sqlite3PagerFilename(Pager *pPager){
  return pPager->zFilename;
}




static const sqlite3_vfs *sqlite3PagerVfs(Pager *pPager){
  return pPager->pVfs;
}






static sqlite3_file *sqlite3PagerFile(Pager *pPager){
  return pPager->fd;
}




static const char *sqlite3PagerJournalname(Pager *pPager){
  return pPager->zJournal;
}





static int sqlite3PagerNosync(Pager *pPager){
  return pPager->noSync;
}
# 42643 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerMovepage(Pager *pPager, DbPage *pPg, Pgno pgno, int isCommit){
  PgHdr *pPgOld;
  Pgno needSyncPgno = 0;
  int rc;
  Pgno origPgno;

  ((void) (0));
  ((void) (0));


  ((void) (0));




  if( pPager->memDb ){
    rc = sqlite3PagerWrite(pPg);
    if( rc ) return rc;
  }
# 42681 "ext/sqlite3/libsqlite/sqlite3.c"
  if( pPg->flags&0x002
   && subjRequiresPage(pPg)
   && 0!=(rc = subjournalPage(pPg))
  ){
    return rc;
  }


                                                                          ;
# 42699 "ext/sqlite3/libsqlite/sqlite3.c"
  if( (pPg->flags&0x004) && !isCommit ){
    needSyncPgno = pPg->pgno;
    ((void) (0));
    ((void) (0));
  }






  pPg->flags &= ~0x004;
  pPgOld = pager_lookup(pPager, pgno);
  ((void) (0));
  if( pPgOld ){
    pPg->flags |= (pPgOld->flags&0x004);
    if( pPager->memDb ){


      sqlite3PcacheMove(pPgOld, pPager->dbSize+1);
    }else{
      sqlite3PcacheDrop(pPgOld);
    }
  }

  origPgno = pPg->pgno;
  sqlite3PcacheMove(pPg, pgno);
  sqlite3PcacheMakeDirty(pPg);





  if( pPager->memDb ){
    ((void) (0));
    sqlite3PcacheMove(pPgOld, origPgno);
    sqlite3PagerUnref(pPgOld);
  }

  if( needSyncPgno ){
# 42753 "ext/sqlite3/libsqlite/sqlite3.c"
    PgHdr *pPgHdr;
    rc = sqlite3PagerAcquire(pPager,needSyncPgno,&pPgHdr,0);
    if( rc!=0 ){
      if( needSyncPgno<=pPager->dbOrigSize ){
        ((void) (0));
        sqlite3BitvecClear(pPager->pInJournal, needSyncPgno, pPager->pTmpSpace);
      }
      return rc;
    }
    pPgHdr->flags |= 0x004;
    sqlite3PcacheMakeDirty(pPgHdr);
    sqlite3PagerUnref(pPgHdr);
  }

  return 0;
}





static void *sqlite3PagerGetData(DbPage *pPg){
  ((void) (0));
  return pPg->pData;
}





static void *sqlite3PagerGetExtra(DbPage *pPg){
  return pPg->pExtra;
}
# 42797 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerLockingMode(Pager *pPager, int eMode){
  ((void) (0));


  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( eMode>=0 && !pPager->tempFile && !sqlite3WalHeapMemory(pPager->pWal) ){
    pPager->exclusiveMode = (u8)eMode;
  }
  return (int)pPager->exclusiveMode;
}
# 42830 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerSetJournalMode(Pager *pPager, int eMode){
  u8 eOld = pPager->journalMode;
# 42841 "ext/sqlite3/libsqlite/sqlite3.c"
  ((void) (0));
# 42852 "ext/sqlite3/libsqlite/sqlite3.c"
  ((void) (0));




  if( pPager->memDb ){
    ((void) (0));
    if( eMode!=4 && eMode!=2 ){
      eMode = eOld;
    }
  }

  if( eMode!=eOld ){


    ((void) (0));
    pPager->journalMode = (u8)eMode;





    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));

    ((void) (0));
    if( !pPager->exclusiveMode && (eOld & 5)==1 && (eMode & 1)==0 ){
# 42892 "ext/sqlite3/libsqlite/sqlite3.c"
      sqlite3OsClose(pPager->jfd);
      if( pPager->eLock>=2 ){
        sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);
      }else{
        int rc = 0;
        int state = pPager->eState;
        ((void) (0));
        if( state==0 ){
          rc = sqlite3PagerSharedLock(pPager);
        }
        if( pPager->eState==1 ){
          ((void) (0));
          rc = pagerLockDb(pPager, 2);
        }
        if( rc==0 ){
          sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);
        }
        if( rc==0 && state==1 ){
          pagerUnlockDb(pPager, 1);
        }else if( state==0 ){
          pager_unlock(pPager);
        }
        ((void) (0));
      }
    }
  }


  return (int)pPager->journalMode;
}




static int sqlite3PagerGetJournalMode(Pager *pPager){
  return (int)pPager->journalMode;
}






static int sqlite3PagerOkToChangeJournalMode(Pager *pPager){
  ((void) (0));
  if( pPager->eState>=3 ) return 0;
  if( (((pPager->jfd)->pMethods) && pPager->journalOff>0) ) return 0;
  return 1;
}







static i64 sqlite3PagerJournalSizeLimit(Pager *pPager, i64 iLimit){
  if( iLimit>=-1 ){
    pPager->journalSizeLimit = iLimit;
  }
  return pPager->journalSizeLimit;
}







static sqlite3_backup **sqlite3PagerBackupPtr(Pager *pPager){
  return &pPager->pBackup;
}
# 42973 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerCheckpoint(Pager *pPager, int eMode, int *pnLog, int *pnCkpt){
  int rc = 0;
  if( pPager->pWal ){
    rc = sqlite3WalCheckpoint(pPager->pWal, eMode,
        pPager->xBusyHandler, pPager->pBusyHandlerArg,
        pPager->ckptSyncFlags, pPager->pageSize, (u8 *)pPager->pTmpSpace,
        pnLog, pnCkpt
    );
  }
  return rc;
}

static int sqlite3PagerWalCallback(Pager *pPager){
  return sqlite3WalCallback(pPager->pWal);
}





static int sqlite3PagerWalSupported(Pager *pPager){
  const sqlite3_io_methods *pMethods = pPager->fd->pMethods;
  return pPager->exclusiveMode || (pMethods->iVersion>=2 && pMethods->xShmMap);
}





static int pagerExclusiveLock(Pager *pPager){
  int rc;

  ((void) (0));
  rc = pagerLockDb(pPager, 4);
  if( rc!=0 ){


    pagerUnlockDb(pPager, 1);
  }

  return rc;
}







static int pagerOpenWal(Pager *pPager){
  int rc = 0;

  ((void) (0));
  ((void) (0));






  if( pPager->exclusiveMode ){
    rc = pagerExclusiveLock(pPager);
  }




  if( rc==0 ){
    rc = sqlite3WalOpen(pPager->pVfs,
        pPager->fd, pPager->zWal, pPager->exclusiveMode, &pPager->pWal
    );
  }

  return rc;
}
# 43065 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerOpenWal(
  Pager *pPager,
  int *pbOpen
){
  int rc = 0;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( !pPager->tempFile && !pPager->pWal ){
    if( !sqlite3PagerWalSupported(pPager) ) return 14;


    sqlite3OsClose(pPager->jfd);

    rc = pagerOpenWal(pPager);
    if( rc==0 ){
      pPager->journalMode = 5;
      pPager->eState = 0;
    }
  }else{
    *pbOpen = 1;
  }

  return rc;
}
# 43104 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3PagerCloseWal(Pager *pPager){
  int rc = 0;

  ((void) (0));





  if( !pPager->pWal ){
    int logexists = 0;
    rc = pagerLockDb(pPager, 1);
    if( rc==0 ){
      rc = sqlite3OsAccess(
          pPager->pVfs, pPager->zWal, 0, &logexists
      );
    }
    if( rc==0 && logexists ){
      rc = pagerOpenWal(pPager);
    }
  }




  if( rc==0 && pPager->pWal ){
    rc = pagerExclusiveLock(pPager);
    if( rc==0 ){
      rc = sqlite3WalClose(pPager->pWal, pPager->ckptSyncFlags,
                           pPager->pageSize, (u8*)pPager->pTmpSpace);
      pPager->pWal = 0;
    }
  }
  return rc;
}
# 43444 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct WalIndexHdr WalIndexHdr;
typedef struct WalIterator WalIterator;
typedef struct WalCkptInfo WalCkptInfo;
# 43459 "ext/sqlite3/libsqlite/sqlite3.c"
struct WalIndexHdr {
  u32 iVersion;
  u32 unused;
  u32 iChange;
  u8 isInit;
  u8 bigEndCksum;
  u16 szPage;
  u32 mxFrame;
  u32 nPage;
  u32 aFrameCksum[2];
  u32 aSalt[2];
  u32 aCksum[2];
};
# 43522 "ext/sqlite3/libsqlite/sqlite3.c"
struct WalCkptInfo {
  u32 nBackfill;
  u32 aReadMark[(8 -3)];
};
# 43569 "ext/sqlite3/libsqlite/sqlite3.c"
struct Wal {
  sqlite3_vfs *pVfs;
  sqlite3_file *pDbFd;
  sqlite3_file *pWalFd;
  u32 iCallback;
  int nWiData;
  volatile u32 **apWiData;
  u32 szPage;
  i16 readLock;
  u8 exclusiveMode;
  u8 writeLock;
  u8 ckptLock;
  u8 readOnly;
  WalIndexHdr hdr;
  const char *zWalName;
  u32 nCkpt;



};
# 43601 "ext/sqlite3/libsqlite/sqlite3.c"
typedef u16 ht_slot;
# 43618 "ext/sqlite3/libsqlite/sqlite3.c"
struct WalIterator {
  int iPrior;
  int nSegment;
  struct WalSegment {
    int iNext;
    ht_slot *aIndex;
    u32 *aPgno;
    int nEntry;
    int iZero;
  } aSegment[1];
};
# 43663 "ext/sqlite3/libsqlite/sqlite3.c"
static int walIndexPage(Wal *pWal, int iPage, volatile u32 **ppPage){
  int rc = 0;


  if( pWal->nWiData<=iPage ){
    int nByte = sizeof(u32*)*(iPage+1);
    volatile u32 **apNew;
    apNew = (volatile u32 **)sqlite3_realloc((void *)pWal->apWiData, nByte);
    if( !apNew ){
      *ppPage = 0;
      return 7;
    }
    memset((void*)&apNew[pWal->nWiData], 0,
           sizeof(u32*)*(iPage+1-pWal->nWiData));
    pWal->apWiData = apNew;
    pWal->nWiData = iPage+1;
  }


  if( pWal->apWiData[iPage]==0 ){
    if( pWal->exclusiveMode==2 ){
      pWal->apWiData[iPage] = (u32 volatile *)sqlite3MallocZero(( sizeof(ht_slot)*(4096*2) + 4096*sizeof(u32) ));
      if( !pWal->apWiData[iPage] ) rc = 7;
    }else{
      rc = sqlite3OsShmMap(pWal->pDbFd, iPage, ( sizeof(ht_slot)*(4096*2) + 4096*sizeof(u32) ),
          pWal->writeLock, (void volatile **)&pWal->apWiData[iPage]
      );
    }
  }

  *ppPage = pWal->apWiData[iPage];
  ((void) (0));
  return rc;
}




static volatile WalCkptInfo *walCkptInfo(Wal *pWal){
  ((void) (0));
  return (volatile WalCkptInfo*)&(pWal->apWiData[0][sizeof(WalIndexHdr)/2]);
}




static volatile WalIndexHdr *walIndexHdr(Wal *pWal){
  ((void) (0));
  return (volatile WalIndexHdr*)pWal->apWiData[0];
}
# 43735 "ext/sqlite3/libsqlite/sqlite3.c"
static void walChecksumBytes(
  int nativeCksum,
  u8 *a,
  int nByte,
  const u32 *aIn,
  u32 *aOut
){
  u32 s1, s2;
  u32 *aData = (u32 *)a;
  u32 *aEnd = (u32 *)&a[nByte];

  if( aIn ){
    s1 = aIn[0];
    s2 = aIn[1];
  }else{
    s1 = s2 = 0;
  }

  ((void) (0));
  ((void) (0));

  if( nativeCksum ){
    do {
      s1 += *aData++ + s2;
      s2 += *aData++ + s1;
    }while( aData<aEnd );
  }else{
    do {
      s1 += ( (((aData[0])&0x000000FF)<<24) + (((aData[0])&0x0000FF00)<<8) + (((aData[0])&0x00FF0000)>>8) + (((aData[0])&0xFF000000)>>24) ) + s2;
      s2 += ( (((aData[1])&0x000000FF)<<24) + (((aData[1])&0x0000FF00)<<8) + (((aData[1])&0x00FF0000)>>8) + (((aData[1])&0xFF000000)>>24) ) + s1;
      aData += 2;
    }while( aData<aEnd );
  }

  aOut[0] = s1;
  aOut[1] = s2;
}

static void walShmBarrier(Wal *pWal){
  if( pWal->exclusiveMode!=2 ){
    sqlite3OsShmBarrier(pWal->pDbFd);
  }
}






static void walIndexWriteHdr(Wal *pWal){
  volatile WalIndexHdr *aHdr = walIndexHdr(pWal);
  const int nCksum = __builtin_offsetof(WalIndexHdr, aCksum);

  ((void) (0));
  pWal->hdr.isInit = 1;
  pWal->hdr.iVersion = 3007000;
  walChecksumBytes(1, (u8*)&pWal->hdr, nCksum, 0, pWal->hdr.aCksum);
  memcpy((void *)&aHdr[1], (void *)&pWal->hdr, sizeof(WalIndexHdr));
  walShmBarrier(pWal);
  memcpy((void *)&aHdr[0], (void *)&pWal->hdr, sizeof(WalIndexHdr));
}
# 43810 "ext/sqlite3/libsqlite/sqlite3.c"
static void walEncodeFrame(
  Wal *pWal,
  u32 iPage,
  u32 nTruncate,
  u8 *aData,
  u8 *aFrame
){
  int nativeCksum;
  u32 *aCksum = pWal->hdr.aFrameCksum;
  ((void) (0));
  sqlite3Put4byte(&aFrame[0], iPage);
  sqlite3Put4byte(&aFrame[4], nTruncate);
  memcpy(&aFrame[8], pWal->hdr.aSalt, 8);

  nativeCksum = (pWal->hdr.bigEndCksum==0);
  walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);
  walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);

  sqlite3Put4byte(&aFrame[16], aCksum[0]);
  sqlite3Put4byte(&aFrame[20], aCksum[1]);
}






static int walDecodeFrame(
  Wal *pWal,
  u32 *piPage,
  u32 *pnTruncate,
  u8 *aData,
  u8 *aFrame
){
  int nativeCksum;
  u32 *aCksum = pWal->hdr.aFrameCksum;
  u32 pgno;
  ((void) (0));




  if( memcmp(&pWal->hdr.aSalt, &aFrame[8], 8)!=0 ){
    return 0;
  }



  pgno = sqlite3Get4byte(&aFrame[0]);
  if( pgno==0 ){
    return 0;
  }






  nativeCksum = (pWal->hdr.bigEndCksum==0);
  walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);
  walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);
  if( aCksum[0]!=sqlite3Get4byte(&aFrame[16])
   || aCksum[1]!=sqlite3Get4byte(&aFrame[20])
  ){

    return 0;
  }




  *piPage = pgno;
  *pnTruncate = sqlite3Get4byte(&aFrame[4]);
  return 1;
}
# 43916 "ext/sqlite3/libsqlite/sqlite3.c"
static int walLockShared(Wal *pWal, int lockIdx){
  int rc;
  if( pWal->exclusiveMode ) return 0;
  rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,
                        2 | 4);

                                                        ;

  return rc;
}
static void walUnlockShared(Wal *pWal, int lockIdx){
  if( pWal->exclusiveMode ) return;
  (void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,
                         1 | 4);
                                                                      ;
}
static int walLockExclusive(Wal *pWal, int lockIdx, int n){
  int rc;
  if( pWal->exclusiveMode ) return 0;
  rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,
                        2 | 8);

                                                           ;

  return rc;
}
static void walUnlockExclusive(Wal *pWal, int lockIdx, int n){
  if( pWal->exclusiveMode ) return;
  (void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,
                         1 | 8);

                                      ;
}






static int walHash(u32 iPage){
  ((void) (0));
  ((void) (0));
  return (iPage*383) & ((4096*2)-1);
}
static int walNextHash(int iPriorHash){
  return (iPriorHash+1)&((4096*2)-1);
}
# 43978 "ext/sqlite3/libsqlite/sqlite3.c"
static int walHashGet(
  Wal *pWal,
  int iHash,
  volatile ht_slot **paHash,
  volatile u32 **paPgno,
  u32 *piZero
){
  int rc;
  volatile u32 *aPgno;

  rc = walIndexPage(pWal, iHash, &aPgno);
  ((void) (0));

  if( rc==0 ){
    u32 iZero;
    volatile ht_slot *aHash;

    aHash = (volatile ht_slot *)&aPgno[4096];
    if( iHash==0 ){
      aPgno = &aPgno[((sizeof(WalIndexHdr)*2 + sizeof(WalCkptInfo))+16)/sizeof(u32)];
      iZero = 0;
    }else{
      iZero = (4096 - (((sizeof(WalIndexHdr)*2 + sizeof(WalCkptInfo))+16)/sizeof(u32))) + (iHash-1)*4096;
    }

    *paPgno = &aPgno[-1];
    *paHash = aHash;
    *piZero = iZero;
  }
  return rc;
}







static int walFramePage(u32 iFrame){
  int iHash = (iFrame+4096 -(4096 - (((sizeof(WalIndexHdr)*2 + sizeof(WalCkptInfo))+16)/sizeof(u32)))-1) / 4096;
  ((void) (0));





  return iHash;
}




static u32 walFramePgno(Wal *pWal, u32 iFrame){
  int iHash = walFramePage(iFrame);
  if( iHash==0 ){
    return pWal->apWiData[0][((sizeof(WalIndexHdr)*2 + sizeof(WalCkptInfo))+16)/sizeof(u32) + iFrame - 1];
  }
  return pWal->apWiData[iHash][(iFrame-1-(4096 - (((sizeof(WalIndexHdr)*2 + sizeof(WalCkptInfo))+16)/sizeof(u32))))%4096];
}
# 44050 "ext/sqlite3/libsqlite/sqlite3.c"
static void walCleanupHash(Wal *pWal){
  volatile ht_slot *aHash = 0;
  volatile u32 *aPgno = 0;
  u32 iZero = 0;
  int iLimit = 0;
  int nByte;
  int i;

  ((void) (0));
                                                      ;
                                                    ;
                                                      ;

  if( pWal->hdr.mxFrame==0 ) return;





  ((void) (0));
  ((void) (0));
  walHashGet(pWal, walFramePage(pWal->hdr.mxFrame), &aHash, &aPgno, &iZero);




  iLimit = pWal->hdr.mxFrame - iZero;
  ((void) (0));
  for(i=0; i<(4096*2); i++){
    if( aHash[i]>iLimit ){
      aHash[i] = 0;
    }
  }




  nByte = (int)((char *)aHash - (char *)&aPgno[iLimit+1]);
  memset((void *)&aPgno[iLimit+1], 0, nByte);
# 44105 "ext/sqlite3/libsqlite/sqlite3.c"
}






static int walIndexAppend(Wal *pWal, u32 iFrame, u32 iPage){
  int rc;
  u32 iZero = 0;
  volatile u32 *aPgno = 0;
  volatile ht_slot *aHash = 0;

  rc = walHashGet(pWal, walFramePage(iFrame), &aHash, &aPgno, &iZero);




  if( rc==0 ){
    int iKey;
    int idx;
    int nCollide;

    idx = iFrame - iZero;
    ((void) (0));




    if( idx==1 ){
      int nByte = (int)((u8 *)&aHash[(4096*2)] - (u8 *)&aPgno[1]);
      memset((void*)&aPgno[1], 0, nByte);
    }







    if( aPgno[idx] ){
      walCleanupHash(pWal);
      ((void) (0));
    }


    nCollide = idx;
    for(iKey=walHash(iPage); aHash[iKey]; iKey=walNextHash(iKey)){
      if( (nCollide--)==0 ) return sqlite3CorruptError(44153);
    }
    aPgno[idx] = iPage;
    aHash[iKey] = (ht_slot)idx;
# 44184 "ext/sqlite3/libsqlite/sqlite3.c"
  }


  return rc;
}
# 44201 "ext/sqlite3/libsqlite/sqlite3.c"
static int walIndexRecover(Wal *pWal){
  int rc;
  i64 nSize;
  u32 aFrameCksum[2] = {0, 0};
  int iLock;
  int nLock;







  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  iLock = 1 + pWal->ckptLock;
  nLock = 8 - iLock;
  rc = walLockExclusive(pWal, iLock, nLock);
  if( rc ){
    return rc;
  }
                                                ;

  memset(&pWal->hdr, 0, sizeof(WalIndexHdr));

  rc = sqlite3OsFileSize(pWal->pWalFd, &nSize);
  if( rc!=0 ){
    goto recovery_error;
  }

  if( nSize>32 ){
    u8 aBuf[32];
    u8 *aFrame = 0;
    int szFrame;
    u8 *aData;
    int iFrame;
    i64 iOffset;
    int szPage;
    u32 magic;
    u32 version;


    rc = sqlite3OsRead(pWal->pWalFd, aBuf, 32, 0);
    if( rc!=0 ){
      goto recovery_error;
    }






    magic = sqlite3Get4byte(&aBuf[0]);
    szPage = sqlite3Get4byte(&aBuf[8]);
    if( (magic&0xFFFFFFFE)!=0x377f0682
     || szPage&(szPage-1)
     || szPage>65536
     || szPage<512
    ){
      goto finished;
    }
    pWal->hdr.bigEndCksum = (u8)(magic&0x00000001);
    pWal->szPage = szPage;
    pWal->nCkpt = sqlite3Get4byte(&aBuf[12]);
    memcpy(&pWal->hdr.aSalt, &aBuf[16], 8);


    walChecksumBytes(pWal->hdr.bigEndCksum==0,
        aBuf, 32 -2*4, 0, pWal->hdr.aFrameCksum
    );
    if( pWal->hdr.aFrameCksum[0]!=sqlite3Get4byte(&aBuf[24])
     || pWal->hdr.aFrameCksum[1]!=sqlite3Get4byte(&aBuf[28])
    ){
      goto finished;
    }



    version = sqlite3Get4byte(&aBuf[4]);
    if( version!=3007000 ){
      rc = sqlite3CantopenError(44283);
      goto finished;
    }


    szFrame = szPage + 24;
    aFrame = (u8 *)sqlite3_malloc(szFrame);
    if( !aFrame ){
      rc = 7;
      goto recovery_error;
    }
    aData = &aFrame[24];


    iFrame = 0;
    for(iOffset=32; (iOffset+szFrame)<=nSize; iOffset+=szFrame){
      u32 pgno;
      u32 nTruncate;
      int isValid;


      rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);
      if( rc!=0 ) break;
      isValid = walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame);
      if( !isValid ) break;
      rc = walIndexAppend(pWal, ++iFrame, pgno);
      if( rc!=0 ) break;


      if( nTruncate ){
        pWal->hdr.mxFrame = iFrame;
        pWal->hdr.nPage = nTruncate;
        pWal->hdr.szPage = (u16)((szPage&0xff00) | (szPage>>16));
                                 ;
                                 ;
        aFrameCksum[0] = pWal->hdr.aFrameCksum[0];
        aFrameCksum[1] = pWal->hdr.aFrameCksum[1];
      }
    }

    sqlite3_free(aFrame);
  }

finished:
  if( rc==0 ){
    volatile WalCkptInfo *pInfo;
    int i;
    pWal->hdr.aFrameCksum[0] = aFrameCksum[0];
    pWal->hdr.aFrameCksum[1] = aFrameCksum[1];
    walIndexWriteHdr(pWal);





    pInfo = walCkptInfo(pWal);
    pInfo->nBackfill = 0;
    pInfo->aReadMark[0] = 0;
    for(i=1; i<(8 -3); i++) pInfo->aReadMark[i] = 0xffffffff;






    if( pWal->hdr.nPage ){
      sqlite3_log(0, "Recovered %d frames from WAL file %s",
          pWal->hdr.nPage, pWal->zWalName
      );
    }
  }

recovery_error:
                                                                ;
  walUnlockExclusive(pWal, iLock, nLock);
  return rc;
}




static void walIndexClose(Wal *pWal, int isDelete){
  if( pWal->exclusiveMode==2 ){
    int i;
    for(i=0; i<pWal->nWiData; i++){
      sqlite3_free((void *)pWal->apWiData[i]);
      pWal->apWiData[i] = 0;
    }
  }else{
    sqlite3OsShmUnmap(pWal->pDbFd, isDelete);
  }
}
# 44391 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3WalOpen(
  sqlite3_vfs *pVfs,
  sqlite3_file *pDbFd,
  const char *zWalName,
  int bNoShm,
  Wal **ppWal
){
  int rc;
  Wal *pRet;
  int flags;

  ((void) (0));
  ((void) (0));
# 44413 "ext/sqlite3/libsqlite/sqlite3.c"
  ((void) (0));




  *ppWal = 0;
  pRet = (Wal*)sqlite3MallocZero(sizeof(Wal) + pVfs->szOsFile);
  if( !pRet ){
    return 7;
  }

  pRet->pVfs = pVfs;
  pRet->pWalFd = (sqlite3_file *)&pRet[1];
  pRet->pDbFd = pDbFd;
  pRet->readLock = -1;
  pRet->zWalName = zWalName;
  pRet->exclusiveMode = (bNoShm ? 2: 0);


  flags = (0x00000002|0x00000004|0x00080000);
  rc = sqlite3OsOpen(pVfs, zWalName, pRet->pWalFd, flags, &flags);
  if( rc==0 && flags&0x00000001 ){
    pRet->readOnly = 1;
  }

  if( rc!=0 ){
    walIndexClose(pRet, 0);
    sqlite3OsClose(pRet->pWalFd);
    sqlite3_free(pRet);
  }else{
    *ppWal = pRet;
                                       ;
  }
  return rc;
}
# 44459 "ext/sqlite3/libsqlite/sqlite3.c"
static int walIteratorNext(
  WalIterator *p,
  u32 *piPage,
  u32 *piFrame
){
  u32 iMin;
  u32 iRet = 0xFFFFFFFF;
  int i;

  iMin = p->iPrior;
  ((void) (0));
  for(i=p->nSegment-1; i>=0; i--){
    struct WalSegment *pSegment = &p->aSegment[i];
    while( pSegment->iNext<pSegment->nEntry ){
      u32 iPg = pSegment->aPgno[pSegment->aIndex[pSegment->iNext]];
      if( iPg>iMin ){
        if( iPg<iRet ){
          iRet = iPg;
          *piFrame = pSegment->iZero + pSegment->aIndex[pSegment->iNext];
        }
        break;
      }
      pSegment->iNext++;
    }
  }

  *piPage = p->iPrior = iRet;
  return (iRet==0xFFFFFFFF);
}
# 44512 "ext/sqlite3/libsqlite/sqlite3.c"
static void walMerge(
  const u32 *aContent,
  ht_slot *aLeft,
  int nLeft,
  ht_slot **paRight,
  int *pnRight,
  ht_slot *aTmp
){
  int iLeft = 0;
  int iRight = 0;
  int iOut = 0;
  int nRight = *pnRight;
  ht_slot *aRight = *paRight;

  ((void) (0));
  while( iRight<nRight || iLeft<nLeft ){
    ht_slot logpage;
    Pgno dbpage;

    if( (iLeft<nLeft)
     && (iRight>=nRight || aContent[aLeft[iLeft]]<aContent[aRight[iRight]])
    ){
      logpage = aLeft[iLeft++];
    }else{
      logpage = aRight[iRight++];
    }
    dbpage = aContent[logpage];

    aTmp[iOut++] = logpage;
    if( iLeft<nLeft && aContent[aLeft[iLeft]]==dbpage ) iLeft++;

    ((void) (0));
    ((void) (0));
  }

  *paRight = aLeft;
  *pnRight = iOut;
  memcpy(aLeft, aTmp, sizeof(aTmp[0])*iOut);
}
# 44569 "ext/sqlite3/libsqlite/sqlite3.c"
static void walMergesort(
  const u32 *aContent,
  ht_slot *aBuffer,
  ht_slot *aList,
  int *pnList
){
  struct Sublist {
    int nList;
    ht_slot *aList;
  };

  const int nList = *pnList;
  int nMerge = 0;
  ht_slot *aMerge = 0;
  int iList;
  int iSub = 0;
  struct Sublist aSub[13];

  memset(aSub, 0, sizeof(aSub));
  ((void) (0));
  ((void) (0));

  for(iList=0; iList<nList; iList++){
    nMerge = 1;
    aMerge = &aList[iList];
    for(iSub=0; iList & (1<<iSub); iSub++){
      struct Sublist *p = &aSub[iSub];
      ((void) (0));
      ((void) (0));
      walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);
    }
    aSub[iSub].aList = aMerge;
    aSub[iSub].nList = nMerge;
  }

  for(iSub++; iSub<((int)(sizeof(aSub)/sizeof(aSub[0]))); iSub++){
    if( nList & (1<<iSub) ){
      struct Sublist *p = &aSub[iSub];
      ((void) (0));
      ((void) (0));
      walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);
    }
  }
  ((void) (0));
  *pnList = nMerge;
# 44623 "ext/sqlite3/libsqlite/sqlite3.c"
}




static void walIteratorFree(WalIterator *p){
  sqlite3ScratchFree(p);
}
# 44644 "ext/sqlite3/libsqlite/sqlite3.c"
static int walIteratorInit(Wal *pWal, WalIterator **pp){
  WalIterator *p;
  int nSegment;
  u32 iLast;
  int nByte;
  int i;
  ht_slot *aTmp;
  int rc = 0;




  ((void) (0));
  iLast = pWal->hdr.mxFrame;


  nSegment = walFramePage(iLast) + 1;
  nByte = sizeof(WalIterator)
        + (nSegment-1)*sizeof(struct WalSegment)
        + iLast*sizeof(ht_slot);
  p = (WalIterator *)sqlite3ScratchMalloc(nByte);
  if( !p ){
    return 7;
  }
  memset(p, 0, nByte);
  p->nSegment = nSegment;




  aTmp = (ht_slot *)sqlite3ScratchMalloc(
      sizeof(ht_slot) * (iLast>4096?4096:iLast)
  );
  if( !aTmp ){
    rc = 7;
  }

  for(i=0; rc==0 && i<nSegment; i++){
    volatile ht_slot *aHash;
    u32 iZero;
    volatile u32 *aPgno;

    rc = walHashGet(pWal, i, &aHash, &aPgno, &iZero);
    if( rc==0 ){
      int j;
      int nEntry;
      ht_slot *aIndex;

      aPgno++;
      if( (i+1)==nSegment ){
        nEntry = (int)(iLast - iZero);
      }else{
        nEntry = (int)((u32*)aHash - (u32*)aPgno);
      }
      aIndex = &((ht_slot *)&p->aSegment[p->nSegment])[iZero];
      iZero++;

      for(j=0; j<nEntry; j++){
        aIndex[j] = (ht_slot)j;
      }
      walMergesort((u32 *)aPgno, aTmp, aIndex, &nEntry);
      p->aSegment[i].iZero = iZero;
      p->aSegment[i].nEntry = nEntry;
      p->aSegment[i].aIndex = aIndex;
      p->aSegment[i].aPgno = (u32 *)aPgno;
    }
  }
  sqlite3ScratchFree(aTmp);

  if( rc!=0 ){
    walIteratorFree(p);
  }
  *pp = p;
  return rc;
}







static int walBusyLock(
  Wal *pWal,
  int (*xBusy)(void*),
  void *pBusyArg,
  int lockIdx,
  int n
){
  int rc;
  do {
    rc = walLockExclusive(pWal, lockIdx, n);
  }while( xBusy && rc==5 && xBusy(pBusyArg) );
  return rc;
}





static int walPagesize(Wal *pWal){
  return (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);
}
# 44779 "ext/sqlite3/libsqlite/sqlite3.c"
static int walCheckpoint(
  Wal *pWal,
  int eMode,
  int (*xBusyCall)(void*),
  void *pBusyArg,
  int sync_flags,
  u8 *zBuf
){
  int rc;
  int szPage;
  WalIterator *pIter = 0;
  u32 iDbpage = 0;
  u32 iFrame = 0;
  u32 mxSafeFrame;
  u32 mxPage;
  int i;
  volatile WalCkptInfo *pInfo;
  int (*xBusy)(void*) = 0;

  szPage = walPagesize(pWal);
                           ;
                           ;
  pInfo = walCkptInfo(pWal);
  if( pInfo->nBackfill>=pWal->hdr.mxFrame ) return 0;


  rc = walIteratorInit(pWal, &pIter);
  if( rc!=0 ){
    return rc;
  }
  ((void) (0));

  if( eMode!=0 ) xBusy = xBusyCall;






  mxSafeFrame = pWal->hdr.mxFrame;
  mxPage = pWal->hdr.nPage;
  for(i=1; i<(8 -3); i++){
    u32 y = pInfo->aReadMark[i];
    if( mxSafeFrame>y ){
      ((void) (0));
      rc = walBusyLock(pWal, xBusy, pBusyArg, (3+(i)), 1);
      if( rc==0 ){
        pInfo->aReadMark[i] = 0xffffffff;
        walUnlockExclusive(pWal, (3+(i)), 1);
      }else if( rc==5 ){
        mxSafeFrame = y;
        xBusy = 0;
      }else{
        goto walcheckpoint_out;
      }
    }
  }

  if( pInfo->nBackfill<mxSafeFrame
   && (rc = walBusyLock(pWal, xBusy, pBusyArg, (3+(0)), 1))==0
  ){
    i64 nSize;
    u32 nBackfill = pInfo->nBackfill;


    if( sync_flags ){
      rc = sqlite3OsSync(pWal->pWalFd, sync_flags);
    }




    if( rc==0 ){
      i64 nReq = ((i64)mxPage * szPage);
      rc = sqlite3OsFileSize(pWal->pDbFd, &nSize);
      if( rc==0 && nSize<nReq ){
        sqlite3OsFileControl(pWal->pDbFd, 5, &nReq);
      }
    }


    while( rc==0 && 0==walIteratorNext(pIter, &iDbpage, &iFrame) ){
      i64 iOffset;
      ((void) (0));
      if( iFrame<=nBackfill || iFrame>mxSafeFrame || iDbpage>mxPage ) continue;
      iOffset = ( 32 + ((iFrame)-1)*(i64)((szPage)+24) ) + 24;

      rc = sqlite3OsRead(pWal->pWalFd, zBuf, szPage, iOffset);
      if( rc!=0 ) break;
      iOffset = (iDbpage-1)*(i64)szPage;
                                     ;
      rc = sqlite3OsWrite(pWal->pDbFd, zBuf, szPage, iOffset);
      if( rc!=0 ) break;
    }


    if( rc==0 ){
      if( mxSafeFrame==walIndexHdr(pWal)->mxFrame ){
        i64 szDb = pWal->hdr.nPage*(i64)szPage;
                                    ;
        rc = sqlite3OsTruncate(pWal->pDbFd, szDb);
        if( rc==0 && sync_flags ){
          rc = sqlite3OsSync(pWal->pDbFd, sync_flags);
        }
      }
      if( rc==0 ){
        pInfo->nBackfill = mxSafeFrame;
      }
    }


    walUnlockExclusive(pWal, (3+(0)), 1);
  }

  if( rc==5 ){


    rc = 0;
  }






  if( rc==0 && eMode!=0 ){
    ((void) (0));
    if( pInfo->nBackfill<pWal->hdr.mxFrame ){
      rc = 5;
    }else if( eMode==2 ){
      ((void) (0));
      rc = walBusyLock(pWal, xBusy, pBusyArg, (3+(1)), (8 -3)-1);
      if( rc==0 ){
        walUnlockExclusive(pWal, (3+(1)), (8 -3)-1);
      }
    }
  }

 walcheckpoint_out:
  walIteratorFree(pIter);
  return rc;
}




static int sqlite3WalClose(
  Wal *pWal,
  int sync_flags,
  int nBuf,
  u8 *zBuf
){
  int rc = 0;
  if( pWal ){
    int isDelete = 0;
# 44943 "ext/sqlite3/libsqlite/sqlite3.c"
    rc = sqlite3OsLock(pWal->pDbFd, 4);
    if( rc==0 ){
      if( pWal->exclusiveMode==0 ){
        pWal->exclusiveMode = 1;
      }
      rc = sqlite3WalCheckpoint(
          pWal, 0, 0, 0, sync_flags, nBuf, zBuf, 0, 0
      );
      if( rc==0 ){
        isDelete = 1;
      }
    }

    walIndexClose(pWal, isDelete);
    sqlite3OsClose(pWal->pWalFd);
    if( isDelete ){
      sqlite3OsDelete(pWal->pVfs, pWal->zWalName, 0);
    }
                                       ;
    sqlite3_free((void *)pWal->apWiData);
    sqlite3_free(pWal);
  }
  return rc;
}
# 44985 "ext/sqlite3/libsqlite/sqlite3.c"
static int walIndexTryHdr(Wal *pWal, int *pChanged){
  u32 aCksum[2];
  WalIndexHdr h1, h2;
  WalIndexHdr volatile *aHdr;


  ((void) (0));
# 45003 "ext/sqlite3/libsqlite/sqlite3.c"
  aHdr = walIndexHdr(pWal);
  memcpy(&h1, (void *)&aHdr[0], sizeof(h1));
  walShmBarrier(pWal);
  memcpy(&h2, (void *)&aHdr[1], sizeof(h2));

  if( memcmp(&h1, &h2, sizeof(h1))!=0 ){
    return 1;
  }
  if( h1.isInit==0 ){
    return 1;
  }
  walChecksumBytes(1, (u8*)&h1, sizeof(h1)-sizeof(h1.aCksum), 0, aCksum);
  if( aCksum[0]!=h1.aCksum[0] || aCksum[1]!=h1.aCksum[1] ){
    return 1;
  }

  if( memcmp(&pWal->hdr, &h1, sizeof(WalIndexHdr)) ){
    *pChanged = 1;
    memcpy(&pWal->hdr, &h1, sizeof(WalIndexHdr));
    pWal->szPage = (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);
                                   ;
                                   ;
  }


  return 0;
}
# 45043 "ext/sqlite3/libsqlite/sqlite3.c"
static int walIndexReadHdr(Wal *pWal, int *pChanged){
  int rc;
  int badHdr;
  volatile u32 *page0;




  ((void) (0));
  rc = walIndexPage(pWal, 0, &page0);
  if( rc!=0 ){
    return rc;
  };
  ((void) (0));






  badHdr = (page0 ? walIndexTryHdr(pWal, pChanged) : 1);




  ((void) (0));
  if( badHdr && 0==(rc = walLockExclusive(pWal, 0, 1)) ){
    pWal->writeLock = 1;
    if( 0==(rc = walIndexPage(pWal, 0, &page0)) ){
      badHdr = walIndexTryHdr(pWal, pChanged);
      if( badHdr ){




        rc = walIndexRecover(pWal);
        *pChanged = 1;
      }
    }
    pWal->writeLock = 0;
    walUnlockExclusive(pWal, 0, 1);
  }





  if( badHdr==0 && pWal->hdr.iVersion!=3007000 ){
    rc = sqlite3CantopenError(45091);
  }

  return rc;
}
# 45153 "ext/sqlite3/libsqlite/sqlite3.c"
static int walTryBeginRead(Wal *pWal, int *pChanged, int useWal, int cnt){
  volatile WalCkptInfo *pInfo;
  u32 mxReadMark;
  int mxI;
  int i;
  int rc = 0;

  ((void) (0));
# 45179 "ext/sqlite3/libsqlite/sqlite3.c"
  if( cnt>5 ){
    int nDelay = 1;
    if( cnt>100 ){

      return 15;
    }
    if( cnt>=10 ) nDelay = (cnt-9)*238;
    sqlite3OsSleep(pWal->pVfs, nDelay);
  }

  if( !useWal ){
    rc = walIndexReadHdr(pWal, pChanged);
    if( rc==5 ){
# 45200 "ext/sqlite3/libsqlite/sqlite3.c"
      if( pWal->apWiData[0]==0 ){







        rc = (-1);
      }else if( 0==(rc = walLockShared(pWal, 2)) ){
        walUnlockShared(pWal, 2);
        rc = (-1);
      }else if( rc==5 ){
        rc = (5 | (1<<8));
      }
    }
    if( rc!=0 ){
      return rc;
    }
  }

  pInfo = walCkptInfo(pWal);
  if( !useWal && pInfo->nBackfill==pWal->hdr.mxFrame ){



    rc = walLockShared(pWal, (3+(0)));
    walShmBarrier(pWal);
    if( rc==0 ){
      if( memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr)) ){
# 45243 "ext/sqlite3/libsqlite/sqlite3.c"
        walUnlockShared(pWal, (3+(0)));
        return (-1);
      }
      pWal->readLock = 0;
      return 0;
    }else if( rc!=5 ){
      return rc;
    }
  }






  mxReadMark = 0;
  mxI = 0;
  for(i=1; i<(8 -3); i++){
    u32 thisMark = pInfo->aReadMark[i];
    if( mxReadMark<=thisMark && thisMark<=pWal->hdr.mxFrame ){
      ((void) (0));
      mxReadMark = thisMark;
      mxI = i;
    }
  }

  {
    if( mxReadMark < pWal->hdr.mxFrame || mxI==0 ){
      for(i=1; i<(8 -3); i++){
        rc = walLockExclusive(pWal, (3+(i)), 1);
        if( rc==0 ){
          mxReadMark = pInfo->aReadMark[i] = pWal->hdr.mxFrame;
          mxI = i;
          walUnlockExclusive(pWal, (3+(i)), 1);
          break;
        }else if( rc!=5 ){
          return rc;
        }
      }
    }
    if( mxI==0 ){
      ((void) (0));
      return (-1);
    }

    rc = walLockShared(pWal, (3+(mxI)));
    if( rc ){
      return rc==5 ? (-1) : rc;
    }
# 45312 "ext/sqlite3/libsqlite/sqlite3.c"
    walShmBarrier(pWal);
    if( pInfo->aReadMark[mxI]!=mxReadMark
     || memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr))
    ){
      walUnlockShared(pWal, (3+(mxI)));
      return (-1);
    }else{
      ((void) (0));
      pWal->readLock = (i16)mxI;
    }
  }
  return rc;
}
# 45340 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3WalBeginReadTransaction(Wal *pWal, int *pChanged){
  int rc;
  int cnt = 0;

  do{
    rc = walTryBeginRead(pWal, pChanged, 0, ++cnt);
  }while( rc==(-1) );
                                    ;
                                     ;
                                 ;
                           ;
  return rc;
}





static void sqlite3WalEndReadTransaction(Wal *pWal){
  sqlite3WalEndWriteTransaction(pWal);
  if( pWal->readLock>=0 ){
    walUnlockShared(pWal, (3+(pWal->readLock)));
    pWal->readLock = -1;
  }
}
# 45374 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3WalRead(
  Wal *pWal,
  Pgno pgno,
  int *pInWal,
  int nOut,
  u8 *pOut
){
  u32 iRead = 0;
  u32 iLast = pWal->hdr.mxFrame;
  int iHash;


  ((void) (0));







  if( iLast==0 || pWal->readLock==0 ){
    *pInWal = 0;
    return 0;
  }
# 45424 "ext/sqlite3/libsqlite/sqlite3.c"
  for(iHash=walFramePage(iLast); iHash>=0 && iRead==0; iHash--){
    volatile ht_slot *aHash;
    volatile u32 *aPgno;
    u32 iZero;
    int iKey;
    int nCollide;
    int rc;

    rc = walHashGet(pWal, iHash, &aHash, &aPgno, &iZero);
    if( rc!=0 ){
      return rc;
    }
    nCollide = (4096*2);
    for(iKey=walHash(pgno); aHash[iKey]; iKey=walNextHash(iKey)){
      u32 iFrame = aHash[iKey] + iZero;
      if( iFrame<=iLast && aPgno[aHash[iKey]]==pgno ){
        ((void) (0));
        iRead = iFrame;
      }
      if( (nCollide--)==0 ){
        return sqlite3CorruptError(45444);
      }
    }
  }
# 45469 "ext/sqlite3/libsqlite/sqlite3.c"
  if( iRead ){
    int sz;
    i64 iOffset;
    sz = pWal->hdr.szPage;
    sz = (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);
                         ;
                         ;
    iOffset = ( 32 + ((iRead)-1)*(i64)((sz)+24) ) + 24;
    *pInWal = 1;

    return sqlite3OsRead(pWal->pWalFd, pOut, nOut, iOffset);
  }

  *pInWal = 0;
  return 0;
}





static Pgno sqlite3WalDbsize(Wal *pWal){
  if( pWal && (pWal->readLock>=0) ){
    return pWal->hdr.nPage;
  }
  return 0;
}
# 45511 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3WalBeginWriteTransaction(Wal *pWal){
  int rc;



  ((void) (0));

  if( pWal->readOnly ){
    return 8;
  }




  rc = walLockExclusive(pWal, 0, 1);
  if( rc ){
    return rc;
  }
  pWal->writeLock = 1;





  if( memcmp(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr))!=0 ){
    walUnlockExclusive(pWal, 0, 1);
    pWal->writeLock = 0;
    rc = 5;
  }

  return rc;
}





static int sqlite3WalEndWriteTransaction(Wal *pWal){
  if( pWal->writeLock ){
    walUnlockExclusive(pWal, 0, 1);
    pWal->writeLock = 0;
  }
  return 0;
}
# 45568 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3WalUndo(Wal *pWal, int (*xUndo)(void *, Pgno), void *pUndoCtx){
  int rc = 0;
  if( (pWal->writeLock) ){
    Pgno iMax = pWal->hdr.mxFrame;
    Pgno iFrame;




    memcpy(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr));

    for(iFrame=pWal->hdr.mxFrame+1;
        (rc==0) && iFrame<=iMax;
        iFrame++
    ){
# 45594 "ext/sqlite3/libsqlite/sqlite3.c"
      ((void) (0));
      rc = xUndo(pUndoCtx, walFramePgno(pWal, iFrame));
    }
    walCleanupHash(pWal);
  }
  ((void) (0));
  return rc;
}







static void sqlite3WalSavepoint(Wal *pWal, u32 *aWalData){
  ((void) (0));
  aWalData[0] = pWal->hdr.mxFrame;
  aWalData[1] = pWal->hdr.aFrameCksum[0];
  aWalData[2] = pWal->hdr.aFrameCksum[1];
  aWalData[3] = pWal->nCkpt;
}







static int sqlite3WalSavepointUndo(Wal *pWal, u32 *aWalData){
  int rc = 0;

  ((void) (0));
  ((void) (0));

  if( aWalData[3]!=pWal->nCkpt ){




    aWalData[0] = 0;
    aWalData[3] = pWal->nCkpt;
  }

  if( aWalData[0]<pWal->hdr.mxFrame ){
    pWal->hdr.mxFrame = aWalData[0];
    pWal->hdr.aFrameCksum[0] = aWalData[1];
    pWal->hdr.aFrameCksum[1] = aWalData[2];
    walCleanupHash(pWal);
  }

  return rc;
}
# 45660 "ext/sqlite3/libsqlite/sqlite3.c"
static int walRestartLog(Wal *pWal){
  int rc = 0;
  int cnt;

  if( pWal->readLock==0 ){
    volatile WalCkptInfo *pInfo = walCkptInfo(pWal);
    ((void) (0));
    if( pInfo->nBackfill>0 ){
      u32 salt1;
      sqlite3_randomness(4, &salt1);
      rc = walLockExclusive(pWal, (3+(1)), (8 -3)-1);
      if( rc==0 ){
# 45682 "ext/sqlite3/libsqlite/sqlite3.c"
        int i;
        u32 *aSalt = pWal->hdr.aSalt;
        pWal->nCkpt++;
        pWal->hdr.mxFrame = 0;
        sqlite3Put4byte((u8*)&aSalt[0], 1 + sqlite3Get4byte((u8*)&aSalt[0]));
        aSalt[1] = salt1;
        walIndexWriteHdr(pWal);
        pInfo->nBackfill = 0;
        for(i=1; i<(8 -3); i++) pInfo->aReadMark[i] = 0xffffffff;
        ((void) (0));
        walUnlockExclusive(pWal, (3+(1)), (8 -3)-1);
      }else if( rc!=5 ){
        return rc;
      }
    }
    walUnlockShared(pWal, (3+(0)));
    pWal->readLock = -1;
    cnt = 0;
    do{
      int notUsed;
      rc = walTryBeginRead(pWal, &notUsed, 1, ++cnt);
    }while( rc==(-1) );
    ((void) (0));
                                       ;
                                   ;
                             ;
  }
  return rc;
}





static int sqlite3WalFrames(
  Wal *pWal,
  int szPage,
  PgHdr *pList,
  Pgno nTruncate,
  int isCommit,
  int sync_flags
){
  int rc;
  u32 iFrame;
  u8 aFrame[24];
  PgHdr *p;
  PgHdr *pLast = 0;
  int nLast = 0;

  ((void) (0));
  ((void) (0));
# 45744 "ext/sqlite3/libsqlite/sqlite3.c"
  if( 0!=(rc = walRestartLog(pWal)) ){
    return rc;
  }





  iFrame = pWal->hdr.mxFrame;
  if( iFrame==0 ){
    u8 aWalHdr[32];
    u32 aCksum[2];

    sqlite3Put4byte(&aWalHdr[0], (0x377f0682 | 0));
    sqlite3Put4byte(&aWalHdr[4], 3007000);
    sqlite3Put4byte(&aWalHdr[8], szPage);
    sqlite3Put4byte(&aWalHdr[12], pWal->nCkpt);
    sqlite3_randomness(8, pWal->hdr.aSalt);
    memcpy(&aWalHdr[16], pWal->hdr.aSalt, 8);
    walChecksumBytes(1, aWalHdr, 32 -2*4, 0, aCksum);
    sqlite3Put4byte(&aWalHdr[24], aCksum[0]);
    sqlite3Put4byte(&aWalHdr[28], aCksum[1]);

    pWal->szPage = szPage;
    pWal->hdr.bigEndCksum = 0;
    pWal->hdr.aFrameCksum[0] = aCksum[0];
    pWal->hdr.aFrameCksum[1] = aCksum[1];

    rc = sqlite3OsWrite(pWal->pWalFd, aWalHdr, sizeof(aWalHdr), 0);
                                                                          ;
    if( rc!=0 ){
      return rc;
    }
  }
  ((void) (0));


  for(p=pList; p; p=p->pDirty){
    u32 nDbsize;
    i64 iOffset;
    void *pData;

    iOffset = ( 32 + ((++iFrame)-1)*(i64)((szPage)+24) );



    nDbsize = (isCommit && p->pDirty==0) ? nTruncate : 0;



    pData = p->pData;

    walEncodeFrame(pWal, p->pgno, nDbsize, pData, aFrame);
    rc = sqlite3OsWrite(pWal->pWalFd, aFrame, sizeof(aFrame), iOffset);
    if( rc!=0 ){
      return rc;
    }


    rc = sqlite3OsWrite(pWal->pWalFd, pData, szPage, iOffset+sizeof(aFrame));
    if( rc!=0 ){
      return rc;
    }
    pLast = p;
  }


  if( sync_flags ){
    i64 iSegment = sqlite3OsSectorSize(pWal->pWalFd);
    i64 iOffset = ( 32 + ((iFrame+1)-1)*(i64)((szPage)+24) );

    ((void) (0));
    ((void) (0));

    iSegment = (((iOffset+iSegment-1)/iSegment) * iSegment);
    while( iOffset<iSegment ){
      void *pData;



      pData = pLast->pData;

      walEncodeFrame(pWal, pLast->pgno, nTruncate, pData, aFrame);

      rc = sqlite3OsWrite(pWal->pWalFd, aFrame, sizeof(aFrame), iOffset);
      if( rc!=0 ){
        return rc;
      }
      iOffset += 24;
      rc = sqlite3OsWrite(pWal->pWalFd, pData, szPage, iOffset);
      if( rc!=0 ){
        return rc;
      }
      nLast++;
      iOffset += szPage;
    }

    rc = sqlite3OsSync(pWal->pWalFd, sync_flags);
  }






  iFrame = pWal->hdr.mxFrame;
  for(p=pList; p && rc==0; p=p->pDirty){
    iFrame++;
    rc = walIndexAppend(pWal, iFrame, p->pgno);
  }
  while( nLast>0 && rc==0 ){
    iFrame++;
    nLast--;
    rc = walIndexAppend(pWal, iFrame, pLast->pgno);
  }

  if( rc==0 ){

    pWal->hdr.szPage = (u16)((szPage&0xff00) | (szPage>>16));
                             ;
                             ;
    pWal->hdr.mxFrame = iFrame;
    if( isCommit ){
      pWal->hdr.iChange++;
      pWal->hdr.nPage = nTruncate;
    }

    if( isCommit ){
      walIndexWriteHdr(pWal);
      pWal->iCallback = iFrame;
    }
  }

                                                                   ;
  return rc;
}
# 45891 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3WalCheckpoint(
  Wal *pWal,
  int eMode,
  int (*xBusy)(void*),
  void *pBusyArg,
  int sync_flags,
  int nBuf,
  u8 *zBuf,
  int *pnLog,
  int *pnCkpt
){
  int rc;
  int isChanged = 0;
  int eMode2 = eMode;

  ((void) (0));
  ((void) (0));

                                                ;
  rc = walLockExclusive(pWal, 1, 1);
  if( rc ){



    return rc;
  }
  pWal->ckptLock = 1;
# 45928 "ext/sqlite3/libsqlite/sqlite3.c"
  if( eMode!=0 ){
    rc = walBusyLock(pWal, xBusy, pBusyArg, 0, 1);
    if( rc==0 ){
      pWal->writeLock = 1;
    }else if( rc==5 ){
      eMode2 = 0;
      rc = 0;
    }
  }


  if( rc==0 ){
    rc = walIndexReadHdr(pWal, &isChanged);
  }


  if( rc==0 ){
    if( pWal->hdr.mxFrame && walPagesize(pWal)!=nBuf ){
      rc = sqlite3CorruptError(45946);
    }else{
      rc = walCheckpoint(pWal, eMode2, xBusy, pBusyArg, sync_flags, zBuf);
    }


    if( rc==0 || rc==5 ){
      if( pnLog ) *pnLog = (int)pWal->hdr.mxFrame;
      if( pnCkpt ) *pnCkpt = (int)(walCkptInfo(pWal)->nBackfill);
    }
  }

  if( isChanged ){






    memset(&pWal->hdr, 0, sizeof(WalIndexHdr));
  }


  sqlite3WalEndWriteTransaction(pWal);
  walUnlockExclusive(pWal, 1, 1);
  pWal->ckptLock = 0;
                                                                  ;
  return (rc==0 && eMode!=eMode2 ? 5 : rc);
}






static int sqlite3WalCallback(Wal *pWal){
  u32 ret = 0;
  if( pWal ){
    ret = pWal->iCallback;
    pWal->iCallback = 0;
  }
  return (int)ret;
}
# 46014 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3WalExclusiveMode(Wal *pWal, int op){
  int rc;
  ((void) (0));
  ((void) (0));







  ((void) (0));
  ((void) (0));

  if( op==0 ){
    if( pWal->exclusiveMode ){
      pWal->exclusiveMode = 0;
      if( walLockShared(pWal, (3+(pWal->readLock)))!=0 ){
        pWal->exclusiveMode = 1;
      }
      rc = pWal->exclusiveMode==0;
    }else{

      rc = 0;
    }
  }else if( op>0 ){
    ((void) (0));
    ((void) (0));
    walUnlockShared(pWal, (3+(pWal->readLock)));
    pWal->exclusiveMode = 1;
    rc = 1;
  }else{
    rc = pWal->exclusiveMode==0;
  }
  return rc;
}






static int sqlite3WalHeapMemory(Wal *pWal){
  return (pWal && pWal->exclusiveMode==2 );
}
# 46312 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct MemPage MemPage;
typedef struct BtLock BtLock;
# 46353 "ext/sqlite3/libsqlite/sqlite3.c"
struct MemPage {
  u8 isInit;
  u8 nOverflow;
  u8 intKey;
  u8 leaf;
  u8 hasData;
  u8 hdrOffset;
  u8 childPtrSize;
  u16 maxLocal;
  u16 minLocal;
  u16 cellOffset;
  u16 nFree;
  u16 nCell;
  u16 maskPage;
  struct _OvflCell {
    u8 *pCell;
    u16 idx;
  } aOvfl[5];
  BtShared *pBt;
  u8 *aData;
  DbPage *pDbPage;
  Pgno pgno;
};
# 46391 "ext/sqlite3/libsqlite/sqlite3.c"
struct BtLock {
  Btree *pBtree;
  Pgno iTable;
  u8 eLock;
  BtLock *pNext;
};
# 46423 "ext/sqlite3/libsqlite/sqlite3.c"
struct Btree {
  sqlite3 *db;
  BtShared *pBt;
  u8 inTrans;
  u8 sharable;
  u8 locked;
  int wantToLock;
  int nBackup;
  Btree *pNext;
  Btree *pPrev;

  BtLock lock;

};
# 46484 "ext/sqlite3/libsqlite/sqlite3.c"
struct BtShared {
  Pager *pPager;
  sqlite3 *db;
  BtCursor *pCursor;
  MemPage *pPage1;
  u8 readOnly;
  u8 pageSizeFixed;
  u8 secureDelete;
  u8 initiallyEmpty;
  u8 openFlags;

  u8 autoVacuum;
  u8 incrVacuum;

  u8 inTransaction;
  u8 doNotUseWAL;
  u16 maxLocal;
  u16 minLocal;
  u16 maxLeaf;
  u16 minLeaf;
  u32 pageSize;
  u32 usableSize;
  int nTransaction;
  u32 nPage;
  void *pSchema;
  void (*xFreeSchema)(void*);
  sqlite3_mutex *mutex;
  Bitvec *pHasContent;

  int nRef;
  BtShared *pNext;
  BtLock *pLock;
  Btree *pWriter;
  u8 isExclusive;
  u8 isPending;

  u8 *pTmpSpace;
};






typedef struct CellInfo CellInfo;
struct CellInfo {
  i64 nKey;
  u8 *pCell;
  u32 nData;
  u32 nPayload;
  u16 nHeader;
  u16 nLocal;
  u16 iOverflow;
  u16 nSize;
};
# 46565 "ext/sqlite3/libsqlite/sqlite3.c"
struct BtCursor {
  Btree *pBtree;
  BtShared *pBt;
  BtCursor *pNext, *pPrev;
  struct KeyInfo *pKeyInfo;
  Pgno pgnoRoot;
  sqlite3_int64 cachedRowid;
  CellInfo info;
  i64 nKey;
  void *pKey;
  int skipNext;
  u8 wrFlag;
  u8 atLast;
  u8 validNKey;
  u8 eState;

  Pgno *aOverflow;
  u8 isIncrblobHandle;

  i16 iPage;
  u16 aiIdx[20];
  MemPage *apPage[20];
};
# 46706 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct IntegrityCk IntegrityCk;
struct IntegrityCk {
  BtShared *pBt;
  Pager *pPager;
  Pgno nPage;
  int *anRef;
  int mxErr;
  int nErr;
  int mallocFailed;
  StrAccum errMsg;
};
# 46983 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3BtreeEnter(Btree *p){
  p->pBt->db = p->db;
}
static void sqlite3BtreeEnterAll(sqlite3 *db){
  int i;
  for(i=0; i<db->nDb; i++){
    Btree *p = db->aDb[i].pBt;
    if( p ){
      p->pBt->db = p->db;
    }
  }
}
# 47020 "ext/sqlite3/libsqlite/sqlite3.c"
static const char zMagicHeader[] = "SQLite format 3";
# 47056 "ext/sqlite3/libsqlite/sqlite3.c"
static BtShared * sqlite3SharedCacheList = 0;
# 47068 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_enable_shared_cache(int enable){
  sqlite3Config.sharedCacheEnabled = enable;
  return 0;
}
# 47220 "ext/sqlite3/libsqlite/sqlite3.c"
static int querySharedCacheTableLock(Btree *p, Pgno iTab, u8 eLock){
  BtShared *pBt = p->pBt;
  BtLock *pIter;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));





  ((void) (0));
  ((void) (0));


  if( !p->sharable ){
    return 0;
  }




  if( pBt->pWriter!=p && pBt->isExclusive ){
                                                     ;
    return (6 | (1<<8));
  }

  for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){
# 47259 "ext/sqlite3/libsqlite/sqlite3.c"
    ((void) (0));
    ((void) (0));
    if( pIter->pBtree!=p && pIter->iTable==iTab && pIter->eLock!=eLock ){
                                                        ;
      if( eLock==2 ){
        ((void) (0));
        pBt->isPending = 1;
      }
      return (6 | (1<<8));
    }
  }
  return 0;
}
# 47292 "ext/sqlite3/libsqlite/sqlite3.c"
static int setSharedCacheTableLock(Btree *p, Pgno iTable, u8 eLock){
  BtShared *pBt = p->pBt;
  BtLock *pLock = 0;
  BtLock *pIter;

  ((void) (0));
  ((void) (0));
  ((void) (0));





  ((void) (0));



  ((void) (0));
  ((void) (0));


  for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){
    if( pIter->iTable==iTable && pIter->pBtree==p ){
      pLock = pIter;
      break;
    }
  }




  if( !pLock ){
    pLock = (BtLock *)sqlite3MallocZero(sizeof(BtLock));
    if( !pLock ){
      return 7;
    }
    pLock->iTable = iTable;
    pLock->pBtree = p;
    pLock->pNext = pBt->pLock;
    pBt->pLock = pLock;
  }





  ((void) (0));
  if( eLock>pLock->eLock ){
    pLock->eLock = eLock;
  }

  return 0;
}
# 47356 "ext/sqlite3/libsqlite/sqlite3.c"
static void clearAllSharedCacheTableLocks(Btree *p){
  BtShared *pBt = p->pBt;
  BtLock **ppIter = &pBt->pLock;

  ((void) (0));
  ((void) (0));
  ((void) (0));

  while( *ppIter ){
    BtLock *pLock = *ppIter;
    ((void) (0));
    ((void) (0));
    if( pLock->pBtree==p ){
      *ppIter = pLock->pNext;
      ((void) (0));
      if( pLock->iTable!=1 ){
        sqlite3_free(pLock);
      }
    }else{
      ppIter = &pLock->pNext;
    }
  }

  ((void) (0));
  if( pBt->pWriter==p ){
    pBt->pWriter = 0;
    pBt->isExclusive = 0;
    pBt->isPending = 0;
  }else if( pBt->nTransaction==2 ){
# 47394 "ext/sqlite3/libsqlite/sqlite3.c"
    pBt->isPending = 0;
  }
}




static void downgradeAllSharedCacheTableLocks(Btree *p){
  BtShared *pBt = p->pBt;
  if( pBt->pWriter==p ){
    BtLock *pLock;
    pBt->pWriter = 0;
    pBt->isExclusive = 0;
    pBt->isPending = 0;
    for(pLock=pBt->pLock; pLock; pLock=pLock->pNext){
      ((void) (0));
      pLock->eLock = 1;
    }
  }
}



static void releasePage(MemPage *pPage);
# 47435 "ext/sqlite3/libsqlite/sqlite3.c"
static void invalidateOverflowCache(BtCursor *pCur){
  ((void) (0));
  sqlite3_free(pCur->aOverflow);
  pCur->aOverflow = 0;
}





static void invalidateAllOverflowCache(BtShared *pBt){
  BtCursor *p;
  ((void) (0));
  for(p=pBt->pCursor; p; p=p->pNext){
    invalidateOverflowCache(p);
  }
}
# 47466 "ext/sqlite3/libsqlite/sqlite3.c"
static void invalidateIncrblobCursors(
  Btree *pBtree,
  i64 iRow,
  int isClearTable
){
  BtCursor *p;
  BtShared *pBt = pBtree->pBt;
  ((void) (0));
  for(p=pBt->pCursor; p; p=p->pNext){
    if( p->isIncrblobHandle && (isClearTable || p->info.nKey==iRow) ){
      p->eState = 0;
    }
  }
}
# 47523 "ext/sqlite3/libsqlite/sqlite3.c"
static int btreeSetHasContent(BtShared *pBt, Pgno pgno){
  int rc = 0;
  if( !pBt->pHasContent ){
    ((void) (0));
    pBt->pHasContent = sqlite3BitvecCreate(pBt->nPage);
    if( !pBt->pHasContent ){
      rc = 7;
    }
  }
  if( rc==0 && pgno<=sqlite3BitvecSize(pBt->pHasContent) ){
    rc = sqlite3BitvecSet(pBt->pHasContent, pgno);
  }
  return rc;
}
# 47545 "ext/sqlite3/libsqlite/sqlite3.c"
static int btreeGetHasContent(BtShared *pBt, Pgno pgno){
  Bitvec *p = pBt->pHasContent;
  return (p && (pgno>sqlite3BitvecSize(p) || sqlite3BitvecTest(p, pgno)));
}





static void btreeClearHasContent(BtShared *pBt){
  sqlite3BitvecDestroy(pBt->pHasContent);
  pBt->pHasContent = 0;
}
# 47566 "ext/sqlite3/libsqlite/sqlite3.c"
static int saveCursorPosition(BtCursor *pCur){
  int rc;

  ((void) (0));
  ((void) (0));
  ((void) (0));

  rc = sqlite3BtreeKeySize(pCur, &pCur->nKey);
  ((void) (0));







  if( 0==pCur->apPage[0]->intKey ){
    void *pKey = sqlite3Malloc( (int)pCur->nKey );
    if( pKey ){
      rc = sqlite3BtreeKey(pCur, 0, (int)pCur->nKey, pKey);
      if( rc==0 ){
        pCur->pKey = pKey;
      }else{
        sqlite3_free(pKey);
      }
    }else{
      rc = 7;
    }
  }
  ((void) (0));

  if( rc==0 ){
    int i;
    for(i=0; i<=pCur->iPage; i++){
      releasePage(pCur->apPage[i]);
      pCur->apPage[i] = 0;
    }
    pCur->iPage = -1;
    pCur->eState = 2;
  }

  invalidateOverflowCache(pCur);
  return rc;
}






static int saveAllCursors(BtShared *pBt, Pgno iRoot, BtCursor *pExcept){
  BtCursor *p;
  ((void) (0));
  ((void) (0));
  for(p=pBt->pCursor; p; p=p->pNext){
    if( p!=pExcept && (0==iRoot || p->pgnoRoot==iRoot) &&
        p->eState==1 ){
      int rc = saveCursorPosition(p);
      if( 0!=rc ){
        return rc;
      }
    }
  }
  return 0;
}




static void sqlite3BtreeClearCursor(BtCursor *pCur){
  ((void) (0));
  sqlite3_free(pCur->pKey);
  pCur->pKey = 0;
  pCur->eState = 0;
}






static int btreeMoveto(
  BtCursor *pCur,
  const void *pKey,
  i64 nKey,
  int bias,
  int *pRes
){
  int rc;
  UnpackedRecord *pIdxKey;
  char aSpace[150];

  if( pKey ){
    ((void) (0));
    pIdxKey = sqlite3VdbeRecordUnpack(pCur->pKeyInfo, (int)nKey, pKey,
                                      aSpace, sizeof(aSpace));
    if( pIdxKey==0 ) return 7;
  }else{
    pIdxKey = 0;
  }
  rc = sqlite3BtreeMovetoUnpacked(pCur, pIdxKey, nKey, bias, pRes);
  if( pKey ){
    sqlite3VdbeDeleteUnpackedRecord(pIdxKey);
  }
  return rc;
}
# 47680 "ext/sqlite3/libsqlite/sqlite3.c"
static int btreeRestoreCursorPosition(BtCursor *pCur){
  int rc;
  ((void) (0));
  ((void) (0));
  if( pCur->eState==3 ){
    return pCur->skipNext;
  }
  pCur->eState = 0;
  rc = btreeMoveto(pCur, pCur->pKey, pCur->nKey, 0, &pCur->skipNext);
  if( rc==0 ){
    sqlite3_free(pCur->pKey);
    pCur->pKey = 0;
    ((void) (0));
  }
  return rc;
}
# 47710 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeCursorHasMoved(BtCursor *pCur, int *pHasMoved){
  int rc;

  rc = (pCur->eState>=2 ? btreeRestoreCursorPosition(pCur) : 0);
  if( rc ){
    *pHasMoved = 1;
    return rc;
  }
  if( pCur->eState!=1 || pCur->skipNext!=0 ){
    *pHasMoved = 1;
  }else{
    *pHasMoved = 0;
  }
  return 0;
}
# 47736 "ext/sqlite3/libsqlite/sqlite3.c"
static Pgno ptrmapPageno(BtShared *pBt, Pgno pgno){
  int nPagesPerMapPage;
  Pgno iPtrMap, ret;
  ((void) (0));
  if( pgno<2 ) return 0;
  nPagesPerMapPage = (pBt->usableSize/5)+1;
  iPtrMap = (pgno-2)/nPagesPerMapPage;
  ret = (iPtrMap*nPagesPerMapPage) + 2;
  if( ret==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){
    ret++;
  }
  return ret;
}
# 47760 "ext/sqlite3/libsqlite/sqlite3.c"
static void ptrmapPut(BtShared *pBt, Pgno key, u8 eType, Pgno parent, int *pRC){
  DbPage *pDbPage;
  u8 *pPtrmap;
  Pgno iPtrmap;
  int offset;
  int rc;

  if( *pRC ) return;

  ((void) (0));

  ((void) (0));

  ((void) (0));
  if( key==0 ){
    *pRC = sqlite3CorruptError(47775);
    return;
  }
  iPtrmap = ptrmapPageno(pBt, key);
  rc = sqlite3PagerAcquire(pBt->pPager,iPtrmap,&pDbPage,0);
  if( rc!=0 ){
    *pRC = rc;
    return;
  }
  offset = (5*(key-iPtrmap-1));
  if( offset<0 ){
    *pRC = sqlite3CorruptError(47786);
    goto ptrmap_exit;
  }
  pPtrmap = (u8 *)sqlite3PagerGetData(pDbPage);

  if( eType!=pPtrmap[offset] || sqlite3Get4byte(&pPtrmap[offset+1])!=parent ){
                                                               ;
    *pRC= rc = sqlite3PagerWrite(pDbPage);
    if( rc==0 ){
      pPtrmap[offset] = eType;
      sqlite3Put4byte(&pPtrmap[offset+1], parent);
    }
  }

ptrmap_exit:
  sqlite3PagerUnref(pDbPage);
}
# 47811 "ext/sqlite3/libsqlite/sqlite3.c"
static int ptrmapGet(BtShared *pBt, Pgno key, u8 *pEType, Pgno *pPgno){
  DbPage *pDbPage;
  int iPtrmap;
  u8 *pPtrmap;
  int offset;
  int rc;

  ((void) (0));

  iPtrmap = ptrmapPageno(pBt, key);
  rc = sqlite3PagerAcquire(pBt->pPager,iPtrmap,&pDbPage,0);
  if( rc!=0 ){
    return rc;
  }
  pPtrmap = (u8 *)sqlite3PagerGetData(pDbPage);

  offset = (5*(key-iPtrmap-1));
  ((void) (0));
  *pEType = pPtrmap[offset];
  if( pPgno ) *pPgno = sqlite3Get4byte(&pPtrmap[offset+1]);

  sqlite3PagerUnref(pDbPage);
  if( *pEType<1 || *pEType>5 ) return sqlite3CorruptError(47833);
  return 0;
}
# 47857 "ext/sqlite3/libsqlite/sqlite3.c"
static u8 *findOverflowCell(MemPage *pPage, int iCell){
  int i;
  ((void) (0));
  for(i=pPage->nOverflow-1; i>=0; i--){
    int k;
    struct _OvflCell *pOvfl;
    pOvfl = &pPage->aOvfl[i];
    k = pOvfl->idx;
    if( k<=iCell ){
      if( k==iCell ){
        return pOvfl->pCell;
      }
      iCell--;
    }
  }
  return ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aData[(pPage)->cellOffset+2*(iCell)])[0]<<8 | (&(pPage)->aData[(pPage)->cellOffset+2*(iCell)])[1])));
}
# 47884 "ext/sqlite3/libsqlite/sqlite3.c"
static void btreeParseCellPtr(
  MemPage *pPage,
  u8 *pCell,
  CellInfo *pInfo
){
  u16 n;
  u32 nPayload;

  ((void) (0));

  pInfo->pCell = pCell;
  ((void) (0));
  n = pPage->childPtrSize;
  ((void) (0));
  if( pPage->intKey ){
    if( pPage->hasData ){
      n += (u8)((*(&pCell[n])<(u8)0x80) ? ((nPayload) = (u32)*(&pCell[n])),1 : sqlite3GetVarint32((&pCell[n]), (u32 *)&(nPayload)));
    }else{
      nPayload = 0;
    }
    n += sqlite3GetVarint(&pCell[n], (u64*)&pInfo->nKey);
    pInfo->nData = nPayload;
  }else{
    pInfo->nData = 0;
    n += (u8)((*(&pCell[n])<(u8)0x80) ? ((nPayload) = (u32)*(&pCell[n])),1 : sqlite3GetVarint32((&pCell[n]), (u32 *)&(nPayload)));
    pInfo->nKey = nPayload;
  }
  pInfo->nPayload = nPayload;
  pInfo->nHeader = n;
                                       ;
                                         ;
  if( !!(nPayload<=pPage->maxLocal) ){



    if( (pInfo->nSize = (u16)(n+nPayload))<4 ) pInfo->nSize = 4;
    pInfo->nLocal = (u16)nPayload;
    pInfo->iOverflow = 0;
  }else{
# 47932 "ext/sqlite3/libsqlite/sqlite3.c"
    int minLocal;
    int maxLocal;
    int surplus;

    minLocal = pPage->minLocal;
    maxLocal = pPage->maxLocal;
    surplus = minLocal + (nPayload - minLocal)%(pPage->pBt->usableSize - 4);
                                 ;
                                   ;
    if( surplus <= maxLocal ){
      pInfo->nLocal = (u16)surplus;
    }else{
      pInfo->nLocal = (u16)minLocal;
    }
    pInfo->iOverflow = (u16)(pInfo->nLocal + n);
    pInfo->nSize = pInfo->iOverflow + 4;
  }
}


static void btreeParseCell(
  MemPage *pPage,
  int iCell,
  CellInfo *pInfo
){
  btreeParseCellPtr((pPage), (((pPage))->aData + (((pPage))->maskPage & ((&((pPage))->aData[((pPage))->cellOffset+2*((iCell))])[0]<<8 | (&((pPage))->aData[((pPage))->cellOffset+2*((iCell))])[1]))), (pInfo));
}







static u16 cellSizePtr(MemPage *pPage, u8 *pCell){
  u8 *pIter = &pCell[pPage->childPtrSize];
  u32 nSize;
# 47979 "ext/sqlite3/libsqlite/sqlite3.c"
  if( pPage->intKey ){
    u8 *pEnd;
    if( pPage->hasData ){
      pIter += (u8)((*(pIter)<(u8)0x80) ? ((nSize) = (u32)*(pIter)),1 : sqlite3GetVarint32((pIter), (u32 *)&(nSize)));
    }else{
      nSize = 0;
    }




    pEnd = &pIter[9];
    while( (*pIter++)&0x80 && pIter<pEnd );
  }else{
    pIter += (u8)((*(pIter)<(u8)0x80) ? ((nSize) = (u32)*(pIter)),1 : sqlite3GetVarint32((pIter), (u32 *)&(nSize)));
  }

                                    ;
                                      ;
  if( nSize>pPage->maxLocal ){
    int minLocal = pPage->minLocal;
    nSize = minLocal + (nSize - minLocal) % (pPage->pBt->usableSize - 4);
                                      ;
                                        ;
    if( nSize>pPage->maxLocal ){
      nSize = minLocal;
    }
    nSize += 4;
  }
  nSize += (u32)(pIter - pCell);


  if( nSize<4 ){
    nSize = 4;
  }

  ((void) (0));
  return (u16)nSize;
}
# 48033 "ext/sqlite3/libsqlite/sqlite3.c"
static void ptrmapPutOvflPtr(MemPage *pPage, u8 *pCell, int *pRC){
  CellInfo info;
  if( *pRC ) return;
  ((void) (0));
  btreeParseCellPtr(pPage, pCell, &info);
  ((void) (0));
  if( info.iOverflow ){
    Pgno ovfl = sqlite3Get4byte(&pCell[info.iOverflow]);
    ptrmapPut(pPage->pBt, ovfl, 3, pPage->pgno, pRC);
  }
}
# 48053 "ext/sqlite3/libsqlite/sqlite3.c"
static int defragmentPage(MemPage *pPage){
  int i;
  int pc;
  int hdr;
  int size;
  int usableSize;
  int cellOffset;
  int cbrk;
  int nCell;
  unsigned char *data;
  unsigned char *temp;
  int iCellFirst;
  int iCellLast;


  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  temp = sqlite3PagerTempSpace(pPage->pBt->pPager);
  data = pPage->aData;
  hdr = pPage->hdrOffset;
  cellOffset = pPage->cellOffset;
  nCell = pPage->nCell;
  ((void) (0));
  usableSize = pPage->pBt->usableSize;
  cbrk = ((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]);
  memcpy(&temp[cbrk], &data[cbrk], usableSize - cbrk);
  cbrk = usableSize;
  iCellFirst = cellOffset + 2*nCell;
  iCellLast = usableSize - 4;
  for(i=0; i<nCell; i++){
    u8 *pAddr;
    pAddr = &data[cellOffset + i*2];
    pc = ((pAddr)[0]<<8 | (pAddr)[1]);
                              ;
                             ;




    if( pc<iCellFirst || pc>iCellLast ){
      return sqlite3CorruptError(48096);
    }

    ((void) (0));
    size = cellSizePtr(pPage, &temp[pc]);
    cbrk -= size;





    if( cbrk<iCellFirst || pc+size>usableSize ){
      return sqlite3CorruptError(48108);
    }

    ((void) (0));
                                     ;
                                   ;
    memcpy(&data[cbrk], &temp[pc], size);
    ((pAddr)[0] = (u8)((cbrk)>>8), (pAddr)[1] = (u8)(cbrk));
  }
  ((void) (0));
  ((&data[hdr+5])[0] = (u8)((cbrk)>>8), (&data[hdr+5])[1] = (u8)(cbrk));
  data[hdr+1] = 0;
  data[hdr+2] = 0;
  data[hdr+7] = 0;
  memset(&data[iCellFirst], 0, cbrk-iCellFirst);
  ((void) (0));
  if( cbrk-iCellFirst!=pPage->nFree ){
    return sqlite3CorruptError(48125);
  }
  return 0;
}
# 48143 "ext/sqlite3/libsqlite/sqlite3.c"
static int allocateSpace(MemPage *pPage, int nByte, int *pIdx){
  const int hdr = pPage->hdrOffset;
  u8 * const data = pPage->aData;
  int nFrag;
  int top;
  int gap;
  int rc;
  int usableSize;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  usableSize = pPage->pBt->usableSize;
  ((void) (0));

  nFrag = data[hdr+7];
  ((void) (0));
  gap = pPage->cellOffset + 2*pPage->nCell;
  top = (((((int)((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]))-1)&0xffff)+1);
  if( gap>top ) return sqlite3CorruptError(48165);
                        ;
                        ;
                      ;

  if( nFrag>=60 ){

    rc = defragmentPage(pPage);
    if( rc ) return rc;
    top = (((((int)((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]))-1)&0xffff)+1);
  }else if( gap+2<=top ){




    int pc, addr;
    for(addr=hdr+1; (pc = ((&data[addr])[0]<<8 | (&data[addr])[1]))>0; addr=pc){
      int size;
      if( pc>usableSize-4 || pc<addr+4 ){
        return sqlite3CorruptError(48184);
      }
      size = ((&data[pc+2])[0]<<8 | (&data[pc+2])[1]);
      if( size>=nByte ){
        int x = size - nByte;
                        ;
                        ;
        if( x<4 ){


          memcpy(&data[addr], &data[pc], 2);
          data[hdr+7] = (u8)(nFrag + x);
        }else if( size+pc > usableSize ){
          return sqlite3CorruptError(48197);
        }else{


          ((&data[pc+2])[0] = (u8)((x)>>8), (&data[pc+2])[1] = (u8)(x));
        }
        *pIdx = pc + x;
        return 0;
      }
    }
  }




                              ;
  if( gap+2+nByte>top ){
    rc = defragmentPage(pPage);
    if( rc ) return rc;
    top = (((((int)((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]))-1)&0xffff)+1);
    ((void) (0));
  }
# 48227 "ext/sqlite3/libsqlite/sqlite3.c"
  top -= nByte;
  ((&data[hdr+5])[0] = (u8)((top)>>8), (&data[hdr+5])[1] = (u8)(top));
  ((void) (0));
  *pIdx = top;
  return 0;
}
# 48242 "ext/sqlite3/libsqlite/sqlite3.c"
static int freeSpace(MemPage *pPage, int start, int size){
  int addr, pbegin, hdr;
  int iLast;
  unsigned char *data = pPage->aData;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( pPage->pBt->secureDelete ){


    memset(&data[start], 0, size);
  }
# 48269 "ext/sqlite3/libsqlite/sqlite3.c"
  hdr = pPage->hdrOffset;
  addr = hdr + 1;
  iLast = pPage->pBt->usableSize - 4;
  ((void) (0));
  while( (pbegin = ((&data[addr])[0]<<8 | (&data[addr])[1]))<start && pbegin>0 ){
    if( pbegin<addr+4 ){
      return sqlite3CorruptError(48275);
    }
    addr = pbegin;
  }
  if( pbegin>iLast ){
    return sqlite3CorruptError(48280);
  }
  ((void) (0));
  ((&data[addr])[0] = (u8)((start)>>8), (&data[addr])[1] = (u8)(start));
  ((&data[start])[0] = (u8)((pbegin)>>8), (&data[start])[1] = (u8)(pbegin));
  ((&data[start+2])[0] = (u8)((size)>>8), (&data[start+2])[1] = (u8)(size));
  pPage->nFree = pPage->nFree + (u16)size;


  addr = hdr + 1;
  while( (pbegin = ((&data[addr])[0]<<8 | (&data[addr])[1]))>0 ){
    int pnext, psize, x;
    ((void) (0));
    ((void) (0));
    pnext = ((&data[pbegin])[0]<<8 | (&data[pbegin])[1]);
    psize = ((&data[pbegin+2])[0]<<8 | (&data[pbegin+2])[1]);
    if( pbegin + psize + 3 >= pnext && pnext>0 ){
      int frag = pnext - (pbegin+psize);
      if( (frag<0) || (frag>(int)data[hdr+7]) ){
        return sqlite3CorruptError(48299);
      }
      data[hdr+7] -= (u8)frag;
      x = ((&data[pnext])[0]<<8 | (&data[pnext])[1]);
      ((&data[pbegin])[0] = (u8)((x)>>8), (&data[pbegin])[1] = (u8)(x));
      x = pnext + ((&data[pnext+2])[0]<<8 | (&data[pnext+2])[1]) - pbegin;
      ((&data[pbegin+2])[0] = (u8)((x)>>8), (&data[pbegin+2])[1] = (u8)(x));
    }else{
      addr = pbegin;
    }
  }


  if( data[hdr+1]==data[hdr+5] && data[hdr+2]==data[hdr+6] ){
    int top;
    pbegin = ((&data[hdr+1])[0]<<8 | (&data[hdr+1])[1]);
    memcpy(&data[hdr+1], &data[pbegin], 2);
    top = ((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]) + ((&data[pbegin+2])[0]<<8 | (&data[pbegin+2])[1]);
    ((&data[hdr+5])[0] = (u8)((top)>>8), (&data[hdr+5])[1] = (u8)(top));
  }
  ((void) (0));
  return 0;
}
# 48335 "ext/sqlite3/libsqlite/sqlite3.c"
static int decodeFlags(MemPage *pPage, int flagByte){
  BtShared *pBt;

  ((void) (0));
  ((void) (0));
  pPage->leaf = (u8)(flagByte>>3); ((void) (0));
  flagByte &= ~0x08;
  pPage->childPtrSize = 4-4*pPage->leaf;
  pBt = pPage->pBt;
  if( flagByte==(0x04 | 0x01) ){
    pPage->intKey = 1;
    pPage->hasData = pPage->leaf;
    pPage->maxLocal = pBt->maxLeaf;
    pPage->minLocal = pBt->minLeaf;
  }else if( flagByte==0x02 ){
    pPage->intKey = 0;
    pPage->hasData = 0;
    pPage->maxLocal = pBt->maxLocal;
    pPage->minLocal = pBt->minLocal;
  }else{
    return sqlite3CorruptError(48355);
  }
  return 0;
}
# 48369 "ext/sqlite3/libsqlite/sqlite3.c"
static int btreeInitPage(MemPage *pPage){

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( !pPage->isInit ){
    u16 pc;
    u8 hdr;
    u8 *data;
    BtShared *pBt;
    int usableSize;
    u16 cellOffset;
    int nFree;
    int top;
    int iCellFirst;
    int iCellLast;

    pBt = pPage->pBt;

    hdr = pPage->hdrOffset;
    data = pPage->aData;
    if( decodeFlags(pPage, data[hdr]) ) return sqlite3CorruptError(48393);
    ((void) (0));
    pPage->maskPage = (u16)(pBt->pageSize - 1);
    pPage->nOverflow = 0;
    usableSize = pBt->usableSize;
    pPage->cellOffset = cellOffset = hdr + 12 - 4*pPage->leaf;
    top = (((((int)((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]))-1)&0xffff)+1);
    pPage->nCell = ((&data[hdr+3])[0]<<8 | (&data[hdr+3])[1]);
    if( pPage->nCell>((pBt->pageSize-8)/6) ){

      return sqlite3CorruptError(48403);
    }
                                          ;
# 48414 "ext/sqlite3/libsqlite/sqlite3.c"
    iCellFirst = cellOffset + 2*pPage->nCell;
    iCellLast = usableSize - 4;
# 48440 "ext/sqlite3/libsqlite/sqlite3.c"
    pc = ((&data[hdr+1])[0]<<8 | (&data[hdr+1])[1]);
    nFree = data[hdr+7] + top;
    while( pc>0 ){
      u16 next, size;
      if( pc<iCellFirst || pc>iCellLast ){

        return sqlite3CorruptError(48446);
      }
      next = ((&data[pc])[0]<<8 | (&data[pc])[1]);
      size = ((&data[pc+2])[0]<<8 | (&data[pc+2])[1]);
      if( (next>0 && next<=pc+size+3) || pc+size>usableSize ){


        return sqlite3CorruptError(48453);
      }
      nFree = nFree + size;
      pc = next;
    }
# 48466 "ext/sqlite3/libsqlite/sqlite3.c"
    if( nFree>usableSize ){
      return sqlite3CorruptError(48467);
    }
    pPage->nFree = (u16)(nFree - iCellFirst);
    pPage->isInit = 1;
  }
  return 0;
}





static void zeroPage(MemPage *pPage, int flags){
  unsigned char *data = pPage->aData;
  BtShared *pBt = pPage->pBt;
  u8 hdr = pPage->hdrOffset;
  u16 first;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pBt->secureDelete ){
    memset(&data[hdr], 0, pBt->usableSize - hdr);
  }
  data[hdr] = (char)flags;
  first = hdr + 8 + 4*((flags&0x08)==0 ?1:0);
  memset(&data[hdr+1], 0, 4);
  data[hdr+7] = 0;
  ((&data[hdr+5])[0] = (u8)((pBt->usableSize)>>8), (&data[hdr+5])[1] = (u8)(pBt->usableSize));
  pPage->nFree = (u16)(pBt->usableSize - first);
  decodeFlags(pPage, flags);
  pPage->hdrOffset = hdr;
  pPage->cellOffset = first;
  pPage->nOverflow = 0;
  ((void) (0));
  pPage->maskPage = (u16)(pBt->pageSize - 1);
  pPage->nCell = 0;
  pPage->isInit = 1;
}






static MemPage *btreePageFromDbPage(DbPage *pDbPage, Pgno pgno, BtShared *pBt){
  MemPage *pPage = (MemPage*)sqlite3PagerGetExtra(pDbPage);
  pPage->aData = sqlite3PagerGetData(pDbPage);
  pPage->pDbPage = pDbPage;
  pPage->pBt = pBt;
  pPage->pgno = pgno;
  pPage->hdrOffset = pPage->pgno==1 ? 100 : 0;
  return pPage;
}
# 48535 "ext/sqlite3/libsqlite/sqlite3.c"
static int btreeGetPage(
  BtShared *pBt,
  Pgno pgno,
  MemPage **ppPage,
  int noContent
){
  int rc;
  DbPage *pDbPage;

  ((void) (0));
  rc = sqlite3PagerAcquire(pBt->pPager, pgno, (DbPage**)&pDbPage, noContent);
  if( rc ) return rc;
  *ppPage = btreePageFromDbPage(pDbPage, pgno, pBt);
  return 0;
}






static MemPage *btreePageLookup(BtShared *pBt, Pgno pgno){
  DbPage *pDbPage;
  ((void) (0));
  pDbPage = sqlite3PagerLookup(pBt->pPager, pgno);
  if( pDbPage ){
    return btreePageFromDbPage(pDbPage, pgno, pBt);
  }
  return 0;
}





static Pgno btreePagecount(BtShared *pBt){
  return pBt->nPage;
}
static u32 sqlite3BtreeLastPage(Btree *p){
  ((void) (0));
  ((void) (0));
  return (int)btreePagecount(p->pBt);
}
# 48587 "ext/sqlite3/libsqlite/sqlite3.c"
static int getAndInitPage(
  BtShared *pBt,
  Pgno pgno,
  MemPage **ppPage
){
  int rc;
  ((void) (0));

  if( pgno>btreePagecount(pBt) ){
    rc = sqlite3CorruptError(48596);
  }else{
    rc = btreeGetPage(pBt, pgno, ppPage, 0);
    if( rc==0 ){
      rc = btreeInitPage(*ppPage);
      if( rc!=0 ){
        releasePage(*ppPage);
      }
    }
  }

                     ;
  ((void) (0));
  return rc;
}





static void releasePage(MemPage *pPage){
  if( pPage ){
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    sqlite3PagerUnref(pPage->pDbPage);
  }
}
# 48635 "ext/sqlite3/libsqlite/sqlite3.c"
static void pageReinit(DbPage *pData){
  MemPage *pPage;
  pPage = (MemPage *)sqlite3PagerGetExtra(pData);
  ((void) (0));
  if( pPage->isInit ){
    ((void) (0));
    pPage->isInit = 0;
    if( sqlite3PagerPageRefcount(pData)>1 ){






      btreeInitPage(pPage);
    }
  }
}




static int btreeInvokeBusyHandler(void *pArg){
  BtShared *pBt = (BtShared*)pArg;
  ((void) (0));
  ((void) (0));
  return sqlite3InvokeBusyHandler(&pBt->db->busyHandler);
}
# 48688 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeOpen(
  const char *zFilename,
  sqlite3 *db,
  Btree **ppBtree,
  int flags,
  int vfsFlags
){
  sqlite3_vfs *pVfs;
  BtShared *pBt = 0;
  Btree *p;
  sqlite3_mutex *mutexOpen = 0;
  int rc = 0;
  u8 nReserve;
  unsigned char zDbHeader[100];


  const int isTempDb = zFilename==0 || zFilename[0]==0;







  const int isMemdb = (zFilename && __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (zFilename) && __builtin_constant_p (":memory:") && (__s1_len = __builtin_strlen (zFilename), __s2_len = __builtin_strlen (":memory:"), (!((size_t)(const void *)((zFilename) + 1) - (size_t)(const void *)(zFilename) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((":memory:") + 1) - (size_t)(const void *)(":memory:") == 1) || __s2_len >= 4)) ? __builtin_strcmp (zFilename, ":memory:") : (__builtin_constant_p (zFilename) && ((size_t)(const void *)((zFilename) + 1) - (size_t)(const void *)(zFilename) == 1) && (__s1_len = __builtin_strlen (zFilename), __s1_len < 4) ? (__builtin_constant_p (":memory:") && ((size_t)(const void *)((":memory:") + 1) - (size_t)(const void *)(":memory:") == 1) ? __builtin_strcmp (zFilename, ":memory:") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (":memory:"); int __result = (((const unsigned char *) (const char *) (zFilename))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (zFilename))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (zFilename))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (zFilename))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (":memory:") && ((size_t)(const void *)((":memory:") + 1) - (size_t)(const void *)(":memory:") == 1) && (__s2_len = __builtin_strlen (":memory:"), __s2_len < 4) ? (__builtin_constant_p (zFilename) && ((size_t)(const void *)((zFilename) + 1) - (size_t)(const void *)(zFilename) == 1) ? __builtin_strcmp (zFilename, ":memory:") : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (zFilename); int __result = (((const unsigned char *) (const char *) (":memory:"))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (":memory:"))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (":memory:"))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (":memory:"))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (zFilename, ":memory:")))); })==0)
                       || (isTempDb && sqlite3TempInMemory(db));


  ((void) (0));
  ((void) (0));
  ((void) (0));


  ((void) (0));


  ((void) (0));

  if( db->flags & 0x00020000 ){
    flags |= 2;
  }
  if( isMemdb ){
    flags |= 4;
  }
  if( (vfsFlags & 0x00000100)!=0 && (isMemdb || isTempDb) ){
    vfsFlags = (vfsFlags & ~0x00000100) | 0x00000200;
  }
  pVfs = db->pVfs;
  p = sqlite3MallocZero(sizeof(Btree));
  if( !p ){
    return 7;
  }
  p->inTrans = 0;
  p->db = db;

  p->lock.pBtree = p;
  p->lock.iTable = 1;







  if( isMemdb==0 && isTempDb==0 ){
    if( vfsFlags & 0x00020000 ){
      int nFullPathname = pVfs->mxPathname+1;
      char *zFullPathname = sqlite3Malloc(nFullPathname);
      sqlite3_mutex *mutexShared;
      p->sharable = 1;
      if( !zFullPathname ){
        sqlite3_free(p);
        return 7;
      }
      sqlite3OsFullPathname(pVfs, zFilename, nFullPathname, zFullPathname);
      mutexOpen = ((sqlite3_mutex*)8);
                                    ;
      mutexShared = ((sqlite3_mutex*)8);
                                      ;
      for(pBt=sqlite3SharedCacheList; pBt; pBt=pBt->pNext){
        ((void) (0));
        if( 0==__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (zFullPathname) && __builtin_constant_p (sqlite3PagerFilename(pBt->pPager)) && (__s1_len = __builtin_strlen (zFullPathname), __s2_len = __builtin_strlen (sqlite3PagerFilename(pBt->pPager)), (!((size_t)(const void *)((zFullPathname) + 1) - (size_t)(const void *)(zFullPathname) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((sqlite3PagerFilename(pBt->pPager)) + 1) - (size_t)(const void *)(sqlite3PagerFilename(pBt->pPager)) == 1) || __s2_len >= 4)) ? __builtin_strcmp (zFullPathname, sqlite3PagerFilename(pBt->pPager)) : (__builtin_constant_p (zFullPathname) && ((size_t)(const void *)((zFullPathname) + 1) - (size_t)(const void *)(zFullPathname) == 1) && (__s1_len = __builtin_strlen (zFullPathname), __s1_len < 4) ? (__builtin_constant_p (sqlite3PagerFilename(pBt->pPager)) && ((size_t)(const void *)((sqlite3PagerFilename(pBt->pPager)) + 1) - (size_t)(const void *)(sqlite3PagerFilename(pBt->pPager)) == 1) ? __builtin_strcmp (zFullPathname, sqlite3PagerFilename(pBt->pPager)) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (sqlite3PagerFilename(pBt->pPager)); int __result = (((const unsigned char *) (const char *) (zFullPathname))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (zFullPathname))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (zFullPathname))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (zFullPathname))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (sqlite3PagerFilename(pBt->pPager)) && ((size_t)(const void *)((sqlite3PagerFilename(pBt->pPager)) + 1) - (size_t)(const void *)(sqlite3PagerFilename(pBt->pPager)) == 1) && (__s2_len = __builtin_strlen (sqlite3PagerFilename(pBt->pPager)), __s2_len < 4) ? (__builtin_constant_p (zFullPathname) && ((size_t)(const void *)((zFullPathname) + 1) - (size_t)(const void *)(zFullPathname) == 1) ? __builtin_strcmp (zFullPathname, sqlite3PagerFilename(pBt->pPager)) : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (zFullPathname); int __result = (((const unsigned char *) (const char *) (sqlite3PagerFilename(pBt->pPager)))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (sqlite3PagerFilename(pBt->pPager)))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (sqlite3PagerFilename(pBt->pPager)))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (sqlite3PagerFilename(pBt->pPager)))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (zFullPathname, sqlite3PagerFilename(pBt->pPager))))); })
                 && sqlite3PagerVfs(pBt->pPager)==pVfs ){
          int iDb;
          for(iDb=db->nDb-1; iDb>=0; iDb--){
            Btree *pExisting = db->aDb[iDb].pBt;
            if( pExisting && pExisting->pBt==pBt ){
                                              ;
                                            ;
              sqlite3_free(zFullPathname);
              sqlite3_free(p);
              return 19;
            }
          }
          p->pBt = pBt;
          pBt->nRef++;
          break;
        }
      }
                                      ;
      sqlite3_free(zFullPathname);
    }
# 48800 "ext/sqlite3/libsqlite/sqlite3.c"
  }

  if( pBt==0 ){





    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));

    pBt = sqlite3MallocZero( sizeof(*pBt) );
    if( pBt==0 ){
      rc = 7;
      goto btree_open_out;
    }
    rc = sqlite3PagerOpen(pVfs, &pBt->pPager, zFilename,
                          sizeof(MemPage), flags, vfsFlags, pageReinit);
    if( rc==0 ){
      rc = sqlite3PagerReadFileheader(pBt->pPager,sizeof(zDbHeader),zDbHeader);
    }
    if( rc!=0 ){
      goto btree_open_out;
    }
    pBt->openFlags = (u8)flags;
    pBt->db = db;
    sqlite3PagerSetBusyhandler(pBt->pPager, btreeInvokeBusyHandler, pBt);
    p->pBt = pBt;

    pBt->pCursor = 0;
    pBt->pPage1 = 0;
    pBt->readOnly = sqlite3PagerIsreadonly(pBt->pPager);



    pBt->pageSize = (zDbHeader[16]<<8) | (zDbHeader[17]<<16);
    if( pBt->pageSize<512 || pBt->pageSize>65536
         || ((pBt->pageSize-1)&pBt->pageSize)!=0 ){
      pBt->pageSize = 0;







      if( zFilename && !isMemdb ){
        pBt->autoVacuum = (0 ? 1 : 0);
        pBt->incrVacuum = (0==2 ? 1 : 0);
      }

      nReserve = 0;
    }else{
      nReserve = zDbHeader[20];
      pBt->pageSizeFixed = 1;

      pBt->autoVacuum = (sqlite3Get4byte(&zDbHeader[36 + 4*4])?1:0);
      pBt->incrVacuum = (sqlite3Get4byte(&zDbHeader[36 + 7*4])?1:0);

    }
    rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize, nReserve);
    if( rc ) goto btree_open_out;
    pBt->usableSize = pBt->pageSize - nReserve;
    ((void) (0));




    if( p->sharable ){
      sqlite3_mutex *mutexShared;
      pBt->nRef = 1;
      mutexShared = ((sqlite3_mutex*)8);
      if( 0 && sqlite3Config.bCoreMutex ){
        pBt->mutex = ((sqlite3_mutex*)8);
        if( pBt->mutex==0 ){
          rc = 7;
          db->mallocFailed = 0;
          goto btree_open_out;
        }
      }
                                      ;
      pBt->pNext = sqlite3SharedCacheList;
      sqlite3SharedCacheList = pBt;
                                      ;
    }

  }






  if( p->sharable ){
    int i;
    Btree *pSib;
    for(i=0; i<db->nDb; i++){
      if( (pSib = db->aDb[i].pBt)!=0 && pSib->sharable ){
        while( pSib->pPrev ){ pSib = pSib->pPrev; }
        if( p->pBt<pSib->pBt ){
          p->pNext = pSib;
          p->pPrev = 0;
          pSib->pPrev = p;
        }else{
          while( pSib->pNext && pSib->pNext->pBt<p->pBt ){
            pSib = pSib->pNext;
          }
          p->pNext = pSib->pNext;
          p->pPrev = pSib;
          if( p->pNext ){
            p->pNext->pPrev = p;
          }
          pSib->pNext = p;
        }
        break;
      }
    }
  }

  *ppBtree = p;

btree_open_out:
  if( rc!=0 ){
    if( pBt && pBt->pPager ){
      sqlite3PagerClose(pBt->pPager);
    }
    sqlite3_free(pBt);
    sqlite3_free(p);
    *ppBtree = 0;
  }else{




    if( sqlite3BtreeSchema(p, 0, 0)==0 ){
      sqlite3PagerSetCachesize(p->pBt->pPager, 2000);
    }
  }
  if( mutexOpen ){
    ((void) (0));
                                  ;
  }
  return rc;
}







static int removeFromSharingList(BtShared *pBt){

  sqlite3_mutex *pMaster;
  BtShared *pList;
  int removed = 0;

  ((void) (0));
  pMaster = ((sqlite3_mutex*)8);
                              ;
  pBt->nRef--;
  if( pBt->nRef<=0 ){
    if( sqlite3SharedCacheList==pBt ){
      sqlite3SharedCacheList = pBt->pNext;
    }else{
      pList = sqlite3SharedCacheList;
      while( (pList) && pList->pNext!=pBt ){
        pList=pList->pNext;
      }
      if( (pList) ){
        pList->pNext = pBt->pNext;
      }
    }
    if( 0 ){
                                    ;
    }
    removed = 1;
  }
                              ;
  return removed;



}





static void allocateTempSpace(BtShared *pBt){
  if( !pBt->pTmpSpace ){
    pBt->pTmpSpace = sqlite3PageMalloc( pBt->pageSize );
  }
}




static void freeTempSpace(BtShared *pBt){
  sqlite3PageFree( pBt->pTmpSpace);
  pBt->pTmpSpace = 0;
}




static int sqlite3BtreeClose(Btree *p){
  BtShared *pBt = p->pBt;
  BtCursor *pCur;


  ((void) (0));
  sqlite3BtreeEnter(p);
  pCur = pBt->pCursor;
  while( pCur ){
    BtCursor *pTmp = pCur;
    pCur = pCur->pNext;
    if( pTmp->pBtree==p ){
      sqlite3BtreeCloseCursor(pTmp);
    }
  }





  sqlite3BtreeRollback(p);
                      ;





  ((void) (0));
  if( !p->sharable || removeFromSharingList(pBt) ){





    ((void) (0));
    sqlite3PagerClose(pBt->pPager);
    if( pBt->xFreeSchema && pBt->pSchema ){
      pBt->xFreeSchema(pBt->pSchema);
    }
    sqlite3DbFree(0, pBt->pSchema);
    freeTempSpace(pBt);
    sqlite3_free(pBt);
  }


  ((void) (0));
  ((void) (0));
  if( p->pPrev ) p->pPrev->pNext = p->pNext;
  if( p->pNext ) p->pNext->pPrev = p->pPrev;


  sqlite3_free(p);
  return 0;
}
# 49079 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeSetCacheSize(Btree *p, int mxPage){
  BtShared *pBt = p->pBt;
  ((void) (0));
  sqlite3BtreeEnter(p);
  sqlite3PagerSetCachesize(pBt->pPager, mxPage);
                      ;
  return 0;
}
# 49097 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeSetSafetyLevel(
  Btree *p,
  int level,
  int fullSync,
  int ckptFullSync
){
  BtShared *pBt = p->pBt;
  ((void) (0));
  ((void) (0));
  sqlite3BtreeEnter(p);
  sqlite3PagerSetSafetyLevel(pBt->pPager, level, fullSync, ckptFullSync);
                      ;
  return 0;
}






static int sqlite3BtreeSyncDisabled(Btree *p){
  BtShared *pBt = p->pBt;
  int rc;
  ((void) (0));
  sqlite3BtreeEnter(p);
  ((void) (0));
  rc = sqlite3PagerNosync(pBt->pPager);
                      ;
  return rc;
}
# 49148 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeSetPageSize(Btree *p, int pageSize, int nReserve, int iFix){
  int rc = 0;
  BtShared *pBt = p->pBt;
  ((void) (0));
  sqlite3BtreeEnter(p);
  if( pBt->pageSizeFixed ){
                        ;
    return 8;
  }
  if( nReserve<0 ){
    nReserve = pBt->pageSize - pBt->usableSize;
  }
  ((void) (0));
  if( pageSize>=512 && pageSize<=65536 &&
        ((pageSize-1)&pageSize)==0 ){
    ((void) (0));
    ((void) (0));
    pBt->pageSize = (u32)pageSize;
    freeTempSpace(pBt);
  }
  rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize, nReserve);
  pBt->usableSize = pBt->pageSize - (u16)nReserve;
  if( iFix ) pBt->pageSizeFixed = 1;
                      ;
  return rc;
}




static int sqlite3BtreeGetPageSize(Btree *p){
  return p->pBt->pageSize;
}







static int sqlite3BtreeGetReserve(Btree *p){
  int n;
  sqlite3BtreeEnter(p);
  n = p->pBt->pageSize - p->pBt->usableSize;
                      ;
  return n;
}






static int sqlite3BtreeMaxPageCount(Btree *p, int mxPage){
  int n;
  sqlite3BtreeEnter(p);
  n = sqlite3PagerMaxPageCount(p->pBt->pPager, mxPage);
                      ;
  return n;
}






static int sqlite3BtreeSecureDelete(Btree *p, int newFlag){
  int b;
  if( p==0 ) return 0;
  sqlite3BtreeEnter(p);
  if( newFlag>=0 ){
    p->pBt->secureDelete = (newFlag!=0) ? 1 : 0;
  }
  b = p->pBt->secureDelete;
                      ;
  return b;
}
# 49233 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeSetAutoVacuum(Btree *p, int autoVacuum){



  BtShared *pBt = p->pBt;
  int rc = 0;
  u8 av = (u8)autoVacuum;

  sqlite3BtreeEnter(p);
  if( pBt->pageSizeFixed && (av ?1:0)!=pBt->autoVacuum ){
    rc = 8;
  }else{
    pBt->autoVacuum = av ?1:0;
    pBt->incrVacuum = av==2 ?1:0;
  }
                      ;
  return rc;

}





static int sqlite3BtreeGetAutoVacuum(Btree *p){



  int rc;
  sqlite3BtreeEnter(p);
  rc = (
    (!p->pBt->autoVacuum)?0:
    (!p->pBt->incrVacuum)?1:
    2
  );
                      ;
  return rc;

}
# 49283 "ext/sqlite3/libsqlite/sqlite3.c"
static int lockBtree(BtShared *pBt){
  int rc;
  MemPage *pPage1;
  int nPage;
  int nPageFile = 0;
  int nPageHeader;

  ((void) (0));
  ((void) (0));
  rc = sqlite3PagerSharedLock(pBt->pPager);
  if( rc!=0 ) return rc;
  rc = btreeGetPage(pBt, 1, &pPage1, 0);
  if( rc!=0 ) return rc;




  nPage = nPageHeader = sqlite3Get4byte(28+(u8*)pPage1->aData);
  sqlite3PagerPagecount(pBt->pPager, &nPageFile);
  if( nPage==0 || memcmp(24+(u8*)pPage1->aData, 92+(u8*)pPage1->aData,4)!=0 ){
    nPage = nPageFile;
  }
  if( nPage>0 ){
    u32 pageSize;
    u32 usableSize;
    u8 *page1 = pPage1->aData;
    rc = 26;
    if( memcmp(page1, zMagicHeader, 16)!=0 ){
      goto page1_init_failed;
    }
# 49322 "ext/sqlite3/libsqlite/sqlite3.c"
    if( page1[18]>2 ){
      pBt->readOnly = 1;
    }
    if( page1[19]>2 ){
      goto page1_init_failed;
    }
# 49337 "ext/sqlite3/libsqlite/sqlite3.c"
    if( page1[19]==2 && pBt->doNotUseWAL==0 ){
      int isOpen = 0;
      rc = sqlite3PagerOpenWal(pBt->pPager, &isOpen);
      if( rc!=0 ){
        goto page1_init_failed;
      }else if( isOpen==0 ){
        releasePage(pPage1);
        return 0;
      }
      rc = 26;
    }







    if( memcmp(&page1[21], "\100\040\040",3)!=0 ){
      goto page1_init_failed;
    }
    pageSize = (page1[16]<<8) | (page1[17]<<16);
    if( ((pageSize-1)&pageSize)!=0
     || pageSize>65536
     || pageSize<=256
    ){
      goto page1_init_failed;
    }
    ((void) (0));
    usableSize = pageSize - page1[20];
    if( (u32)pageSize!=pBt->pageSize ){






      releasePage(pPage1);
      pBt->usableSize = usableSize;
      pBt->pageSize = pageSize;
      freeTempSpace(pBt);
      rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize,
                                   pageSize-usableSize);
      return rc;
    }
    if( (pBt->db->flags & 0x00800000)==0 && nPage>nPageFile ){
      rc = sqlite3CorruptError(49383);
      goto page1_init_failed;
    }
    if( usableSize<480 ){
      goto page1_init_failed;
    }
    pBt->pageSize = pageSize;
    pBt->usableSize = usableSize;

    pBt->autoVacuum = (sqlite3Get4byte(&page1[36 + 4*4])?1:0);
    pBt->incrVacuum = (sqlite3Get4byte(&page1[36 + 7*4])?1:0);

  }
# 49410 "ext/sqlite3/libsqlite/sqlite3.c"
  pBt->maxLocal = (u16)((pBt->usableSize-12)*64/255 - 23);
  pBt->minLocal = (u16)((pBt->usableSize-12)*32/255 - 23);
  pBt->maxLeaf = (u16)(pBt->usableSize - 35);
  pBt->minLeaf = (u16)((pBt->usableSize-12)*32/255 - 23);
  ((void) (0));
  pBt->pPage1 = pPage1;
  pBt->nPage = nPage;
  return 0;

page1_init_failed:
  releasePage(pPage1);
  pBt->pPage1 = 0;
  return rc;
}
# 49433 "ext/sqlite3/libsqlite/sqlite3.c"
static void unlockBtreeIfUnused(BtShared *pBt){
  ((void) (0));
  ((void) (0));
  if( pBt->inTransaction==0 && pBt->pPage1!=0 ){
    ((void) (0));
    ((void) (0));
    ((void) (0));
    releasePage(pBt->pPage1);
    pBt->pPage1 = 0;
  }
}






static int newDatabase(BtShared *pBt){
  MemPage *pP1;
  unsigned char *data;
  int rc;

  ((void) (0));
  if( pBt->nPage>0 ){
    return 0;
  }
  pP1 = pBt->pPage1;
  ((void) (0));
  data = pP1->aData;
  rc = sqlite3PagerWrite(pP1->pDbPage);
  if( rc ) return rc;
  memcpy(data, zMagicHeader, sizeof(zMagicHeader));
  ((void) (0));
  data[16] = (u8)((pBt->pageSize>>8)&0xff);
  data[17] = (u8)((pBt->pageSize>>16)&0xff);
  data[18] = 1;
  data[19] = 1;
  ((void) (0));
  data[20] = (u8)(pBt->pageSize - pBt->usableSize);
  data[21] = 64;
  data[22] = 32;
  data[23] = 32;
  memset(&data[24], 0, 100-24);
  zeroPage(pP1, 0x01|0x08|0x04 );
  pBt->pageSizeFixed = 1;

  ((void) (0));
  ((void) (0));
  sqlite3Put4byte(&data[36 + 4*4], pBt->autoVacuum);
  sqlite3Put4byte(&data[36 + 7*4], pBt->incrVacuum);

  pBt->nPage = 1;
  data[31] = 1;
  return 0;
}
# 49524 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeBeginTrans(Btree *p, int wrflag){
  sqlite3 *pBlock = 0;
  BtShared *pBt = p->pBt;
  int rc = 0;

  sqlite3BtreeEnter(p);
  ((void) (0)); ((void) (0));;





  if( p->inTrans==2 || (p->inTrans==1 && !wrflag) ){
    goto trans_begun;
  }


  if( pBt->readOnly && wrflag ){
    rc = 8;
    goto trans_begun;
  }






  if( (wrflag && pBt->inTransaction==2) || pBt->isPending ){
    pBlock = pBt->pWriter->db;
  }else if( wrflag>1 ){
    BtLock *pIter;
    for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){
      if( pIter->pBtree!=p ){
        pBlock = pIter->pBtree->db;
        break;
      }
    }
  }
  if( pBlock ){
                                           ;
    rc = (6 | (1<<8));
    goto trans_begun;
  }





  rc = querySharedCacheTableLock(p, 1, 1);
  if( 0!=rc ) goto trans_begun;

  pBt->initiallyEmpty = (u8)(pBt->nPage==0);
  do {







    while( pBt->pPage1==0 && 0==(rc = lockBtree(pBt)) );

    if( rc==0 && wrflag ){
      if( pBt->readOnly ){
        rc = 8;
      }else{
        rc = sqlite3PagerBegin(pBt->pPager,wrflag>1,sqlite3TempInMemory(p->db));
        if( rc==0 ){
          rc = newDatabase(pBt);
        }
      }
    }

    if( rc!=0 ){
      unlockBtreeIfUnused(pBt);
    }
  }while( (rc&0xFF)==5 && pBt->inTransaction==0 &&
          btreeInvokeBusyHandler(pBt) );

  if( rc==0 ){
    if( p->inTrans==0 ){
      pBt->nTransaction++;

      if( p->sharable ){
 ((void) (0));
        p->lock.eLock = 1;
        p->lock.pNext = pBt->pLock;
        pBt->pLock = &p->lock;
      }

    }
    p->inTrans = (wrflag?2:1);
    if( p->inTrans>pBt->inTransaction ){
      pBt->inTransaction = p->inTrans;
    }
    if( wrflag ){
      MemPage *pPage1 = pBt->pPage1;

      ((void) (0));
      pBt->pWriter = p;
      pBt->isExclusive = (u8)(wrflag>1);
# 49633 "ext/sqlite3/libsqlite/sqlite3.c"
      if( pBt->nPage!=sqlite3Get4byte(&pPage1->aData[28]) ){
        rc = sqlite3PagerWrite(pPage1->pDbPage);
        if( rc==0 ){
          sqlite3Put4byte(&pPage1->aData[28], pBt->nPage);
        }
      }
    }
  }


trans_begun:
  if( rc==0 && wrflag ){




    rc = sqlite3PagerOpenSavepoint(pBt->pPager, p->db->nSavepoint);
  }

  ((void) (0)); ((void) (0));;
                      ;
  return rc;
}
# 49664 "ext/sqlite3/libsqlite/sqlite3.c"
static int setChildPtrmaps(MemPage *pPage){
  int i;
  int nCell;
  int rc;
  BtShared *pBt = pPage->pBt;
  u8 isInitOrig = pPage->isInit;
  Pgno pgno = pPage->pgno;

  ((void) (0));
  rc = btreeInitPage(pPage);
  if( rc!=0 ){
    goto set_child_ptrmaps_out;
  }
  nCell = pPage->nCell;

  for(i=0; i<nCell; i++){
    u8 *pCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aData[(pPage)->cellOffset+2*(i)])[0]<<8 | (&(pPage)->aData[(pPage)->cellOffset+2*(i)])[1])));

    ptrmapPutOvflPtr(pPage, pCell, &rc);

    if( !pPage->leaf ){
      Pgno childPgno = sqlite3Get4byte(pCell);
      ptrmapPut(pBt, childPgno, 5, pgno, &rc);
    }
  }

  if( !pPage->leaf ){
    Pgno childPgno = sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8]);
    ptrmapPut(pBt, childPgno, 5, pgno, &rc);
  }

set_child_ptrmaps_out:
  pPage->isInit = isInitOrig;
  return rc;
}
# 49714 "ext/sqlite3/libsqlite/sqlite3.c"
static int modifyPagePointer(MemPage *pPage, Pgno iFrom, Pgno iTo, u8 eType){
  ((void) (0));
  ((void) (0));
  if( eType==4 ){

    if( sqlite3Get4byte(pPage->aData)!=iFrom ){
      return sqlite3CorruptError(49720);
    }
    sqlite3Put4byte(pPage->aData, iTo);
  }else{
    u8 isInitOrig = pPage->isInit;
    int i;
    int nCell;

    btreeInitPage(pPage);
    nCell = pPage->nCell;

    for(i=0; i<nCell; i++){
      u8 *pCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aData[(pPage)->cellOffset+2*(i)])[0]<<8 | (&(pPage)->aData[(pPage)->cellOffset+2*(i)])[1])));
      if( eType==3 ){
        CellInfo info;
        btreeParseCellPtr(pPage, pCell, &info);
        if( info.iOverflow ){
          if( iFrom==sqlite3Get4byte(&pCell[info.iOverflow]) ){
            sqlite3Put4byte(&pCell[info.iOverflow], iTo);
            break;
          }
        }
      }else{
        if( sqlite3Get4byte(pCell)==iFrom ){
          sqlite3Put4byte(pCell, iTo);
          break;
        }
      }
    }

    if( i==nCell ){
      if( eType!=5 ||
          sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8])!=iFrom ){
        return sqlite3CorruptError(49753);
      }
      sqlite3Put4byte(&pPage->aData[pPage->hdrOffset+8], iTo);
    }

    pPage->isInit = isInitOrig;
  }
  return 0;
}
# 49773 "ext/sqlite3/libsqlite/sqlite3.c"
static int relocatePage(
  BtShared *pBt,
  MemPage *pDbPage,
  u8 eType,
  Pgno iPtrPage,
  Pgno iFreePage,
  int isCommit
){
  MemPage *pPtrPage;
  Pgno iDbPage = pDbPage->pgno;
  Pager *pPager = pBt->pPager;
  int rc;

  ((void) (0));

  ((void) (0));
  ((void) (0));



                                           ;
  rc = sqlite3PagerMovepage(pPager, pDbPage->pDbPage, iFreePage, isCommit);
  if( rc!=0 ){
    return rc;
  }
  pDbPage->pgno = iFreePage;
# 49808 "ext/sqlite3/libsqlite/sqlite3.c"
  if( eType==5 || eType==1 ){
    rc = setChildPtrmaps(pDbPage);
    if( rc!=0 ){
      return rc;
    }
  }else{
    Pgno nextOvfl = sqlite3Get4byte(pDbPage->aData);
    if( nextOvfl!=0 ){
      ptrmapPut(pBt, nextOvfl, 4, iFreePage, &rc);
      if( rc!=0 ){
        return rc;
      }
    }
  }





  if( eType!=1 ){
    rc = btreeGetPage(pBt, iPtrPage, &pPtrPage, 0);
    if( rc!=0 ){
      return rc;
    }
    rc = sqlite3PagerWrite(pPtrPage->pDbPage);
    if( rc!=0 ){
      releasePage(pPtrPage);
      return rc;
    }
    rc = modifyPagePointer(pPtrPage, iDbPage, iFreePage, eType);
    releasePage(pPtrPage);
    if( rc==0 ){
      ptrmapPut(pBt, iFreePage, eType, iPtrPage, &rc);
    }
  }
  return rc;
}


static int allocateBtreePage(BtShared *, MemPage **, Pgno *, Pgno, u8);
# 49867 "ext/sqlite3/libsqlite/sqlite3.c"
static int incrVacuumStep(BtShared *pBt, Pgno nFin, Pgno iLastPg){
  Pgno nFreeList;
  int rc;

  ((void) (0));
  ((void) (0));

  if( !(ptrmapPageno((pBt), (iLastPg))==(iLastPg)) && iLastPg!=((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){
    u8 eType;
    Pgno iPtrPage;

    nFreeList = sqlite3Get4byte(&pBt->pPage1->aData[36]);
    if( nFreeList==0 ){
      return 101;
    }

    rc = ptrmapGet(pBt, iLastPg, &eType, &iPtrPage);
    if( rc!=0 ){
      return rc;
    }
    if( eType==1 ){
      return sqlite3CorruptError(49888);
    }

    if( eType==2 ){
      if( nFin==0 ){





        Pgno iFreePg;
        MemPage *pFreePg;
        rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iLastPg, 1);
        if( rc!=0 ){
          return rc;
        }
        ((void) (0));
        releasePage(pFreePg);
      }
    } else {
      Pgno iFreePg;
      MemPage *pLastPg;

      rc = btreeGetPage(pBt, iLastPg, &pLastPg, 0);
      if( rc!=0 ){
        return rc;
      }
# 49923 "ext/sqlite3/libsqlite/sqlite3.c"
      do {
        MemPage *pFreePg;
        rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, 0, 0);
        if( rc!=0 ){
          releasePage(pLastPg);
          return rc;
        }
        releasePage(pFreePg);
      }while( nFin!=0 && iFreePg>nFin );
      ((void) (0));

      rc = sqlite3PagerWrite(pLastPg->pDbPage);
      if( rc==0 ){
        rc = relocatePage(pBt, pLastPg, eType, iPtrPage, iFreePg, nFin!=0);
      }
      releasePage(pLastPg);
      if( rc!=0 ){
        return rc;
      }
    }
  }

  if( nFin==0 ){
    iLastPg--;
    while( iLastPg==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1))||(ptrmapPageno((pBt), (iLastPg))==(iLastPg)) ){
      if( (ptrmapPageno((pBt), (iLastPg))==(iLastPg)) ){
        MemPage *pPg;
        rc = btreeGetPage(pBt, iLastPg, &pPg, 0);
        if( rc!=0 ){
          return rc;
        }
        rc = sqlite3PagerWrite(pPg->pDbPage);
        releasePage(pPg);
        if( rc!=0 ){
          return rc;
        }
      }
      iLastPg--;
    }
    sqlite3PagerTruncateImage(pBt->pPager, iLastPg);
    pBt->nPage = iLastPg;
  }
  return 0;
}
# 49976 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeIncrVacuum(Btree *p){
  int rc;
  BtShared *pBt = p->pBt;

  sqlite3BtreeEnter(p);
  ((void) (0));
  if( !pBt->autoVacuum ){
    rc = 101;
  }else{
    invalidateAllOverflowCache(pBt);
    rc = incrVacuumStep(pBt, 0, btreePagecount(pBt));
    if( rc==0 ){
      rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
      sqlite3Put4byte(&pBt->pPage1->aData[28], pBt->nPage);
    }
  }
                      ;
  return rc;
}
# 50005 "ext/sqlite3/libsqlite/sqlite3.c"
static int autoVacuumCommit(BtShared *pBt){
  int rc = 0;
  Pager *pPager = pBt->pPager;
                                                     ;

  ((void) (0));
  invalidateAllOverflowCache(pBt);
  ((void) (0));
  if( !pBt->incrVacuum ){
    Pgno nFin;
    Pgno nFree;
    Pgno nPtrmap;
    Pgno iFree;
    int nEntry;
    Pgno nOrig;

    nOrig = btreePagecount(pBt);
    if( (ptrmapPageno((pBt), (nOrig))==(nOrig)) || nOrig==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){




      return sqlite3CorruptError(50027);
    }

    nFree = sqlite3Get4byte(&pBt->pPage1->aData[36]);
    nEntry = pBt->usableSize/5;
    nPtrmap = (nFree-nOrig+ptrmapPageno(pBt, nOrig)+nEntry)/nEntry;
    nFin = nOrig - nFree - nPtrmap;
    if( nOrig>((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) && nFin<((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){
      nFin--;
    }
    while( (ptrmapPageno((pBt), (nFin))==(nFin)) || nFin==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){
      nFin--;
    }
    if( nFin>nOrig ) return sqlite3CorruptError(50040);

    for(iFree=nOrig; iFree>nFin && rc==0; iFree--){
      rc = incrVacuumStep(pBt, nFin, iFree);
    }
    if( (rc==101 || rc==0) && nFree>0 ){
      rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
      sqlite3Put4byte(&pBt->pPage1->aData[32], 0);
      sqlite3Put4byte(&pBt->pPage1->aData[36], 0);
      sqlite3Put4byte(&pBt->pPage1->aData[28], nFin);
      sqlite3PagerTruncateImage(pBt->pPager, nFin);
      pBt->nPage = nFin;
    }
    if( rc!=0 ){
      sqlite3PagerRollback(pPager);
    }
  }

  ((void) (0));
  return rc;
}
# 50092 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeCommitPhaseOne(Btree *p, const char *zMaster){
  int rc = 0;
  if( p->inTrans==2 ){
    BtShared *pBt = p->pBt;
    sqlite3BtreeEnter(p);

    if( pBt->autoVacuum ){
      rc = autoVacuumCommit(pBt);
      if( rc!=0 ){
                            ;
        return rc;
      }
    }

    rc = sqlite3PagerCommitPhaseOne(pBt->pPager, zMaster, 0);
                        ;
  }
  return rc;
}





static void btreeEndTransaction(Btree *p){
  BtShared *pBt = p->pBt;
  ((void) (0));

  btreeClearHasContent(pBt);
  if( p->inTrans>0 && p->db->activeVdbeCnt>1 ){



    downgradeAllSharedCacheTableLocks(p);
    p->inTrans = 1;
  }else{




    if( p->inTrans!=0 ){
      clearAllSharedCacheTableLocks(p);
      pBt->nTransaction--;
      if( 0==pBt->nTransaction ){
        pBt->inTransaction = 0;
      }
    }



    p->inTrans = 0;
    unlockBtreeIfUnused(pBt);
  }

  ((void) (0)); ((void) (0));;
}
# 50175 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeCommitPhaseTwo(Btree *p, int bCleanup){

  if( p->inTrans==0 ) return 0;
  sqlite3BtreeEnter(p);
  ((void) (0)); ((void) (0));;




  if( p->inTrans==2 ){
    int rc;
    BtShared *pBt = p->pBt;
    ((void) (0));
    ((void) (0));
    rc = sqlite3PagerCommitPhaseTwo(pBt->pPager);
    if( rc!=0 && bCleanup==0 ){
                          ;
      return rc;
    }
    pBt->inTransaction = 1;
  }

  btreeEndTransaction(p);
                      ;
  return 0;
}




static int sqlite3BtreeCommit(Btree *p){
  int rc;
  sqlite3BtreeEnter(p);
  rc = sqlite3BtreeCommitPhaseOne(p, 0);
  if( rc==0 ){
    rc = sqlite3BtreeCommitPhaseTwo(p, 0);
  }
                      ;
  return rc;
}
# 50254 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3BtreeTripAllCursors(Btree *pBtree, int errCode){
  BtCursor *p;
  sqlite3BtreeEnter(pBtree);
  for(p=pBtree->pBt->pCursor; p; p=p->pNext){
    int i;
    sqlite3BtreeClearCursor(p);
    p->eState = 3;
    p->skipNext = errCode;
    for(i=0; i<=p->iPage; i++){
      releasePage(p->apPage[i]);
      p->apPage[i] = 0;
    }
  }
                           ;
}
# 50279 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeRollback(Btree *p){
  int rc;
  BtShared *pBt = p->pBt;
  MemPage *pPage1;

  sqlite3BtreeEnter(p);
  rc = saveAllCursors(pBt, 0, 0);

  if( rc!=0 ){







    sqlite3BtreeTripAllCursors(p, rc);
  }

  ((void) (0)); ((void) (0));;

  if( p->inTrans==2 ){
    int rc2;

    ((void) (0));
    rc2 = sqlite3PagerRollback(pBt->pPager);
    if( rc2!=0 ){
      rc = rc2;
    }




    if( btreeGetPage(pBt, 1, &pPage1, 0)==0 ){
      int nPage = sqlite3Get4byte(28+(u8*)pPage1->aData);
                          ;
      if( nPage==0 ) sqlite3PagerPagecount(pBt->pPager, &nPage);
                                   ;
      pBt->nPage = nPage;
      releasePage(pPage1);
    }
    ((void) (0));
    pBt->inTransaction = 1;
  }

  btreeEndTransaction(p);
                      ;
  return rc;
}
# 50347 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeBeginStmt(Btree *p, int iStatement){
  int rc;
  BtShared *pBt = p->pBt;
  sqlite3BtreeEnter(p);
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));





  rc = sqlite3PagerOpenSavepoint(pBt->pPager, iStatement);
                      ;
  return rc;
}
# 50378 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeSavepoint(Btree *p, int op, int iSavepoint){
  int rc = 0;
  if( p && p->inTrans==2 ){
    BtShared *pBt = p->pBt;
    ((void) (0));
    ((void) (0));
    sqlite3BtreeEnter(p);
    rc = sqlite3PagerSavepoint(pBt->pPager, op, iSavepoint);
    if( rc==0 ){
      if( iSavepoint<0 && pBt->initiallyEmpty ) pBt->nPage = 0;
      rc = newDatabase(pBt);
      pBt->nPage = sqlite3Get4byte(28 + pBt->pPage1->aData);




      ((void) (0));
    }
                        ;
  }
  return rc;
}
# 50433 "ext/sqlite3/libsqlite/sqlite3.c"
static int btreeCursor(
  Btree *p,
  int iTable,
  int wrFlag,
  struct KeyInfo *pKeyInfo,
  BtCursor *pCur
){
  BtShared *pBt = p->pBt;

  ((void) (0));
  ((void) (0));





  ((void) (0));
  ((void) (0));


  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( (wrFlag && pBt->readOnly) ){
    return 8;
  }
  if( iTable==1 && btreePagecount(pBt)==0 ){
    return 16;
  }



  pCur->pgnoRoot = (Pgno)iTable;
  pCur->iPage = -1;
  pCur->pKeyInfo = pKeyInfo;
  pCur->pBtree = p;
  pCur->pBt = pBt;
  pCur->wrFlag = (u8)wrFlag;
  pCur->pNext = pBt->pCursor;
  if( pCur->pNext ){
    pCur->pNext->pPrev = pCur;
  }
  pBt->pCursor = pCur;
  pCur->eState = 0;
  pCur->cachedRowid = 0;
  return 0;
}
static int sqlite3BtreeCursor(
  Btree *p,
  int iTable,
  int wrFlag,
  struct KeyInfo *pKeyInfo,
  BtCursor *pCur
){
  int rc;
  sqlite3BtreeEnter(p);
  rc = btreeCursor(p, iTable, wrFlag, pKeyInfo, pCur);
                      ;
  return rc;
}
# 50503 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeCursorSize(void){
  return (((sizeof(BtCursor))+7)&~7);
}
# 50515 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3BtreeCursorZero(BtCursor *p){
  memset(p, 0, __builtin_offsetof(BtCursor, iPage));
}
# 50531 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3BtreeSetCachedRowid(BtCursor *pCur, sqlite3_int64 iRowid){
  BtCursor *p;
  for(p=pCur->pBt->pCursor; p; p=p->pNext){
    if( p->pgnoRoot==pCur->pgnoRoot ) p->cachedRowid = iRowid;
  }
  ((void) (0));
}







static sqlite3_int64 sqlite3BtreeGetCachedRowid(BtCursor *pCur){
  return pCur->cachedRowid;
}





static int sqlite3BtreeCloseCursor(BtCursor *pCur){
  Btree *pBtree = pCur->pBtree;
  if( pBtree ){
    int i;
    BtShared *pBt = pCur->pBt;
    sqlite3BtreeEnter(pBtree);
    sqlite3BtreeClearCursor(pCur);
    if( pCur->pPrev ){
      pCur->pPrev->pNext = pCur->pNext;
    }else{
      pBt->pCursor = pCur->pNext;
    }
    if( pCur->pNext ){
      pCur->pNext->pPrev = pCur->pPrev;
    }
    for(i=0; i<=pCur->iPage; i++){
      releasePage(pCur->apPage[i]);
    }
    unlockBtreeIfUnused(pBt);
    invalidateOverflowCache(pCur);

                             ;
  }
  return 0;
}
# 50651 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeKeySize(BtCursor *pCur, i64 *pSize){
  ((void) (0));
  ((void) (0));
  if( pCur->eState!=1 ){
    *pSize = 0;
  }else{
    if( pCur->info.nSize==0 ){ int iPage = pCur->iPage; btreeParseCell(pCur->apPage[iPage],pCur->aiIdx[iPage],&pCur->info); pCur->validNKey = 1; }else{ ; };
    *pSize = pCur->info.nKey;
  }
  return 0;
}
# 50675 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeDataSize(BtCursor *pCur, u32 *pSize){
  ((void) (0));
  ((void) (0));
  if( pCur->info.nSize==0 ){ int iPage = pCur->iPage; btreeParseCell(pCur->apPage[iPage],pCur->aiIdx[iPage],&pCur->info); pCur->validNKey = 1; }else{ ; };
  *pSize = pCur->info.nData;
  return 0;
}
# 50702 "ext/sqlite3/libsqlite/sqlite3.c"
static int getOverflowPage(
  BtShared *pBt,
  Pgno ovfl,
  MemPage **ppPage,
  Pgno *pPgnoNext
){
  Pgno next = 0;
  MemPage *pPage = 0;
  int rc = 0;

  ((void) (0));
  ((void) (0));
# 50722 "ext/sqlite3/libsqlite/sqlite3.c"
  if( pBt->autoVacuum ){
    Pgno pgno;
    Pgno iGuess = ovfl+1;
    u8 eType;

    while( (ptrmapPageno((pBt), (iGuess))==(iGuess)) || iGuess==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){
      iGuess++;
    }

    if( iGuess<=btreePagecount(pBt) ){
      rc = ptrmapGet(pBt, iGuess, &eType, &pgno);
      if( rc==0 && eType==4 && pgno==ovfl ){
        next = iGuess;
        rc = 101;
      }
    }
  }


  ((void) (0));
  if( rc==0 ){
    rc = btreeGetPage(pBt, ovfl, &pPage, 0);
    ((void) (0));
    if( rc==0 ){
      next = sqlite3Get4byte(pPage->aData);
    }
  }

  *pPgnoNext = next;
  if( ppPage ){
    *ppPage = pPage;
  }else{
    releasePage(pPage);
  }
  return (rc==101 ? 0 : rc);
}
# 50770 "ext/sqlite3/libsqlite/sqlite3.c"
static int copyPayload(
  void *pPayload,
  void *pBuf,
  int nByte,
  int eOp,
  DbPage *pDbPage
){
  if( eOp ){

    int rc = sqlite3PagerWrite(pDbPage);
    if( rc!=0 ){
      return rc;
    }
    memcpy(pPayload, pBuf, nByte);
  }else{

    memcpy(pBuf, pPayload, nByte);
  }
  return 0;
}
# 50819 "ext/sqlite3/libsqlite/sqlite3.c"
static int accessPayload(
  BtCursor *pCur,
  u32 offset,
  u32 amt,
  unsigned char *pBuf,
  int eOp
){
  unsigned char *aPayload;
  int rc = 0;
  u32 nKey;
  int iIdx = 0;
  MemPage *pPage = pCur->apPage[pCur->iPage];
  BtShared *pBt = pCur->pBt;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( pCur->info.nSize==0 ){ int iPage = pCur->iPage; btreeParseCell(pCur->apPage[iPage],pCur->aiIdx[iPage],&pCur->info); pCur->validNKey = 1; }else{ ; };
  aPayload = pCur->info.pCell + pCur->info.nHeader;
  nKey = (pPage->intKey ? 0 : (int)pCur->info.nKey);

  if( (offset+amt > nKey+pCur->info.nData)
   || &aPayload[pCur->info.nLocal] > &pPage->aData[pBt->usableSize]
  ){

    return sqlite3CorruptError(50846);
  }


  if( offset<pCur->info.nLocal ){
    int a = amt;
    if( a+offset>pCur->info.nLocal ){
      a = pCur->info.nLocal - offset;
    }
    rc = copyPayload(&aPayload[offset], pBuf, a, eOp, pPage->pDbPage);
    offset = 0;
    pBuf += a;
    amt -= a;
  }else{
    offset -= pCur->info.nLocal;
  }

  if( rc==0 && amt>0 ){
    const u32 ovflSize = pBt->usableSize - 4;
    Pgno nextPage;

    nextPage = sqlite3Get4byte(&aPayload[pCur->info.nLocal]);
# 50877 "ext/sqlite3/libsqlite/sqlite3.c"
    if( pCur->isIncrblobHandle && !pCur->aOverflow ){
      int nOvfl = (pCur->info.nPayload-pCur->info.nLocal+ovflSize-1)/ovflSize;
      pCur->aOverflow = (Pgno *)sqlite3MallocZero(sizeof(Pgno)*nOvfl);


      if( (nOvfl) && !pCur->aOverflow ){
        rc = 7;
      }
    }





    if( pCur->aOverflow && pCur->aOverflow[offset/ovflSize] ){
      iIdx = (offset/ovflSize);
      nextPage = pCur->aOverflow[iIdx];
      offset = (offset%ovflSize);
    }


    for( ; rc==0 && amt>0 && nextPage; iIdx++){



      if( pCur->aOverflow ){
        ((void) (0));
        pCur->aOverflow[iIdx] = nextPage;
      }


      if( offset>=ovflSize ){







        if( pCur->aOverflow && pCur->aOverflow[iIdx+1] ){
          nextPage = pCur->aOverflow[iIdx+1];
        } else

          rc = getOverflowPage(pBt, nextPage, 0, &nextPage);
        offset -= ovflSize;
      }else{



        DbPage *pDbPage;
        int a = amt;
        rc = sqlite3PagerAcquire(pBt->pPager,nextPage,&pDbPage,0);
        if( rc==0 ){
          aPayload = sqlite3PagerGetData(pDbPage);
          nextPage = sqlite3Get4byte(aPayload);
          if( a + offset > ovflSize ){
            a = ovflSize - offset;
          }
          rc = copyPayload(&aPayload[offset+4], pBuf, a, eOp, pDbPage);
          sqlite3PagerUnref(pDbPage);
          offset = 0;
          amt -= a;
          pBuf += a;
        }
      }
    }
  }

  if( rc==0 && amt>0 ){
    return sqlite3CorruptError(50946);
  }
  return rc;
}
# 50963 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeKey(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  return accessPayload(pCur, offset, amt, (unsigned char*)pBuf, 0);
}
# 50980 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeData(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){
  int rc;


  if ( pCur->eState==0 ){
    return 4;
  }


  ((void) (0));
  rc = (pCur->eState>=2 ? btreeRestoreCursorPosition(pCur) : 0);
  if( rc==0 ){
    ((void) (0));
    ((void) (0));
    ((void) (0));
    rc = accessPayload(pCur, offset, amt, pBuf, 0);
  }
  return rc;
}
# 51019 "ext/sqlite3/libsqlite/sqlite3.c"
static const unsigned char *fetchPayload(
  BtCursor *pCur,
  int *pAmt,
  int skipKey
){
  unsigned char *aPayload;
  MemPage *pPage;
  u32 nKey;
  u32 nLocal;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  pPage = pCur->apPage[pCur->iPage];
  ((void) (0));
  if( (pCur->info.nSize==0) ){
    btreeParseCell(pCur->apPage[pCur->iPage], pCur->aiIdx[pCur->iPage],
                   &pCur->info);
  }
  aPayload = pCur->info.pCell;
  aPayload += pCur->info.nHeader;
  if( pPage->intKey ){
    nKey = 0;
  }else{
    nKey = (int)pCur->info.nKey;
  }
  if( skipKey ){
    aPayload += nKey;
    nLocal = pCur->info.nLocal - nKey;
  }else{
    nLocal = pCur->info.nLocal;
    ((void) (0));
  }
  *pAmt = nLocal;
  return aPayload;
}
# 51071 "ext/sqlite3/libsqlite/sqlite3.c"
static const void *sqlite3BtreeKeyFetch(BtCursor *pCur, int *pAmt){
  const void *p = 0;
  ((void) (0));
  ((void) (0));
  if( (pCur->eState==1) ){
    p = (const void*)fetchPayload(pCur, pAmt, 0);
  }
  return p;
}
static const void *sqlite3BtreeDataFetch(BtCursor *pCur, int *pAmt){
  const void *p = 0;
  ((void) (0));
  ((void) (0));
  if( (pCur->eState==1) ){
    p = (const void*)fetchPayload(pCur, pAmt, 1);
  }
  return p;
}
# 51100 "ext/sqlite3/libsqlite/sqlite3.c"
static int moveToChild(BtCursor *pCur, u32 newPgno){
  int rc;
  int i = pCur->iPage;
  MemPage *pNewPage;
  BtShared *pBt = pCur->pBt;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pCur->iPage>=(20 -1) ){
    return sqlite3CorruptError(51110);
  }
  rc = getAndInitPage(pBt, newPgno, &pNewPage);
  if( rc ) return rc;
  pCur->apPage[i+1] = pNewPage;
  pCur->aiIdx[i+1] = 0;
  pCur->iPage++;

  pCur->info.nSize = 0;
  pCur->validNKey = 0;
  if( pNewPage->nCell<1 || pNewPage->intKey!=pCur->apPage[i]->intKey ){
    return sqlite3CorruptError(51121);
  }
  return 0;
}
# 51154 "ext/sqlite3/libsqlite/sqlite3.c"
static void moveToParent(BtCursor *pCur){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));




   ;
  releasePage(pCur->apPage[pCur->iPage]);
  pCur->iPage--;
  pCur->info.nSize = 0;
  pCur->validNKey = 0;
}
# 51191 "ext/sqlite3/libsqlite/sqlite3.c"
static int moveToRoot(BtCursor *pCur){
  MemPage *pRoot;
  int rc = 0;
  Btree *p = pCur->pBtree;
  BtShared *pBt = p->pBt;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pCur->eState>=2 ){
    if( pCur->eState==3 ){
      ((void) (0));
      return pCur->skipNext;
    }
    sqlite3BtreeClearCursor(pCur);
  }

  if( pCur->iPage>=0 ){
    int i;
    for(i=1; i<=pCur->iPage; i++){
      releasePage(pCur->apPage[i]);
    }
    pCur->iPage = 0;
  }else{
    rc = getAndInitPage(pBt, pCur->pgnoRoot, &pCur->apPage[0]);
    if( rc!=0 ){
      pCur->eState = 0;
      return rc;
    }
    pCur->iPage = 0;





    ((void) (0));
    if( (pCur->pKeyInfo==0)!=pCur->apPage[0]->intKey ){
      return sqlite3CorruptError(51229);
    }
  }







  pRoot = pCur->apPage[0];
  ((void) (0));
  ((void) (0));

  pCur->aiIdx[0] = 0;
  pCur->info.nSize = 0;
  pCur->atLast = 0;
  pCur->validNKey = 0;

  if( pRoot->nCell==0 && !pRoot->leaf ){
    Pgno subpage;
    if( pRoot->pgno!=1 ) return sqlite3CorruptError(51250);
    subpage = sqlite3Get4byte(&pRoot->aData[pRoot->hdrOffset+8]);
    pCur->eState = 1;
    rc = moveToChild(pCur, subpage);
  }else{
    pCur->eState = ((pRoot->nCell>0)?1:0);
  }
  return rc;
}
# 51267 "ext/sqlite3/libsqlite/sqlite3.c"
static int moveToLeftmost(BtCursor *pCur){
  Pgno pgno;
  int rc = 0;
  MemPage *pPage;

  ((void) (0));
  ((void) (0));
  while( rc==0 && !(pPage = pCur->apPage[pCur->iPage])->leaf ){
    ((void) (0));
    pgno = sqlite3Get4byte(((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aData[(pPage)->cellOffset+2*(pCur->aiIdx[pCur->iPage])])[0]<<8 | (&(pPage)->aData[(pPage)->cellOffset+2*(pCur->aiIdx[pCur->iPage])])[1]))));
    rc = moveToChild(pCur, pgno);
  }
  return rc;
}
# 51292 "ext/sqlite3/libsqlite/sqlite3.c"
static int moveToRightmost(BtCursor *pCur){
  Pgno pgno;
  int rc = 0;
  MemPage *pPage = 0;

  ((void) (0));
  ((void) (0));
  while( rc==0 && !(pPage = pCur->apPage[pCur->iPage])->leaf ){
    pgno = sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8]);
    pCur->aiIdx[pCur->iPage] = pPage->nCell;
    rc = moveToChild(pCur, pgno);
  }
  if( rc==0 ){
    pCur->aiIdx[pCur->iPage] = pPage->nCell-1;
    pCur->info.nSize = 0;
    pCur->validNKey = 0;
  }
  return rc;
}





static int sqlite3BtreeFirst(BtCursor *pCur, int *pRes){
  int rc;

  ((void) (0));
  ((void) (0));
  rc = moveToRoot(pCur);
  if( rc==0 ){
    if( pCur->eState==0 ){
      ((void) (0));
      *pRes = 1;
    }else{
      ((void) (0));
      *pRes = 0;
      rc = moveToLeftmost(pCur);
    }
  }
  return rc;
}





static int sqlite3BtreeLast(BtCursor *pCur, int *pRes){
  int rc;

  ((void) (0));
  ((void) (0));


  if( 1==pCur->eState && pCur->atLast ){
# 51357 "ext/sqlite3/libsqlite/sqlite3.c"
    return 0;
  }

  rc = moveToRoot(pCur);
  if( rc==0 ){
    if( 0==pCur->eState ){
      ((void) (0));
      *pRes = 1;
    }else{
      ((void) (0));
      *pRes = 0;
      rc = moveToRightmost(pCur);
      pCur->atLast = rc==0 ?1:0;
    }
  }
  return rc;
}
# 51403 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeMovetoUnpacked(
  BtCursor *pCur,
  UnpackedRecord *pIdxKey,
  i64 intKey,
  int biasRight,
  int *pRes
){
  int rc;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));



  if( pCur->eState==1 && pCur->validNKey
   && pCur->apPage[0]->intKey
  ){
    if( pCur->info.nKey==intKey ){
      *pRes = 0;
      return 0;
    }
    if( pCur->atLast && pCur->info.nKey<intKey ){
      *pRes = -1;
      return 0;
    }
  }

  rc = moveToRoot(pCur);
  if( rc ){
    return rc;
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( pCur->eState==0 ){
    *pRes = -1;
    ((void) (0));
    return 0;
  }
  ((void) (0));
  for(;;){
    int lwr, upr;
    Pgno chldPg;
    MemPage *pPage = pCur->apPage[pCur->iPage];
    int c;







    ((void) (0));
    ((void) (0));
    lwr = 0;
    upr = pPage->nCell-1;
    if( biasRight ){
      pCur->aiIdx[pCur->iPage] = (u16)upr;
    }else{
      pCur->aiIdx[pCur->iPage] = (u16)((upr+lwr)/2);
    }
    for(;;){
      int idx = pCur->aiIdx[pCur->iPage];
      u8 *pCell;

      pCur->info.nSize = 0;
      pCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aData[(pPage)->cellOffset+2*(idx)])[0]<<8 | (&(pPage)->aData[(pPage)->cellOffset+2*(idx)])[1]))) + pPage->childPtrSize;
      if( pPage->intKey ){
        i64 nCellKey;
        if( pPage->hasData ){
          u32 dummy;
          pCell += (u8)((*(pCell)<(u8)0x80) ? ((dummy) = (u32)*(pCell)),1 : sqlite3GetVarint32((pCell), (u32 *)&(dummy)));
        }
        sqlite3GetVarint(pCell, (u64*)&nCellKey);
        if( nCellKey==intKey ){
          c = 0;
        }else if( nCellKey<intKey ){
          c = -1;
        }else{
          ((void) (0));
          c = +1;
        }
        pCur->validNKey = 1;
        pCur->info.nKey = nCellKey;
      }else{
# 51498 "ext/sqlite3/libsqlite/sqlite3.c"
        int nCell = pCell[0];
        if( !(nCell & 0x80) && nCell<=pPage->maxLocal ){



          c = sqlite3VdbeRecordCompare(nCell, (void*)&pCell[1], pIdxKey);
        }else if( !(pCell[1] & 0x80)
          && (nCell = ((nCell&0x7f)<<7) + pCell[1])<=pPage->maxLocal
        ){


          c = sqlite3VdbeRecordCompare(nCell, (void*)&pCell[2], pIdxKey);
        }else{




          void *pCellKey;
          u8 * const pCellBody = pCell - pPage->childPtrSize;
          btreeParseCellPtr(pPage, pCellBody, &pCur->info);
          nCell = (int)pCur->info.nKey;
          pCellKey = sqlite3Malloc( nCell );
          if( pCellKey==0 ){
            rc = 7;
            goto moveto_finish;
          }
          rc = accessPayload(pCur, 0, nCell, (unsigned char*)pCellKey, 0);
          if( rc ){
            sqlite3_free(pCellKey);
            goto moveto_finish;
          }
          c = sqlite3VdbeRecordCompare(nCell, pCellKey, pIdxKey);
          sqlite3_free(pCellKey);
        }
      }
      if( c==0 ){
        if( pPage->intKey && !pPage->leaf ){
          lwr = idx;
          upr = lwr - 1;
          break;
        }else{
          *pRes = 0;
          rc = 0;
          goto moveto_finish;
        }
      }
      if( c<0 ){
        lwr = idx+1;
      }else{
        upr = idx-1;
      }
      if( lwr>upr ){
        break;
      }
      pCur->aiIdx[pCur->iPage] = (u16)((lwr+upr)/2);
    }
    ((void) (0));
    ((void) (0));
    if( pPage->leaf ){
      chldPg = 0;
    }else if( lwr>=pPage->nCell ){
      chldPg = sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8]);
    }else{
      chldPg = sqlite3Get4byte(((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aData[(pPage)->cellOffset+2*(lwr)])[0]<<8 | (&(pPage)->aData[(pPage)->cellOffset+2*(lwr)])[1]))));
    }
    if( chldPg==0 ){
      ((void) (0));
      *pRes = c;
      rc = 0;
      goto moveto_finish;
    }
    pCur->aiIdx[pCur->iPage] = (u16)lwr;
    pCur->info.nSize = 0;
    pCur->validNKey = 0;
    rc = moveToChild(pCur, chldPg);
    if( rc ) goto moveto_finish;
  }
moveto_finish:
  return rc;
}
# 51587 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeEof(BtCursor *pCur){




  return (1!=pCur->eState);
}







static int sqlite3BtreeNext(BtCursor *pCur, int *pRes){
  int rc;
  int idx;
  MemPage *pPage;

  ((void) (0));
  rc = (pCur->eState>=2 ? btreeRestoreCursorPosition(pCur) : 0);
  if( rc!=0 ){
    return rc;
  }
  ((void) (0));
  if( 0==pCur->eState ){
    *pRes = 1;
    return 0;
  }
  if( pCur->skipNext>0 ){
    pCur->skipNext = 0;
    *pRes = 0;
    return 0;
  }
  pCur->skipNext = 0;

  pPage = pCur->apPage[pCur->iPage];
  idx = ++pCur->aiIdx[pCur->iPage];
  ((void) (0));
  ((void) (0));

  pCur->info.nSize = 0;
  pCur->validNKey = 0;
  if( idx>=pPage->nCell ){
    if( !pPage->leaf ){
      rc = moveToChild(pCur, sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8]));
      if( rc ) return rc;
      rc = moveToLeftmost(pCur);
      *pRes = 0;
      return rc;
    }
    do{
      if( pCur->iPage==0 ){
        *pRes = 1;
        pCur->eState = 0;
        return 0;
      }
      moveToParent(pCur);
      pPage = pCur->apPage[pCur->iPage];
    }while( pCur->aiIdx[pCur->iPage]>=pPage->nCell );
    *pRes = 0;
    if( pPage->intKey ){
      rc = sqlite3BtreeNext(pCur, pRes);
    }else{
      rc = 0;
    }
    return rc;
  }
  *pRes = 0;
  if( pPage->leaf ){
    return 0;
  }
  rc = moveToLeftmost(pCur);
  return rc;
}
# 51670 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreePrevious(BtCursor *pCur, int *pRes){
  int rc;
  MemPage *pPage;

  ((void) (0));
  rc = (pCur->eState>=2 ? btreeRestoreCursorPosition(pCur) : 0);
  if( rc!=0 ){
    return rc;
  }
  pCur->atLast = 0;
  if( 0==pCur->eState ){
    *pRes = 1;
    return 0;
  }
  if( pCur->skipNext<0 ){
    pCur->skipNext = 0;
    *pRes = 0;
    return 0;
  }
  pCur->skipNext = 0;

  pPage = pCur->apPage[pCur->iPage];
  ((void) (0));
  if( !pPage->leaf ){
    int idx = pCur->aiIdx[pCur->iPage];
    rc = moveToChild(pCur, sqlite3Get4byte(((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aData[(pPage)->cellOffset+2*(idx)])[0]<<8 | (&(pPage)->aData[(pPage)->cellOffset+2*(idx)])[1])))));
    if( rc ){
      return rc;
    }
    rc = moveToRightmost(pCur);
  }else{
    while( pCur->aiIdx[pCur->iPage]==0 ){
      if( pCur->iPage==0 ){
        pCur->eState = 0;
        *pRes = 1;
        return 0;
      }
      moveToParent(pCur);
    }
    pCur->info.nSize = 0;
    pCur->validNKey = 0;

    pCur->aiIdx[pCur->iPage]--;
    pPage = pCur->apPage[pCur->iPage];
    if( pPage->intKey && !pPage->leaf ){
      rc = sqlite3BtreePrevious(pCur, pRes);
    }else{
      rc = 0;
    }
  }
  *pRes = 0;
  return rc;
}
# 51745 "ext/sqlite3/libsqlite/sqlite3.c"
static int allocateBtreePage(
  BtShared *pBt,
  MemPage **ppPage,
  Pgno *pPgno,
  Pgno nearby,
  u8 exact
){
  MemPage *pPage1;
  int rc;
  u32 n;
  u32 k;
  MemPage *pTrunk = 0;
  MemPage *pPrevTrunk = 0;
  Pgno mxPage;

  ((void) (0));
  pPage1 = pBt->pPage1;
  mxPage = btreePagecount(pBt);
  n = sqlite3Get4byte(&pPage1->aData[36]);
                         ;
  if( n>=mxPage ){
    return sqlite3CorruptError(51766);
  }
  if( n>0 ){

    Pgno iTrunk;
    u8 searchList = 0;






    if( exact && nearby<=mxPage ){
      u8 eType;
      ((void) (0));
      ((void) (0));
      rc = ptrmapGet(pBt, nearby, &eType, 0);
      if( rc ) return rc;
      if( eType==2 ){
        searchList = 1;
      }
      *pPgno = nearby;
    }





    rc = sqlite3PagerWrite(pPage1->pDbPage);
    if( rc ) return rc;
    sqlite3Put4byte(&pPage1->aData[36], n-1);





    do {
      pPrevTrunk = pTrunk;
      if( pPrevTrunk ){
        iTrunk = sqlite3Get4byte(&pPrevTrunk->aData[0]);
      }else{
        iTrunk = sqlite3Get4byte(&pPage1->aData[32]);
      }
                                ;
      if( iTrunk>mxPage ){
        rc = sqlite3CorruptError(51811);
      }else{
        rc = btreeGetPage(pBt, iTrunk, &pTrunk, 0);
      }
      if( rc ){
        pTrunk = 0;
        goto end_allocate_page;
      }

      k = sqlite3Get4byte(&pTrunk->aData[4]);
      if( k==0 && !searchList ){



        ((void) (0));
        rc = sqlite3PagerWrite(pTrunk->pDbPage);
        if( rc ){
          goto end_allocate_page;
        }
        *pPgno = iTrunk;
        memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);
        *ppPage = pTrunk;
        pTrunk = 0;
                                                                         ;
      }else if( k>(u32)(pBt->usableSize/4 - 2) ){

        rc = sqlite3CorruptError(51837);
        goto end_allocate_page;

      }else if( searchList && nearby==iTrunk ){



        ((void) (0));
        *ppPage = pTrunk;
        searchList = 0;
        rc = sqlite3PagerWrite(pTrunk->pDbPage);
        if( rc ){
          goto end_allocate_page;
        }
        if( k==0 ){
          if( !pPrevTrunk ){
            memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);
          }else{
            rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);
            if( rc!=0 ){
              goto end_allocate_page;
            }
            memcpy(&pPrevTrunk->aData[0], &pTrunk->aData[0], 4);
          }
        }else{




          MemPage *pNewTrunk;
          Pgno iNewTrunk = sqlite3Get4byte(&pTrunk->aData[8]);
          if( iNewTrunk>mxPage ){
            rc = sqlite3CorruptError(51869);
            goto end_allocate_page;
          }
                                       ;
          rc = btreeGetPage(pBt, iNewTrunk, &pNewTrunk, 0);
          if( rc!=0 ){
            goto end_allocate_page;
          }
          rc = sqlite3PagerWrite(pNewTrunk->pDbPage);
          if( rc!=0 ){
            releasePage(pNewTrunk);
            goto end_allocate_page;
          }
          memcpy(&pNewTrunk->aData[0], &pTrunk->aData[0], 4);
          sqlite3Put4byte(&pNewTrunk->aData[4], k-1);
          memcpy(&pNewTrunk->aData[8], &pTrunk->aData[12], (k-1)*4);
          releasePage(pNewTrunk);
          if( !pPrevTrunk ){
            ((void) (0));
            sqlite3Put4byte(&pPage1->aData[32], iNewTrunk);
          }else{
            rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);
            if( rc ){
              goto end_allocate_page;
            }
            sqlite3Put4byte(&pPrevTrunk->aData[0], iNewTrunk);
          }
        }
        pTrunk = 0;
                                                                         ;

      }else if( k>0 ){

        u32 closest;
        Pgno iPage;
        unsigned char *aData = pTrunk->aData;
        if( nearby>0 ){
          u32 i;
          int dist;
          closest = 0;
          dist = sqlite3AbsInt32(sqlite3Get4byte(&aData[8]) - nearby);
          for(i=1; i<k; i++){
            int d2 = sqlite3AbsInt32(sqlite3Get4byte(&aData[8+i*4]) - nearby);
            if( d2<dist ){
              closest = i;
              dist = d2;
            }
          }
        }else{
          closest = 0;
        }

        iPage = sqlite3Get4byte(&aData[8+closest*4]);
                                 ;
        if( iPage>mxPage ){
          rc = sqlite3CorruptError(51924);
          goto end_allocate_page;
        }
                                 ;
        if( !searchList || iPage==nearby ){
          int noContent;
          *pPgno = iPage;


                                                          ;
          rc = sqlite3PagerWrite(pTrunk->pDbPage);
          if( rc ) goto end_allocate_page;
          if( closest<k-1 ){
            memcpy(&aData[8+closest*4], &aData[4+k*4], 4);
          }
          sqlite3Put4byte(&aData[4], k-1);
          noContent = !btreeGetHasContent(pBt, *pPgno);
          rc = btreeGetPage(pBt, *pPgno, ppPage, noContent);
          if( rc==0 ){
            rc = sqlite3PagerWrite((*ppPage)->pDbPage);
            if( rc!=0 ){
              releasePage(*ppPage);
            }
          }
          searchList = 0;
        }
      }
      releasePage(pPrevTrunk);
      pPrevTrunk = 0;
    }while( searchList );
  }else{


    rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
    if( rc ) return rc;
    pBt->nPage++;
    if( pBt->nPage==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ) pBt->nPage++;


    if( pBt->autoVacuum && (ptrmapPageno((pBt), (pBt->nPage))==(pBt->nPage)) ){




      MemPage *pPg = 0;
                                                                               ;
      ((void) (0));
      rc = btreeGetPage(pBt, pBt->nPage, &pPg, 1);
      if( rc==0 ){
        rc = sqlite3PagerWrite(pPg->pDbPage);
        releasePage(pPg);
      }
      if( rc ) return rc;
      pBt->nPage++;
      if( pBt->nPage==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){ pBt->nPage++; }
    }

    sqlite3Put4byte(28 + (u8*)pBt->pPage1->aData, pBt->nPage);
    *pPgno = pBt->nPage;

    ((void) (0));
    rc = btreeGetPage(pBt, *pPgno, ppPage, 1);
    if( rc ) return rc;
    rc = sqlite3PagerWrite((*ppPage)->pDbPage);
    if( rc!=0 ){
      releasePage(*ppPage);
    }
                                                      ;
  }

  ((void) (0));

end_allocate_page:
  releasePage(pTrunk);
  releasePage(pPrevTrunk);
  if( rc==0 ){
    if( sqlite3PagerPageRefcount((*ppPage)->pDbPage)>1 ){
      releasePage(*ppPage);
      return sqlite3CorruptError(52002);
    }
    (*ppPage)->isInit = 0;
  }else{
    *ppPage = 0;
  }
  ((void) (0));
  return rc;
}
# 52024 "ext/sqlite3/libsqlite/sqlite3.c"
static int freePage2(BtShared *pBt, MemPage *pMemPage, Pgno iPage){
  MemPage *pTrunk = 0;
  Pgno iTrunk = 0;
  MemPage *pPage1 = pBt->pPage1;
  MemPage *pPage;
  int rc;
  int nFree;

  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( pMemPage ){
    pPage = pMemPage;
    sqlite3PagerRef(pPage->pDbPage);
  }else{
    pPage = btreePageLookup(pBt, iPage);
  }


  rc = sqlite3PagerWrite(pPage1->pDbPage);
  if( rc ) goto freepage_out;
  nFree = sqlite3Get4byte(&pPage1->aData[36]);
  sqlite3Put4byte(&pPage1->aData[36], nFree+1);

  if( pBt->secureDelete ){



    if( (!pPage && ((rc = btreeGetPage(pBt, iPage, &pPage, 0))!=0) )
     || ((rc = sqlite3PagerWrite(pPage->pDbPage))!=0)
    ){
      goto freepage_out;
    }
    memset(pPage->aData, 0, pPage->pBt->pageSize);
  }




  if( (pBt->autoVacuum) ){
    ptrmapPut(pBt, iPage, 2, 0, &rc);
    if( rc ) goto freepage_out;
  }
# 52076 "ext/sqlite3/libsqlite/sqlite3.c"
  if( nFree!=0 ){
    u32 nLeaf;

    iTrunk = sqlite3Get4byte(&pPage1->aData[32]);
    rc = btreeGetPage(pBt, iTrunk, &pTrunk, 0);
    if( rc!=0 ){
      goto freepage_out;
    }

    nLeaf = sqlite3Get4byte(&pTrunk->aData[4]);
    ((void) (0));
    if( nLeaf > (u32)pBt->usableSize/4 - 2 ){
      rc = sqlite3CorruptError(52088);
      goto freepage_out;
    }
    if( nLeaf < (u32)pBt->usableSize/4 - 8 ){
# 52106 "ext/sqlite3/libsqlite/sqlite3.c"
      rc = sqlite3PagerWrite(pTrunk->pDbPage);
      if( rc==0 ){
        sqlite3Put4byte(&pTrunk->aData[4], nLeaf+1);
        sqlite3Put4byte(&pTrunk->aData[8+nLeaf*4], iPage);
        if( pPage && !pBt->secureDelete ){
          sqlite3PagerDontWrite(pPage->pDbPage);
        }
        rc = btreeSetHasContent(pBt, iPage);
      }
                                                                               ;
      goto freepage_out;
    }
  }







  if( pPage==0 && 0!=(rc = btreeGetPage(pBt, iPage, &pPage, 0)) ){
    goto freepage_out;
  }
  rc = sqlite3PagerWrite(pPage->pDbPage);
  if( rc!=0 ){
    goto freepage_out;
  }
  sqlite3Put4byte(pPage->aData, iTrunk);
  sqlite3Put4byte(&pPage->aData[4], 0);
  sqlite3Put4byte(&pPage1->aData[32], iPage);
                                                                             ;

freepage_out:
  if( pPage ){
    pPage->isInit = 0;
  }
  releasePage(pPage);
  releasePage(pTrunk);
  return rc;
}
static void freePage(MemPage *pPage, int *pRC){
  if( (*pRC)==0 ){
    *pRC = freePage2(pPage->pBt, pPage, pPage->pgno);
  }
}




static int clearCell(MemPage *pPage, unsigned char *pCell){
  BtShared *pBt = pPage->pBt;
  CellInfo info;
  Pgno ovflPgno;
  int rc;
  int nOvfl;
  u32 ovflPageSize;

  ((void) (0));
  btreeParseCellPtr(pPage, pCell, &info);
  if( info.iOverflow==0 ){
    return 0;
  }
  ovflPgno = sqlite3Get4byte(&pCell[info.iOverflow]);
  ((void) (0));
  ovflPageSize = pBt->usableSize - 4;
  nOvfl = (info.nPayload - info.nLocal + ovflPageSize - 1)/ovflPageSize;
  ((void) (0));
  while( nOvfl-- ){
    Pgno iNext = 0;
    MemPage *pOvfl = 0;
    if( ovflPgno<2 || ovflPgno>btreePagecount(pBt) ){



      return sqlite3CorruptError(52180);
    }
    if( nOvfl ){
      rc = getOverflowPage(pBt, ovflPgno, &pOvfl, &iNext);
      if( rc ) return rc;
    }

    if( ( pOvfl || ((pOvfl = btreePageLookup(pBt, ovflPgno))!=0) )
     && sqlite3PagerPageRefcount(pOvfl->pDbPage)!=1
    ){
# 52200 "ext/sqlite3/libsqlite/sqlite3.c"
      rc = sqlite3CorruptError(52200);
    }else{
      rc = freePage2(pBt, pOvfl, ovflPgno);
    }

    if( pOvfl ){
      sqlite3PagerUnref(pOvfl->pDbPage);
    }
    if( rc ) return rc;
    ovflPgno = iNext;
  }
  return 0;
}
# 52226 "ext/sqlite3/libsqlite/sqlite3.c"
static int fillInCell(
  MemPage *pPage,
  unsigned char *pCell,
  const void *pKey, i64 nKey,
  const void *pData,int nData,
  int nZero,
  int *pnSize
){
  int nPayload;
  const u8 *pSrc;
  int nSrc, n, rc;
  int spaceLeft;
  MemPage *pOvfl = 0;
  MemPage *pToRelease = 0;
  unsigned char *pPrior;
  unsigned char *pPayload;
  BtShared *pBt = pPage->pBt;
  Pgno pgnoOvfl = 0;
  int nHeader;
  CellInfo info;

  ((void) (0));



  ((void) (0));



  nHeader = 0;
  if( !pPage->leaf ){
    nHeader += 4;
  }
  if( pPage->hasData ){
    nHeader += sqlite3PutVarint(&pCell[nHeader], nData+nZero);
  }else{
    nData = nZero = 0;
  }
  nHeader += sqlite3PutVarint(&pCell[nHeader], *(u64*)&nKey);
  btreeParseCellPtr(pPage, pCell, &info);
  ((void) (0));
  ((void) (0));
  ((void) (0));


  nPayload = nData + nZero;
  if( pPage->intKey ){
    pSrc = pData;
    nSrc = nData;
    nData = 0;
  }else{
    if( (nKey>0x7fffffff || pKey==0) ){
      return sqlite3CorruptError(52278);
    }
    nPayload += (int)nKey;
    pSrc = pKey;
    nSrc = (int)nKey;
  }
  *pnSize = info.nSize;
  spaceLeft = info.nLocal;
  pPayload = &pCell[nHeader];
  pPrior = &pCell[info.iOverflow];

  while( nPayload>0 ){
    if( spaceLeft==0 ){

      Pgno pgnoPtrmap = pgnoOvfl;
      if( pBt->autoVacuum ){
        do{
          pgnoOvfl++;
        } while(
          (ptrmapPageno((pBt), (pgnoOvfl))==(pgnoOvfl)) || pgnoOvfl==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1))
        );
      }

      rc = allocateBtreePage(pBt, &pOvfl, &pgnoOvfl, pgnoOvfl, 0);
# 52313 "ext/sqlite3/libsqlite/sqlite3.c"
      if( pBt->autoVacuum && rc==0 ){
        u8 eType = (pgnoPtrmap?4:3);
        ptrmapPut(pBt, pgnoOvfl, eType, pgnoPtrmap, &rc);
        if( rc ){
          releasePage(pOvfl);
        }
      }

      if( rc ){
        releasePage(pToRelease);
        return rc;
      }



      ((void) (0));



      ((void) (0));


      sqlite3Put4byte(pPrior, pgnoOvfl);
      releasePage(pToRelease);
      pToRelease = pOvfl;
      pPrior = pOvfl->aData;
      sqlite3Put4byte(pPrior, 0);
      pPayload = &pOvfl->aData[4];
      spaceLeft = pBt->usableSize - 4;
    }
    n = nPayload;
    if( n>spaceLeft ) n = spaceLeft;



    ((void) (0));



    ((void) (0));


    if( nSrc>0 ){
      if( n>nSrc ) n = nSrc;
      ((void) (0));
      memcpy(pPayload, pSrc, n);
    }else{
      memset(pPayload, 0, n);
    }
    nPayload -= n;
    pPayload += n;
    pSrc += n;
    nSrc -= n;
    spaceLeft -= n;
    if( nSrc==0 ){
      nSrc = nData;
      pSrc = pData;
    }
  }
  releasePage(pToRelease);
  return 0;
}
# 52384 "ext/sqlite3/libsqlite/sqlite3.c"
static void dropCell(MemPage *pPage, int idx, int sz, int *pRC){
  int i;
  u32 pc;
  u8 *data;
  u8 *ptr;
  int rc;
  int hdr;

  if( *pRC ) return;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  data = pPage->aData;
  ptr = &data[pPage->cellOffset + 2*idx];
  pc = ((ptr)[0]<<8 | (ptr)[1]);
  hdr = pPage->hdrOffset;
                                        ;
                                           ;
  if( pc < (u32)((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]) || pc+sz > pPage->pBt->usableSize ){
    *pRC = sqlite3CorruptError(52405);
    return;
  }
  rc = freeSpace(pPage, pc, sz);
  if( rc ){
    *pRC = rc;
    return;
  }
  for(i=idx+1; i<pPage->nCell; i++, ptr+=2){
    ptr[0] = ptr[2];
    ptr[1] = ptr[3];
  }
  pPage->nCell--;
  ((&data[hdr+3])[0] = (u8)((pPage->nCell)>>8), (&data[hdr+3])[1] = (u8)(pPage->nCell));
  pPage->nFree += 2;
}
# 52439 "ext/sqlite3/libsqlite/sqlite3.c"
static void insertCell(
  MemPage *pPage,
  int i,
  u8 *pCell,
  int sz,
  u8 *pTemp,
  Pgno iChild,
  int *pRC
){
  int idx = 0;
  int j;
  int end;
  int ins;
  int cellOffset;
  u8 *data;
  u8 *ptr;

  int nSkip = (iChild ? 4 : 0);

  if( *pRC ) return;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));





  ((void) (0));
  if( pPage->nOverflow || sz+2>pPage->nFree ){
    if( pTemp ){
      memcpy(pTemp+nSkip, pCell+nSkip, sz-nSkip);
      pCell = pTemp;
    }
    if( iChild ){
      sqlite3Put4byte(pCell, iChild);
    }
    j = pPage->nOverflow++;
    ((void) (0));
    pPage->aOvfl[j].pCell = pCell;
    pPage->aOvfl[j].idx = (u16)i;
  }else{
    int rc = sqlite3PagerWrite(pPage->pDbPage);
    if( rc!=0 ){
      *pRC = rc;
      return;
    }
    ((void) (0));
    data = pPage->aData;
    cellOffset = pPage->cellOffset;
    end = cellOffset + 2*pPage->nCell;
    ins = cellOffset + 2*i;
    rc = allocateSpace(pPage, sz, &idx);
    if( rc ){ *pRC = rc; return; }


    ((void) (0));
    ((void) (0));
    pPage->nCell++;
    pPage->nFree -= (u16)(2 + sz);
    memcpy(&data[idx+nSkip], pCell+nSkip, sz-nSkip);
    if( iChild ){
      sqlite3Put4byte(&data[idx], iChild);
    }
    for(j=end, ptr=&data[j]; j>ins; j-=2, ptr-=2){
      ptr[0] = ptr[-2];
      ptr[1] = ptr[-1];
    }
    ((&data[ins])[0] = (u8)((idx)>>8), (&data[ins])[1] = (u8)(idx));
    ((&data[pPage->hdrOffset+3])[0] = (u8)((pPage->nCell)>>8), (&data[pPage->hdrOffset+3])[1] = (u8)(pPage->nCell));

    if( pPage->pBt->autoVacuum ){



      ptrmapPutOvflPtr(pPage, pCell, pRC);
    }

  }
}





static void assemblePage(
  MemPage *pPage,
  int nCell,
  u8 **apCell,
  u16 *aSize
){
  int i;
  u8 *pCellptr;
  int cellbody;
  u8 * const data = pPage->aData;
  const int hdr = pPage->hdrOffset;
  const int nUsable = pPage->pBt->usableSize;

  ((void) (0));
  ((void) (0));
  ((void) (0));

  ((void) (0));


  ((void) (0));
  ((void) (0));

  pCellptr = &data[pPage->cellOffset + nCell*2];
  cellbody = nUsable;
  for(i=nCell-1; i>=0; i--){
    pCellptr -= 2;
    cellbody -= aSize[i];
    ((pCellptr)[0] = (u8)((cellbody)>>8), (pCellptr)[1] = (u8)(cellbody));
    memcpy(&data[cellbody], apCell[i], aSize[i]);
  }
  ((&data[hdr+3])[0] = (u8)((nCell)>>8), (&data[hdr+3])[1] = (u8)(nCell));
  ((&data[hdr+5])[0] = (u8)((cellbody)>>8), (&data[hdr+5])[1] = (u8)(cellbody));
  pPage->nFree -= (nCell*2 + nUsable - cellbody);
  pPage->nCell = (u16)nCell;
}
# 52603 "ext/sqlite3/libsqlite/sqlite3.c"
static int balance_quick(MemPage *pParent, MemPage *pPage, u8 *pSpace){
  BtShared *const pBt = pPage->pBt;
  MemPage *pNew;
  int rc;
  Pgno pgnoNew;

  ((void) (0));
  ((void) (0));
  ((void) (0));


  if( pPage->nCell<=0 ) return sqlite3CorruptError(52614);





  rc = allocateBtreePage(pBt, &pNew, &pgnoNew, 0, 0);

  if( rc==0 ){

    u8 *pOut = &pSpace[4];
    u8 *pCell = pPage->aOvfl[0].pCell;
    u16 szCell = cellSizePtr(pPage, pCell);
    u8 *pStop;

    ((void) (0));
    ((void) (0));
    zeroPage(pNew, 0x01|0x04|0x08);
    assemblePage(pNew, 1, &pCell, &szCell);
# 52643 "ext/sqlite3/libsqlite/sqlite3.c"
    if( (pBt->autoVacuum) ){
      ptrmapPut(pBt, pgnoNew, 5, pParent->pgno, &rc);
      if( szCell>pNew->minLocal ){
        ptrmapPutOvflPtr(pNew, pCell, &rc);
      }
    }
# 52663 "ext/sqlite3/libsqlite/sqlite3.c"
    pCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aData[(pPage)->cellOffset+2*(pPage->nCell-1)])[0]<<8 | (&(pPage)->aData[(pPage)->cellOffset+2*(pPage->nCell-1)])[1])));
    pStop = &pCell[9];
    while( (*(pCell++)&0x80) && pCell<pStop );
    pStop = &pCell[9];
    while( ((*(pOut++) = *(pCell++))&0x80) && pCell<pStop );


    insertCell(pParent, pParent->nCell, pSpace, (int)(pOut-pSpace),
               0, pPage->pgno, &rc);


    sqlite3Put4byte(&pParent->aData[pParent->hdrOffset+8], pgnoNew);


    releasePage(pNew);
  }

  return rc;
}
# 52743 "ext/sqlite3/libsqlite/sqlite3.c"
static void copyNodeContent(MemPage *pFrom, MemPage *pTo, int *pRC){
  if( (*pRC)==0 ){
    BtShared * const pBt = pFrom->pBt;
    u8 * const aFrom = pFrom->aData;
    u8 * const aTo = pTo->aData;
    int const iFromHdr = pFrom->hdrOffset;
    int const iToHdr = ((pTo->pgno==1) ? 100 : 0);
    int rc;
    int iData;


    ((void) (0));
    ((void) (0));
    ((void) (0));


    iData = ((&aFrom[iFromHdr+5])[0]<<8 | (&aFrom[iFromHdr+5])[1]);
    memcpy(&aTo[iData], &aFrom[iData], pBt->usableSize-iData);
    memcpy(&aTo[iToHdr], &aFrom[iFromHdr], pFrom->cellOffset + 2*pFrom->nCell);






    pTo->isInit = 0;
    rc = btreeInitPage(pTo);
    if( rc!=0 ){
      *pRC = rc;
      return;
    }




    if( (pBt->autoVacuum) ){
      *pRC = setChildPtrmaps(pTo);
    }
  }
}
# 52824 "ext/sqlite3/libsqlite/sqlite3.c"
static int balance_nonroot(
  MemPage *pParent,
  int iParentIdx,
  u8 *aOvflSpace,
  int isRoot
){
  BtShared *pBt;
  int nCell = 0;
  int nMaxCells = 0;
  int nNew = 0;
  int nOld;
  int i, j, k;
  int nxDiv;
  int rc = 0;
  u16 leafCorrection;
  int leafData;
  int usableSpace;
  int pageFlags;
  int subtotal;
  int iSpace1 = 0;
  int iOvflSpace = 0;
  int szScratch;
  MemPage *apOld[(1*2+1)];
  MemPage *apCopy[(1*2+1)];
  MemPage *apNew[(1*2+1)+2];
  u8 *pRight;
  u8 *apDiv[(1*2+1)-1];
  int cntNew[(1*2+1)+2];
  int szNew[(1*2+1)+2];
  u8 **apCell = 0;
  u16 *szCell;
  u8 *aSpace1;
  Pgno pgno;

  pBt = pParent->pBt;
  ((void) (0));
  ((void) (0));
# 52871 "ext/sqlite3/libsqlite/sqlite3.c"
  ((void) (0));
  ((void) (0));

  if( !aOvflSpace ){
    return 7;
  }
# 52889 "ext/sqlite3/libsqlite/sqlite3.c"
  i = pParent->nOverflow + pParent->nCell;
  if( i<2 ){
    nxDiv = 0;
    nOld = i+1;
  }else{
    nOld = 3;
    if( iParentIdx==0 ){
      nxDiv = 0;
    }else if( iParentIdx==i ){
      nxDiv = i-2;
    }else{
      nxDiv = iParentIdx-1;
    }
    i = 2;
  }
  if( (i+nxDiv-pParent->nOverflow)==pParent->nCell ){
    pRight = &pParent->aData[pParent->hdrOffset+8];
  }else{
    pRight = ((pParent)->aData + ((pParent)->maskPage & ((&(pParent)->aData[(pParent)->cellOffset+2*(i+nxDiv-pParent->nOverflow)])[0]<<8 | (&(pParent)->aData[(pParent)->cellOffset+2*(i+nxDiv-pParent->nOverflow)])[1])));
  }
  pgno = sqlite3Get4byte(pRight);
  while( 1 ){
    rc = getAndInitPage(pBt, pgno, &apOld[i]);
    if( rc ){
      memset(apOld, 0, (i+1)*sizeof(MemPage*));
      goto balance_cleanup;
    }
    nMaxCells += 1+apOld[i]->nCell+apOld[i]->nOverflow;
    if( (i--)==0 ) break;

    if( i+nxDiv==pParent->aOvfl[0].idx && pParent->nOverflow ){
      apDiv[i] = pParent->aOvfl[0].pCell;
      pgno = sqlite3Get4byte(apDiv[i]);
      szNew[i] = cellSizePtr(pParent, apDiv[i]);
      pParent->nOverflow = 0;
    }else{
      apDiv[i] = ((pParent)->aData + ((pParent)->maskPage & ((&(pParent)->aData[(pParent)->cellOffset+2*(i+nxDiv-pParent->nOverflow)])[0]<<8 | (&(pParent)->aData[(pParent)->cellOffset+2*(i+nxDiv-pParent->nOverflow)])[1])));
      pgno = sqlite3Get4byte(apDiv[i]);
      szNew[i] = cellSizePtr(pParent, apDiv[i]);
# 52941 "ext/sqlite3/libsqlite/sqlite3.c"
      if( pBt->secureDelete ){
        int iOff = ((int)(long int)(apDiv[i])) - ((int)(long int)(pParent->aData));
        if( (iOff+szNew[i])>(int)pBt->usableSize ){
          rc = sqlite3CorruptError(52944);
          memset(apOld, 0, (i+1)*sizeof(MemPage*));
          goto balance_cleanup;
        }else{
          memcpy(&aOvflSpace[iOff], apDiv[i], szNew[i]);
          apDiv[i] = &aOvflSpace[apDiv[i]-pParent->aData];
        }
      }
      dropCell(pParent, i+nxDiv-pParent->nOverflow, szNew[i], &rc);
    }
  }



  nMaxCells = (nMaxCells + 3)&~3;




  k = pBt->pageSize + (((sizeof(MemPage))+7)&~7);
  szScratch =
       nMaxCells*sizeof(u8*)
     + nMaxCells*sizeof(u16)
     + pBt->pageSize
     + k*nOld;
  apCell = sqlite3ScratchMalloc( szScratch );
  if( apCell==0 ){
    rc = 7;
    goto balance_cleanup;
  }
  szCell = (u16*)&apCell[nMaxCells];
  aSpace1 = (u8*)&szCell[nMaxCells];
  ((void) (0));
# 52994 "ext/sqlite3/libsqlite/sqlite3.c"
  leafCorrection = apOld[0]->leaf*4;
  leafData = apOld[0]->hasData;
  for(i=0; i<nOld; i++){
    int limit;





    MemPage *pOld = apCopy[i] = (MemPage*)&aSpace1[pBt->pageSize + k*i];
    memcpy(pOld, apOld[i], sizeof(MemPage));
    pOld->aData = (void*)&pOld[1];
    memcpy(pOld->aData, apOld[i]->aData, pBt->pageSize);

    limit = pOld->nCell+pOld->nOverflow;
    for(j=0; j<limit; j++){
      ((void) (0));
      apCell[nCell] = findOverflowCell(pOld, j);
      szCell[nCell] = cellSizePtr(pOld, apCell[nCell]);
      nCell++;
    }
    if( i<nOld-1 && !leafData){
      u16 sz = (u16)szNew[i];
      u8 *pTemp;
      ((void) (0));
      szCell[nCell] = sz;
      pTemp = &aSpace1[iSpace1];
      iSpace1 += sz;
      ((void) (0));
      ((void) (0));
      memcpy(pTemp, apDiv[i], sz);
      apCell[nCell] = pTemp+leafCorrection;
      ((void) (0));
      szCell[nCell] = szCell[nCell] - leafCorrection;
      if( !pOld->leaf ){
        ((void) (0));
        ((void) (0));


        memcpy(apCell[nCell], &pOld->aData[8], 4);
      }else{
        ((void) (0));
        if( szCell[nCell]<4 ){

          szCell[nCell] = 4;
        }
      }
      nCell++;
    }
  }
# 53061 "ext/sqlite3/libsqlite/sqlite3.c"
  usableSpace = pBt->usableSize - 12 + leafCorrection;
  for(subtotal=k=i=0; i<nCell; i++){
    ((void) (0));
    subtotal += szCell[i] + 2;
    if( subtotal > usableSpace ){
      szNew[k] = subtotal - szCell[i];
      cntNew[k] = i;
      if( leafData ){ i--; }
      subtotal = 0;
      k++;
      if( k>(1*2+1)+1 ){ rc = sqlite3CorruptError(53071); goto balance_cleanup; }
    }
  }
  szNew[k] = subtotal;
  cntNew[k] = nCell;
  k++;
# 53088 "ext/sqlite3/libsqlite/sqlite3.c"
  for(i=k-1; i>0; i--){
    int szRight = szNew[i];
    int szLeft = szNew[i-1];
    int r;
    int d;

    r = cntNew[i-1] - 1;
    d = r + 1 - leafData;
    ((void) (0));
    ((void) (0));
    while( szRight==0 || szRight+szCell[d]+2<=szLeft-(szCell[r]+2) ){
      szRight += szCell[d] + 2;
      szLeft -= szCell[r] + 2;
      cntNew[i-1]--;
      r = cntNew[i-1] - 1;
      d = r + 1 - leafData;
    }
    szNew[i] = szRight;
    szNew[i-1] = szLeft;
  }





  ((void) (0));





    ;




  if( apOld[0]->pgno<=1 ){
    rc = sqlite3CorruptError(53125);
    goto balance_cleanup;
  }
  pageFlags = apOld[0]->aData[0];
  for(i=0; i<k; i++){
    MemPage *pNew;
    if( i<nOld ){
      pNew = apNew[i] = apOld[i];
      apOld[i] = 0;
      rc = sqlite3PagerWrite(pNew->pDbPage);
      nNew++;
      if( rc ) goto balance_cleanup;
    }else{
      ((void) (0));
      rc = allocateBtreePage(pBt, &pNew, &pgno, pgno, 0);
      if( rc ) goto balance_cleanup;
      apNew[i] = pNew;
      nNew++;


      if( (pBt->autoVacuum) ){
        ptrmapPut(pBt, pNew->pgno, 5, pParent->pgno, &rc);
        if( rc!=0 ){
          goto balance_cleanup;
        }
      }
    }
  }



  while( i<nOld ){
    freePage(apOld[i], &rc);
    if( rc ) goto balance_cleanup;
    releasePage(apOld[i]);
    apOld[i] = 0;
    i++;
  }
# 53178 "ext/sqlite3/libsqlite/sqlite3.c"
  for(i=0; i<k-1; i++){
    int minV = apNew[i]->pgno;
    int minI = i;
    for(j=i+1; j<k; j++){
      if( apNew[j]->pgno<(unsigned)minV ){
        minI = j;
        minV = apNew[j]->pgno;
      }
    }
    if( minI>i ){
      MemPage *pT;
      pT = apNew[i];
      apNew[i] = apNew[minI];
      apNew[minI] = pT;
    }
  }





                                                          ;

  ((void) (0));
  sqlite3Put4byte(pRight, apNew[nNew-1]->pgno);





  j = 0;
  for(i=0; i<nNew; i++){

    MemPage *pNew = apNew[i];
    ((void) (0));
    zeroPage(pNew, pageFlags);
    assemblePage(pNew, cntNew[i]-j, &apCell[j], &szCell[j]);
    ((void) (0));
    ((void) (0));

    j = cntNew[i];




    ((void) (0));
    if( j<nCell ){
      u8 *pCell;
      u8 *pTemp;
      int sz;

      ((void) (0));
      pCell = apCell[j];
      sz = szCell[j] + leafCorrection;
      pTemp = &aOvflSpace[iOvflSpace];
      if( !pNew->leaf ){
        memcpy(&pNew->aData[8], pCell, 4);
      }else if( leafData ){





        CellInfo info;
        j--;
        btreeParseCellPtr(pNew, apCell[j], &info);
        pCell = pTemp;
        sz = 4 + sqlite3PutVarint(&pCell[4], info.nKey);
        pTemp = 0;
      }else{
        pCell -= 4;
# 53260 "ext/sqlite3/libsqlite/sqlite3.c"
        if( szCell[j]==4 ){
          ((void) (0));
          sz = cellSizePtr(pParent, pCell);
        }
      }
      iOvflSpace += sz;
      ((void) (0));
      ((void) (0));
      insertCell(pParent, nxDiv, pCell, sz, pTemp, pNew->pgno, &rc);
      if( rc!=0 ) goto balance_cleanup;
      ((void) (0));

      j++;
      nxDiv++;
    }
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( (pageFlags & 0x08)==0 ){
    u8 *zChild = &apCopy[nOld-1]->aData[8];
    memcpy(&apNew[nNew-1]->aData[8], zChild, 4);
  }

  if( isRoot && pParent->nCell==0 && pParent->hdrOffset<=apNew[0]->nFree ){
# 53299 "ext/sqlite3/libsqlite/sqlite3.c"
    ((void) (0));
    ((void) (0));


    copyNodeContent(apNew[0], pParent, &rc);
    freePage(apNew[0], &rc);
  }else if( (pBt->autoVacuum) ){
# 53337 "ext/sqlite3/libsqlite/sqlite3.c"
    MemPage *pNew = apNew[0];
    MemPage *pOld = apCopy[0];
    int nOverflow = pOld->nOverflow;
    int iNextOld = pOld->nCell + nOverflow;
    int iOverflow = (nOverflow ? pOld->aOvfl[0].idx : -1);
    j = 0;
    k = 0;
    for(i=0; i<nCell; i++){
      int isDivider = 0;
      while( i==iNextOld ){



        pOld = apCopy[++j];
        iNextOld = i + !leafData + pOld->nCell + pOld->nOverflow;
        if( pOld->nOverflow ){
          nOverflow = pOld->nOverflow;
          iOverflow = i + !leafData + pOld->aOvfl[0].idx;
        }
        isDivider = !leafData;
      }

      ((void) (0));
      ((void) (0));
      ((void) (0));
      if( i==iOverflow ){
        isDivider = 1;
        if( (--nOverflow)>0 ){
          iOverflow++;
        }
      }

      if( i==cntNew[k] ){



        pNew = apNew[++k];
        if( !leafData ) continue;
      }
      ((void) (0));
      ((void) (0));





      if( isDivider || pOld->pgno!=pNew->pgno ){
        if( !leafCorrection ){
          ptrmapPut(pBt, sqlite3Get4byte(apCell[i]), 5, pNew->pgno, &rc);
        }
        if( szCell[i]>pNew->minLocal ){
          ptrmapPutOvflPtr(pNew, apCell[i], &rc);
        }
      }
    }

    if( !leafCorrection ){
      for(i=0; i<nNew; i++){
        u32 key = sqlite3Get4byte(&apNew[i]->aData[8]);
        ptrmapPut(pBt, key, 5, apNew[i]->pgno, &rc);
      }
    }
# 53408 "ext/sqlite3/libsqlite/sqlite3.c"
  }

  ((void) (0));

                             ;




balance_cleanup:
  sqlite3ScratchFree(apCell);
  for(i=0; i<nOld; i++){
    releasePage(apOld[i]);
  }
  for(i=0; i<nNew; i++){
    releasePage(apNew[i]);
  }

  return rc;
}
# 53449 "ext/sqlite3/libsqlite/sqlite3.c"
static int balance_deeper(MemPage *pRoot, MemPage **ppChild){
  int rc;
  MemPage *pChild = 0;
  Pgno pgnoChild = 0;
  BtShared *pBt = pRoot->pBt;

  ((void) (0));
  ((void) (0));





  rc = sqlite3PagerWrite(pRoot->pDbPage);
  if( rc==0 ){
    rc = allocateBtreePage(pBt,&pChild,&pgnoChild,pRoot->pgno,0);
    copyNodeContent(pRoot, pChild, &rc);
    if( (pBt->autoVacuum) ){
      ptrmapPut(pBt, pgnoChild, 5, pRoot->pgno, &rc);
    }
  }
  if( rc ){
    *ppChild = 0;
    releasePage(pChild);
    return rc;
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));

                                                                       ;


  memcpy(pChild->aOvfl, pRoot->aOvfl, pRoot->nOverflow*sizeof(pRoot->aOvfl[0]));
  pChild->nOverflow = pRoot->nOverflow;


  zeroPage(pRoot, pChild->aData[0] & ~0x08);
  sqlite3Put4byte(&pRoot->aData[pRoot->hdrOffset+8], pgnoChild);

  *ppChild = pChild;
  return 0;
}
# 53503 "ext/sqlite3/libsqlite/sqlite3.c"
static int balance(BtCursor *pCur){
  int rc = 0;
  const int nMin = pCur->pBt->usableSize * 2 / 3;
  u8 aBalanceQuickSpace[13];
  u8 *pFree = 0;

                                          ;
                                           ;

  do {
    int iPage = pCur->iPage;
    MemPage *pPage = pCur->apPage[iPage];

    if( iPage==0 ){
      if( pPage->nOverflow ){





        ((void) (0));
        rc = balance_deeper(pPage, &pCur->apPage[1]);
        if( rc==0 ){
          pCur->iPage = 1;
          pCur->aiIdx[0] = 0;
          pCur->aiIdx[1] = 0;
          ((void) (0));
        }
      }else{
        break;
      }
    }else if( pPage->nOverflow==0 && pPage->nFree<=nMin ){
      break;
    }else{
      MemPage * const pParent = pCur->apPage[iPage-1];
      int const iIdx = pCur->aiIdx[iPage-1];

      rc = sqlite3PagerWrite(pParent->pDbPage);
      if( rc==0 ){

        if( pPage->hasData
         && pPage->nOverflow==1
         && pPage->aOvfl[0].idx==pPage->nCell
         && pParent->pgno!=1
         && pParent->nCell==iIdx
        ){
# 53562 "ext/sqlite3/libsqlite/sqlite3.c"
          ((void) (0));
          rc = balance_quick(pParent, pPage, aBalanceQuickSpace);
        }else

        {
# 53584 "ext/sqlite3/libsqlite/sqlite3.c"
          u8 *pSpace = sqlite3PageMalloc(pCur->pBt->pageSize);
          rc = balance_nonroot(pParent, iIdx, pSpace, iPage==1);
          if( pFree ){




            sqlite3PageFree(pFree);
          }




          pFree = pSpace;
        }
      }

      pPage->nOverflow = 0;


      releasePage(pPage);
      pCur->iPage--;
    }
  }while( rc==0 );

  if( pFree ){
    sqlite3PageFree(pFree);
  }
  return rc;
}
# 53638 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeInsert(
  BtCursor *pCur,
  const void *pKey, i64 nKey,
  const void *pData, int nData,
  int nZero,
  int appendBias,
  int seekResult
){
  int rc;
  int loc = seekResult;
  int szNew = 0;
  int idx;
  MemPage *pPage;
  Btree *p = pCur->pBtree;
  BtShared *pBt = p->pBt;
  unsigned char *oldCell;
  unsigned char *newCell = 0;

  if( pCur->eState==3 ){
    ((void) (0));
    return pCur->skipNext;
  }

  ((void) (0));
  ((void) (0));
  ((void) (0));






  ((void) (0));




  if( pCur->pKeyInfo==0 ){
    invalidateIncrblobCursors(p, nKey, 0);
  }
# 53690 "ext/sqlite3/libsqlite/sqlite3.c"
  rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur);
  if( rc ) return rc;
  if( !loc ){
    rc = btreeMoveto(pCur, pKey, nKey, appendBias, &loc);
    if( rc ) return rc;
  }
  ((void) (0));

  pPage = pCur->apPage[pCur->iPage];
  ((void) (0));
  ((void) (0));



                                              ;
  ((void) (0));
  allocateTempSpace(pBt);
  newCell = pBt->pTmpSpace;
  if( newCell==0 ) return 7;
  rc = fillInCell(pPage, newCell, pKey, nKey, pData, nData, nZero, &szNew);
  if( rc ) goto end_insert;
  ((void) (0));
  ((void) (0));
  idx = pCur->aiIdx[pCur->iPage];
  if( loc==0 ){
    u16 szOld;
    ((void) (0));
    rc = sqlite3PagerWrite(pPage->pDbPage);
    if( rc ){
      goto end_insert;
    }
    oldCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aData[(pPage)->cellOffset+2*(idx)])[0]<<8 | (&(pPage)->aData[(pPage)->cellOffset+2*(idx)])[1])));
    if( !pPage->leaf ){
      memcpy(newCell, oldCell, 4);
    }
    szOld = cellSizePtr(pPage, oldCell);
    rc = clearCell(pPage, oldCell);
    dropCell(pPage, idx, szOld, &rc);
    if( rc ) goto end_insert;
  }else if( loc<0 && pPage->nCell>0 ){
    ((void) (0));
    idx = ++pCur->aiIdx[pCur->iPage];
  }else{
    ((void) (0));
  }
  insertCell(pPage, idx, newCell, szNew, 0, 0, &rc);
  ((void) (0));
# 53758 "ext/sqlite3/libsqlite/sqlite3.c"
  pCur->info.nSize = 0;
  pCur->validNKey = 0;
  if( rc==0 && pPage->nOverflow ){
    rc = balance(pCur);





    pCur->apPage[pCur->iPage]->nOverflow = 0;
    pCur->eState = 0;
  }
  ((void) (0));

end_insert:
  return rc;
}





static int sqlite3BtreeDelete(BtCursor *pCur){
  Btree *p = pCur->pBtree;
  BtShared *pBt = p->pBt;
  int rc;
  MemPage *pPage;
  unsigned char *pCell;
  int iCellIdx;
  int iCellDepth;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( (pCur->aiIdx[pCur->iPage]>=pCur->apPage[pCur->iPage]->nCell)
   || (pCur->eState!=1)
  ){
    return 1;
  }



  if( pCur->pKeyInfo==0 ){
    invalidateIncrblobCursors(p, pCur->info.nKey, 0);
  }

  iCellDepth = pCur->iPage;
  iCellIdx = pCur->aiIdx[iCellDepth];
  pPage = pCur->apPage[iCellDepth];
  pCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aData[(pPage)->cellOffset+2*(iCellIdx)])[0]<<8 | (&(pPage)->aData[(pPage)->cellOffset+2*(iCellIdx)])[1])));
# 53820 "ext/sqlite3/libsqlite/sqlite3.c"
  if( !pPage->leaf ){
    int notUsed;
    rc = sqlite3BtreePrevious(pCur, &notUsed);
    if( rc ) return rc;
  }






  rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur);
  if( rc ) return rc;
  rc = sqlite3PagerWrite(pPage->pDbPage);
  if( rc ) return rc;
  rc = clearCell(pPage, pCell);
  dropCell(pPage, iCellIdx, cellSizePtr(pPage, pCell), &rc);
  if( rc ) return rc;






  if( !pPage->leaf ){
    MemPage *pLeaf = pCur->apPage[pCur->iPage];
    int nCell;
    Pgno n = pCur->apPage[iCellDepth+1]->pgno;
    unsigned char *pTmp;

    pCell = ((pLeaf)->aData + ((pLeaf)->maskPage & ((&(pLeaf)->aData[(pLeaf)->cellOffset+2*(pLeaf->nCell-1)])[0]<<8 | (&(pLeaf)->aData[(pLeaf)->cellOffset+2*(pLeaf->nCell-1)])[1])));
    nCell = cellSizePtr(pLeaf, pCell);
    ((void) (0));

    allocateTempSpace(pBt);
    pTmp = pBt->pTmpSpace;

    rc = sqlite3PagerWrite(pLeaf->pDbPage);
    insertCell(pPage, iCellIdx, pCell-4, nCell+4, pTmp, n, &rc);
    dropCell(pLeaf, pLeaf->nCell-1, nCell, &rc);
    if( rc ) return rc;
  }
# 53878 "ext/sqlite3/libsqlite/sqlite3.c"
  rc = balance(pCur);
  if( rc==0 && pCur->iPage>iCellDepth ){
    while( pCur->iPage>iCellDepth ){
      releasePage(pCur->apPage[pCur->iPage--]);
    }
    rc = balance(pCur);
  }

  if( rc==0 ){
    moveToRoot(pCur);
  }
  return rc;
}
# 53903 "ext/sqlite3/libsqlite/sqlite3.c"
static int btreeCreateTable(Btree *p, int *piTable, int createTabFlags){
  BtShared *pBt = p->pBt;
  MemPage *pRoot;
  Pgno pgnoRoot;
  int rc;
  int ptfFlags;

  ((void) (0));
  ((void) (0));
  ((void) (0));







  if( pBt->autoVacuum ){
    Pgno pgnoMove;
    MemPage *pPageMove;






    invalidateAllOverflowCache(pBt);





    sqlite3BtreeGetMeta(p, 4, &pgnoRoot);
    pgnoRoot++;




    while( pgnoRoot==ptrmapPageno(pBt, pgnoRoot) ||
        pgnoRoot==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){
      pgnoRoot++;
    }
    ((void) (0));





    rc = allocateBtreePage(pBt, &pPageMove, &pgnoMove, pgnoRoot, 1);
    if( rc!=0 ){
      return rc;
    }

    if( pgnoMove!=pgnoRoot ){






      u8 eType = 0;
      Pgno iPtrPage = 0;

      releasePage(pPageMove);


      rc = btreeGetPage(pBt, pgnoRoot, &pRoot, 0);
      if( rc!=0 ){
        return rc;
      }
      rc = ptrmapGet(pBt, pgnoRoot, &eType, &iPtrPage);
      if( eType==1 || eType==2 ){
        rc = sqlite3CorruptError(53975);
      }
      if( rc!=0 ){
        releasePage(pRoot);
        return rc;
      }
      ((void) (0));
      ((void) (0));
      rc = relocatePage(pBt, pRoot, eType, iPtrPage, pgnoMove, 0);
      releasePage(pRoot);


      if( rc!=0 ){
        return rc;
      }
      rc = btreeGetPage(pBt, pgnoRoot, &pRoot, 0);
      if( rc!=0 ){
        return rc;
      }
      rc = sqlite3PagerWrite(pRoot->pDbPage);
      if( rc!=0 ){
        releasePage(pRoot);
        return rc;
      }
    }else{
      pRoot = pPageMove;
    }


    ptrmapPut(pBt, pgnoRoot, 1, 0, &rc);
    if( rc ){
      releasePage(pRoot);
      return rc;
    }





    ((void) (0));
    rc = sqlite3BtreeUpdateMeta(p, 4, pgnoRoot);
    if( (rc) ){
      releasePage(pRoot);
      return rc;
    }

  }else{
    rc = allocateBtreePage(pBt, &pRoot, &pgnoRoot, 1, 0);
    if( rc ) return rc;
  }

  ((void) (0));
  if( createTabFlags & 1 ){
    ptfFlags = 0x01 | 0x04 | 0x08;
  }else{
    ptfFlags = 0x02 | 0x08;
  }
  zeroPage(pRoot, ptfFlags);
  sqlite3PagerUnref(pRoot->pDbPage);
  ((void) (0));
  *piTable = (int)pgnoRoot;
  return 0;
}
static int sqlite3BtreeCreateTable(Btree *p, int *piTable, int flags){
  int rc;
  sqlite3BtreeEnter(p);
  rc = btreeCreateTable(p, piTable, flags);
                      ;
  return rc;
}





static int clearDatabasePage(
  BtShared *pBt,
  Pgno pgno,
  int freePageFlag,
  int *pnChange
){
  MemPage *pPage;
  int rc;
  unsigned char *pCell;
  int i;

  ((void) (0));
  if( pgno>btreePagecount(pBt) ){
    return sqlite3CorruptError(54063);
  }

  rc = getAndInitPage(pBt, pgno, &pPage);
  if( rc ) return rc;
  for(i=0; i<pPage->nCell; i++){
    pCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aData[(pPage)->cellOffset+2*(i)])[0]<<8 | (&(pPage)->aData[(pPage)->cellOffset+2*(i)])[1])));
    if( !pPage->leaf ){
      rc = clearDatabasePage(pBt, sqlite3Get4byte(pCell), 1, pnChange);
      if( rc ) goto cleardatabasepage_out;
    }
    rc = clearCell(pPage, pCell);
    if( rc ) goto cleardatabasepage_out;
  }
  if( !pPage->leaf ){
    rc = clearDatabasePage(pBt, sqlite3Get4byte(&pPage->aData[8]), 1, pnChange);
    if( rc ) goto cleardatabasepage_out;
  }else if( pnChange ){
    ((void) (0));
    *pnChange += pPage->nCell;
  }
  if( freePageFlag ){
    freePage(pPage, &rc);
  }else if( (rc = sqlite3PagerWrite(pPage->pDbPage))==0 ){
    zeroPage(pPage, pPage->aData[0] | 0x08);
  }

cleardatabasepage_out:
  releasePage(pPage);
  return rc;
}
# 54108 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeClearTable(Btree *p, int iTable, int *pnChange){
  int rc;
  BtShared *pBt = p->pBt;
  sqlite3BtreeEnter(p);
  ((void) (0));




  invalidateIncrblobCursors(p, 0, 1);

  rc = saveAllCursors(pBt, (Pgno)iTable, 0);
  if( 0==rc ){
    rc = clearDatabasePage(pBt, (Pgno)iTable, 0, pnChange);
  }
                      ;
  return rc;
}
# 54147 "ext/sqlite3/libsqlite/sqlite3.c"
static int btreeDropTable(Btree *p, Pgno iTable, int *piMoved){
  int rc;
  MemPage *pPage = 0;
  BtShared *pBt = p->pBt;

  ((void) (0));
  ((void) (0));
# 54163 "ext/sqlite3/libsqlite/sqlite3.c"
  if( (pBt->pCursor) ){
                                                             ;
    return (6 | (1<<8));
  }

  rc = btreeGetPage(pBt, (Pgno)iTable, &pPage, 0);
  if( rc ) return rc;
  rc = sqlite3BtreeClearTable(p, iTable, 0);
  if( rc ){
    releasePage(pPage);
    return rc;
  }

  *piMoved = 0;

  if( iTable>1 ){




    if( pBt->autoVacuum ){
      Pgno maxRootPgno;
      sqlite3BtreeGetMeta(p, 4, &maxRootPgno);

      if( iTable==maxRootPgno ){



        freePage(pPage, &rc);
        releasePage(pPage);
        if( rc!=0 ){
          return rc;
        }
      }else{




        MemPage *pMove;
        releasePage(pPage);
        rc = btreeGetPage(pBt, maxRootPgno, &pMove, 0);
        if( rc!=0 ){
          return rc;
        }
        rc = relocatePage(pBt, pMove, 1, 0, iTable, 0);
        releasePage(pMove);
        if( rc!=0 ){
          return rc;
        }
        pMove = 0;
        rc = btreeGetPage(pBt, maxRootPgno, &pMove, 0);
        freePage(pMove, &rc);
        releasePage(pMove);
        if( rc!=0 ){
          return rc;
        }
        *piMoved = maxRootPgno;
      }






      maxRootPgno--;
      while( maxRootPgno==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1))
             || (ptrmapPageno((pBt), (maxRootPgno))==(maxRootPgno)) ){
        maxRootPgno--;
      }
      ((void) (0));

      rc = sqlite3BtreeUpdateMeta(p, 4, maxRootPgno);
    }else{
      freePage(pPage, &rc);
      releasePage(pPage);
    }

  }else{




    zeroPage(pPage, 0x01|0x08 );
    releasePage(pPage);
  }
  return rc;
}
static int sqlite3BtreeDropTable(Btree *p, int iTable, int *piMoved){
  int rc;
  sqlite3BtreeEnter(p);
  rc = btreeDropTable(p, iTable, piMoved);
                      ;
  return rc;
}
# 54272 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3BtreeGetMeta(Btree *p, int idx, u32 *pMeta){
  BtShared *pBt = p->pBt;

  sqlite3BtreeEnter(p);
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  *pMeta = sqlite3Get4byte(&pBt->pPage1->aData[36 + idx*4]);







                      ;
}





static int sqlite3BtreeUpdateMeta(Btree *p, int idx, u32 iMeta){
  BtShared *pBt = p->pBt;
  unsigned char *pP1;
  int rc;
  ((void) (0));
  sqlite3BtreeEnter(p);
  ((void) (0));
  ((void) (0));
  pP1 = pBt->pPage1->aData;
  rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
  if( rc==0 ){
    sqlite3Put4byte(&pP1[36 + idx*4], iMeta);

    if( idx==7 ){
      ((void) (0));
      ((void) (0));
      pBt->incrVacuum = (u8)iMeta;
    }

  }
                      ;
  return rc;
}
# 54329 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeCount(BtCursor *pCur, i64 *pnEntry){
  i64 nEntry = 0;
  int rc;
  rc = moveToRoot(pCur);




  while( rc==0 ){
    int iIdx;
    MemPage *pPage;





    pPage = pCur->apPage[pCur->iPage];
    if( pPage->leaf || !pPage->intKey ){
      nEntry += pPage->nCell;
    }
# 54360 "ext/sqlite3/libsqlite/sqlite3.c"
    if( pPage->leaf ){
      do {
        if( pCur->iPage==0 ){

          *pnEntry = nEntry;
          return 0;
        }
        moveToParent(pCur);
      }while ( pCur->aiIdx[pCur->iPage]>=pCur->apPage[pCur->iPage]->nCell );

      pCur->aiIdx[pCur->iPage]++;
      pPage = pCur->apPage[pCur->iPage];
    }




    iIdx = pCur->aiIdx[pCur->iPage];
    if( iIdx==pPage->nCell ){
      rc = moveToChild(pCur, sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8]));
    }else{
      rc = moveToChild(pCur, sqlite3Get4byte(((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aData[(pPage)->cellOffset+2*(iIdx)])[0]<<8 | (&(pPage)->aData[(pPage)->cellOffset+2*(iIdx)])[1])))));
    }
  }


  return rc;
}






static Pager *sqlite3BtreePager(Btree *p){
  return p->pBt->pPager;
}





static void checkAppendMsg(
  IntegrityCk *pCheck,
  char *zMsg1,
  const char *zFormat,
  ...
){
  va_list ap;
  if( !pCheck->mxErr ) return;
  pCheck->mxErr--;
  pCheck->nErr++;
  __builtin_va_start(ap, zFormat);
  if( pCheck->errMsg.nChar ){
    sqlite3StrAccumAppend(&pCheck->errMsg, "\n", 1);
  }
  if( zMsg1 ){
    sqlite3StrAccumAppend(&pCheck->errMsg, zMsg1, -1);
  }
  sqlite3VXPrintf(&pCheck->errMsg, 1, zFormat, ap);
  __builtin_va_end(ap);
  if( pCheck->errMsg.mallocFailed ){
    pCheck->mallocFailed = 1;
  }
}
# 54436 "ext/sqlite3/libsqlite/sqlite3.c"
static int checkRef(IntegrityCk *pCheck, Pgno iPage, char *zContext){
  if( iPage==0 ) return 1;
  if( iPage>pCheck->nPage ){
    checkAppendMsg(pCheck, zContext, "invalid page number %d", iPage);
    return 1;
  }
  if( pCheck->anRef[iPage]==1 ){
    checkAppendMsg(pCheck, zContext, "2nd reference to page %d", iPage);
    return 1;
  }
  return (pCheck->anRef[iPage]++)>1;
}







static void checkPtrmap(
  IntegrityCk *pCheck,
  Pgno iChild,
  u8 eType,
  Pgno iParent,
  char *zContext
){
  int rc;
  u8 ePtrmapType;
  Pgno iPtrmapParent;

  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);
  if( rc!=0 ){
    if( rc==7 || rc==(10 | (12<<8)) ) pCheck->mallocFailed = 1;
    checkAppendMsg(pCheck, zContext, "Failed to read ptrmap key=%d", iChild);
    return;
  }

  if( ePtrmapType!=eType || iPtrmapParent!=iParent ){
    checkAppendMsg(pCheck, zContext,
      "Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)",
      iChild, eType, iParent, ePtrmapType, iPtrmapParent);
  }
}






static void checkList(
  IntegrityCk *pCheck,
  int isFreeList,
  int iPage,
  int N,
  char *zContext
){
  int i;
  int expected = N;
  int iFirst = iPage;
  while( N-- > 0 && pCheck->mxErr ){
    DbPage *pOvflPage;
    unsigned char *pOvflData;
    if( iPage<1 ){
      checkAppendMsg(pCheck, zContext,
         "%d of %d pages missing from overflow list starting at %d",
          N+1, expected, iFirst);
      break;
    }
    if( checkRef(pCheck, iPage, zContext) ) break;
    if( sqlite3PagerAcquire(pCheck->pPager,(Pgno)iPage,&pOvflPage,0) ){
      checkAppendMsg(pCheck, zContext, "failed to get page %d", iPage);
      break;
    }
    pOvflData = (unsigned char *)sqlite3PagerGetData(pOvflPage);
    if( isFreeList ){
      int n = sqlite3Get4byte(&pOvflData[4]);

      if( pCheck->pBt->autoVacuum ){
        checkPtrmap(pCheck, iPage, 2, 0, zContext);
      }

      if( n>(int)pCheck->pBt->usableSize/4-2 ){
        checkAppendMsg(pCheck, zContext,
           "freelist leaf count too big on page %d", iPage);
        N--;
      }else{
        for(i=0; i<n; i++){
          Pgno iFreePage = sqlite3Get4byte(&pOvflData[8+i*4]);

          if( pCheck->pBt->autoVacuum ){
            checkPtrmap(pCheck, iFreePage, 2, 0, zContext);
          }

          checkRef(pCheck, iFreePage, zContext);
        }
        N -= n;
      }
    }

    else{




      if( pCheck->pBt->autoVacuum && N>0 ){
        i = sqlite3Get4byte(pOvflData);
        checkPtrmap(pCheck, i, 4, iPage, zContext);
      }
    }

    iPage = sqlite3Get4byte(pOvflData);
    sqlite3PagerUnref(pOvflPage);
  }
}
# 54571 "ext/sqlite3/libsqlite/sqlite3.c"
static int checkTreePage(
  IntegrityCk *pCheck,
  int iPage,
  char *zParentContext,
  i64 *pnParentMinKey,
  i64 *pnParentMaxKey
){
  MemPage *pPage;
  int i, rc, depth, d2, pgno, cnt;
  int hdr, cellStart;
  int nCell;
  u8 *data;
  BtShared *pBt;
  int usableSize;
  char zContext[100];
  char *hit = 0;
  i64 nMinKey = 0;
  i64 nMaxKey = 0;

  sqlite3_snprintf(sizeof(zContext), zContext, "Page %d: ", iPage);



  pBt = pCheck->pBt;
  usableSize = pBt->usableSize;
  if( iPage==0 ) return 0;
  if( checkRef(pCheck, iPage, zParentContext) ) return 0;
  if( (rc = btreeGetPage(pBt, (Pgno)iPage, &pPage, 0))!=0 ){
    checkAppendMsg(pCheck, zContext,
       "unable to get the page. error code=%d", rc);
    return 0;
  }



  pPage->isInit = 0;
  if( (rc = btreeInitPage(pPage))!=0 ){
    ((void) (0));
    checkAppendMsg(pCheck, zContext,
                   "btreeInitPage() returns error code %d", rc);
    releasePage(pPage);
    return 0;
  }



  depth = 0;
  for(i=0; i<pPage->nCell && pCheck->mxErr; i++){
    u8 *pCell;
    u32 sz;
    CellInfo info;



    sqlite3_snprintf(sizeof(zContext), zContext,
             "On tree page %d cell %d: ", iPage, i);
    pCell = ((pPage)->aData + ((pPage)->maskPage & ((&(pPage)->aData[(pPage)->cellOffset+2*(i)])[0]<<8 | (&(pPage)->aData[(pPage)->cellOffset+2*(i)])[1])));
    btreeParseCellPtr(pPage, pCell, &info);
    sz = info.nData;
    if( !pPage->intKey ) sz += (int)info.nKey;


    else if( i==0 ) nMinKey = nMaxKey = info.nKey;
    else{
      if( info.nKey <= nMaxKey ){
        checkAppendMsg(pCheck, zContext,
            "Rowid %lld out of order (previous was %lld)", info.nKey, nMaxKey);
      }
      nMaxKey = info.nKey;
    }
    ((void) (0));
    if( (sz>info.nLocal)
     && (&pCell[info.iOverflow]<=&pPage->aData[pBt->usableSize])
    ){
      int nPage = (sz - info.nLocal + usableSize - 5)/(usableSize - 4);
      Pgno pgnoOvfl = sqlite3Get4byte(&pCell[info.iOverflow]);

      if( pBt->autoVacuum ){
        checkPtrmap(pCheck, pgnoOvfl, 3, iPage, zContext);
      }

      checkList(pCheck, 0, pgnoOvfl, nPage, zContext);
    }



    if( !pPage->leaf ){
      pgno = sqlite3Get4byte(pCell);

      if( pBt->autoVacuum ){
        checkPtrmap(pCheck, pgno, 5, iPage, zContext);
      }

      d2 = checkTreePage(pCheck, pgno, zContext, &nMinKey, i==0 ? ((void*)0) : &nMaxKey);
      if( i>0 && d2!=depth ){
        checkAppendMsg(pCheck, zContext, "Child page depth differs");
      }
      depth = d2;
    }
  }

  if( !pPage->leaf ){
    pgno = sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8]);
    sqlite3_snprintf(sizeof(zContext), zContext,
                     "On page %d at right child: ", iPage);

    if( pBt->autoVacuum ){
      checkPtrmap(pCheck, pgno, 5, iPage, zContext);
    }

    checkTreePage(pCheck, pgno, zContext, ((void*)0), !pPage->nCell ? ((void*)0) : &nMaxKey);
  }




  if( pPage->leaf && pPage->intKey ){

    if( pnParentMinKey ){

      if( !pnParentMaxKey ){
        if( nMaxKey > *pnParentMinKey ){
          checkAppendMsg(pCheck, zContext,
              "Rowid %lld out of order (max larger than parent min of %lld)",
              nMaxKey, *pnParentMinKey);
        }
      }else{
        if( nMinKey <= *pnParentMinKey ){
          checkAppendMsg(pCheck, zContext,
              "Rowid %lld out of order (min less than parent min of %lld)",
              nMinKey, *pnParentMinKey);
        }
        if( nMaxKey > *pnParentMaxKey ){
          checkAppendMsg(pCheck, zContext,
              "Rowid %lld out of order (max larger than parent max of %lld)",
              nMaxKey, *pnParentMaxKey);
        }
        *pnParentMinKey = nMaxKey;
      }

    } else if( pnParentMaxKey ){
      if( nMinKey <= *pnParentMaxKey ){
        checkAppendMsg(pCheck, zContext,
            "Rowid %lld out of order (min less than parent max of %lld)",
            nMinKey, *pnParentMaxKey);
      }
    }
  }



  data = pPage->aData;
  hdr = pPage->hdrOffset;
  hit = sqlite3PageMalloc( pBt->pageSize );
  if( hit==0 ){
    pCheck->mallocFailed = 1;
  }else{
    int contentOffset = (((((int)((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]))-1)&0xffff)+1);
    ((void) (0));
    memset(hit+contentOffset, 0, usableSize-contentOffset);
    memset(hit, 1, contentOffset);
    nCell = ((&data[hdr+3])[0]<<8 | (&data[hdr+3])[1]);
    cellStart = hdr + 12 - 4*pPage->leaf;
    for(i=0; i<nCell; i++){
      int pc = ((&data[cellStart+i*2])[0]<<8 | (&data[cellStart+i*2])[1]);
      u32 size = 65536;
      int j;
      if( pc<=usableSize-4 ){
        size = cellSizePtr(pPage, &data[pc]);
      }
      if( (int)(pc+size-1)>=usableSize ){
        checkAppendMsg(pCheck, 0,
            "Corruption detected in cell %d on page %d",i,iPage);
      }else{
        for(j=pc+size-1; j>=pc; j--) hit[j]++;
      }
    }
    i = ((&data[hdr+1])[0]<<8 | (&data[hdr+1])[1]);
    while( i>0 ){
      int size, j;
      ((void) (0));
      size = ((&data[i+2])[0]<<8 | (&data[i+2])[1]);
      ((void) (0));
      for(j=i+size-1; j>=i; j--) hit[j]++;
      j = ((&data[i])[0]<<8 | (&data[i])[1]);
      ((void) (0));
      ((void) (0));
      i = j;
    }
    for(i=cnt=0; i<usableSize; i++){
      if( hit[i]==0 ){
        cnt++;
      }else if( hit[i]>1 ){
        checkAppendMsg(pCheck, 0,
          "Multiple uses for byte %d of page %d", i, iPage);
        break;
      }
    }
    if( cnt!=data[hdr+7] ){
      checkAppendMsg(pCheck, 0,
          "Fragmentation of %d bytes reported as %d on page %d",
          cnt, data[hdr+7], iPage);
    }
  }
  sqlite3PageFree(hit);
  releasePage(pPage);
  return depth+1;
}
# 54795 "ext/sqlite3/libsqlite/sqlite3.c"
static char *sqlite3BtreeIntegrityCheck(
  Btree *p,
  int *aRoot,
  int nRoot,
  int mxErr,
  int *pnErr
){
  Pgno i;
  int nRef;
  IntegrityCk sCheck;
  BtShared *pBt = p->pBt;
  char zErr[100];

  sqlite3BtreeEnter(p);
  ((void) (0));
  nRef = sqlite3PagerRefcount(pBt->pPager);
  sCheck.pBt = pBt;
  sCheck.pPager = pBt->pPager;
  sCheck.nPage = btreePagecount(sCheck.pBt);
  sCheck.mxErr = mxErr;
  sCheck.nErr = 0;
  sCheck.mallocFailed = 0;
  *pnErr = 0;
  if( sCheck.nPage==0 ){
                        ;
    return 0;
  }
  sCheck.anRef = sqlite3Malloc( (sCheck.nPage+1)*sizeof(sCheck.anRef[0]) );
  if( !sCheck.anRef ){
    *pnErr = 1;
                        ;
    return 0;
  }
  for(i=0; i<=sCheck.nPage; i++){ sCheck.anRef[i] = 0; }
  i = ((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1));
  if( i<=sCheck.nPage ){
    sCheck.anRef[i] = 1;
  }
  sqlite3StrAccumInit(&sCheck.errMsg, zErr, sizeof(zErr), 20000);
  sCheck.errMsg.useMalloc = 2;



  checkList(&sCheck, 1, sqlite3Get4byte(&pBt->pPage1->aData[32]),
            sqlite3Get4byte(&pBt->pPage1->aData[36]), "Main freelist: ");



  for(i=0; (int)i<nRoot && sCheck.mxErr; i++){
    if( aRoot[i]==0 ) continue;

    if( pBt->autoVacuum && aRoot[i]>1 ){
      checkPtrmap(&sCheck, aRoot[i], 1, 0, 0);
    }

    checkTreePage(&sCheck, aRoot[i], "List of tree roots: ", ((void*)0), ((void*)0));
  }



  for(i=1; i<=sCheck.nPage && sCheck.mxErr; i++){
# 54864 "ext/sqlite3/libsqlite/sqlite3.c"
    if( sCheck.anRef[i]==0 &&
       (ptrmapPageno(pBt, i)!=i || !pBt->autoVacuum) ){
      checkAppendMsg(&sCheck, 0, "Page %d is never used", i);
    }
    if( sCheck.anRef[i]!=0 &&
       (ptrmapPageno(pBt, i)==i && pBt->autoVacuum) ){
      checkAppendMsg(&sCheck, 0, "Pointer map page %d is referenced", i);
    }

  }





  if( (nRef != sqlite3PagerRefcount(pBt->pPager)) ){
    checkAppendMsg(&sCheck, 0,
      "Outstanding page count goes from %d to %d during this analysis",
      nRef, sqlite3PagerRefcount(pBt->pPager)
    );
  }



                      ;
  sqlite3_free(sCheck.anRef);
  if( sCheck.mallocFailed ){
    sqlite3StrAccumReset(&sCheck.errMsg);
    *pnErr = sCheck.nErr+1;
    return 0;
  }
  *pnErr = sCheck.nErr;
  if( sCheck.nErr==0 ) sqlite3StrAccumReset(&sCheck.errMsg);
  return sqlite3StrAccumFinish(&sCheck.errMsg);
}
# 54907 "ext/sqlite3/libsqlite/sqlite3.c"
static const char *sqlite3BtreeGetFilename(Btree *p){
  ((void) (0));
  return sqlite3PagerFilename(p->pBt->pPager);
}
# 54920 "ext/sqlite3/libsqlite/sqlite3.c"
static const char *sqlite3BtreeGetJournalname(Btree *p){
  ((void) (0));
  return sqlite3PagerJournalname(p->pBt->pPager);
}




static int sqlite3BtreeIsInTrans(Btree *p){
  ((void) (0));
  return (p && (p->inTrans==2));
}
# 54942 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeCheckpoint(Btree *p, int eMode, int *pnLog, int *pnCkpt){
  int rc = 0;
  if( p ){
    BtShared *pBt = p->pBt;
    sqlite3BtreeEnter(p);
    if( pBt->inTransaction!=0 ){
      rc = 6;
    }else{
      rc = sqlite3PagerCheckpoint(pBt->pPager, eMode, pnLog, pnCkpt);
    }
                        ;
  }
  return rc;
}





static int sqlite3BtreeIsInReadTrans(Btree *p){
  ((void) (0));
  ((void) (0));
  return p->inTrans!=0;
}

static int sqlite3BtreeIsInBackup(Btree *p){
  ((void) (0));
  ((void) (0));
  return p->nBackup!=0;
}
# 54993 "ext/sqlite3/libsqlite/sqlite3.c"
static void *sqlite3BtreeSchema(Btree *p, int nBytes, void(*xFree)(void *)){
  BtShared *pBt = p->pBt;
  sqlite3BtreeEnter(p);
  if( !pBt->pSchema && nBytes ){
    pBt->pSchema = sqlite3DbMallocZero(0, nBytes);
    pBt->xFreeSchema = xFree;
  }
                      ;
  return pBt->pSchema;
}






static int sqlite3BtreeSchemaLocked(Btree *p){
  int rc;
  ((void) (0));
  sqlite3BtreeEnter(p);
  rc = querySharedCacheTableLock(p, 1, 1);
  ((void) (0));
                      ;
  return rc;
}
# 55026 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeLockTable(Btree *p, int iTab, u8 isWriteLock){
  int rc = 0;
  ((void) (0));
  if( p->sharable ){
    u8 lockType = 1 + isWriteLock;
    ((void) (0));
    ((void) (0));

    sqlite3BtreeEnter(p);
    rc = querySharedCacheTableLock(p, iTab, lockType);
    if( rc==0 ){
      rc = setSharedCacheTableLock(p, iTab, lockType);
    }
                        ;
  }
  return rc;
}
# 55056 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreePutData(BtCursor *pCsr, u32 offset, u32 amt, void *z){
  int rc;
  ((void) (0));
  ((void) (0));
  ((void) (0));

  rc = (pCsr->eState>=2 ? btreeRestoreCursorPosition(pCsr) : 0);
  if( rc!=0 ){
    return rc;
  }
  ((void) (0));
  if( pCsr->eState!=1 ){
    return 4;
  }
# 55078 "ext/sqlite3/libsqlite/sqlite3.c"
  if( !pCsr->wrFlag ){
    return 8;
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  return accessPayload(pCsr, offset, amt, (unsigned char *)z, 1);
}
# 55099 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3BtreeCacheOverflow(BtCursor *pCur){
  ((void) (0));
  ((void) (0));
  invalidateOverflowCache(pCur);
  pCur->isIncrblobHandle = 1;
}







static int sqlite3BtreeSetVersion(Btree *pBtree, int iVersion){
  BtShared *pBt = pBtree->pBt;
  int rc;

  ((void) (0));
  ((void) (0));




  pBt->doNotUseWAL = (u8)(iVersion==1);

  rc = sqlite3BtreeBeginTrans(pBtree, 0);
  if( rc==0 ){
    u8 *aData = pBt->pPage1->aData;
    if( aData[18]!=(u8)iVersion || aData[19]!=(u8)iVersion ){
      rc = sqlite3BtreeBeginTrans(pBtree, 2);
      if( rc==0 ){
        rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
        if( rc==0 ){
          aData[18] = (u8)iVersion;
          aData[19] = (u8)iVersion;
        }
      }
    }
  }

  pBt->doNotUseWAL = 0;
  return rc;
}
# 55169 "ext/sqlite3/libsqlite/sqlite3.c"
struct sqlite3_backup {
  sqlite3* pDestDb;
  Btree *pDest;
  u32 iDestSchema;
  int bDestLocked;

  Pgno iNext;
  sqlite3* pSrcDb;
  Btree *pSrc;

  int rc;




  Pgno nRemaining;
  Pgno nPagecount;

  int isAttached;
  sqlite3_backup *pNext;
};
# 55230 "ext/sqlite3/libsqlite/sqlite3.c"
static Btree *findBtree(sqlite3 *pErrorDb, sqlite3 *pDb, const char *zDb){
  int i = sqlite3FindDbName(pDb, zDb);

  if( i==1 ){
    Parse *pParse;
    int rc = 0;
    pParse = sqlite3DbMallocZero(pErrorDb,sizeof(*pParse));
    if( pParse==0 ){
      sqlite3Error(pErrorDb, 7, "out of memory");
      rc = 7;
    }else{
      pParse->db = pDb;
      if( sqlite3OpenTempDatabase(pParse) ){
        sqlite3Error(pErrorDb, pParse->rc, "%s", pParse->zErrMsg);
        rc = 1;
      }
      sqlite3DbFree(pErrorDb, pParse->zErrMsg);
      sqlite3DbFree(pErrorDb,pParse);
    }
    if( rc ){
      return 0;
    }
  }

  if( i<0 ){
    sqlite3Error(pErrorDb, 1, "unknown database %s", zDb);
    return 0;
  }

  return pDb->aDb[i].pBt;
}





static int setDestPgsz(sqlite3_backup *p){
  int rc;
  rc = sqlite3BtreeSetPageSize(p->pDest,sqlite3BtreeGetPageSize(p->pSrc),-1,0);
  return rc;
}
# 55280 "ext/sqlite3/libsqlite/sqlite3.c"
           sqlite3_backup *sqlite3_backup_init(
  sqlite3* pDestDb,
  const char *zDestDb,
  sqlite3* pSrcDb,
  const char *zSrcDb
){
  sqlite3_backup *p;
# 55296 "ext/sqlite3/libsqlite/sqlite3.c"
                                    ;
                                     ;

  if( pSrcDb==pDestDb ){
    sqlite3Error(
        pDestDb, 1, "source and destination must be distinct"
    );
    p = 0;
  }else {




    p = (sqlite3_backup *)sqlite3_malloc(sizeof(sqlite3_backup));
    if( !p ){
      sqlite3Error(pDestDb, 7, 0);
    }
  }


  if( p ){
    memset(p, 0, sizeof(sqlite3_backup));
    p->pSrc = findBtree(pDestDb, pSrcDb, zSrcDb);
    p->pDest = findBtree(pDestDb, pDestDb, zDestDb);
    p->pDestDb = pDestDb;
    p->pSrcDb = pSrcDb;
    p->iNext = 1;
    p->isAttached = 0;

    if( 0==p->pSrc || 0==p->pDest || setDestPgsz(p)==7 ){





      sqlite3_free(p);
      p = 0;
    }
  }
  if( p ){
    p->pSrc->nBackup++;
  }

                                     ;
                                    ;
  return p;
}






static int isFatalError(int rc){
  return (rc!=0 && rc!=5 && (rc!=6));
}






static int backupOnePage(sqlite3_backup *p, Pgno iSrcPg, const u8 *zSrcData){
  Pager * const pDestPager = sqlite3BtreePager(p->pDest);
  const int nSrcPgsz = sqlite3BtreeGetPageSize(p->pSrc);
  int nDestPgsz = sqlite3BtreeGetPageSize(p->pDest);
  const int nCopy = ((nSrcPgsz)<(nDestPgsz)?(nSrcPgsz):(nDestPgsz));
  const i64 iEnd = (i64)iSrcPg*(i64)nSrcPgsz;





  int rc = 0;
  i64 iOff;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));




  if( nSrcPgsz!=nDestPgsz && sqlite3PagerIsMemdb(pDestPager) ){
    rc = 8;
  }
# 55408 "ext/sqlite3/libsqlite/sqlite3.c"
  for(iOff=iEnd-(i64)nSrcPgsz; rc==0 && iOff<iEnd; iOff+=nDestPgsz){
    DbPage *pDestPg = 0;
    Pgno iDest = (Pgno)(iOff/nDestPgsz)+1;
    if( iDest==((Pgno)((sqlite3PendingByte/((p->pDest->pBt)->pageSize))+1)) ) continue;
    if( 0==(rc = sqlite3PagerAcquire(pDestPager,iDest,&pDestPg,0))
     && 0==(rc = sqlite3PagerWrite(pDestPg))
    ){
      const u8 *zIn = &zSrcData[iOff%nSrcPgsz];
      u8 *zDestData = sqlite3PagerGetData(pDestPg);
      u8 *zOut = &zDestData[iOff%nDestPgsz];
# 55426 "ext/sqlite3/libsqlite/sqlite3.c"
      memcpy(zOut, zIn, nCopy);
      ((u8 *)sqlite3PagerGetExtra(pDestPg))[0] = 0;
    }
    sqlite3PagerUnref(pDestPg);
  }

  return rc;
}
# 55443 "ext/sqlite3/libsqlite/sqlite3.c"
static int backupTruncateFile(sqlite3_file *pFile, i64 iSize){
  i64 iCurrent;
  int rc = sqlite3OsFileSize(pFile, &iCurrent);
  if( rc==0 && iCurrent>iSize ){
    rc = sqlite3OsTruncate(pFile, iSize);
  }
  return rc;
}





static void attachBackupObject(sqlite3_backup *p){
  sqlite3_backup **pp;
  ((void) (0));
  pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc));
  p->pNext = *pp;
  *pp = p;
  p->isAttached = 1;
}




           int sqlite3_backup_step(sqlite3_backup *p, int nPage){
  int rc;
  int destMode;
  int pgszSrc = 0;
  int pgszDest = 0;

                                       ;
  sqlite3BtreeEnter(p->pSrc);
  if( p->pDestDb ){
                                          ;
  }

  rc = p->rc;
  if( !isFatalError(rc) ){
    Pager * const pSrcPager = sqlite3BtreePager(p->pSrc);
    Pager * const pDestPager = sqlite3BtreePager(p->pDest);
    int ii;
    int nSrcPage = -1;
    int bCloseTrans = 0;




    if( p->pDestDb && p->pSrc->pBt->inTransaction==2 ){
      rc = 5;
    }else{
      rc = 0;
    }


    if( 0==rc && p->bDestLocked==0
     && 0==(rc = sqlite3BtreeBeginTrans(p->pDest, 2))
    ){
      p->bDestLocked = 1;
      sqlite3BtreeGetMeta(p->pDest, 1, &p->iDestSchema);
    }





    if( rc==0 && 0==sqlite3BtreeIsInReadTrans(p->pSrc) ){
      rc = sqlite3BtreeBeginTrans(p->pSrc, 0);
      bCloseTrans = 1;
    }



    pgszSrc = sqlite3BtreeGetPageSize(p->pSrc);
    pgszDest = sqlite3BtreeGetPageSize(p->pDest);
    destMode = sqlite3PagerGetJournalMode(sqlite3BtreePager(p->pDest));
    if( 0==rc && destMode==5 && pgszSrc!=pgszDest ){
      rc = 8;
    }




    nSrcPage = (int)sqlite3BtreeLastPage(p->pSrc);
    ((void) (0));
    for(ii=0; (nPage<0 || ii<nPage) && p->iNext<=(Pgno)nSrcPage && !rc; ii++){
      const Pgno iSrcPg = p->iNext;
      if( iSrcPg!=((Pgno)((sqlite3PendingByte/((p->pSrc->pBt)->pageSize))+1)) ){
        DbPage *pSrcPg;
        rc = sqlite3PagerAcquire(pSrcPager,iSrcPg,&pSrcPg,0);
        if( rc==0 ){
          rc = backupOnePage(p, iSrcPg, sqlite3PagerGetData(pSrcPg));
          sqlite3PagerUnref(pSrcPg);
        }
      }
      p->iNext++;
    }
    if( rc==0 ){
      p->nPagecount = nSrcPage;
      p->nRemaining = nSrcPage+1-p->iNext;
      if( p->iNext>(Pgno)nSrcPage ){
        rc = 101;
      }else if( !p->isAttached ){
        attachBackupObject(p);
      }
    }






    if( rc==101
     && (rc = sqlite3BtreeUpdateMeta(p->pDest,1,p->iDestSchema+1))==0
    ){
      int nDestTruncate;

      if( p->pDestDb ){
        sqlite3ResetInternalSchema(p->pDestDb, -1);
      }
# 55576 "ext/sqlite3/libsqlite/sqlite3.c"
      ((void) (0));
      ((void) (0));
      if( pgszSrc<pgszDest ){
        int ratio = pgszDest/pgszSrc;
        nDestTruncate = (nSrcPage+ratio-1)/ratio;
        if( nDestTruncate==(int)((Pgno)((sqlite3PendingByte/((p->pDest->pBt)->pageSize))+1)) ){
          nDestTruncate--;
        }
      }else{
        nDestTruncate = nSrcPage * (pgszSrc/pgszDest);
      }
      sqlite3PagerTruncateImage(pDestPager, nDestTruncate);

      if( pgszSrc<pgszDest ){
# 55599 "ext/sqlite3/libsqlite/sqlite3.c"
        const i64 iSize = (i64)pgszSrc * (i64)nSrcPage;
        sqlite3_file * const pFile = sqlite3PagerFile(pDestPager);
        i64 iOff;
        i64 iEnd;

        ((void) (0));
        ((void) (0));
# 55616 "ext/sqlite3/libsqlite/sqlite3.c"
        rc = sqlite3PagerCommitPhaseOne(pDestPager, 0, 1);


        iEnd = ((sqlite3PendingByte + pgszDest)<(iSize)?(sqlite3PendingByte + pgszDest):(iSize));
        for(
          iOff=sqlite3PendingByte+pgszSrc;
          rc==0 && iOff<iEnd;
          iOff+=pgszSrc
        ){
          PgHdr *pSrcPg = 0;
          const Pgno iSrcPg = (Pgno)((iOff/pgszSrc)+1);
          rc = sqlite3PagerAcquire(pSrcPager,iSrcPg,&pSrcPg,0);
          if( rc==0 ){
            u8 *zData = sqlite3PagerGetData(pSrcPg);
            rc = sqlite3OsWrite(pFile, zData, pgszSrc, iOff);
          }
          sqlite3PagerUnref(pSrcPg);
        }
        if( rc==0 ){
          rc = backupTruncateFile(pFile, iSize);
        }


        if( rc==0 ){
          rc = sqlite3PagerSync(pDestPager);
        }
      }else{
        rc = sqlite3PagerCommitPhaseOne(pDestPager, 0, 0);
      }


      if( 0==rc
       && 0==(rc = sqlite3BtreeCommitPhaseTwo(p->pDest, 0))
      ){
        rc = 101;
      }
    }






    if( bCloseTrans ){
                         ;
                         sqlite3BtreeCommitPhaseOne(p->pSrc, 0);
                         sqlite3BtreeCommitPhaseTwo(p->pSrc, 0);
      ((void) (0));
    }

    if( rc==(10 | (12<<8)) ){
      rc = 7;
    }
    p->rc = rc;
  }
  if( p->pDestDb ){
                                          ;
  }
                            ;
                                       ;
  return rc;
}




           int sqlite3_backup_finish(sqlite3_backup *p){
  sqlite3_backup **pp;
  sqlite3_mutex *mutex;
  int rc;


  if( p==0 ) return 0;
                                       ;
  sqlite3BtreeEnter(p->pSrc);
  mutex = p->pSrcDb->mutex;
  if( p->pDestDb ){
                                          ;
  }


  if( p->pDestDb ){
    p->pSrc->nBackup--;
  }
  if( p->isAttached ){
    pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc));
    while( *pp!=p ){
      pp = &(*pp)->pNext;
    }
    *pp = p->pNext;
  }


  sqlite3BtreeRollback(p->pDest);


  rc = (p->rc==101) ? 0 : p->rc;
  sqlite3Error(p->pDestDb, rc, 0);


  if( p->pDestDb ){
                                          ;
  }
                            ;
  if( p->pDestDb ){



    sqlite3_free(p);
  }
                            ;
  return rc;
}





           int sqlite3_backup_remaining(sqlite3_backup *p){
  return p->nRemaining;
}





           int sqlite3_backup_pagecount(sqlite3_backup *p){
  return p->nPagecount;
}
# 55758 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3BackupUpdate(sqlite3_backup *pBackup, Pgno iPage, const u8 *aData){
  sqlite3_backup *p;
  for(p=pBackup; p; p=p->pNext){
    ((void) (0));
    if( !isFatalError(p->rc) && iPage<p->iNext ){




      int rc;
      ((void) (0));
                                            ;
      rc = backupOnePage(p, iPage, aData);
                                            ;
      ((void) (0));
      if( rc!=0 ){
        p->rc = rc;
      }
    }
  }
}
# 55791 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3BackupRestart(sqlite3_backup *pBackup){
  sqlite3_backup *p;
  for(p=pBackup; p; p=p->pNext){
    ((void) (0));
    p->iNext = 1;
  }
}
# 55808 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3BtreeCopyFile(Btree *pTo, Btree *pFrom){
  int rc;
  sqlite3_backup b;
  sqlite3BtreeEnter(pTo);
  sqlite3BtreeEnter(pFrom);






  memset(&b, 0, sizeof(b));
  b.pSrcDb = pFrom->db;
  b.pSrc = pFrom;
  b.pDest = pTo;
  b.iNext = 1;
# 55832 "ext/sqlite3/libsqlite/sqlite3.c"
  sqlite3_backup_step(&b, 0x7FFFFFFF);
  ((void) (0));
  rc = sqlite3_backup_finish(&b);
  if( rc==0 ){
    pTo->pBt->pageSizeFixed = 0;
  }

                          ;
                        ;
  return rc;
}
# 55884 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeChangeEncoding(Mem *pMem, int desiredEnc){
  int rc;
  ((void) (0));
  ((void) (0));

  if( !(pMem->flags&0x0002) || pMem->enc==desiredEnc ){
    return 0;
  }
  ((void) (0));







  rc = sqlite3VdbeMemTranslate(pMem, (u8)desiredEnc);
  ((void) (0));
  ((void) (0));
  ((void) (0));
  return rc;

}
# 55921 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeMemGrow(Mem *pMem, int n, int preserve){
  ((void) (0));





  ((void) (0));

  if( n<32 ) n = 32;
  if( sqlite3DbMallocSize(pMem->db, pMem->zMalloc)<n ){
    if( preserve && pMem->z==pMem->zMalloc ){
      pMem->z = pMem->zMalloc = sqlite3DbReallocOrFree(pMem->db, pMem->z, n);
      preserve = 0;
    }else{
      sqlite3DbFree(pMem->db, pMem->zMalloc);
      pMem->zMalloc = sqlite3DbMallocRaw(pMem->db, n);
    }
  }

  if( pMem->z && preserve && pMem->zMalloc && pMem->z!=pMem->zMalloc ){
    memcpy(pMem->zMalloc, pMem->z, pMem->n);
  }
  if( pMem->flags&0x0400 && pMem->xDel ){
    pMem->xDel((void *)(pMem->z));
  }

  pMem->z = pMem->zMalloc;
  if( pMem->z==0 ){
    pMem->flags = 0x0001;
  }else{
    pMem->flags &= ~(0x1000|0x0800);
  }
  pMem->xDel = 0;
  return (pMem->z ? 0 : 7);
}
# 55966 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeMemMakeWriteable(Mem *pMem){
  int f;
  ((void) (0));
  ((void) (0));
  (((pMem)->flags&0x4000)?sqlite3VdbeMemExpandBlob(pMem):0);
  f = pMem->flags;
  if( (f&(0x0002|0x0010)) && pMem->z!=pMem->zMalloc ){
    if( sqlite3VdbeMemGrow(pMem, pMem->n + 2, 1) ){
      return 7;
    }
    pMem->z[pMem->n] = 0;
    pMem->z[pMem->n+1] = 0;
    pMem->flags |= 0x0200;



  }

  return 0;
}






static int sqlite3VdbeMemExpandBlob(Mem *pMem){
  if( pMem->flags & 0x4000 ){
    int nByte;
    ((void) (0));
    ((void) (0));
    ((void) (0));


    nByte = pMem->n + pMem->u.nZero;
    if( nByte<=0 ){
      nByte = 1;
    }
    if( sqlite3VdbeMemGrow(pMem, nByte, 1) ){
      return 7;
    }

    memset(&pMem->z[pMem->n], 0, pMem->u.nZero);
    pMem->n += pMem->u.nZero;
    pMem->flags &= ~(0x4000|0x0200);
  }
  return 0;
}






static int sqlite3VdbeMemNulTerminate(Mem *pMem){
  ((void) (0));
  if( (pMem->flags & 0x0200)!=0 || (pMem->flags & 0x0002)==0 ){
    return 0;
  }
  if( sqlite3VdbeMemGrow(pMem, pMem->n+2, 1) ){
    return 7;
  }
  pMem->z[pMem->n] = 0;
  pMem->z[pMem->n+1] = 0;
  pMem->flags |= 0x0200;
  return 0;
}
# 56047 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeMemStringify(Mem *pMem, int enc){
  int rc = 0;
  int fg = pMem->flags;
  const int nByte = 32;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));


  if( sqlite3VdbeMemGrow(pMem, nByte, 0) ){
    return 7;
  }







  if( fg & 0x0004 ){
    sqlite3_snprintf(nByte, pMem->z, "%lld", pMem->u.i);
  }else{
    ((void) (0));
    sqlite3_snprintf(nByte, pMem->z, "%!.15g", pMem->r);
  }
  pMem->n = sqlite3Strlen30(pMem->z);
  pMem->enc = 1;
  pMem->flags |= 0x0002|0x0200;
  sqlite3VdbeChangeEncoding(pMem, enc);
  return rc;
}
# 56091 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeMemFinalize(Mem *pMem, FuncDef *pFunc){
  int rc = 0;
  if( (pFunc && pFunc->xFinalize) ){
    sqlite3_context ctx;
    ((void) (0));
    ((void) (0));
    memset(&ctx, 0, sizeof(ctx));
    ctx.s.flags = 0x0001;
    ctx.s.db = pMem->db;
    ctx.pMem = pMem;
    ctx.pFunc = pFunc;
    pFunc->xFinalize(&ctx);
    ((void) (0));
    sqlite3DbFree(pMem->db, pMem->zMalloc);
    memcpy(pMem, &ctx.s, sizeof(ctx.s));
    rc = ctx.isError;
  }
  return rc;
}






static void sqlite3VdbeMemReleaseExternal(Mem *p){
  ((void) (0));
                                ;
                                ;
                                   ;
                                  ;
  if( p->flags&(0x2000|0x0400|0x0020|0x0040) ){
    if( p->flags&0x2000 ){
      sqlite3VdbeMemFinalize(p, p->u.pDef);
      ((void) (0));
      sqlite3VdbeMemRelease(p);
    }else if( p->flags&0x0400 && p->xDel ){
      ((void) (0));
      p->xDel((void *)p->z);
      p->xDel = 0;
    }else if( p->flags&0x0020 ){
      sqlite3RowSetClear(p->u.pRowSet);
    }else if( p->flags&0x0040 ){
      sqlite3VdbeMemSetNull(p);
    }
  }
}






static void sqlite3VdbeMemRelease(Mem *p){
  sqlite3VdbeMemReleaseExternal(p);
  sqlite3DbFree(p->db, p->zMalloc);
  p->z = 0;
  p->zMalloc = 0;
  p->xDel = 0;
}
# 56164 "ext/sqlite3/libsqlite/sqlite3.c"
static i64 doubleToInt64(double r){
# 56176 "ext/sqlite3/libsqlite/sqlite3.c"
  static const i64 maxInt = (0xffffffff|(((i64)0x7fffffff)<<32));
  static const i64 minInt = (((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32)));

  if( r<(double)minInt ){
    return minInt;
  }else if( r>(double)maxInt ){




    return minInt;
  }else{
    return (i64)r;
  }

}
# 56204 "ext/sqlite3/libsqlite/sqlite3.c"
static i64 sqlite3VdbeIntValue(Mem *pMem){
  int flags;
  ((void) (0));
  ((void) (0));
  flags = pMem->flags;
  if( flags & 0x0004 ){
    return pMem->u.i;
  }else if( flags & 0x0008 ){
    return doubleToInt64(pMem->r);
  }else if( flags & (0x0002|0x0010) ){
    i64 value = 0;
    ((void) (0));
                          ;
    sqlite3Atoi64(pMem->z, &value, pMem->n, pMem->enc);
    return value;
  }else{
    return 0;
  }
}







static double sqlite3VdbeRealValue(Mem *pMem){
  ((void) (0));
  ((void) (0));
  if( pMem->flags & 0x0008 ){
    return pMem->r;
  }else if( pMem->flags & 0x0004 ){
    return (double)pMem->u.i;
  }else if( pMem->flags & (0x0002|0x0010) ){

    double val = (double)0;
    sqlite3AtoF(pMem->z, &val, pMem->n, pMem->enc);
    return val;
  }else{

    return (double)0;
  }
}





static void sqlite3VdbeIntegerAffinity(Mem *pMem){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  pMem->u.i = doubleToInt64(pMem->r);
# 56272 "ext/sqlite3/libsqlite/sqlite3.c"
  if( pMem->r==(double)pMem->u.i && pMem->u.i>(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32)))
      && (pMem->u.i<(0xffffffff|(((i64)0x7fffffff)<<32))) ){
    pMem->flags |= 0x0004;
  }
}




static int sqlite3VdbeMemIntegerify(Mem *pMem){
  ((void) (0));
  ((void) (0));
  ((void) (0));

  pMem->u.i = sqlite3VdbeIntValue(pMem);
  ((pMem)->flags = ((pMem)->flags&~(0x00ff|0x4000))|0x0004);
  return 0;
}





static int sqlite3VdbeMemRealify(Mem *pMem){
  ((void) (0));
  ((void) (0));

  pMem->r = sqlite3VdbeRealValue(pMem);
  ((pMem)->flags = ((pMem)->flags&~(0x00ff|0x4000))|0x0008);
  return 0;
}
# 56312 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeMemNumerify(Mem *pMem){
  if( (pMem->flags & (0x0004|0x0008|0x0001))==0 ){
    ((void) (0));
    ((void) (0));
    if( 0==sqlite3Atoi64(pMem->z, &pMem->u.i, pMem->n, pMem->enc) ){
      ((pMem)->flags = ((pMem)->flags&~(0x00ff|0x4000))|0x0004);
    }else{
      pMem->r = sqlite3VdbeRealValue(pMem);
      ((pMem)->flags = ((pMem)->flags&~(0x00ff|0x4000))|0x0008);
      sqlite3VdbeIntegerAffinity(pMem);
    }
  }
  ((void) (0));
  pMem->flags &= ~(0x0002|0x0010);
  return 0;
}




static void sqlite3VdbeMemSetNull(Mem *pMem){
  if( pMem->flags & 0x0040 ){
    VdbeFrame *pFrame = pMem->u.pFrame;
    pFrame->pParent = pFrame->v->pDelFrame;
    pFrame->v->pDelFrame = pFrame;
  }
  if( pMem->flags & 0x0020 ){
    sqlite3RowSetClear(pMem->u.pRowSet);
  }
  ((pMem)->flags = ((pMem)->flags&~(0x00ff|0x4000))|0x0001);
  pMem->type = 5;
}





static void sqlite3VdbeMemSetZeroBlob(Mem *pMem, int n){
  sqlite3VdbeMemRelease(pMem);
  pMem->flags = 0x0010|0x4000;
  pMem->type = 4;
  pMem->n = 0;
  if( n<0 ) n = 0;
  pMem->u.nZero = n;
  pMem->enc = 1;
# 56365 "ext/sqlite3/libsqlite/sqlite3.c"
}





static void sqlite3VdbeMemSetInt64(Mem *pMem, i64 val){
  sqlite3VdbeMemRelease(pMem);
  pMem->u.i = val;
  pMem->flags = 0x0004;
  pMem->type = 1;
}






static void sqlite3VdbeMemSetDouble(Mem *pMem, double val){
  if( sqlite3IsNaN(val) ){
    sqlite3VdbeMemSetNull(pMem);
  }else{
    sqlite3VdbeMemRelease(pMem);
    pMem->r = val;
    pMem->flags = 0x0008;
    pMem->type = 2;
  }
}






static void sqlite3VdbeMemSetRowSet(Mem *pMem){
  sqlite3 *db = pMem->db;
  ((void) (0));
  ((void) (0));
  sqlite3VdbeMemRelease(pMem);
  pMem->zMalloc = sqlite3DbMallocRaw(db, 64);
  if( db->mallocFailed ){
    pMem->flags = 0x0001;
  }else{
    ((void) (0));
    pMem->u.pRowSet = sqlite3RowSetInit(db, pMem->zMalloc,
                                       sqlite3DbMallocSize(db, pMem->zMalloc));
    ((void) (0));
    pMem->flags = 0x0020;
  }
}





static int sqlite3VdbeMemTooBig(Mem *p){
  ((void) (0));
  if( p->flags & (0x0002|0x0010) ){
    int n = p->n;
    if( p->flags & 0x4000 ){
      n += p->u.nZero;
    }
    return n>p->db->aLimit[0];
  }
  return 0;
}
# 56465 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3VdbeMemShallowCopy(Mem *pTo, const Mem *pFrom, int srcType){
  ((void) (0));
  sqlite3VdbeMemReleaseExternal(pTo);
  memcpy(pTo, pFrom, (size_t)(&(((Mem *)0)->zMalloc)));
  pTo->xDel = 0;
  if( (pFrom->flags&0x0800)==0 ){
    pTo->flags &= ~(0x0400|0x0800|0x1000);
    ((void) (0));
    pTo->flags |= srcType;
  }
}





static int sqlite3VdbeMemCopy(Mem *pTo, const Mem *pFrom){
  int rc = 0;

  ((void) (0));
  sqlite3VdbeMemReleaseExternal(pTo);
  memcpy(pTo, pFrom, (size_t)(&(((Mem *)0)->zMalloc)));
  pTo->flags &= ~0x0400;

  if( pTo->flags&(0x0002|0x0010) ){
    if( 0==(pFrom->flags&0x0800) ){
      pTo->flags |= 0x1000;
      rc = sqlite3VdbeMemMakeWriteable(pTo);
    }
  }

  return rc;
}







static void sqlite3VdbeMemMove(Mem *pTo, Mem *pFrom){
  ((void) (0));
  ((void) (0));
  ((void) (0));

  sqlite3VdbeMemRelease(pTo);
  memcpy(pTo, pFrom, sizeof(Mem));
  pFrom->flags = 0x0001;
  pFrom->xDel = 0;
  pFrom->zMalloc = 0;
}
# 56532 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeMemSetStr(
  Mem *pMem,
  const char *z,
  int n,
  u8 enc,
  void (*xDel)(void*)
){
  int nByte = n;
  int iLimit;
  u16 flags = 0;

  ((void) (0));
  ((void) (0));


  if( !z ){
    sqlite3VdbeMemSetNull(pMem);
    return 0;
  }

  if( pMem->db ){
    iLimit = pMem->db->aLimit[0];
  }else{
    iLimit = 1000000000;
  }
  flags = (enc==0?0x0010:0x0002);
  if( nByte<0 ){
    ((void) (0));
    if( enc==1 ){
      for(nByte=0; nByte<=iLimit && z[nByte]; nByte++){}
    }else{
      for(nByte=0; nByte<=iLimit && (z[nByte] | z[nByte+1]); nByte+=2){}
    }
    flags |= 0x0200;
  }





  if( xDel==((sqlite3_destructor_type)-1) ){
    int nAlloc = nByte;
    if( flags&0x0200 ){
      nAlloc += (enc==1?1:2);
    }
    if( nByte>iLimit ){
      return 18;
    }
    if( sqlite3VdbeMemGrow(pMem, nAlloc, 0) ){
      return 7;
    }
    memcpy(pMem->z, z, nAlloc);
  }else if( xDel==((sqlite3_destructor_type)sqlite3DbFree) ){
    sqlite3VdbeMemRelease(pMem);
    pMem->zMalloc = pMem->z = (char *)z;
    pMem->xDel = 0;
  }else{
    sqlite3VdbeMemRelease(pMem);
    pMem->z = (char *)z;
    pMem->xDel = xDel;
    flags |= ((xDel==((sqlite3_destructor_type)0))?0x0800:0x0400);
  }

  pMem->n = nByte;
  pMem->flags = flags;
  pMem->enc = (enc==0 ? 1 : enc);
  pMem->type = (enc==0 ? 4 : 3);


  if( pMem->enc!=1 && sqlite3VdbeMemHandleBom(pMem) ){
    return 7;
  }


  if( nByte>iLimit ){
    return 18;
  }

  return 0;
}
# 56622 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3MemCompare(const Mem *pMem1, const Mem *pMem2, const CollSeq *pColl){
  int rc;
  int f1, f2;
  int combined_flags;

  f1 = pMem1->flags;
  f2 = pMem2->flags;
  combined_flags = f1|f2;
  ((void) (0));




  if( combined_flags&0x0001 ){
    return (f2&0x0001) - (f1&0x0001);
  }





  if( combined_flags&(0x0004|0x0008) ){
    if( !(f1&(0x0004|0x0008)) ){
      return 1;
    }
    if( !(f2&(0x0004|0x0008)) ){
      return -1;
    }
    if( (f1 & f2 & 0x0004)==0 ){
      double r1, r2;
      if( (f1&0x0008)==0 ){
        r1 = (double)pMem1->u.i;
      }else{
        r1 = pMem1->r;
      }
      if( (f2&0x0008)==0 ){
        r2 = (double)pMem2->u.i;
      }else{
        r2 = pMem2->r;
      }
      if( r1<r2 ) return -1;
      if( r1>r2 ) return 1;
      return 0;
    }else{
      ((void) (0));
      ((void) (0));
      if( pMem1->u.i < pMem2->u.i ) return -1;
      if( pMem1->u.i > pMem2->u.i ) return 1;
      return 0;
    }
  }




  if( combined_flags&0x0002 ){
    if( (f1 & 0x0002)==0 ){
      return 1;
    }
    if( (f2 & 0x0002)==0 ){
      return -1;
    }

    ((void) (0));
    ((void) (0));






    ((void) (0));

    if( pColl ){
      if( pMem1->enc==pColl->enc ){


        return pColl->xCmp(pColl->pUser,pMem1->n,pMem1->z,pMem2->n,pMem2->z);
      }else{
        const void *v1, *v2;
        int n1, n2;
        Mem c1;
        Mem c2;
        memset(&c1, 0, sizeof(c1));
        memset(&c2, 0, sizeof(c2));
        sqlite3VdbeMemShallowCopy(&c1, pMem1, 0x1000);
        sqlite3VdbeMemShallowCopy(&c2, pMem2, 0x1000);
        v1 = sqlite3ValueText((sqlite3_value*)&c1, pColl->enc);
        n1 = v1==0 ? 0 : c1.n;
        v2 = sqlite3ValueText((sqlite3_value*)&c2, pColl->enc);
        n2 = v2==0 ? 0 : c2.n;
        rc = pColl->xCmp(pColl->pUser, n1, v1, n2, v2);
        sqlite3VdbeMemRelease(&c1);
        sqlite3VdbeMemRelease(&c2);
        return rc;
      }
    }


  }


  rc = memcmp(pMem1->z, pMem2->z, (pMem1->n>pMem2->n)?pMem2->n:pMem1->n);
  if( rc==0 ){
    rc = pMem1->n - pMem2->n;
  }
  return rc;
}
# 56744 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeMemFromBtree(
  BtCursor *pCur,
  int offset,
  int amt,
  int key,
  Mem *pMem
){
  char *zData;
  int available = 0;
  int rc = 0;

  ((void) (0));



  ((void) (0));
  if( key ){
    zData = (char *)sqlite3BtreeKeyFetch(pCur, &available);
  }else{
    zData = (char *)sqlite3BtreeDataFetch(pCur, &available);
  }
  ((void) (0));

  if( offset+amt<=available && (pMem->flags&0x0400)==0 ){
    sqlite3VdbeMemRelease(pMem);
    pMem->z = &zData[offset];
    pMem->flags = 0x0010|0x1000;
  }else if( 0==(rc = sqlite3VdbeMemGrow(pMem, amt+2, 0)) ){
    pMem->flags = 0x0010|0x0400|0x0200;
    pMem->enc = 0;
    pMem->type = 4;
    if( key ){
      rc = sqlite3BtreeKey(pCur, offset, amt, pMem->z);
    }else{
      rc = sqlite3BtreeData(pCur, offset, amt, pMem->z);
    }
    pMem->z[amt] = 0;
    pMem->z[amt+1] = 0;
    if( rc!=0 ){
      sqlite3VdbeMemRelease(pMem);
    }
  }
  pMem->n = amt;

  return rc;
}
# 56801 "ext/sqlite3/libsqlite/sqlite3.c"
static const void *sqlite3ValueText(sqlite3_value* pVal, u8 enc){
  if( !pVal ) return 0;

  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( pVal->flags&0x0001 ){
    return 0;
  }
  ((void) (0));
  pVal->flags |= (pVal->flags & 0x0010)>>3;
  (((pVal)->flags&0x4000)?sqlite3VdbeMemExpandBlob(pVal):0);
  if( pVal->flags&0x0002 ){
    sqlite3VdbeChangeEncoding(pVal, enc & ~8);
    if( (enc & 8)!=0 && 1==(1&((int)(long int)(pVal->z))) ){
      ((void) (0));
      if( sqlite3VdbeMemMakeWriteable(pVal)!=0 ){
        return 0;
      }
    }
    sqlite3VdbeMemNulTerminate(pVal);
  }else{
    ((void) (0));
    sqlite3VdbeMemStringify(pVal, enc);
    ((void) (0));
  }
  ((void) (0));

  if( pVal->enc==(enc & ~8) ){
    return pVal->z;
  }else{
    return 0;
  }
}




static sqlite3_value *sqlite3ValueNew(sqlite3 *db){
  Mem *p = sqlite3DbMallocZero(db, sizeof(*p));
  if( p ){
    p->flags = 0x0001;
    p->type = 5;
    p->db = db;
  }
  return p;
}
# 56860 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3ValueFromExpr(
  sqlite3 *db,
  Expr *pExpr,
  u8 enc,
  u8 affinity,
  sqlite3_value **ppVal
){
  int op;
  char *zVal = 0;
  sqlite3_value *pVal = 0;
  int negInt = 1;
  const char *zNeg = "";

  if( !pExpr ){
    *ppVal = 0;
    return 0;
  }
  op = pExpr->op;
# 56886 "ext/sqlite3/libsqlite/sqlite3.c"
  if( (op==132) ) op = pExpr->op2;





  if( op==156
   && (pExpr->pLeft->op==129 || pExpr->pLeft->op==130) ){
    pExpr = pExpr->pLeft;
    op = pExpr->op;
    negInt = -1;
    zNeg = "-";
  }

  if( op==94 || op==130 || op==129 ){
    pVal = sqlite3ValueNew(db);
    if( pVal==0 ) goto no_mem;
    if( (((pExpr)->flags&(0x0400))==(0x0400)) ){
      sqlite3VdbeMemSetInt64(pVal, (i64)pExpr->u.iValue*negInt);
    }else{
      zVal = sqlite3MPrintf(db, "%s%s", zNeg, pExpr->u.zToken);
      if( zVal==0 ) goto no_mem;
      sqlite3ValueSetStr(pVal, -1, zVal, 1, ((sqlite3_destructor_type)sqlite3DbFree));
      if( op==130 ) pVal->type = 2;
    }
    if( (op==129 || op==130 ) && affinity=='b' ){
      sqlite3ValueApplyAffinity(pVal, 'c', 1);
    }else{
      sqlite3ValueApplyAffinity(pVal, affinity, 1);
    }
    if( pVal->flags & (0x0004|0x0008) ) pVal->flags &= ~0x0002;
    if( enc!=1 ){
      sqlite3VdbeChangeEncoding(pVal, enc);
    }
  }else if( op==156 ) {

    if( 0==sqlite3ValueFromExpr(db,pExpr->pLeft,enc,affinity,&pVal) ){
      sqlite3VdbeMemNumerify(pVal);
      if( pVal->u.i==(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) ){
        pVal->flags &= 0x0004;
        pVal->flags |= 0x0008;
        pVal->r = (double)(0xffffffff|(((i64)0x7fffffff)<<32));
      }else{
        pVal->u.i = -pVal->u.i;
      }
      pVal->r = -pVal->r;
      sqlite3ValueApplyAffinity(pVal, affinity, enc);
    }
  }else if( op==98 ){
    pVal = sqlite3ValueNew(db);
    if( pVal==0 ) goto no_mem;
  }

  else if( op==131 ){
    int nVal;
    ((void) (0));
    ((void) (0));
    pVal = sqlite3ValueNew(db);
    if( !pVal ) goto no_mem;
    zVal = &pExpr->u.zToken[2];
    nVal = sqlite3Strlen30(zVal)-1;
    ((void) (0));
    sqlite3VdbeMemSetStr(pVal, sqlite3HexToBlob(db, zVal, nVal), nVal/2,
                         0, ((sqlite3_destructor_type)sqlite3DbFree));
  }


  if( pVal ){
    sqlite3VdbeMemStoreType(pVal);
  }
  *ppVal = pVal;
  return 0;

no_mem:
  db->mallocFailed = 1;
  sqlite3DbFree(db, zVal);
  sqlite3ValueFree(pVal);
  *ppVal = 0;
  return 7;
}




static void sqlite3ValueSetStr(
  sqlite3_value *v,
  int n,
  const void *z,
  u8 enc,
  void (*xDel)(void*)
){
  if( v ) sqlite3VdbeMemSetStr((Mem *)v, z, n, enc, xDel);
}




static void sqlite3ValueFree(sqlite3_value *v){
  if( !v ) return;
  sqlite3VdbeMemRelease((Mem *)v);
  sqlite3DbFree(((Mem*)v)->db, v);
}





static int sqlite3ValueBytes(sqlite3_value *pVal, u8 enc){
  Mem *p = (Mem*)pVal;
  if( (p->flags & 0x0010)!=0 || sqlite3ValueText(pVal, enc) ){
    if( p->flags & 0x4000 ){
      return p->n + p->u.nZero;
    }else{
      return p->n;
    }
  }
  return 0;
}
# 57039 "ext/sqlite3/libsqlite/sqlite3.c"
static Vdbe *sqlite3VdbeCreate(sqlite3 *db){
  Vdbe *p;
  p = sqlite3DbMallocZero(db, sizeof(Vdbe) );
  if( p==0 ) return 0;
  p->db = db;
  if( db->pVdbe ){
    db->pVdbe->pPrev = p;
  }
  p->pNext = db->pVdbe;
  p->pPrev = 0;
  db->pVdbe = p;
  p->magic = 0x26bceaa5;
  return p;
}




static void sqlite3VdbeSetSql(Vdbe *p, const char *z, int n, int isPrepareV2){
  ((void) (0));
  if( p==0 ) return;



  ((void) (0));
  p->zSql = sqlite3DbStrNDup(p->db, z, n);
  p->isPrepareV2 = (u8)isPrepareV2;
}




           const char *sqlite3_sql(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe *)pStmt;
  return (p && p->isPrepareV2) ? p->zSql : 0;
}




static void sqlite3VdbeSwap(Vdbe *pA, Vdbe *pB){
  Vdbe tmp, *pTmp;
  char *zTmp;
  tmp = *pA;
  *pA = *pB;
  *pB = tmp;
  pTmp = pA->pNext;
  pA->pNext = pB->pNext;
  pB->pNext = pTmp;
  pTmp = pA->pPrev;
  pA->pPrev = pB->pPrev;
  pB->pPrev = pTmp;
  zTmp = pA->zSql;
  pA->zSql = pB->zSql;
  pB->zSql = zTmp;
  pB->isPrepareV2 = pA->isPrepareV2;
}
# 57115 "ext/sqlite3/libsqlite/sqlite3.c"
static int growOpArray(Vdbe *p){
  VdbeOp *pNew;
  int nNew = (p->nOpAlloc ? p->nOpAlloc*2 : (int)(1024/sizeof(Op)));
  pNew = sqlite3DbRealloc(p->db, p->aOp, nNew*sizeof(Op));
  if( pNew ){
    p->nOpAlloc = sqlite3DbMallocSize(p->db, pNew)/sizeof(Op);
    p->aOp = pNew;
  }
  return (pNew ? 0 : 7);
}
# 57142 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeAddOp3(Vdbe *p, int op, int p1, int p2, int p3){
  int i;
  VdbeOp *pOp;

  i = p->nOp;
  ((void) (0));
  ((void) (0));
  if( p->nOpAlloc<=i ){
    if( growOpArray(p) ){
      return 1;
    }
  }
  p->nOp++;
  pOp = &p->aOp[i];
  pOp->opcode = (u8)op;
  pOp->p5 = 0;
  pOp->p1 = p1;
  pOp->p2 = p2;
  pOp->p3 = p3;
  pOp->p4.p = 0;
  pOp->p4type = 0;
  p->expired = 0;
  if( op==99 ){


    int j;
    for(j=0; j<p->db->nDb; j++) sqlite3VdbeUsesBtree(p, j);
  }
# 57178 "ext/sqlite3/libsqlite/sqlite3.c"
  return i;
}
static int sqlite3VdbeAddOp0(Vdbe *p, int op){
  return sqlite3VdbeAddOp3(p, op, 0, 0, 0);
}
static int sqlite3VdbeAddOp1(Vdbe *p, int op, int p1){
  return sqlite3VdbeAddOp3(p, op, p1, 0, 0);
}
static int sqlite3VdbeAddOp2(Vdbe *p, int op, int p1, int p2){
  return sqlite3VdbeAddOp3(p, op, p1, p2, 0);
}





static int sqlite3VdbeAddOp4(
  Vdbe *p,
  int op,
  int p1,
  int p2,
  int p3,
  const char *zP4,
  int p4type
){
  int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);
  sqlite3VdbeChangeP4(p, addr, zP4, p4type);
  return addr;
}




static int sqlite3VdbeAddOp4Int(
  Vdbe *p,
  int op,
  int p1,
  int p2,
  int p3,
  int p4
){
  int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);
  sqlite3VdbeChangeP4(p, addr, ((void*)(long int)(p4)), (-14));
  return addr;
}
# 57238 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeMakeLabel(Vdbe *p){
  int i;
  i = p->nLabel++;
  ((void) (0));
  if( i>=p->nLabelAlloc ){
    int n = p->nLabelAlloc*2 + 5;
    p->aLabel = sqlite3DbReallocOrFree(p->db, p->aLabel,
                                       n*sizeof(p->aLabel[0]));
    p->nLabelAlloc = sqlite3DbMallocSize(p->db, p->aLabel)/sizeof(p->aLabel[0]);
  }
  if( p->aLabel ){
    p->aLabel[i] = -1;
  }
  return -1-i;
}






static void sqlite3VdbeResolveLabel(Vdbe *p, int x){
  int j = -1-x;
  ((void) (0));
  ((void) (0));
  if( p->aLabel ){
    p->aLabel[j] = p->nOp;
  }
}




static void sqlite3VdbeRunOnlyOnce(Vdbe *p){
  p->runOnlyOnce = 1;
}
# 57409 "ext/sqlite3/libsqlite/sqlite3.c"
static void resolveP2Values(Vdbe *p, int *pMaxFuncArgs){
  int i;
  int nMaxArgs = *pMaxFuncArgs;
  Op *pOp;
  int *aLabel = p->aLabel;
  p->readOnly = 1;
  for(pOp=p->aOp, i=p->nOp-1; i>=0; i--, pOp++){
    u8 opcode = pOp->opcode;

    pOp->opflags = sqlite3OpcodeProperty[opcode];
    if( opcode==18 || opcode==116 ){
      if( pOp->p5>nMaxArgs ) nMaxArgs = pOp->p5;
    }else if( (opcode==34 && pOp->p2!=0) || opcode==120 ){
      p->readOnly = 0;

    }else if( opcode==133 ){
      if( pOp->p2>nMaxArgs ) nMaxArgs = pOp->p2;
    }else if( opcode==128 ){
      int n;
      ((void) (0));
      ((void) (0));
      n = pOp[-1].p1;
      if( n>nMaxArgs ) nMaxArgs = n;

    }

    if( (pOp->opflags & 0x0001)!=0 && pOp->p2<0 ){
      ((void) (0));
      pOp->p2 = aLabel[-1-pOp->p2];
    }
  }
  sqlite3DbFree(p->db, p->aLabel);
  p->aLabel = 0;

  *pMaxFuncArgs = nMaxArgs;
}




static int sqlite3VdbeCurrentAddr(Vdbe *p){
  ((void) (0));
  return p->nOp;
}
# 57465 "ext/sqlite3/libsqlite/sqlite3.c"
static VdbeOp *sqlite3VdbeTakeOpArray(Vdbe *p, int *pnOp, int *pnMaxArg){
  VdbeOp *aOp = p->aOp;
  ((void) (0));


  ((void) (0));

  resolveP2Values(p, pnMaxArg);
  *pnOp = p->nOp;
  p->aOp = 0;
  return aOp;
}





static int sqlite3VdbeAddOpList(Vdbe *p, int nOp, VdbeOpList const *aOp){
  int addr;
  ((void) (0));
  if( p->nOp + nOp > p->nOpAlloc && growOpArray(p) ){
    return 0;
  }
  addr = p->nOp;
  if( (nOp>0) ){
    int i;
    VdbeOpList const *pIn = aOp;
    for(i=0; i<nOp; i++, pIn++){
      int p2 = pIn->p2;
      VdbeOp *pOut = &p->aOp[i+addr];
      pOut->opcode = pIn->opcode;
      pOut->p1 = pIn->p1;
      if( p2<0 && (sqlite3OpcodeProperty[pOut->opcode] & 0x0001)!=0 ){
        pOut->p2 = addr + (-1-(p2));
      }else{
        pOut->p2 = p2;
      }
      pOut->p3 = pIn->p3;
      pOut->p4type = 0;
      pOut->p4.p = 0;
      pOut->p5 = 0;






    }
    p->nOp += nOp;
  }
  return addr;
}







static void sqlite3VdbeChangeP1(Vdbe *p, int addr, int val){
  ((void) (0));
  ((void) (0));
  if( p->nOp>addr ){
    p->aOp[addr].p1 = val;
  }
}





static void sqlite3VdbeChangeP2(Vdbe *p, int addr, int val){
  ((void) (0));
  ((void) (0));
  if( p->nOp>addr ){
    p->aOp[addr].p2 = val;
  }
}




static void sqlite3VdbeChangeP3(Vdbe *p, int addr, int val){
  ((void) (0));
  ((void) (0));
  if( p->nOp>addr ){
    p->aOp[addr].p3 = val;
  }
}





static void sqlite3VdbeChangeP5(Vdbe *p, u8 val){
  ((void) (0));
  if( p->aOp ){
    ((void) (0));
    p->aOp[p->nOp-1].p5 = val;
  }
}





static void sqlite3VdbeJumpHere(Vdbe *p, int addr){
  ((void) (0));
  sqlite3VdbeChangeP2(p, addr, p->nOp);
}






static void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef){
  if( (pDef) && (pDef->flags & 0x04)!=0 ){
    sqlite3DbFree(db, pDef);
  }
}

static void vdbeFreeOpArray(sqlite3 *, Op *, int);




static void freeP4(sqlite3 *db, int p4type, void *p4){
  if( p4 ){
    ((void) (0));
    switch( p4type ){
      case (-12):
      case (-13):
      case (-1):
      case (-6):
      case (-15):
      case (-16): {
        sqlite3DbFree(db, p4);
        break;
      }
      case (-11): {
        if( db->pnBytesFreed==0 ) sqlite3_free(p4);
        break;
      }
      case (-7): {
        VdbeFunc *pVdbeFunc = (VdbeFunc *)p4;
        freeEphemeralFunction(db, pVdbeFunc->pFunc);
        if( db->pnBytesFreed==0 ) sqlite3VdbeDeleteAuxData(pVdbeFunc, 0);
        sqlite3DbFree(db, pVdbeFunc);
        break;
      }
      case (-5): {
        freeEphemeralFunction(db, (FuncDef*)p4);
        break;
      }
      case (-8): {
        if( db->pnBytesFreed==0 ){
          sqlite3ValueFree((sqlite3_value*)p4);
        }else{
          Mem *p = (Mem*)p4;
          sqlite3DbFree(db, p->zMalloc);
          sqlite3DbFree(db, p);
        }
        break;
      }
      case (-10) : {
        if( db->pnBytesFreed==0 ) sqlite3VtabUnlock((VTable *)p4);
        break;
      }
    }
  }
}






static void vdbeFreeOpArray(sqlite3 *db, Op *aOp, int nOp){
  if( aOp ){
    Op *pOp;
    for(pOp=aOp; pOp<&aOp[nOp]; pOp++){
      freeP4(db, pOp->p4type, pOp->p4.p);



    }
  }
  sqlite3DbFree(db, aOp);
}






static void sqlite3VdbeLinkSubProgram(Vdbe *pVdbe, SubProgram *p){
  p->pNext = pVdbe->pProgram;
  pVdbe->pProgram = p;
}




static void sqlite3VdbeChangeToNoop(Vdbe *p, int addr, int N){
  if( p->aOp ){
    VdbeOp *pOp = &p->aOp[addr];
    sqlite3 *db = p->db;
    while( N-- ){
      freeP4(db, pOp->p4type, pOp->p4.p);
      memset(pOp, 0, sizeof(pOp[0]));
      pOp->opcode = 137;
      pOp++;
    }
  }
}
# 57707 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3VdbeChangeP4(Vdbe *p, int addr, const char *zP4, int n){
  Op *pOp;
  sqlite3 *db;
  ((void) (0));
  db = p->db;
  ((void) (0));
  if( p->aOp==0 || db->mallocFailed ){
    if ( n!=(-6) && n!=(-10) ) {
      freeP4(db, n, (void*)*(char**)&zP4);
    }
    return;
  }
  ((void) (0));
  ((void) (0));
  if( addr<0 ){
    addr = p->nOp - 1;
  }
  pOp = &p->aOp[addr];
  freeP4(db, pOp->p4type, pOp->p4.p);
  pOp->p4.p = 0;
  if( n==(-14) ){


    pOp->p4.i = ((int)(long int)(zP4));
    pOp->p4type = (-14);
  }else if( zP4==0 ){
    pOp->p4.p = 0;
    pOp->p4type = 0;
  }else if( n==(-6) ){
    KeyInfo *pKeyInfo;
    int nField, nByte;

    nField = ((KeyInfo*)zP4)->nField;
    nByte = sizeof(*pKeyInfo) + (nField-1)*sizeof(pKeyInfo->aColl[0]) + nField;
    pKeyInfo = sqlite3DbMallocRaw(0, nByte);
    pOp->p4.pKeyInfo = pKeyInfo;
    if( pKeyInfo ){
      u8 *aSortOrder;
      memcpy((char*)pKeyInfo, zP4, nByte - nField);
      aSortOrder = pKeyInfo->aSortOrder;
      if( aSortOrder ){
        pKeyInfo->aSortOrder = (unsigned char*)&pKeyInfo->aColl[nField];
        memcpy(pKeyInfo->aSortOrder, aSortOrder, nField);
      }
      pOp->p4type = (-6);
    }else{
      p->db->mallocFailed = 1;
      pOp->p4type = 0;
    }
  }else if( n==(-16) ){
    pOp->p4.p = (void*)zP4;
    pOp->p4type = (-6);
  }else if( n==(-10) ){
    pOp->p4.p = (void*)zP4;
    pOp->p4type = (-10);
    sqlite3VtabLock((VTable *)zP4);
    ((void) (0));
  }else if( n<0 ){
    pOp->p4.p = (void*)zP4;
    pOp->p4type = (signed char)n;
  }else{
    if( n==0 ) n = sqlite3Strlen30(zP4);
    pOp->p4.z = sqlite3DbStrNDup(p->db, zP4, n);
    pOp->p4type = (-1);
  }
}
# 57831 "ext/sqlite3/libsqlite/sqlite3.c"
static VdbeOp *sqlite3VdbeGetOp(Vdbe *p, int addr){


  static const VdbeOp dummy;
  ((void) (0));
  if( addr<0 ){



    addr = p->nOp - 1;
  }
  ((void) (0));
  if( p->db->mallocFailed ){
    return (VdbeOp*)&dummy;
  }else{
    return &p->aOp[addr];
  }
}







static char *displayP4(Op *pOp, char *zTemp, int nTemp){
  char *zP4 = zTemp;
  ((void) (0));
  switch( pOp->p4type ){
    case (-17):
    case (-6): {
      int i, j;
      KeyInfo *pKeyInfo = pOp->p4.pKeyInfo;
      sqlite3_snprintf(nTemp, zTemp, "keyinfo(%d", pKeyInfo->nField);
      i = sqlite3Strlen30(zTemp);
      for(j=0; j<pKeyInfo->nField; j++){
        CollSeq *pColl = pKeyInfo->aColl[j];
        if( pColl ){
          int n = sqlite3Strlen30(pColl->zName);
          if( i+n>nTemp-6 ){
            memcpy(&zTemp[i],",...",4);
            break;
          }
          zTemp[i++] = ',';
          if( pKeyInfo->aSortOrder && pKeyInfo->aSortOrder[j] ){
            zTemp[i++] = '-';
          }
          memcpy(&zTemp[i], pColl->zName,n+1);
          i += n;
        }else if( i+4<nTemp-6 ){
          memcpy(&zTemp[i],",nil",4);
          i += 4;
        }
      }
      zTemp[i++] = ')';
      zTemp[i] = 0;
      ((void) (0));
      break;
    }
    case (-4): {
      CollSeq *pColl = pOp->p4.pColl;
      sqlite3_snprintf(nTemp, zTemp, "collseq(%.20s)", pColl->zName);
      break;
    }
    case (-5): {
      FuncDef *pDef = pOp->p4.pFunc;
      sqlite3_snprintf(nTemp, zTemp, "%s(%d)", pDef->zName, pDef->nArg);
      break;
    }
    case (-13): {
      sqlite3_snprintf(nTemp, zTemp, "%lld", *pOp->p4.pI64);
      break;
    }
    case (-14): {
      sqlite3_snprintf(nTemp, zTemp, "%d", pOp->p4.i);
      break;
    }
    case (-12): {
      sqlite3_snprintf(nTemp, zTemp, "%.16g", *pOp->p4.pReal);
      break;
    }
    case (-8): {
      Mem *pMem = pOp->p4.pMem;
      ((void) (0));
      if( pMem->flags & 0x0002 ){
        zP4 = pMem->z;
      }else if( pMem->flags & 0x0004 ){
        sqlite3_snprintf(nTemp, zTemp, "%lld", pMem->u.i);
      }else if( pMem->flags & 0x0008 ){
        sqlite3_snprintf(nTemp, zTemp, "%.16g", pMem->r);
      }else{
        ((void) (0));
        zP4 = "(blob)";
      }
      break;
    }

    case (-10): {
      sqlite3_vtab *pVtab = pOp->p4.pVtab->pVtab;
      sqlite3_snprintf(nTemp, zTemp, "vtab:%p:%p", pVtab, pVtab->pModule);
      break;
    }

    case (-15): {
      sqlite3_snprintf(nTemp, zTemp, "intarray");
      break;
    }
    case (-18): {
      sqlite3_snprintf(nTemp, zTemp, "program");
      break;
    }
    default: {
      zP4 = pOp->p4.z;
      if( zP4==0 ){
        zP4 = zTemp;
        zTemp[0] = 0;
      }
    }
  }
  ((void) (0));
  return zP4;
}
# 57962 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3VdbeUsesBtree(Vdbe *p, int i){
  ((void) (0));
  ((void) (0));
  p->btreeMask |= ((yDbMask)1)<<i;
  if( i!=1 && 0 ){
    p->lockMask |= ((yDbMask)1)<<i;
  }
}
# 58058 "ext/sqlite3/libsqlite/sqlite3.c"
static void releaseMemArray(Mem *p, int N){
  if( p && N ){
    Mem *pEnd;
    sqlite3 *db = p->db;
    u8 malloc_failed = db->mallocFailed;
    if( db->pnBytesFreed ){
      for(pEnd=&p[N]; p<pEnd; p++){
        sqlite3DbFree(db, p->zMalloc);
      }
      return;
    }
    for(pEnd=&p[N]; p<pEnd; p++){
      ((void) (0));
# 58084 "ext/sqlite3/libsqlite/sqlite3.c"
      if( p->flags&(0x2000|0x0400|0x0040|0x0020) ){
        sqlite3VdbeMemRelease(p);
      }else if( p->zMalloc ){
        sqlite3DbFree(db, p->zMalloc);
        p->zMalloc = 0;
      }

      p->flags = 0x0001;
    }
    db->mallocFailed = malloc_failed;
  }
}





static void sqlite3VdbeFrameDelete(VdbeFrame *p){
  int i;
  Mem *aMem = ((Mem *)&((u8 *)p)[(((sizeof(VdbeFrame))+7)&~7)]);
  VdbeCursor **apCsr = (VdbeCursor **)&aMem[p->nChildMem];
  for(i=0; i<p->nChildCsr; i++){
    sqlite3VdbeFreeCursor(p->v, apCsr[i]);
  }
  releaseMemArray(aMem, p->nChildMem);
  sqlite3DbFree(p->v->db, p);
}
# 58128 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeList(
  Vdbe *p
){
  int nRow;
  int nSub = 0;
  SubProgram **apSub = 0;
  Mem *pSub = 0;
  sqlite3 *db = p->db;
  int i;
  int rc = 0;
  Mem *pMem = p->pResultSet = &p->aMem[1];

  ((void) (0));
  ((void) (0));
  ((void) (0));





  releaseMemArray(pMem, 8);

  if( p->rc==7 ){


    db->mallocFailed = 1;
    return 1;
  }
# 58164 "ext/sqlite3/libsqlite/sqlite3.c"
  nRow = p->nOp;
  if( p->explain==1 ){




    ((void) (0));
    pSub = &p->aMem[9];
    if( pSub->flags&0x0010 ){


      nSub = pSub->n/sizeof(Vdbe*);
      apSub = (SubProgram **)pSub->z;
    }
    for(i=0; i<nSub; i++){
      nRow += apSub[i]->nOp;
    }
  }

  do{
    i = p->pc++;
  }while( i<nRow && p->explain==2 && p->aOp[i].opcode!=138 );
  if( i>=nRow ){
    p->rc = 0;
    rc = 101;
  }else if( db->u1.isInterrupted ){
    p->rc = 9;
    rc = 1;
    sqlite3SetString(&p->zErrMsg, db, "%s", sqlite3ErrStr(p->rc));
  }else{
    char *z;
    Op *pOp;
    if( i<p->nOp ){


      pOp = &p->aOp[i];
    }else{


      int j;
      i -= p->nOp;
      for(j=0; i>=apSub[j]->nOp; j++){
        i -= apSub[j]->nOp;
      }
      pOp = &apSub[j]->aOp[i];
    }
    if( p->explain==1 ){
      pMem->flags = 0x0004;
      pMem->type = 1;
      pMem->u.i = i;
      pMem++;

      pMem->flags = 0x0800|0x0002|0x0200;
      pMem->z = (char*)sqlite3OpcodeName(pOp->opcode);
      ((void) (0));
      pMem->n = sqlite3Strlen30(pMem->z);
      pMem->type = 3;
      pMem->enc = 1;
      pMem++;






      if( pOp->p4type==(-18) ){
        int nByte = (nSub+1)*sizeof(SubProgram*);
        int j;
        for(j=0; j<nSub; j++){
          if( apSub[j]==pOp->p4.pProgram ) break;
        }
        if( j==nSub && 0==sqlite3VdbeMemGrow(pSub, nByte, 1) ){
          apSub = (SubProgram **)pSub->z;
          apSub[nSub++] = pOp->p4.pProgram;
          pSub->flags |= 0x0010;
          pSub->n = nSub*sizeof(SubProgram*);
        }
      }
    }

    pMem->flags = 0x0004;
    pMem->u.i = pOp->p1;
    pMem->type = 1;
    pMem++;

    pMem->flags = 0x0004;
    pMem->u.i = pOp->p2;
    pMem->type = 1;
    pMem++;

    pMem->flags = 0x0004;
    pMem->u.i = pOp->p3;
    pMem->type = 1;
    pMem++;

    if( sqlite3VdbeMemGrow(pMem, 32, 0) ){
      ((void) (0));
      return 1;
    }
    pMem->flags = 0x0400|0x0002|0x0200;
    z = displayP4(pOp, pMem->z, 32);
    if( z!=pMem->z ){
      sqlite3VdbeMemSetStr(pMem, z, -1, 1, 0);
    }else{
      ((void) (0));
      pMem->n = sqlite3Strlen30(pMem->z);
      pMem->enc = 1;
    }
    pMem->type = 3;
    pMem++;

    if( p->explain==1 ){
      if( sqlite3VdbeMemGrow(pMem, 4, 0) ){
        ((void) (0));
        return 1;
      }
      pMem->flags = 0x0400|0x0002|0x0200;
      pMem->n = 2;
      sqlite3_snprintf(3, pMem->z, "%.2x", pOp->p5);
      pMem->type = 3;
      pMem->enc = 1;
      pMem++;
# 58296 "ext/sqlite3/libsqlite/sqlite3.c"
      {
        pMem->flags = 0x0001;
        pMem->type = 5;
      }
    }

    p->nResColumn = 8 - 4*(p->explain-1);
    p->rc = 0;
    rc = 100;
  }
  return rc;
}
# 58378 "ext/sqlite3/libsqlite/sqlite3.c"
static void *allocSpace(
  void *pBuf,
  int nByte,
  u8 **ppFrom,
  u8 *pEnd,
  int *pnByte
){
  ((void) (0));
  if( pBuf ) return pBuf;
  nByte = (((nByte)+7)&~7);
  if( &(*ppFrom)[nByte] <= pEnd ){
    pBuf = (void*)*ppFrom;
    *ppFrom += nByte;
  }else{
    *pnByte += nByte;
  }
  return pBuf;
}
# 58414 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3VdbeMakeReady(
  Vdbe *p,
  int nVar,
  int nMem,
  int nCursor,
  int nArg,
  int isExplain,
  int usesStmtJournal
){
  int n;
  sqlite3 *db = p->db;

  ((void) (0));
  ((void) (0));



  ((void) (0));


  p->magic = 0xbdf20da3;
# 58445 "ext/sqlite3/libsqlite/sqlite3.c"
  nMem += nCursor;






  if( nVar>=0 && (db->mallocFailed==0) ){
    u8 *zCsr = (u8 *)&p->aOp[p->nOp];
    u8 *zEnd = (u8 *)&p->aOp[p->nOpAlloc];
    int nByte;

    resolveP2Values(p, &nArg);
    p->usesStmtJournal = (u8)usesStmtJournal;
    if( isExplain && nMem<10 ){
      nMem = 10;
    }
    memset(zCsr, 0, zEnd-zCsr);
    zCsr += (zCsr - (u8*)0)&7;
    ((void) (0));
# 58476 "ext/sqlite3/libsqlite/sqlite3.c"
    do {
      nByte = 0;
      p->aMem = allocSpace(p->aMem, nMem*sizeof(Mem), &zCsr, zEnd, &nByte);
      p->aVar = allocSpace(p->aVar, nVar*sizeof(Mem), &zCsr, zEnd, &nByte);
      p->apArg = allocSpace(p->apArg, nArg*sizeof(Mem*), &zCsr, zEnd, &nByte);
      p->azVar = allocSpace(p->azVar, nVar*sizeof(char*), &zCsr, zEnd, &nByte);
      p->apCsr = allocSpace(p->apCsr, nCursor*sizeof(VdbeCursor*),
                            &zCsr, zEnd, &nByte);
      if( nByte ){
        p->pFree = sqlite3DbMallocZero(db, nByte);
      }
      zCsr = p->pFree;
      zEnd = &zCsr[nByte];
    }while( nByte && !db->mallocFailed );

    p->nCursor = (u16)nCursor;
    if( p->aVar ){
      p->nVar = (ynVar)nVar;
      for(n=0; n<nVar; n++){
        p->aVar[n].flags = 0x0001;
        p->aVar[n].db = db;
      }
    }
    if( p->aMem ){
      p->aMem--;
      p->nMem = nMem;
      for(n=1; n<=nMem; n++){
        p->aMem[n].flags = 0x0001;
        p->aMem[n].db = db;
      }
    }
  }






  p->pc = -1;
  p->rc = 0;
  p->errorAction = 2;
  p->explain |= isExplain;
  p->magic = 0xbdf20da3;
  p->nChange = 0;
  p->cacheCtr = 1;
  p->minWriteFileFormat = 255;
  p->iStatement = 0;
  p->nFkConstraint = 0;
# 58533 "ext/sqlite3/libsqlite/sqlite3.c"
}





static void sqlite3VdbeFreeCursor(Vdbe *p, VdbeCursor *pCx){
  if( pCx==0 ){
    return;
  }
  if( pCx->pBt ){
    sqlite3BtreeClose(pCx->pBt);


  }else if( pCx->pCursor ){
    sqlite3BtreeCloseCursor(pCx->pCursor);
  }

  if( pCx->pVtabCursor ){
    sqlite3_vtab_cursor *pVtabCursor = pCx->pVtabCursor;
    const sqlite3_module *pModule = pCx->pModule;
    p->inVtabMethod = 1;
    pModule->xClose(pVtabCursor);
    p->inVtabMethod = 0;
  }

}






static int sqlite3VdbeFrameRestore(VdbeFrame *pFrame){
  Vdbe *v = pFrame->v;
  v->aOp = pFrame->aOp;
  v->nOp = pFrame->nOp;
  v->aMem = pFrame->aMem;
  v->nMem = pFrame->nMem;
  v->apCsr = pFrame->apCsr;
  v->nCursor = pFrame->nCursor;
  v->db->lastRowid = pFrame->lastRowid;
  v->nChange = pFrame->nChange;
  return pFrame->pc;
}
# 58587 "ext/sqlite3/libsqlite/sqlite3.c"
static void closeAllCursors(Vdbe *p){
  if( p->pFrame ){
    VdbeFrame *pFrame;
    for(pFrame=p->pFrame; pFrame->pParent; pFrame=pFrame->pParent);
    sqlite3VdbeFrameRestore(pFrame);
  }
  p->pFrame = 0;
  p->nFrame = 0;

  if( p->apCsr ){
    int i;
    for(i=0; i<p->nCursor; i++){
      VdbeCursor *pC = p->apCsr[i];
      if( pC ){
        sqlite3VdbeFreeCursor(p, pC);
        p->apCsr[i] = 0;
      }
    }
  }
  if( p->aMem ){
    releaseMemArray(&p->aMem[1], p->nMem);
  }
  while( p->pDelFrame ){
    VdbeFrame *pDel = p->pDelFrame;
    p->pDelFrame = pDel->pParent;
    sqlite3VdbeFrameDelete(pDel);
  }
}
# 58623 "ext/sqlite3/libsqlite/sqlite3.c"
static void Cleanup(Vdbe *p){
  sqlite3 *db = p->db;
# 58634 "ext/sqlite3/libsqlite/sqlite3.c"
  sqlite3DbFree(db, p->zErrMsg);
  p->zErrMsg = 0;
  p->pResultSet = 0;
}







static void sqlite3VdbeSetNumCols(Vdbe *p, int nResColumn){
  Mem *pColName;
  int n;
  sqlite3 *db = p->db;

  releaseMemArray(p->aColName, p->nResColumn*5);
  sqlite3DbFree(db, p->aColName);
  n = nResColumn*5;
  p->nResColumn = (u16)nResColumn;
  p->aColName = pColName = (Mem*)sqlite3DbMallocZero(db, sizeof(Mem)*n );
  if( p->aColName==0 ) return;
  while( n-- > 0 ){
    pColName->flags = 0x0001;
    pColName->db = p->db;
    pColName++;
  }
}
# 58673 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeSetColName(
  Vdbe *p,
  int idx,
  int var,
  const char *zName,
  void (*xDel)(void*)
){
  int rc;
  Mem *pColName;
  ((void) (0));
  ((void) (0));
  if( p->db->mallocFailed ){
    ((void) (0));
    return 7;
  }
  ((void) (0));
  pColName = &(p->aColName[idx+var*p->nResColumn]);
  rc = sqlite3VdbeMemSetStr(pColName, zName, -1, 1, xDel);
  ((void) (0));
  return rc;
}







static int vdbeCommit(sqlite3 *db, Vdbe *p){
  int i;
  int nTrans = 0;
  int rc = 0;
  int needXcommit = 0;
# 58720 "ext/sqlite3/libsqlite/sqlite3.c"
  rc = sqlite3VtabSync(db, &p->zErrMsg);







  for(i=0; rc==0 && i<db->nDb; i++){
    Btree *pBt = db->aDb[i].pBt;
    if( sqlite3BtreeIsInTrans(pBt) ){
      needXcommit = 1;
      if( i!=1 ) nTrans++;
      rc = sqlite3PagerExclusiveLock(sqlite3BtreePager(pBt));
    }
  }
  if( rc!=0 ){
    return rc;
  }


  if( needXcommit && db->xCommitCallback ){
    rc = db->xCommitCallback(db->pCommitArg);
    if( rc ){
      return 19;
    }
  }
# 58757 "ext/sqlite3/libsqlite/sqlite3.c"
  if( 0==sqlite3Strlen30(sqlite3BtreeGetFilename(db->aDb[0].pBt))
   || nTrans<=1
  ){
    for(i=0; rc==0 && i<db->nDb; i++){
      Btree *pBt = db->aDb[i].pBt;
      if( pBt ){
        rc = sqlite3BtreeCommitPhaseOne(pBt, 0);
      }
    }






    for(i=0; rc==0 && i<db->nDb; i++){
      Btree *pBt = db->aDb[i].pBt;
      if( pBt ){
        rc = sqlite3BtreeCommitPhaseTwo(pBt, 0);
      }
    }
    if( rc==0 ){
      sqlite3VtabCommit(db);
    }
  }






  else{
    sqlite3_vfs *pVfs = db->pVfs;
    int needSync = 0;
    char *zMaster = 0;
    char const *zMainFile = sqlite3BtreeGetFilename(db->aDb[0].pBt);
    sqlite3_file *pMaster = 0;
    i64 offset = 0;
    int res;


    do {
      u32 iRandom;
      sqlite3DbFree(db, zMaster);
      sqlite3_randomness(sizeof(iRandom), &iRandom);
      zMaster = sqlite3MPrintf(db, "%s-mj%08X", zMainFile, iRandom&0x7fffffff);
      if( !zMaster ){
        return 7;
      }
      rc = sqlite3OsAccess(pVfs, zMaster, 0, &res);
    }while( rc==0 && res );
    if( rc==0 ){

      rc = sqlite3OsOpenMalloc(pVfs, zMaster, &pMaster,
          0x00000002|0x00000004|
          0x00000010|0x00004000, 0
      );
    }
    if( rc!=0 ){
      sqlite3DbFree(db, zMaster);
      return rc;
    }







    for(i=0; i<db->nDb; i++){
      Btree *pBt = db->aDb[i].pBt;
      if( sqlite3BtreeIsInTrans(pBt) ){
        char const *zFile = sqlite3BtreeGetJournalname(pBt);
        if( zFile==0 ){
          continue;
        }
        ((void) (0));
        if( !needSync && !sqlite3BtreeSyncDisabled(pBt) ){
          needSync = 1;
        }
        rc = sqlite3OsWrite(pMaster, zFile, sqlite3Strlen30(zFile)+1, offset);
        offset += sqlite3Strlen30(zFile)+1;
        if( rc!=0 ){
          sqlite3OsCloseFree(pMaster);
          sqlite3OsDelete(pVfs, zMaster, 0);
          sqlite3DbFree(db, zMaster);
          return rc;
        }
      }
    }




    if( needSync
     && 0==(sqlite3OsDeviceCharacteristics(pMaster)&0x00000400)
     && 0!=(rc = sqlite3OsSync(pMaster, 0x00002))
    ){
      sqlite3OsCloseFree(pMaster);
      sqlite3OsDelete(pVfs, zMaster, 0);
      sqlite3DbFree(db, zMaster);
      return rc;
    }
# 58871 "ext/sqlite3/libsqlite/sqlite3.c"
    for(i=0; rc==0 && i<db->nDb; i++){
      Btree *pBt = db->aDb[i].pBt;
      if( pBt ){
        rc = sqlite3BtreeCommitPhaseOne(pBt, zMaster);
      }
    }
    sqlite3OsCloseFree(pMaster);
    ((void) (0));
    if( rc!=0 ){
      sqlite3DbFree(db, zMaster);
      return rc;
    }





    rc = sqlite3OsDelete(pVfs, zMaster, 1);
    sqlite3DbFree(db, zMaster);
    zMaster = 0;
    if( rc ){
      return rc;
    }
# 58902 "ext/sqlite3/libsqlite/sqlite3.c"
                                 ;
    sqlite3BeginBenignMalloc();
    for(i=0; i<db->nDb; i++){
      Btree *pBt = db->aDb[i].pBt;
      if( pBt ){
        sqlite3BtreeCommitPhaseTwo(pBt, 1);
      }
    }
    sqlite3EndBenignMalloc();
                                ;

    sqlite3VtabCommit(db);
  }


  return rc;
}
# 58965 "ext/sqlite3/libsqlite/sqlite3.c"
static void invalidateCursorsOnModifiedBtrees(sqlite3 *db){
  int i;
  for(i=0; i<db->nDb; i++){
    Btree *p = db->aDb[i].pBt;
    if( p && sqlite3BtreeIsInTrans(p) ){
      sqlite3BtreeTripAllCursors(p, 4);
    }
  }
}
# 58985 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeCloseStatement(Vdbe *p, int eOp){
  sqlite3 *const db = p->db;
  int rc = 0;






  if( db->nStatement && p->iStatement ){
    int i;
    const int iSavepoint = p->iStatement-1;

    ((void) (0));
    ((void) (0));
    ((void) (0));

    for(i=0; i<db->nDb; i++){
      int rc2 = 0;
      Btree *pBt = db->aDb[i].pBt;
      if( pBt ){
        if( eOp==2 ){
          rc2 = sqlite3BtreeSavepoint(pBt, 2, iSavepoint);
        }
        if( rc2==0 ){
          rc2 = sqlite3BtreeSavepoint(pBt, 1, iSavepoint);
        }
        if( rc==0 ){
          rc = rc2;
        }
      }
    }
    db->nStatement--;
    p->iStatement = 0;




    if( eOp==2 ){
      db->nDeferredCons = p->nStmtDefCons;
    }
  }
  return rc;
}
# 59041 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeCheckFk(Vdbe *p, int deferred){
  sqlite3 *db = p->db;
  if( (deferred && db->nDeferredCons>0) || (!deferred && p->nFkConstraint>0) ){
    p->rc = 19;
    p->errorAction = 2;
    sqlite3SetString(&p->zErrMsg, db, "foreign key constraint failed");
    return 1;
  }
  return 0;
}
# 59066 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeHalt(Vdbe *p){
  int rc;
  sqlite3 *db = p->db;
# 59086 "ext/sqlite3/libsqlite/sqlite3.c"
  if( p->db->mallocFailed ){
    p->rc = 7;
  }
  closeAllCursors(p);
  if( p->magic!=0xbdf20da3 ){
    return 0;
  }
                        ;


  if( p->pc>=0 ){
    int mrc;
    int eStatementOp = 0;
    int isSpecialError;


                       ;


    mrc = p->rc & 0xff;
    ((void) (0));
    isSpecialError = mrc==7 || mrc==10
                     || mrc==9 || mrc==13;
    if( isSpecialError ){
# 59122 "ext/sqlite3/libsqlite/sqlite3.c"
      if( !p->readOnly || mrc!=9 ){
        if( (mrc==7 || mrc==13) && p->usesStmtJournal ){
          eStatementOp = 2;
        }else{



          invalidateCursorsOnModifiedBtrees(db);
          sqlite3RollbackAll(db);
          sqlite3CloseSavepoints(db);
          db->autoCommit = 1;
        }
      }
    }


    if( p->rc==0 ){
      sqlite3VdbeCheckFk(p, 0);
    }







    if( !((db)->nVTrans>0 && (db)->aVTrans==0)
     && db->autoCommit
     && db->writeVdbeCnt==(p->readOnly==0)
    ){
      if( p->rc==0 || (p->errorAction==3 && !isSpecialError) ){
        rc = sqlite3VdbeCheckFk(p, 1);
        if( rc!=0 ){
          if( (p->readOnly) ){
                               ;
            return 1;
          }
          rc = 19;
        }else{




          rc = vdbeCommit(db, p);
        }
        if( rc==5 && p->readOnly ){
                             ;
          return 5;
        }else if( rc!=0 ){
          p->rc = rc;
          sqlite3RollbackAll(db);
        }else{
          db->nDeferredCons = 0;
          sqlite3CommitInternalChanges(db);
        }
      }else{
        sqlite3RollbackAll(db);
      }
      db->nStatement = 0;
    }else if( eStatementOp==0 ){
      if( p->rc==0 || p->errorAction==3 ){
        eStatementOp = 1;
      }else if( p->errorAction==2 ){
        eStatementOp = 2;
      }else{
        invalidateCursorsOnModifiedBtrees(db);
        sqlite3RollbackAll(db);
        sqlite3CloseSavepoints(db);
        db->autoCommit = 1;
      }
    }
# 59205 "ext/sqlite3/libsqlite/sqlite3.c"
    if( eStatementOp ){
      rc = sqlite3VdbeCloseStatement(p, eStatementOp);
      if( rc ){
        ((void) (0));
        if( (p->rc==0) || p->rc==19 ){
          p->rc = rc;
          sqlite3DbFree(db, p->zErrMsg);
          p->zErrMsg = 0;
        }
        invalidateCursorsOnModifiedBtrees(db);
        sqlite3RollbackAll(db);
        sqlite3CloseSavepoints(db);
        db->autoCommit = 1;
      }
    }




    if( p->changeCntOn ){
      if( eStatementOp!=2 ){
        sqlite3VdbeSetChanges(db, p->nChange);
      }else{
        sqlite3VdbeSetChanges(db, 0);
      }
      p->nChange = 0;
    }


    if( p->rc!=0 && db->flags&0x00000200 ){
      sqlite3ResetInternalSchema(db, -1);
      db->flags = (db->flags | 0x00000200);
    }


                       ;
  }


  if( p->pc>=0 ){
    db->activeVdbeCnt--;
    if( !p->readOnly ){
      db->writeVdbeCnt--;
    }
    ((void) (0));
  }
  p->magic = 0x519c2973;
                        ;
  if( p->db->mallocFailed ){
    p->rc = 7;
  }





  if( db->autoCommit ){
                                 ;
  }

  ((void) (0));
  return (p->rc==5 ? 5 : 0);
}






static void sqlite3VdbeResetStepResult(Vdbe *p){
  p->rc = 0;
}
# 59289 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeReset(Vdbe *p){
  sqlite3 *db;
  db = p->db;





  sqlite3VdbeHalt(p);






  if( p->pc>=0 ){
    if( p->zErrMsg ){
      sqlite3BeginBenignMalloc();
      sqlite3ValueSetStr(db->pErr,-1,p->zErrMsg,1,((sqlite3_destructor_type)-1));
      sqlite3EndBenignMalloc();
      db->errCode = p->rc;
      sqlite3DbFree(db, p->zErrMsg);
      p->zErrMsg = 0;
    }else if( p->rc ){
      sqlite3Error(db, p->rc, 0);
    }else{
      sqlite3Error(db, 0, 0);
    }
    if( p->runOnlyOnce ) p->expired = 1;
  }else if( p->rc && p->expired ){




    sqlite3Error(db, p->rc, 0);
    sqlite3ValueSetStr(db->pErr, -1, p->zErrMsg, 1, ((sqlite3_destructor_type)-1));
    sqlite3DbFree(db, p->zErrMsg);
    p->zErrMsg = 0;
  }



  Cleanup(p);
# 59357 "ext/sqlite3/libsqlite/sqlite3.c"
  p->magic = 0x26bceaa5;
  return p->rc & db->errMask;
}





static int sqlite3VdbeFinalize(Vdbe *p){
  int rc = 0;
  if( p->magic==0xbdf20da3 || p->magic==0x519c2973 ){
    rc = sqlite3VdbeReset(p);
    ((void) (0));
  }
  sqlite3VdbeDelete(p);
  return rc;
}







static void sqlite3VdbeDeleteAuxData(VdbeFunc *pVdbeFunc, int mask){
  int i;
  for(i=0; i<pVdbeFunc->nAux; i++){
    struct AuxData *pAux = &pVdbeFunc->apAux[i];
    if( (i>31 || !(mask&(((u32)1)<<i))) && pAux->pAux ){
      if( pAux->xDelete ){
        pAux->xDelete(pAux->pAux);
      }
      pAux->pAux = 0;
    }
  }
}







static void sqlite3VdbeDeleteObject(sqlite3 *db, Vdbe *p){
  SubProgram *pSub, *pNext;
  ((void) (0));
  releaseMemArray(p->aVar, p->nVar);
  releaseMemArray(p->aColName, p->nResColumn*5);
  for(pSub=p->pProgram; pSub; pSub=pNext){
    pNext = pSub->pNext;
    vdbeFreeOpArray(db, pSub->aOp, pSub->nOp);
    sqlite3DbFree(db, pSub);
  }
  vdbeFreeOpArray(db, p->aOp, p->nOp);
  sqlite3DbFree(db, p->aLabel);
  sqlite3DbFree(db, p->aColName);
  sqlite3DbFree(db, p->zSql);
  sqlite3DbFree(db, p->pFree);
  sqlite3DbFree(db, p);
}




static void sqlite3VdbeDelete(Vdbe *p){
  sqlite3 *db;

  if( (p==0) ) return;
  db = p->db;
  if( p->pPrev ){
    p->pPrev->pNext = p->pNext;
  }else{
    ((void) (0));
    db->pVdbe = p->pNext;
  }
  if( p->pNext ){
    p->pNext->pPrev = p->pPrev;
  }
  p->magic = 0xb606c3c8;
  p->db = 0;
  sqlite3VdbeDeleteObject(db, p);
}
# 59453 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeCursorMoveto(VdbeCursor *p){
  if( p->deferredMoveto ){
    int res, rc;



    ((void) (0));
    rc = sqlite3BtreeMovetoUnpacked(p->pCursor, 0, p->movetoTarget, 0, &res);
    if( rc ) return rc;
    p->lastRowid = p->movetoTarget;
    if( res!=0 ) return sqlite3CorruptError(59463);
    p->rowidIsValid = 1;



    p->deferredMoveto = 0;
    p->cacheStatus = 0;
  }else if( (p->pCursor) ){
    int hasMoved;
    int rc = sqlite3BtreeCursorHasMoved(p->pCursor, &hasMoved);
    if( rc ) return rc;
    if( hasMoved ){
      p->cacheStatus = 0;
      p->nullRow = 1;
    }
  }
  return 0;
}
# 59527 "ext/sqlite3/libsqlite/sqlite3.c"
static u32 sqlite3VdbeSerialType(Mem *pMem, int file_format){
  int flags = pMem->flags;
  int n;

  if( flags&0x0001 ){
    return 0;
  }
  if( flags&0x0004 ){


    i64 i = pMem->u.i;
    u64 u;
    if( file_format>=4 && (i&1)==i ){
      return 8+(u32)i;
    }
    if( i<0 ){
      if( i<(-((((i64)0x00008000)<<32)-1)) ) return 6;

      u = -i;
    }else{
      u = i;
    }
    if( u<=127 ) return 1;
    if( u<=32767 ) return 2;
    if( u<=8388607 ) return 3;
    if( u<=2147483647 ) return 4;
    if( u<=((((i64)0x00008000)<<32)-1) ) return 5;
    return 6;
  }
  if( flags&0x0008 ){
    return 7;
  }
  ((void) (0));
  n = pMem->n;
  if( flags & 0x4000 ){
    n += pMem->u.nZero;
  }
  ((void) (0));
  return ((n*2) + 12 + ((flags&0x0002)!=0));
}




static u32 sqlite3VdbeSerialTypeLen(u32 serial_type){
  if( serial_type>=12 ){
    return (serial_type-12)/2;
  }else{
    static const u8 aSize[] = { 0, 1, 2, 3, 4, 6, 8, 8, 0, 0, 0, 0 };
    return aSize[serial_type];
  }
}
# 59651 "ext/sqlite3/libsqlite/sqlite3.c"
static u32 sqlite3VdbeSerialPut(u8 *buf, int nBuf, Mem *pMem, int file_format){
  u32 serial_type = sqlite3VdbeSerialType(pMem, file_format);
  u32 len;


  if( serial_type<=7 && serial_type>0 ){
    u64 v;
    u32 i;
    if( serial_type==7 ){
      ((void) (0));
      memcpy(&v, &pMem->r, sizeof(v));
                             ;
    }else{
      v = pMem->u.i;
    }
    len = i = sqlite3VdbeSerialTypeLen(serial_type);
    ((void) (0));
    while( i-- ){
      buf[i] = (u8)(v&0xFF);
      v >>= 8;
    }
    return len;
  }


  if( serial_type>=12 ){
    ((void) (0));

    ((void) (0));
    len = pMem->n;
    memcpy(buf, pMem->z, len);
    if( pMem->flags & 0x4000 ){
      len += pMem->u.nZero;
      ((void) (0));
      if( len > (u32)nBuf ){
        len = (u32)nBuf;
      }
      memset(&buf[pMem->n], 0, len-pMem->n);
    }
    return len;
  }


  return 0;
}





static u32 sqlite3VdbeSerialGet(
  const unsigned char *buf,
  u32 serial_type,
  Mem *pMem
){
  switch( serial_type ){
    case 10:
    case 11:
    case 0: {
      pMem->flags = 0x0001;
      break;
    }
    case 1: {
      pMem->u.i = (signed char)buf[0];
      pMem->flags = 0x0004;
      return 1;
    }
    case 2: {
      pMem->u.i = (((signed char)buf[0])<<8) | buf[1];
      pMem->flags = 0x0004;
      return 2;
    }
    case 3: {
      pMem->u.i = (((signed char)buf[0])<<16) | (buf[1]<<8) | buf[2];
      pMem->flags = 0x0004;
      return 3;
    }
    case 4: {
      pMem->u.i = (buf[0]<<24) | (buf[1]<<16) | (buf[2]<<8) | buf[3];
      pMem->flags = 0x0004;
      return 4;
    }
    case 5: {
      u64 x = (((signed char)buf[0])<<8) | buf[1];
      u32 y = (buf[2]<<24) | (buf[3]<<16) | (buf[4]<<8) | buf[5];
      x = (x<<32) | y;
      pMem->u.i = *(i64*)&x;
      pMem->flags = 0x0004;
      return 6;
    }
    case 6:
    case 7: {
      u64 x;
      u32 y;
# 59758 "ext/sqlite3/libsqlite/sqlite3.c"
      x = (buf[0]<<24) | (buf[1]<<16) | (buf[2]<<8) | buf[3];
      y = (buf[4]<<24) | (buf[5]<<16) | (buf[6]<<8) | buf[7];
      x = (x<<32) | y;
      if( serial_type==6 ){
        pMem->u.i = *(i64*)&x;
        pMem->flags = 0x0004;
      }else{
        ((void) (0));
                               ;
        memcpy(&pMem->r, &x, sizeof(x));
        pMem->flags = sqlite3IsNaN(pMem->r) ? 0x0001 : 0x0008;
      }
      return 8;
    }
    case 8:
    case 9: {
      pMem->u.i = serial_type-8;
      pMem->flags = 0x0004;
      return 0;
    }
    default: {
      u32 len = (serial_type-12)/2;
      pMem->z = (char *)buf;
      pMem->n = len;
      pMem->xDel = 0;
      if( serial_type&0x01 ){
        pMem->flags = 0x0002 | 0x1000;
      }else{
        pMem->flags = 0x0010 | 0x1000;
      }
      return len;
    }
  }
  return 0;
}
# 59808 "ext/sqlite3/libsqlite/sqlite3.c"
static UnpackedRecord *sqlite3VdbeRecordUnpack(
  KeyInfo *pKeyInfo,
  int nKey,
  const void *pKey,
  char *pSpace,
  int szSpace
){
  const unsigned char *aKey = (const unsigned char *)pKey;
  UnpackedRecord *p;
  int nByte;
  int d;
  u32 idx;
  u16 u;
  u32 szHdr;
  Mem *pMem;
  int nOff;






  nOff = (8 - (((int)(long int)(pSpace)) & 7)) & 7;
  pSpace += nOff;
  szSpace -= nOff;
  nByte = (((sizeof(UnpackedRecord))+7)&~7) + sizeof(Mem)*(pKeyInfo->nField+1);
  if( nByte>szSpace ){
    p = sqlite3DbMallocRaw(pKeyInfo->db, nByte);
    if( p==0 ) return 0;
    p->flags = 0x0001 | 0x0002;
  }else{
    p = (UnpackedRecord*)pSpace;
    p->flags = 0x0002;
  }
  p->pKeyInfo = pKeyInfo;
  p->nField = pKeyInfo->nField + 1;
  p->aMem = pMem = (Mem*)&((char*)p)[(((sizeof(UnpackedRecord))+7)&~7)];
  ((void) (0));
  idx = (u8)((*(aKey)<(u8)0x80) ? ((szHdr) = (u32)*(aKey)),1 : sqlite3GetVarint32((aKey), (u32 *)&(szHdr)));
  d = szHdr;
  u = 0;
  while( idx<szHdr && u<p->nField && d<=nKey ){
    u32 serial_type;

    idx += (u8)((*(&aKey[idx])<(u8)0x80) ? ((serial_type) = (u32)*(&aKey[idx])),1 : sqlite3GetVarint32((&aKey[idx]), (u32 *)&(serial_type)));
    pMem->enc = pKeyInfo->enc;
    pMem->db = pKeyInfo->db;
    pMem->flags = 0;
    pMem->zMalloc = 0;
    d += sqlite3VdbeSerialGet(&aKey[d], serial_type, pMem);
    pMem++;
    u++;
  }
  ((void) (0));
  p->nField = u;
  return (void*)p;
}




static void sqlite3VdbeDeleteUnpackedRecord(UnpackedRecord *p){
  int i;
  Mem *pMem;

  ((void) (0));
  ((void) (0));
  for(i=0, pMem=p->aMem; i<p->nField; i++, pMem++){





    if( (pMem->zMalloc) ) sqlite3VdbeMemRelease(pMem);
  }
  if( p->flags & 0x0001 ){
    sqlite3DbFree(p->pKeyInfo->db, p);
  }
}
# 59914 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeRecordCompare(
  int nKey1, const void *pKey1,
  UnpackedRecord *pPKey2
){
  int d1;
  u32 idx1;
  u32 szHdr1;
  int i = 0;
  int nField;
  int rc = 0;
  const unsigned char *aKey1 = (const unsigned char *)pKey1;
  KeyInfo *pKeyInfo;
  Mem mem1;

  pKeyInfo = pPKey2->pKeyInfo;
  mem1.enc = pKeyInfo->enc;
  mem1.db = pKeyInfo->db;
# 59943 "ext/sqlite3/libsqlite/sqlite3.c"
  idx1 = (u8)((*(aKey1)<(u8)0x80) ? ((szHdr1) = (u32)*(aKey1)),1 : sqlite3GetVarint32((aKey1), (u32 *)&(szHdr1)));
  d1 = szHdr1;
  if( pPKey2->flags & 0x0004 ){
    szHdr1--;
  }
  nField = pKeyInfo->nField;
  while( idx1<szHdr1 && i<pPKey2->nField ){
    u32 serial_type1;


    idx1 += (u8)((*(aKey1+idx1)<(u8)0x80) ? ((serial_type1) = (u32)*(aKey1+idx1)),1 : sqlite3GetVarint32((aKey1+idx1), (u32 *)&(serial_type1)));
    if( d1>=nKey1 && sqlite3VdbeSerialTypeLen(serial_type1)>0 ) break;



    d1 += sqlite3VdbeSerialGet(&aKey1[d1], serial_type1, &mem1);



    rc = sqlite3MemCompare(&mem1, &pPKey2->aMem[i],
                           i<nField ? pKeyInfo->aColl[i] : 0);
    if( rc!=0 ){
      ((void) (0));


      if( pKeyInfo->aSortOrder && i<nField && pKeyInfo->aSortOrder[i] ){
        rc = -rc;
      }






      if( (pPKey2->flags & 0x0020) && i==(pPKey2->nField-1) ){
        ((void) (0));
        ((void) (0));
        pPKey2->flags &= ~0x0020;
        pPKey2->rowid = mem1.u.i;
      }

      return rc;
    }
    i++;
  }





  ((void) (0));
# 60003 "ext/sqlite3/libsqlite/sqlite3.c"
  ((void) (0));
  if( pPKey2->flags & 0x0008 ){
    rc = -1;
  }else if( pPKey2->flags & 0x0010 ){

  }else if( idx1<szHdr1 ){
    rc = 1;
  }
  return rc;
}
# 60023 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeIdxRowid(sqlite3 *db, BtCursor *pCur, i64 *rowid){
  i64 nCellKey = 0;
  int rc;
  u32 szHdr;
  u32 typeRowid;
  u32 lenRowid;
  Mem m, v;

  (void)(db);






  ((void) (0));
  rc = sqlite3BtreeKeySize(pCur, &nCellKey);
  ((void) (0));
  ((void) (0));


  memset(&m, 0, sizeof(m));
  rc = sqlite3VdbeMemFromBtree(pCur, 0, (int)nCellKey, 1, &m);
  if( rc ){
    return rc;
  }


  (void)(u8)((*((u8*)m.z)<(u8)0x80) ? ((szHdr) = (u32)*((u8*)m.z)),1 : sqlite3GetVarint32(((u8*)m.z), (u32 *)&(szHdr)));
                      ;
                        ;
  if( !!(szHdr<3 || (int)szHdr>m.n) ){
    goto idx_rowid_corruption;
  }



  (void)(u8)((*((u8*)&m.z[szHdr-1])<(u8)0x80) ? ((typeRowid) = (u32)*((u8*)&m.z[szHdr-1])),1 : sqlite3GetVarint32(((u8*)&m.z[szHdr-1]), (u32 *)&(typeRowid)));
                          ;
                          ;
                          ;
                          ;
                          ;
                          ;
                          ;
                          ;
  if( !!(typeRowid<1 || typeRowid>9 || typeRowid==7) ){
    goto idx_rowid_corruption;
  }
  lenRowid = sqlite3VdbeSerialTypeLen(typeRowid);
                                      ;
  if( !!((u32)m.n<szHdr+lenRowid) ){
    goto idx_rowid_corruption;
  }


  sqlite3VdbeSerialGet((u8*)&m.z[m.n-lenRowid], typeRowid, &v);
  *rowid = v.u.i;
  sqlite3VdbeMemRelease(&m);
  return 0;



idx_rowid_corruption:
                          ;
  sqlite3VdbeMemRelease(&m);
  return sqlite3CorruptError(60089);
}
# 60103 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeIdxKeyCompare(
  VdbeCursor *pC,
  UnpackedRecord *pUnpacked,
  int *res
){
  i64 nCellKey = 0;
  int rc;
  BtCursor *pCur = pC->pCursor;
  Mem m;

  ((void) (0));
  rc = sqlite3BtreeKeySize(pCur, &nCellKey);
  ((void) (0));


  if( nCellKey<=0 || nCellKey>0x7fffffff ){
    *res = 0;
    return sqlite3CorruptError(60120);
  }
  memset(&m, 0, sizeof(m));
  rc = sqlite3VdbeMemFromBtree(pC->pCursor, 0, (int)nCellKey, 1, &m);
  if( rc ){
    return rc;
  }
  ((void) (0));
  *res = sqlite3VdbeRecordCompare(m.n, m.z, pUnpacked);
  sqlite3VdbeMemRelease(&m);
  return 0;
}





static void sqlite3VdbeSetChanges(sqlite3 *db, int nChange){
  ((void) (0));
  db->nChange = nChange;
  db->nTotalChange += nChange;
}





static void sqlite3VdbeCountChanges(Vdbe *v){
  v->changeCntOn = 1;
}
# 60161 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3ExpirePreparedStatements(sqlite3 *db){
  Vdbe *p;
  for(p = db->pVdbe; p; p=p->pNext){
    p->expired = 1;
  }
}




static sqlite3 *sqlite3VdbeDb(Vdbe *v){
  return v->db;
}
# 60183 "ext/sqlite3/libsqlite/sqlite3.c"
static sqlite3_value *sqlite3VdbeGetValue(Vdbe *v, int iVar, u8 aff){
  ((void) (0));
  if( v ){
    Mem *pMem = &v->aVar[iVar-1];
    if( 0==(pMem->flags & 0x0001) ){
      sqlite3_value *pRet = sqlite3ValueNew(v->db);
      if( pRet ){
        sqlite3VdbeMemCopy((Mem *)pRet, pMem);
        sqlite3ValueApplyAffinity(pRet, aff, 1);
        sqlite3VdbeMemStoreType((Mem *)pRet);
      }
      return pRet;
    }
  }
  return 0;
}






static void sqlite3VdbeSetVarmask(Vdbe *v, int iVar){
  ((void) (0));
  if( iVar>32 ){
    v->expmask = 0xffffffff;
  }else{
    v->expmask |= ((u32)1 << (iVar-1));
  }
}
# 60241 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_expired(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe*)pStmt;
  return p==0 || p->expired;
}







static int vdbeSafety(Vdbe *p){
  if( p->db==0 ){
    sqlite3_log(21, "API called with finalized prepared statement");
    return 1;
  }else{
    return 0;
  }
}
static int vdbeSafetyNotNull(Vdbe *p){
  if( p==0 ){
    sqlite3_log(21, "API called with NULL prepared statement");
    return 1;
  }else{
    return vdbeSafety(p);
  }
}
# 60278 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_finalize(sqlite3_stmt *pStmt){
  int rc;
  if( pStmt==0 ){


    rc = 0;
  }else{
    Vdbe *v = (Vdbe*)pStmt;
    sqlite3 *db = v->db;



    if( vdbeSafety(v) ) return sqlite3MisuseError(60290);



                              ;
    rc = sqlite3VdbeFinalize(v);
    rc = sqlite3ApiExit(db, rc);
                              ;
  }
  return rc;
}
# 60310 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_reset(sqlite3_stmt *pStmt){
  int rc;
  if( pStmt==0 ){
    rc = 0;
  }else{
    Vdbe *v = (Vdbe*)pStmt;
                                     ;
    rc = sqlite3VdbeReset(v);
    sqlite3VdbeMakeReady(v, -1, 0, 0, 0, 0, 0);
    ((void) (0));
    rc = sqlite3ApiExit(v->db, rc);
                                     ;
  }
  return rc;
}




           int sqlite3_clear_bindings(sqlite3_stmt *pStmt){
  int i;
  int rc = 0;
  Vdbe *p = (Vdbe*)pStmt;



                            ;
  for(i=0; i<p->nVar; i++){
    sqlite3VdbeMemRelease(&p->aVar[i]);
    p->aVar[i].flags = 0x0001;
  }
  if( p->isPrepareV2 && p->expmask ){
    p->expired = 1;
  }
                            ;
  return rc;
}






           const void *sqlite3_value_blob(sqlite3_value *pVal){
  Mem *p = (Mem*)pVal;
  if( p->flags & (0x0010|0x0002) ){
    sqlite3VdbeMemExpandBlob(p);
    p->flags &= ~0x0002;
    p->flags |= 0x0010;
    return p->n ? p->z : 0;
  }else{
    return sqlite3_value_text(pVal);
  }
}
           int sqlite3_value_bytes(sqlite3_value *pVal){
  return sqlite3ValueBytes(pVal, 1);
}
           int sqlite3_value_bytes16(sqlite3_value *pVal){
  return sqlite3ValueBytes(pVal, 2);
}
           double sqlite3_value_double(sqlite3_value *pVal){
  return sqlite3VdbeRealValue((Mem*)pVal);
}
           int sqlite3_value_int(sqlite3_value *pVal){
  return (int)sqlite3VdbeIntValue((Mem*)pVal);
}
           sqlite_int64 sqlite3_value_int64(sqlite3_value *pVal){
  return sqlite3VdbeIntValue((Mem*)pVal);
}
           const unsigned char *sqlite3_value_text(sqlite3_value *pVal){
  return (const unsigned char *)sqlite3ValueText(pVal, 1);
}

           const void *sqlite3_value_text16(sqlite3_value* pVal){
  return sqlite3ValueText(pVal, 2);
}
           const void *sqlite3_value_text16be(sqlite3_value *pVal){
  return sqlite3ValueText(pVal, 3);
}
           const void *sqlite3_value_text16le(sqlite3_value *pVal){
  return sqlite3ValueText(pVal, 2);
}

           int sqlite3_value_type(sqlite3_value* pVal){
  return pVal->type;
}
# 60405 "ext/sqlite3/libsqlite/sqlite3.c"
static void setResultStrOrError(
  sqlite3_context *pCtx,
  const char *z,
  int n,
  u8 enc,
  void (*xDel)(void*)
){
  if( sqlite3VdbeMemSetStr(&pCtx->s, z, n, enc, xDel)==18 ){
    sqlite3_result_error_toobig(pCtx);
  }
}
           void sqlite3_result_blob(
  sqlite3_context *pCtx,
  const void *z,
  int n,
  void (*xDel)(void *)
){
  ((void) (0));
  ((void) (0));
  setResultStrOrError(pCtx, z, n, 0, xDel);
}
           void sqlite3_result_double(sqlite3_context *pCtx, double rVal){
  ((void) (0));
  sqlite3VdbeMemSetDouble(&pCtx->s, rVal);
}
           void sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n){
  ((void) (0));
  pCtx->isError = 1;
  sqlite3VdbeMemSetStr(&pCtx->s, z, n, 1, ((sqlite3_destructor_type)-1));
}

           void sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n){
  ((void) (0));
  pCtx->isError = 1;
  sqlite3VdbeMemSetStr(&pCtx->s, z, n, 2, ((sqlite3_destructor_type)-1));
}

           void sqlite3_result_int(sqlite3_context *pCtx, int iVal){
  ((void) (0));
  sqlite3VdbeMemSetInt64(&pCtx->s, (i64)iVal);
}
           void sqlite3_result_int64(sqlite3_context *pCtx, i64 iVal){
  ((void) (0));
  sqlite3VdbeMemSetInt64(&pCtx->s, iVal);
}
           void sqlite3_result_null(sqlite3_context *pCtx){
  ((void) (0));
  sqlite3VdbeMemSetNull(&pCtx->s);
}
           void sqlite3_result_text(
  sqlite3_context *pCtx,
  const char *z,
  int n,
  void (*xDel)(void *)
){
  ((void) (0));
  setResultStrOrError(pCtx, z, n, 1, xDel);
}

           void sqlite3_result_text16(
  sqlite3_context *pCtx,
  const void *z,
  int n,
  void (*xDel)(void *)
){
  ((void) (0));
  setResultStrOrError(pCtx, z, n, 2, xDel);
}
           void sqlite3_result_text16be(
  sqlite3_context *pCtx,
  const void *z,
  int n,
  void (*xDel)(void *)
){
  ((void) (0));
  setResultStrOrError(pCtx, z, n, 3, xDel);
}
           void sqlite3_result_text16le(
  sqlite3_context *pCtx,
  const void *z,
  int n,
  void (*xDel)(void *)
){
  ((void) (0));
  setResultStrOrError(pCtx, z, n, 2, xDel);
}

           void sqlite3_result_value(sqlite3_context *pCtx, sqlite3_value *pValue){
  ((void) (0));
  sqlite3VdbeMemCopy(&pCtx->s, pValue);
}
           void sqlite3_result_zeroblob(sqlite3_context *pCtx, int n){
  ((void) (0));
  sqlite3VdbeMemSetZeroBlob(&pCtx->s, n);
}
           void sqlite3_result_error_code(sqlite3_context *pCtx, int errCode){
  pCtx->isError = errCode;
  if( pCtx->s.flags & 0x0001 ){
    sqlite3VdbeMemSetStr(&pCtx->s, sqlite3ErrStr(errCode), -1,
                         1, ((sqlite3_destructor_type)0));
  }
}


           void sqlite3_result_error_toobig(sqlite3_context *pCtx){
  ((void) (0));
  pCtx->isError = 18;
  sqlite3VdbeMemSetStr(&pCtx->s, "string or blob too big", -1,
                       1, ((sqlite3_destructor_type)0));
}


           void sqlite3_result_error_nomem(sqlite3_context *pCtx){
  ((void) (0));
  sqlite3VdbeMemSetNull(&pCtx->s);
  pCtx->isError = 7;
  pCtx->s.db->mallocFailed = 1;
}





static int doWalCallbacks(sqlite3 *db){
  int rc = 0;

  int i;
  for(i=0; i<db->nDb; i++){
    Btree *pBt = db->aDb[i].pBt;
    if( pBt ){
      int nEntry = sqlite3PagerWalCallback(sqlite3BtreePager(pBt));
      if( db->xWalCallback && nEntry>0 && rc==0 ){
        rc = db->xWalCallback(db->pWalArg, db, db->aDb[i].zName, nEntry);
      }
    }
  }

  return rc;
}
# 60554 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Step(Vdbe *p){
  sqlite3 *db;
  int rc;

  ((void) (0));
  if( p->magic!=0xbdf20da3 ){
# 60583 "ext/sqlite3/libsqlite/sqlite3.c"
    sqlite3_reset((sqlite3_stmt*)p);

  }


  db = p->db;
  if( db->mallocFailed ){
    p->rc = 7;
    return 7;
  }

  if( p->pc<=0 && p->expired ){
    p->rc = 17;
    rc = 1;
    goto end_of_step;
  }
  if( p->pc<0 ){




    if( db->activeVdbeCnt==0 ){
      db->u1.isInterrupted = 0;
    }

    ((void) (0));


    if( db->xProfile && !db->init.busy ){
      sqlite3OsCurrentTimeInt64(db->pVfs, &p->startTime);
    }


    db->activeVdbeCnt++;
    if( p->readOnly==0 ) db->writeVdbeCnt++;
    p->pc = 0;
  }

  if( p->explain ){
    rc = sqlite3VdbeList(p);
  }else

  {
    db->vdbeExecCnt++;
    rc = sqlite3VdbeExec(p);
    db->vdbeExecCnt--;
  }




  if( rc!=100 && db->xProfile && !db->init.busy && p->zSql ){
    sqlite3_int64 iNow;
    sqlite3OsCurrentTimeInt64(db->pVfs, &iNow);
    db->xProfile(db->pProfileArg, p->zSql, (iNow - p->startTime)*1000000);
  }


  if( rc==101 ){
    ((void) (0));
    p->rc = doWalCallbacks(db);
    if( p->rc!=0 ){
      rc = 1;
    }
  }

  db->errCode = rc;
  if( 7==sqlite3ApiExit(p->db, p->rc) ){
    p->rc = 7;
  }
end_of_step:







  ((void) (0));


  ((void) (0));
  if( p->isPrepareV2 && rc!=100 && rc!=101 ){




    rc = db->errCode = p->rc;
  }
  return (rc&db->errMask);
}






           int sqlite3_step(sqlite3_stmt *pStmt){
  int rc = 0;
  int rc2 = 0;
  Vdbe *v = (Vdbe*)pStmt;
  int cnt = 0;
  sqlite3 *db;

  if( vdbeSafetyNotNull(v) ){
    return sqlite3MisuseError(60688);
  }
  db = v->db;
                                ;
  while( (rc = sqlite3Step(v))==17
         && cnt++ < 5
         && (rc2 = rc = sqlite3Reprepare(v))==0 ){
    sqlite3_reset(pStmt);
    v->expired = 0;
  }
  if( rc2!=0 && (v->isPrepareV2) && (db->pErr) ){
# 60707 "ext/sqlite3/libsqlite/sqlite3.c"
    const char *zErr = (const char *)sqlite3_value_text(db->pErr);
    sqlite3DbFree(db, v->zErrMsg);
    if( !db->mallocFailed ){
      v->zErrMsg = sqlite3DbStrDup(db, zErr);
      v->rc = rc2;
    } else {
      v->zErrMsg = 0;
      v->rc = rc = 7;
    }
  }
  rc = sqlite3ApiExit(db, rc);
                                ;
  return rc;
}





           void *sqlite3_user_data(sqlite3_context *p){
  ((void) (0));
  return p->pFunc->pUserData;
}
# 60741 "ext/sqlite3/libsqlite/sqlite3.c"
           sqlite3 *sqlite3_context_db_handle(sqlite3_context *p){
  ((void) (0));
  return p->s.db;
}
# 60754 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3InvalidFunction(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  const char *zName = context->pFunc->zName;
  char *zErr;
  (void)(NotUsed),(void)(NotUsed2);
  zErr = sqlite3_mprintf(
      "unable to use function %s in the requested context", zName);
  sqlite3_result_error(context, zErr, -1);
  sqlite3_free(zErr);
}






           void *sqlite3_aggregate_context(sqlite3_context *p, int nByte){
  Mem *pMem;
  ((void) (0));
  ((void) (0));
  pMem = p->pMem;
                     ;
  if( (pMem->flags & 0x2000)==0 ){
    if( nByte<=0 ){
      sqlite3VdbeMemReleaseExternal(pMem);
      pMem->flags = 0x0001;
      pMem->z = 0;
    }else{
      sqlite3VdbeMemGrow(pMem, nByte, 0);
      pMem->flags = 0x2000;
      pMem->u.pDef = p->pFunc;
      if( pMem->z ){
        memset(pMem->z, 0, nByte);
      }
    }
  }
  return (void*)pMem->z;
}





           void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){
  VdbeFunc *pVdbeFunc;

  ((void) (0));
  pVdbeFunc = pCtx->pVdbeFunc;
  if( !pVdbeFunc || iArg>=pVdbeFunc->nAux || iArg<0 ){
    return 0;
  }
  return pVdbeFunc->apAux[iArg].pAux;
}






           void sqlite3_set_auxdata(
  sqlite3_context *pCtx,
  int iArg,
  void *pAux,
  void (*xDelete)(void*)
){
  struct AuxData *pAuxData;
  VdbeFunc *pVdbeFunc;
  if( iArg<0 ) goto failed;

  ((void) (0));
  pVdbeFunc = pCtx->pVdbeFunc;
  if( !pVdbeFunc || pVdbeFunc->nAux<=iArg ){
    int nAux = (pVdbeFunc ? pVdbeFunc->nAux : 0);
    int nMalloc = sizeof(VdbeFunc) + sizeof(struct AuxData)*iArg;
    pVdbeFunc = sqlite3DbRealloc(pCtx->s.db, pVdbeFunc, nMalloc);
    if( !pVdbeFunc ){
      goto failed;
    }
    pCtx->pVdbeFunc = pVdbeFunc;
    memset(&pVdbeFunc->apAux[nAux], 0, sizeof(struct AuxData)*(iArg+1-nAux));
    pVdbeFunc->nAux = iArg+1;
    pVdbeFunc->pFunc = pCtx->pFunc;
  }

  pAuxData = &pVdbeFunc->apAux[iArg];
  if( pAuxData->pAux && pAuxData->xDelete ){
    pAuxData->xDelete(pAuxData->pAux);
  }
  pAuxData->pAux = pAux;
  pAuxData->xDelete = xDelete;
  return;

failed:
  if( xDelete ){
    xDelete(pAux);
  }
}
# 60865 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_aggregate_count(sqlite3_context *p){
  ((void) (0));
  return p->pMem->n;
}





           int sqlite3_column_count(sqlite3_stmt *pStmt){
  Vdbe *pVm = (Vdbe *)pStmt;
  return pVm ? pVm->nResColumn : 0;
}





           int sqlite3_data_count(sqlite3_stmt *pStmt){
  Vdbe *pVm = (Vdbe *)pStmt;
  if( pVm==0 || pVm->pResultSet==0 ) return 0;
  return pVm->nResColumn;
}
# 60896 "ext/sqlite3/libsqlite/sqlite3.c"
static Mem *columnMem(sqlite3_stmt *pStmt, int i){
  Vdbe *pVm;
  Mem *pOut;

  pVm = (Vdbe *)pStmt;
  if( pVm && pVm->pResultSet!=0 && i<pVm->nResColumn && i>=0 ){
                                       ;
    pOut = &pVm->pResultSet[i];
  }else{
# 60916 "ext/sqlite3/libsqlite/sqlite3.c"
    static const Mem nullMem



      = {0, "", (double)0, {0}, 0, 0x0001, 5, 0,



         0, 0 };

    if( pVm && (pVm->db) ){
                                         ;
      sqlite3Error(pVm->db, 25, 0);
    }
    pOut = (Mem*)&nullMem;
  }
  return pOut;
}
# 60953 "ext/sqlite3/libsqlite/sqlite3.c"
static void columnMallocFailure(sqlite3_stmt *pStmt)
{





  Vdbe *p = (Vdbe *)pStmt;
  if( p ){
    p->rc = sqlite3ApiExit(p->db, p->rc);
                                     ;
  }
}





           const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){
  const void *val;
  val = sqlite3_value_blob( columnMem(pStmt,i) );




  columnMallocFailure(pStmt);
  return val;
}
           int sqlite3_column_bytes(sqlite3_stmt *pStmt, int i){
  int val = sqlite3_value_bytes( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}
           int sqlite3_column_bytes16(sqlite3_stmt *pStmt, int i){
  int val = sqlite3_value_bytes16( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}
           double sqlite3_column_double(sqlite3_stmt *pStmt, int i){
  double val = sqlite3_value_double( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}
           int sqlite3_column_int(sqlite3_stmt *pStmt, int i){
  int val = sqlite3_value_int( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}
           sqlite_int64 sqlite3_column_int64(sqlite3_stmt *pStmt, int i){
  sqlite_int64 val = sqlite3_value_int64( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}
           const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int i){
  const unsigned char *val = sqlite3_value_text( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}
           sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt, int i){
  Mem *pOut = columnMem(pStmt, i);
  if( pOut->flags&0x0800 ){
    pOut->flags &= ~0x0800;
    pOut->flags |= 0x1000;
  }
  columnMallocFailure(pStmt);
  return (sqlite3_value *)pOut;
}

           const void *sqlite3_column_text16(sqlite3_stmt *pStmt, int i){
  const void *val = sqlite3_value_text16( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}

           int sqlite3_column_type(sqlite3_stmt *pStmt, int i){
  int iType = sqlite3_value_type( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return iType;
}
# 61056 "ext/sqlite3/libsqlite/sqlite3.c"
static const void *columnName(
  sqlite3_stmt *pStmt,
  int N,
  const void *(*xFunc)(Mem*),
  int useType
){
  const void *ret = 0;
  Vdbe *p = (Vdbe *)pStmt;
  int n;
  sqlite3 *db = p->db;

  ((void) (0));
  n = sqlite3_column_count(pStmt);
  if( N<n && N>=0 ){
    N += useType*n;
                                  ;
    ((void) (0));
    ret = xFunc(&p->aColName[N]);



    if( db->mallocFailed ){
      db->mallocFailed = 0;
      ret = 0;
    }
                                  ;
  }
  return ret;
}





           const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N){
  return columnName(
      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, 0);
}

           const void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N){
  return columnName(
      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, 0);
}
# 61115 "ext/sqlite3/libsqlite/sqlite3.c"
           const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N){
  return columnName(
      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, 1);
}

           const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){
  return columnName(
      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, 1);
}
# 61133 "ext/sqlite3/libsqlite/sqlite3.c"
           const char *sqlite3_column_database_name(sqlite3_stmt *pStmt, int N){
  return columnName(
      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, 2);
}

           const void *sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N){
  return columnName(
      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, 2);
}







           const char *sqlite3_column_table_name(sqlite3_stmt *pStmt, int N){
  return columnName(
      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, 3);
}

           const void *sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N){
  return columnName(
      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, 3);
}







           const char *sqlite3_column_origin_name(sqlite3_stmt *pStmt, int N){
  return columnName(
      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, 4);
}

           const void *sqlite3_column_origin_name16(sqlite3_stmt *pStmt, int N){
  return columnName(
      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, 4);
}
# 61193 "ext/sqlite3/libsqlite/sqlite3.c"
static int vdbeUnbind(Vdbe *p, int i){
  Mem *pVar;
  if( vdbeSafetyNotNull(p) ){
    return sqlite3MisuseError(61196);
  }
                                   ;
  if( p->magic!=0xbdf20da3 || p->pc>=0 ){
    sqlite3Error(p->db, 21, 0);
                                     ;
    sqlite3_log(21,
        "bind on a busy prepared statement: [%s]", p->zSql);
    return sqlite3MisuseError(61204);
  }
  if( i<1 || i>p->nVar ){
    sqlite3Error(p->db, 25, 0);
                                     ;
    return 25;
  }
  i--;
  pVar = &p->aVar[i];
  sqlite3VdbeMemRelease(pVar);
  pVar->flags = 0x0001;
  sqlite3Error(p->db, 0, 0);
# 61226 "ext/sqlite3/libsqlite/sqlite3.c"
  if( p->isPrepareV2 &&
     ((i<32 && p->expmask & ((u32)1 << i)) || p->expmask==0xffffffff)
  ){
    p->expired = 1;
  }
  return 0;
}




static int bindText(
  sqlite3_stmt *pStmt,
  int i,
  const void *zData,
  int nData,
  void (*xDel)(void*),
  u8 encoding
){
  Vdbe *p = (Vdbe *)pStmt;
  Mem *pVar;
  int rc;

  rc = vdbeUnbind(p, i);
  if( rc==0 ){
    if( zData!=0 ){
      pVar = &p->aVar[i-1];
      rc = sqlite3VdbeMemSetStr(pVar, zData, nData, encoding, xDel);
      if( rc==0 && encoding!=0 ){
        rc = sqlite3VdbeChangeEncoding(pVar, ((p->db)->aDb[0].pSchema->enc));
      }
      sqlite3Error(p->db, rc, 0);
      rc = sqlite3ApiExit(p->db, rc);
    }
                                     ;
  }else if( xDel!=((sqlite3_destructor_type)0) && xDel!=((sqlite3_destructor_type)-1) ){
    xDel((void*)zData);
  }
  return rc;
}





           int sqlite3_bind_blob(
  sqlite3_stmt *pStmt,
  int i,
  const void *zData,
  int nData,
  void (*xDel)(void*)
){
  return bindText(pStmt, i, zData, nData, xDel, 0);
}
           int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  if( rc==0 ){
    sqlite3VdbeMemSetDouble(&p->aVar[i-1], rValue);
                                     ;
  }
  return rc;
}
           int sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue){
  return sqlite3_bind_int64(p, i, (i64)iValue);
}
           int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  if( rc==0 ){
    sqlite3VdbeMemSetInt64(&p->aVar[i-1], iValue);
                                     ;
  }
  return rc;
}
           int sqlite3_bind_null(sqlite3_stmt *pStmt, int i){
  int rc;
  Vdbe *p = (Vdbe*)pStmt;
  rc = vdbeUnbind(p, i);
  if( rc==0 ){
                                     ;
  }
  return rc;
}
           int sqlite3_bind_text(
  sqlite3_stmt *pStmt,
  int i,
  const char *zData,
  int nData,
  void (*xDel)(void*)
){
  return bindText(pStmt, i, zData, nData, xDel, 1);
}

           int sqlite3_bind_text16(
  sqlite3_stmt *pStmt,
  int i,
  const void *zData,
  int nData,
  void (*xDel)(void*)
){
  return bindText(pStmt, i, zData, nData, xDel, 2);
}

           int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue){
  int rc;
  switch( pValue->type ){
    case 1: {
      rc = sqlite3_bind_int64(pStmt, i, pValue->u.i);
      break;
    }
    case 2: {
      rc = sqlite3_bind_double(pStmt, i, pValue->r);
      break;
    }
    case 4: {
      if( pValue->flags & 0x4000 ){
        rc = sqlite3_bind_zeroblob(pStmt, i, pValue->u.nZero);
      }else{
        rc = sqlite3_bind_blob(pStmt, i, pValue->z, pValue->n,((sqlite3_destructor_type)-1));
      }
      break;
    }
    case 3: {
      rc = bindText(pStmt,i, pValue->z, pValue->n, ((sqlite3_destructor_type)-1),
                              pValue->enc);
      break;
    }
    default: {
      rc = sqlite3_bind_null(pStmt, i);
      break;
    }
  }
  return rc;
}
           int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  if( rc==0 ){
    sqlite3VdbeMemSetZeroBlob(&p->aVar[i-1], n);
                                     ;
  }
  return rc;
}





           int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe*)pStmt;
  return p ? p->nVar : 0;
}






static void createVarMap(Vdbe *p){
  if( !p->okVar ){
    int j;
    Op *pOp;
                                     ;





    for(j=0, pOp=p->aOp; j<p->nOp; j++, pOp++){
      if( pOp->opcode==12 ){
        ((void) (0));
        p->azVar[pOp->p1-1] = pOp->p4.z;
      }
    }
    p->okVar = 1;
                                     ;
  }
}







           const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){
  Vdbe *p = (Vdbe*)pStmt;
  if( p==0 || i<1 || i>p->nVar ){
    return 0;
  }
  createVarMap(p);
  return p->azVar[i-1];
}






static int sqlite3VdbeParameterIndex(Vdbe *p, const char *zName, int nName){
  int i;
  if( p==0 ){
    return 0;
  }
  createVarMap(p);
  if( zName ){
    for(i=0; i<p->nVar; i++){
      const char *z = p->azVar[i];
      if( z && memcmp(z,zName,nName)==0 && z[nName]==0 ){
        return i+1;
      }
    }
  }
  return 0;
}
           int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName){
  return sqlite3VdbeParameterIndex((Vdbe*)pStmt, zName, sqlite3Strlen30(zName));
}




static int sqlite3TransferBindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){
  Vdbe *pFrom = (Vdbe*)pFromStmt;
  Vdbe *pTo = (Vdbe*)pToStmt;
  int i;
  ((void) (0));
  ((void) (0));
                                     ;
  for(i=0; i<pFrom->nVar; i++){
    sqlite3VdbeMemMove(&pTo->aVar[i], &pFrom->aVar[i]);
  }
                                     ;
  return 0;
}
# 61479 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){
  Vdbe *pFrom = (Vdbe*)pFromStmt;
  Vdbe *pTo = (Vdbe*)pToStmt;
  if( pFrom->nVar!=pTo->nVar ){
    return 1;
  }
  if( pTo->isPrepareV2 && pTo->expmask ){
    pTo->expired = 1;
  }
  if( pFrom->isPrepareV2 && pFrom->expmask ){
    pFrom->expired = 1;
  }
  return sqlite3TransferBindings(pFromStmt, pToStmt);
}
# 61501 "ext/sqlite3/libsqlite/sqlite3.c"
           sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){
  return pStmt ? ((Vdbe*)pStmt)->db : 0;
}





           int sqlite3_stmt_readonly(sqlite3_stmt *pStmt){
  return pStmt ? ((Vdbe*)pStmt)->readOnly : 1;
}







           sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt){
  sqlite3_stmt *pNext;
                                 ;
  if( pStmt==0 ){
    pNext = (sqlite3_stmt*)pDb->pVdbe;
  }else{
    pNext = (sqlite3_stmt*)((Vdbe*)pStmt)->pNext;
  }
                                 ;
  return pNext;
}




           int sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag){
  Vdbe *pVdbe = (Vdbe*)pStmt;
  int v = pVdbe->aCounter[op-1];
  if( resetFlag ) pVdbe->aCounter[op-1] = 0;
  return v;
}
# 61567 "ext/sqlite3/libsqlite/sqlite3.c"
static int findNextHostParameter(const char *zSql, int *pnToken){
  int tokenType;
  int nTotal = 0;
  int n;

  *pnToken = 0;
  while( zSql[0] ){
    n = sqlite3GetToken((u8*)zSql, &tokenType);
    ((void) (0));
    if( tokenType==133 ){
      *pnToken = n;
      break;
    }
    nTotal += n;
    zSql += n;
  }
  return nTotal;
}
# 61605 "ext/sqlite3/libsqlite/sqlite3.c"
static char *sqlite3VdbeExpandSql(
  Vdbe *p,
  const char *zRawSql
){
  sqlite3 *db;
  int idx = 0;
  int nextIndex = 1;
  int n;
  int nToken;
  int i;
  Mem *pVar;
  StrAccum out;
  char zBase[100];

  db = p->db;
  sqlite3StrAccumInit(&out, zBase, sizeof(zBase),
                      db->aLimit[0]);
  out.db = db;
  if( db->vdbeExecCnt>1 ){
    while( *zRawSql ){
      const char *zStart = zRawSql;
      while( *(zRawSql++)!='\n' && *zRawSql );
      sqlite3StrAccumAppend(&out, "-- ", 3);
      sqlite3StrAccumAppend(&out, zStart, (int)(zRawSql-zStart));
    }
  }else{
    while( zRawSql[0] ){
      n = findNextHostParameter(zRawSql, &nToken);
      ((void) (0));
      sqlite3StrAccumAppend(&out, zRawSql, n);
      zRawSql += n;
      ((void) (0));
      if( nToken==0 ) break;
      if( zRawSql[0]=='?' ){
        if( nToken>1 ){
          ((void) (0));
          sqlite3GetInt32(&zRawSql[1], &idx);
        }else{
          idx = nextIndex;
        }
      }else{
        ((void) (0));
                                   ;
                                   ;
                                   ;
        idx = sqlite3VdbeParameterIndex(p, zRawSql, nToken);
        ((void) (0));
      }
      zRawSql += nToken;
      nextIndex = idx + 1;
      ((void) (0));
      pVar = &p->aVar[idx-1];
      if( pVar->flags & 0x0001 ){
        sqlite3StrAccumAppend(&out, "NULL", 4);
      }else if( pVar->flags & 0x0004 ){
        sqlite3XPrintf(&out, "%lld", pVar->u.i);
      }else if( pVar->flags & 0x0008 ){
        sqlite3XPrintf(&out, "%!.15g", pVar->r);
      }else if( pVar->flags & 0x0002 ){

        u8 enc = ((db)->aDb[0].pSchema->enc);
        if( enc!=1 ){
          Mem utf8;
          memset(&utf8, 0, sizeof(utf8));
          utf8.db = db;
          sqlite3VdbeMemSetStr(&utf8, pVar->z, pVar->n, enc, ((sqlite3_destructor_type)0));
          sqlite3VdbeChangeEncoding(&utf8, 1);
          sqlite3XPrintf(&out, "'%.*q'", utf8.n, utf8.z);
          sqlite3VdbeMemRelease(&utf8);
        }else

        {
          sqlite3XPrintf(&out, "'%.*q'", pVar->n, pVar->z);
        }
      }else if( pVar->flags & 0x4000 ){
        sqlite3XPrintf(&out, "zeroblob(%d)", pVar->u.nZero);
      }else{
        ((void) (0));
        sqlite3StrAccumAppend(&out, "x'", 2);
        for(i=0; i<pVar->n; i++){
          sqlite3XPrintf(&out, "%02x", pVar->z[i]&0xff);
        }
        sqlite3StrAccumAppend(&out, "'", 1);
      }
    }
  }
  return sqlite3StrAccumFinish(&out);
}
# 61861 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3VdbeMemStoreType(Mem *pMem){
  int flags = pMem->flags;
  if( flags & 0x0001 ){
    pMem->type = 5;
  }
  else if( flags & 0x0004 ){
    pMem->type = 1;
  }
  else if( flags & 0x0008 ){
    pMem->type = 2;
  }
  else if( flags & 0x0002 ){
    pMem->type = 3;
  }else{
    pMem->type = 4;
  }
}





static VdbeCursor *allocateCursor(
  Vdbe *p,
  int iCur,
  int nField,
  int iDb,
  int isBtreeCursor
){
# 61908 "ext/sqlite3/libsqlite/sqlite3.c"
  Mem *pMem = &p->aMem[p->nMem-iCur];

  int nByte;
  VdbeCursor *pCx = 0;
  nByte =
      (((sizeof(VdbeCursor))+7)&~7) +
      (isBtreeCursor?sqlite3BtreeCursorSize():0) +
      2*nField*sizeof(u32);

  ((void) (0));
  if( p->apCsr[iCur] ){
    sqlite3VdbeFreeCursor(p, p->apCsr[iCur]);
    p->apCsr[iCur] = 0;
  }
  if( 0==sqlite3VdbeMemGrow(pMem, nByte, 0) ){
    p->apCsr[iCur] = pCx = (VdbeCursor*)pMem->z;
    memset(pCx, 0, sizeof(VdbeCursor));
    pCx->iDb = iDb;
    pCx->nField = nField;
    if( nField ){
      pCx->aType = (u32 *)&pMem->z[(((sizeof(VdbeCursor))+7)&~7)];
    }
    if( isBtreeCursor ){
      pCx->pCursor = (BtCursor*)
          &pMem->z[(((sizeof(VdbeCursor))+7)&~7)+2*nField*sizeof(u32)];
      sqlite3BtreeCursorZero(pCx->pCursor);
    }
  }
  return pCx;
}







static void applyNumericAffinity(Mem *pRec){
  if( (pRec->flags & (0x0008|0x0004))==0 ){
    double rValue;
    i64 iValue;
    u8 enc = pRec->enc;
    if( (pRec->flags&0x0002)==0 ) return;
    if( sqlite3AtoF(pRec->z, &rValue, pRec->n, enc)==0 ) return;
    if( 0==sqlite3Atoi64(pRec->z, &iValue, pRec->n, enc) ){
      pRec->u.i = iValue;
      pRec->flags |= 0x0004;
    }else{
      pRec->r = rValue;
      pRec->flags |= 0x0008;
    }
  }
}
# 61980 "ext/sqlite3/libsqlite/sqlite3.c"
static void applyAffinity(
  Mem *pRec,
  char affinity,
  u8 enc
){
  if( affinity=='a' ){




    if( 0==(pRec->flags&0x0002) && (pRec->flags&(0x0008|0x0004)) ){
      sqlite3VdbeMemStringify(pRec, enc);
    }
    pRec->flags &= ~(0x0008|0x0004);
  }else if( affinity!='b' ){
    ((void) (0));

    applyNumericAffinity(pRec);
    if( pRec->flags & 0x0008 ){
      sqlite3VdbeIntegerAffinity(pRec);
    }
  }
}







           int sqlite3_value_numeric_type(sqlite3_value *pVal){
  Mem *pMem = (Mem*)pVal;
  if( pMem->type==3 ){
    applyNumericAffinity(pMem);
    sqlite3VdbeMemStoreType(pMem);
  }
  return pMem->type;
}





static void sqlite3ValueApplyAffinity(
  sqlite3_value *pVal,
  u8 affinity,
  u8 enc
){
  applyAffinity((Mem *)pVal, affinity, enc);
}
# 62290 "ext/sqlite3/libsqlite/sqlite3.c"
static void importVtabErrMsg(Vdbe *p, sqlite3_vtab *pVtab){
  sqlite3 *db = p->db;
  sqlite3DbFree(db, p->zErrMsg);
  p->zErrMsg = sqlite3DbStrDup(db, pVtab->zErrMsg);
  sqlite3_free(pVtab->zErrMsg);
  pVtab->zErrMsg = 0;
}
# 62330 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VdbeExec(
  Vdbe *p
){
  int pc=0;
  Op *aOp = p->aOp;
  Op *pOp;
  int rc = 0;
  sqlite3 *db = p->db;
  u8 resetSchemaOnFault = 0;
  u8 encoding = ((db)->aDb[0].pSchema->enc);

  int checkProgress;
  int nProgressOps = 0;

  Mem *aMem = p->aMem;
  Mem *pIn1 = 0;
  Mem *pIn2 = 0;
  Mem *pIn3 = 0;
  Mem *pOut = 0;
  int iCompare = 0;
  int *aPermute = 0;
# 62363 "ext/sqlite3/libsqlite/sqlite3.c"
  union vdbeExecUnion {
    struct OP_Yield_stack_vars {
      int pcDest;
    } aa;
    struct OP_Variable_stack_vars {
      Mem *pVar;
    } ab;
    struct OP_Move_stack_vars {
      char *zMalloc;
      int n;
      int p1;
      int p2;
    } ac;
    struct OP_ResultRow_stack_vars {
      Mem *pMem;
      int i;
    } ad;
    struct OP_Concat_stack_vars {
      i64 nByte;
    } ae;
    struct OP_Remainder_stack_vars {
      int flags;
      i64 iA;
      i64 iB;
      double rA;
      double rB;
    } af;
    struct OP_Function_stack_vars {
      int i;
      Mem *pArg;
      sqlite3_context ctx;
      sqlite3_value **apVal;
      int n;
    } ag;
    struct OP_ShiftRight_stack_vars {
      i64 iA;
      u64 uA;
      i64 iB;
      u8 op;
    } ah;
    struct OP_Ge_stack_vars {
      int res;
      char affinity;
      u16 flags1;
      u16 flags3;
    } ai;
    struct OP_Compare_stack_vars {
      int n;
      int i;
      int p1;
      int p2;
      const KeyInfo *pKeyInfo;
      int idx;
      CollSeq *pColl;
      int bRev;
    } aj;
    struct OP_Or_stack_vars {
      int v1;
      int v2;
    } ak;
    struct OP_IfNot_stack_vars {
      int c;
    } al;
    struct OP_Column_stack_vars {
      u32 payloadSize;
      i64 payloadSize64;
      int p1;
      int p2;
      VdbeCursor *pC;
      char *zRec;
      BtCursor *pCrsr;
      u32 *aType;
      u32 *aOffset;
      int nField;
      int len;
      int i;
      char *zData;
      Mem *pDest;
      Mem sMem;
      u8 *zIdx;
      u8 *zEndHdr;
      u32 offset;
      u32 szField;
      int szHdr;
      int avail;
      Mem *pReg;
    } am;
    struct OP_Affinity_stack_vars {
      const char *zAffinity;
      char cAff;
    } an;
    struct OP_MakeRecord_stack_vars {
      u8 *zNewRecord;
      Mem *pRec;
      u64 nData;
      int nHdr;
      i64 nByte;
      int nZero;
      int nVarint;
      u32 serial_type;
      Mem *pData0;
      Mem *pLast;
      int nField;
      char *zAffinity;
      int file_format;
      int i;
      int len;
    } ao;
    struct OP_Count_stack_vars {
      i64 nEntry;
      BtCursor *pCrsr;
    } ap;
    struct OP_Savepoint_stack_vars {
      int p1;
      char *zName;
      int nName;
      Savepoint *pNew;
      Savepoint *pSavepoint;
      Savepoint *pTmp;
      int iSavepoint;
      int ii;
    } aq;
    struct OP_AutoCommit_stack_vars {
      int desiredAutoCommit;
      int iRollback;
      int turnOnAC;
    } ar;
    struct OP_Transaction_stack_vars {
      Btree *pBt;
    } as;
    struct OP_ReadCookie_stack_vars {
      int iMeta;
      int iDb;
      int iCookie;
    } at;
    struct OP_SetCookie_stack_vars {
      Db *pDb;
    } au;
    struct OP_VerifyCookie_stack_vars {
      int iMeta;
      int iGen;
      Btree *pBt;
    } av;
    struct OP_OpenWrite_stack_vars {
      int nField;
      KeyInfo *pKeyInfo;
      int p2;
      int iDb;
      int wrFlag;
      Btree *pX;
      VdbeCursor *pCur;
      Db *pDb;
    } aw;
    struct OP_OpenEphemeral_stack_vars {
      VdbeCursor *pCx;
    } ax;
    struct OP_OpenPseudo_stack_vars {
      VdbeCursor *pCx;
    } ay;
    struct OP_SeekGt_stack_vars {
      int res;
      int oc;
      VdbeCursor *pC;
      UnpackedRecord r;
      int nField;
      i64 iKey;
    } az;
    struct OP_Seek_stack_vars {
      VdbeCursor *pC;
    } ba;
    struct OP_Found_stack_vars {
      int alreadyExists;
      VdbeCursor *pC;
      int res;
      UnpackedRecord *pIdxKey;
      UnpackedRecord r;
      char aTempRec[(((sizeof(UnpackedRecord))+7)&~7) + sizeof(Mem)*3 + 7];
    } bb;
    struct OP_IsUnique_stack_vars {
      u16 ii;
      VdbeCursor *pCx;
      BtCursor *pCrsr;
      u16 nField;
      Mem *aMx;
      UnpackedRecord r;
      i64 R;
    } bc;
    struct OP_NotExists_stack_vars {
      VdbeCursor *pC;
      BtCursor *pCrsr;
      int res;
      u64 iKey;
    } bd;
    struct OP_NewRowid_stack_vars {
      i64 v;
      VdbeCursor *pC;
      int res;
      int cnt;
      Mem *pMem;
      VdbeFrame *pFrame;
    } be;
    struct OP_InsertInt_stack_vars {
      Mem *pData;
      Mem *pKey;
      i64 iKey;
      VdbeCursor *pC;
      int nZero;
      int seekResult;
      const char *zDb;
      const char *zTbl;
      int op;
    } bf;
    struct OP_Delete_stack_vars {
      i64 iKey;
      VdbeCursor *pC;
    } bg;
    struct OP_RowData_stack_vars {
      VdbeCursor *pC;
      BtCursor *pCrsr;
      u32 n;
      i64 n64;
    } bh;
    struct OP_Rowid_stack_vars {
      VdbeCursor *pC;
      i64 v;
      sqlite3_vtab *pVtab;
      const sqlite3_module *pModule;
    } bi;
    struct OP_NullRow_stack_vars {
      VdbeCursor *pC;
    } bj;
    struct OP_Last_stack_vars {
      VdbeCursor *pC;
      BtCursor *pCrsr;
      int res;
    } bk;
    struct OP_Rewind_stack_vars {
      VdbeCursor *pC;
      BtCursor *pCrsr;
      int res;
    } bl;
    struct OP_Next_stack_vars {
      VdbeCursor *pC;
      BtCursor *pCrsr;
      int res;
    } bm;
    struct OP_IdxInsert_stack_vars {
      VdbeCursor *pC;
      BtCursor *pCrsr;
      int nKey;
      const char *zKey;
    } bn;
    struct OP_IdxDelete_stack_vars {
      VdbeCursor *pC;
      BtCursor *pCrsr;
      int res;
      UnpackedRecord r;
    } bo;
    struct OP_IdxRowid_stack_vars {
      BtCursor *pCrsr;
      VdbeCursor *pC;
      i64 rowid;
    } bp;
    struct OP_IdxGE_stack_vars {
      VdbeCursor *pC;
      int res;
      UnpackedRecord r;
    } bq;
    struct OP_Destroy_stack_vars {
      int iMoved;
      int iCnt;
      Vdbe *pVdbe;
      int iDb;
    } br;
    struct OP_Clear_stack_vars {
      int nChange;
    } bs;
    struct OP_CreateTable_stack_vars {
      int pgno;
      int flags;
      Db *pDb;
    } bt;
    struct OP_ParseSchema_stack_vars {
      int iDb;
      const char *zMaster;
      char *zSql;
      InitData initData;
    } bu;
    struct OP_IntegrityCk_stack_vars {
      int nRoot;
      int *aRoot;
      int j;
      int nErr;
      char *z;
      Mem *pnErr;
    } bv;
    struct OP_RowSetRead_stack_vars {
      i64 val;
    } bw;
    struct OP_RowSetTest_stack_vars {
      int iSet;
      int exists;
    } bx;
    struct OP_Program_stack_vars {
      int nMem;
      int nByte;
      Mem *pRt;
      Mem *pMem;
      Mem *pEnd;
      VdbeFrame *pFrame;
      SubProgram *pProgram;
      void *t;
    } by;
    struct OP_Param_stack_vars {
      VdbeFrame *pFrame;
      Mem *pIn;
    } bz;
    struct OP_MemMax_stack_vars {
      Mem *pIn1;
      VdbeFrame *pFrame;
    } ca;
    struct OP_AggStep_stack_vars {
      int n;
      int i;
      Mem *pMem;
      Mem *pRec;
      sqlite3_context ctx;
      sqlite3_value **apVal;
    } cb;
    struct OP_AggFinal_stack_vars {
      Mem *pMem;
    } cc;
    struct OP_Checkpoint_stack_vars {
      int i;
      int aRes[3];
      Mem *pMem;
    } cd;
    struct OP_JournalMode_stack_vars {
      Btree *pBt;
      Pager *pPager;
      int eNew;
      int eOld;
      const char *zFilename;
    } ce;
    struct OP_IncrVacuum_stack_vars {
      Btree *pBt;
    } cf;
    struct OP_VBegin_stack_vars {
      VTable *pVTab;
    } cg;
    struct OP_VOpen_stack_vars {
      VdbeCursor *pCur;
      sqlite3_vtab_cursor *pVtabCursor;
      sqlite3_vtab *pVtab;
      sqlite3_module *pModule;
    } ch;
    struct OP_VFilter_stack_vars {
      int nArg;
      int iQuery;
      const sqlite3_module *pModule;
      Mem *pQuery;
      Mem *pArgc;
      sqlite3_vtab_cursor *pVtabCursor;
      sqlite3_vtab *pVtab;
      VdbeCursor *pCur;
      int res;
      int i;
      Mem **apArg;
    } ci;
    struct OP_VColumn_stack_vars {
      sqlite3_vtab *pVtab;
      const sqlite3_module *pModule;
      Mem *pDest;
      sqlite3_context sContext;
    } cj;
    struct OP_VNext_stack_vars {
      sqlite3_vtab *pVtab;
      const sqlite3_module *pModule;
      int res;
      VdbeCursor *pCur;
    } ck;
    struct OP_VRename_stack_vars {
      sqlite3_vtab *pVtab;
      Mem *pName;
    } cl;
    struct OP_VUpdate_stack_vars {
      sqlite3_vtab *pVtab;
      sqlite3_module *pModule;
      int nArg;
      int i;
      sqlite_int64 rowid;
      Mem **apArg;
      Mem *pX;
    } cm;
    struct OP_Trace_stack_vars {
      char *zTrace;
    } cn;
  } u;



  ((void) (0));
                     ;
  if( p->rc==7 ){


    goto no_mem;
  }
  ((void) (0));
  p->rc = 0;
  ((void) (0));
  p->pResultSet = 0;
  db->busyHandler.nBusy = 0;
  if( db->u1.isInterrupted ) goto abort_due_to_interrupt;;
                          ;

  checkProgress = db->xProgress!=0;
# 62793 "ext/sqlite3/libsqlite/sqlite3.c"
  for(pc=p->pc; rc==0; pc++){
    ((void) (0));
    if( db->mallocFailed ) goto no_mem;




    pOp = &aOp[pc];
# 62834 "ext/sqlite3/libsqlite/sqlite3.c"
    if( checkProgress ){
      if( db->nProgressOps==nProgressOps ){
        int prc;
        prc = db->xProgress(db->pProgressArg);
        if( prc!=0 ){
          rc = 9;
          goto vdbe_error_halt;
        }
        nProgressOps = 0;
      }
      nProgressOps++;
    }







    ((void) (0));
    if( pOp->opflags & 0x0002 ){
      ((void) (0));
      ((void) (0));
      pOut = &aMem[pOp->p2];
                               ;
      sqlite3VdbeMemReleaseExternal(pOut);
      pOut->flags = 0x0004;
    }
# 62895 "ext/sqlite3/libsqlite/sqlite3.c"
    switch( pOp->opcode ){
# 62939 "ext/sqlite3/libsqlite/sqlite3.c"
case 1: {
  if( db->u1.isInterrupted ) goto abort_due_to_interrupt;;
  pc = pOp->p2 - 1;
  break;
}






case 2: {
  pIn1 = &aMem[pOp->p1];
  ((void) (0));
                           ;
  pIn1->flags = 0x0004;
  pIn1->u.i = pc;
                               ;
  pc = pOp->p2 - 1;
  break;
}





case 3: {
  pIn1 = &aMem[pOp->p1];
  ((void) (0));
  pc = (int)pIn1->u.i;
  break;
}





case 4: {



  pIn1 = &aMem[pOp->p1];
  ((void) (0));
  pIn1->flags = 0x0004;
  u.aa.pcDest = (int)pIn1->u.i;
  pIn1->u.i = pc;
                               ;
  pc = u.aa.pcDest;
  break;
}







case 5: {
  pIn3 = &aMem[pOp->p3];
  if( (pIn3->flags & 0x0001)==0 ) break;

}
# 63021 "ext/sqlite3/libsqlite/sqlite3.c"
case 6: {
  if( pOp->p1==0 && p->pFrame ){

    VdbeFrame *pFrame = p->pFrame;
    p->pFrame = pFrame->pParent;
    p->nFrame--;
    sqlite3VdbeSetChanges(db, p->nChange);
    pc = sqlite3VdbeFrameRestore(pFrame);
    if( pOp->p2==4 ){





      pc = p->aOp[pc].p2-1;
    }
    aOp = p->aOp;
    aMem = p->aMem;
    break;
  }

  p->rc = pOp->p1;
  p->errorAction = (u8)pOp->p2;
  p->pc = pc;
  if( pOp->p4.z ){
    ((void) (0));
    sqlite3SetString(&p->zErrMsg, db, "%s", pOp->p4.z);
                                           ;
    sqlite3_log(pOp->p1, "abort at %d in [%s]: %s", pc, p->zSql, pOp->p4.z);
  }else if( p->rc ){
                                           ;
    sqlite3_log(pOp->p1, "constraint failed at %d in [%s]", pc, p->zSql);
  }
  rc = sqlite3VdbeHalt(p);
  ((void) (0));
  if( rc==5 ){
    p->rc = rc = 5;
  }else{
    ((void) (0));
    ((void) (0));
    rc = p->rc ? 1 : 101;
  }
  goto vdbe_return;
}





case 7: {
  pOut->u.i = pOp->p1;
  break;
}






case 8: {
  ((void) (0));
  pOut->u.i = *pOp->p4.pI64;
  break;
}







case 130: {
  pOut->flags = 0x0008;
  ((void) (0));
  pOut->r = *pOp->p4.pReal;
  break;
}







case 94: {
  ((void) (0));
  pOp->opcode = 9;
  pOp->p1 = sqlite3Strlen30(pOp->p4.z);


  if( encoding!=1 ){
    rc = sqlite3VdbeMemSetStr(pOut, pOp->p4.z, -1, 1, ((sqlite3_destructor_type)0));
    if( rc==18 ) goto too_big;
    if( 0!=sqlite3VdbeChangeEncoding(pOut, encoding) ) goto no_mem;
    ((void) (0));
    ((void) (0));
    pOut->zMalloc = 0;
    pOut->flags |= 0x0800;
    pOut->flags &= ~0x0400;
    if( pOp->p4type==(-1) ){
      sqlite3DbFree(db, pOp->p4.z);
    }
    pOp->p4type = (-1);
    pOp->p4.z = pOut->z;
    pOp->p1 = pOut->n;
  }

  if( pOp->p1>db->aLimit[0] ){
    goto too_big;
  }

}





case 9: {
  ((void) (0));
  pOut->flags = 0x0002|0x0800|0x0200;
  pOut->z = pOp->p4.z;
  pOut->n = pOp->p1;
  pOut->enc = encoding;
                           ;
  break;
}





case 10: {
  pOut->flags = 0x0001;
  break;
}







case 11: {
  ((void) (0));
  sqlite3VdbeMemSetStr(pOut, pOp->p4.z, pOp->p1, 0, 0);
  pOut->enc = encoding;
                           ;
  break;
}
# 63178 "ext/sqlite3/libsqlite/sqlite3.c"
case 12: {




  ((void) (0));
  u.ab.pVar = &p->aVar[pOp->p1 - 1];
  if( sqlite3VdbeMemTooBig(u.ab.pVar) ){
    goto too_big;
  }
  sqlite3VdbeMemShallowCopy(pOut, u.ab.pVar, 0x0800);
                           ;
  break;
}
# 63200 "ext/sqlite3/libsqlite/sqlite3.c"
case 13: {







  u.ac.n = pOp->p3;
  u.ac.p1 = pOp->p1;
  u.ac.p2 = pOp->p2;
  ((void) (0));
  ((void) (0));

  pIn1 = &aMem[u.ac.p1];
  pOut = &aMem[u.ac.p2];
  while( u.ac.n-- ){
    ((void) (0));
    ((void) (0));
    ((void) (0));
                             ;
    u.ac.zMalloc = pOut->zMalloc;
    pOut->zMalloc = 0;
    sqlite3VdbeMemMove(pOut, pIn1);
    pIn1->zMalloc = u.ac.zMalloc;
                                   ;
    pIn1++;
    pOut++;
  }
  break;
}
# 63239 "ext/sqlite3/libsqlite/sqlite3.c"
case 14: {
  pIn1 = &aMem[pOp->p1];
  pOut = &aMem[pOp->p2];
  ((void) (0));
  sqlite3VdbeMemShallowCopy(pOut, pIn1, 0x1000);
  if( ((pOut)->flags&0x1000)!=0 && sqlite3VdbeMemMakeWriteable(pOut) ){ goto no_mem;};
                               ;
  break;
}
# 63261 "ext/sqlite3/libsqlite/sqlite3.c"
case 15: {
  pIn1 = &aMem[pOp->p1];
  pOut = &aMem[pOp->p2];
  ((void) (0));
  sqlite3VdbeMemShallowCopy(pOut, pIn1, 0x1000);



                               ;
  break;
}
# 63281 "ext/sqlite3/libsqlite/sqlite3.c"
case 16: {




  ((void) (0));
  ((void) (0));
  ((void) (0));




  if( 0!=(rc = sqlite3VdbeCheckFk(p, 0)) ){
    ((void) (0));
    ((void) (0));
    break;
  }
# 63314 "ext/sqlite3/libsqlite/sqlite3.c"
  ((void) (0));
  rc = sqlite3VdbeCloseStatement(p, 1);
  if( (rc!=0) ){
    break;
  }


  p->cacheCtr = (p->cacheCtr + 2)|1;





  u.ad.pMem = p->pResultSet = &aMem[pOp->p1];
  for(u.ad.i=0; u.ad.i<pOp->p2; u.ad.i++){
    ((void) (0));
    if( ((&u.ad.pMem[u.ad.i])->flags&0x1000)!=0 && sqlite3VdbeMemMakeWriteable(&u.ad.pMem[u.ad.i]) ){ goto no_mem;};
    ((void) (0));

    sqlite3VdbeMemNulTerminate(&u.ad.pMem[u.ad.i]);
    sqlite3VdbeMemStoreType(&u.ad.pMem[u.ad.i]);
                                                      ;
  }
  if( db->mallocFailed ) goto no_mem;



  p->pc = pc + 1;
  rc = 100;
  goto vdbe_return;
}
# 63358 "ext/sqlite3/libsqlite/sqlite3.c"
case 91: {




  pIn1 = &aMem[pOp->p1];
  pIn2 = &aMem[pOp->p2];
  pOut = &aMem[pOp->p3];
  ((void) (0));
  if( (pIn1->flags | pIn2->flags) & 0x0001 ){
    sqlite3VdbeMemSetNull(pOut);
    break;
  }
  if( (((pIn1)->flags&0x4000)?sqlite3VdbeMemExpandBlob(pIn1):0) || (((pIn2)->flags&0x4000)?sqlite3VdbeMemExpandBlob(pIn2):0) ) goto no_mem;
  if(((pIn1)->flags&(0x0002|0x0010))==0 && sqlite3VdbeMemStringify(pIn1,encoding)) { goto no_mem; };
  if(((pIn2)->flags&(0x0002|0x0010))==0 && sqlite3VdbeMemStringify(pIn2,encoding)) { goto no_mem; };
  u.ae.nByte = pIn1->n + pIn2->n;
  if( u.ae.nByte>db->aLimit[0] ){
    goto too_big;
  }
  ((pOut)->flags = ((pOut)->flags&~(0x00ff|0x4000))|0x0002);
  if( sqlite3VdbeMemGrow(pOut, (int)u.ae.nByte+2, pOut==pIn2) ){
    goto no_mem;
  }
  if( pOut!=pIn2 ){
    memcpy(pOut->z, pIn2->z, pIn2->n);
  }
  memcpy(&pOut->z[pIn2->n], pIn1->z, pIn1->n);
  pOut->z[u.ae.nByte] = 0;
  pOut->z[u.ae.nByte+1] = 0;
  pOut->flags |= 0x0200;
  pOut->n = (int)u.ae.nByte;
  pOut->enc = encoding;
                           ;
  break;
}
# 63428 "ext/sqlite3/libsqlite/sqlite3.c"
case 86:
case 87:
case 88:
case 89:
case 90: {
# 63441 "ext/sqlite3/libsqlite/sqlite3.c"
  pIn1 = &aMem[pOp->p1];
  applyNumericAffinity(pIn1);
  pIn2 = &aMem[pOp->p2];
  applyNumericAffinity(pIn2);
  pOut = &aMem[pOp->p3];
  u.af.flags = pIn1->flags | pIn2->flags;
  if( (u.af.flags & 0x0001)!=0 ) goto arithmetic_result_is_null;
  if( (pIn1->flags & pIn2->flags & 0x0004)==0x0004 ){
    u.af.iA = pIn1->u.i;
    u.af.iB = pIn2->u.i;
    switch( pOp->opcode ){
      case 86: if( sqlite3AddInt64(&u.af.iB,u.af.iA) ) goto fp_math; break;
      case 87: if( sqlite3SubInt64(&u.af.iB,u.af.iA) ) goto fp_math; break;
      case 88: if( sqlite3MulInt64(&u.af.iB,u.af.iA) ) goto fp_math; break;
      case 89: {
        if( u.af.iA==0 ) goto arithmetic_result_is_null;
        if( u.af.iA==-1 && u.af.iB==(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) ) goto fp_math;
        u.af.iB /= u.af.iA;
        break;
      }
      default: {
        if( u.af.iA==0 ) goto arithmetic_result_is_null;
        if( u.af.iA==-1 ) u.af.iA = 1;
        u.af.iB %= u.af.iA;
        break;
      }
    }
    pOut->u.i = u.af.iB;
    ((pOut)->flags = ((pOut)->flags&~(0x00ff|0x4000))|0x0004);
  }else{
fp_math:
    u.af.rA = sqlite3VdbeRealValue(pIn1);
    u.af.rB = sqlite3VdbeRealValue(pIn2);
    switch( pOp->opcode ){
      case 86: u.af.rB += u.af.rA; break;
      case 87: u.af.rB -= u.af.rA; break;
      case 88: u.af.rB *= u.af.rA; break;
      case 89: {

        if( u.af.rA==(double)0 ) goto arithmetic_result_is_null;
        u.af.rB /= u.af.rA;
        break;
      }
      default: {
        u.af.iA = (i64)u.af.rA;
        u.af.iB = (i64)u.af.rB;
        if( u.af.iA==0 ) goto arithmetic_result_is_null;
        if( u.af.iA==-1 ) u.af.iA = 1;
        u.af.rB = (double)(u.af.iB % u.af.iA);
        break;
      }
    }




    if( sqlite3IsNaN(u.af.rB) ){
      goto arithmetic_result_is_null;
    }
    pOut->r = u.af.rB;
    ((pOut)->flags = ((pOut)->flags&~(0x00ff|0x4000))|0x0008);
    if( (u.af.flags & 0x0008)==0 ){
      sqlite3VdbeIntegerAffinity(pOut);
    }

  }
  break;

arithmetic_result_is_null:
  sqlite3VdbeMemSetNull(pOut);
  break;
}
# 63525 "ext/sqlite3/libsqlite/sqlite3.c"
case 17: {
  ((void) (0));
  break;
}
# 63546 "ext/sqlite3/libsqlite/sqlite3.c"
case 18: {
# 63555 "ext/sqlite3/libsqlite/sqlite3.c"
  u.ag.n = pOp->p5;
  u.ag.apVal = p->apArg;
  ((void) (0));
  ((void) (0));
  pOut = &aMem[pOp->p3];
                           ;

  ((void) (0));
  ((void) (0));
  u.ag.pArg = &aMem[pOp->p2];
  for(u.ag.i=0; u.ag.i<u.ag.n; u.ag.i++, u.ag.pArg++){
    ((void) (0));
    u.ag.apVal[u.ag.i] = u.ag.pArg;
    if( ((u.ag.pArg)->flags&0x1000)!=0 && sqlite3VdbeMemMakeWriteable(u.ag.pArg) ){ goto no_mem;};
    sqlite3VdbeMemStoreType(u.ag.pArg);
                                             ;
  }

  ((void) (0));
  if( pOp->p4type==(-5) ){
    u.ag.ctx.pFunc = pOp->p4.pFunc;
    u.ag.ctx.pVdbeFunc = 0;
  }else{
    u.ag.ctx.pVdbeFunc = (VdbeFunc*)pOp->p4.pVdbeFunc;
    u.ag.ctx.pFunc = u.ag.ctx.pVdbeFunc->pFunc;
  }

  u.ag.ctx.s.flags = 0x0001;
  u.ag.ctx.s.db = db;
  u.ag.ctx.s.xDel = 0;
  u.ag.ctx.s.zMalloc = 0;





  sqlite3VdbeMemMove(&u.ag.ctx.s, pOut);
  ((&u.ag.ctx.s)->flags = ((&u.ag.ctx.s)->flags&~(0x00ff|0x4000))|0x0001);

  u.ag.ctx.isError = 0;
  if( u.ag.ctx.pFunc->flags & 0x08 ){
    ((void) (0));
    ((void) (0));
    ((void) (0));
    u.ag.ctx.pColl = pOp[-1].p4.pColl;
  }
  (*u.ag.ctx.pFunc->xFunc)(&u.ag.ctx, u.ag.n, u.ag.apVal);
  if( db->mallocFailed ){





    sqlite3VdbeMemRelease(&u.ag.ctx.s);
    goto no_mem;
  }




  if( u.ag.ctx.pVdbeFunc ){
    sqlite3VdbeDeleteAuxData(u.ag.ctx.pVdbeFunc, pOp->p1);
    pOp->p4.pVdbeFunc = u.ag.ctx.pVdbeFunc;
    pOp->p4type = (-7);
  }


  if( u.ag.ctx.isError ){
    sqlite3SetString(&p->zErrMsg, db, "%s", sqlite3_value_text(&u.ag.ctx.s));
    rc = u.ag.ctx.isError;
  }


  sqlite3VdbeChangeEncoding(&u.ag.ctx.s, encoding);
  sqlite3VdbeMemMove(pOut, &u.ag.ctx.s);
  if( sqlite3VdbeMemTooBig(pOut) ){
    goto too_big;
  }
# 63642 "ext/sqlite3/libsqlite/sqlite3.c"
                               ;
                           ;
  break;
}
# 63673 "ext/sqlite3/libsqlite/sqlite3.c"
case 82:
case 83:
case 84:
case 85: {







  pIn1 = &aMem[pOp->p1];
  pIn2 = &aMem[pOp->p2];
  pOut = &aMem[pOp->p3];
  if( (pIn1->flags | pIn2->flags) & 0x0001 ){
    sqlite3VdbeMemSetNull(pOut);
    break;
  }
  u.ah.iA = sqlite3VdbeIntValue(pIn2);
  u.ah.iB = sqlite3VdbeIntValue(pIn1);
  u.ah.op = pOp->opcode;
  if( u.ah.op==82 ){
    u.ah.iA &= u.ah.iB;
  }else if( u.ah.op==83 ){
    u.ah.iA |= u.ah.iB;
  }else if( u.ah.iB!=0 ){
    ((void) (0));


    if( u.ah.iB<0 ){
      ((void) (0));
      u.ah.op = 2*84 + 1 - u.ah.op;
      u.ah.iB = u.ah.iB>(-64) ? -u.ah.iB : 64;
    }

    if( u.ah.iB>=64 ){
      u.ah.iA = (u.ah.iA>=0 || u.ah.op==84) ? 0 : -1;
    }else{
      memcpy(&u.ah.uA, &u.ah.iA, sizeof(u.ah.uA));
      if( u.ah.op==84 ){
        u.ah.uA <<= u.ah.iB;
      }else{
        u.ah.uA >>= u.ah.iB;

        if( u.ah.iA<0 ) u.ah.uA |= ((((u64)0xffffffff)<<32)|0xffffffff) << (64-u.ah.iB);
      }
      memcpy(&u.ah.iA, &u.ah.uA, sizeof(u.ah.iA));
    }
  }
  pOut->u.i = u.ah.iA;
  ((pOut)->flags = ((pOut)->flags&~(0x00ff|0x4000))|0x0004);
  break;
}
# 63734 "ext/sqlite3/libsqlite/sqlite3.c"
case 20: {
  pIn1 = &aMem[pOp->p1];
                           ;
  sqlite3VdbeMemIntegerify(pIn1);
  pIn1->u.i += pOp->p2;
  break;
}
# 63749 "ext/sqlite3/libsqlite/sqlite3.c"
case 21: {
  pIn1 = &aMem[pOp->p1];
  applyAffinity(pIn1, 'c', encoding);
  if( (pIn1->flags & 0x0004)==0 ){
    if( pOp->p2==0 ){
      rc = 20;
      goto abort_due_to_error;
    }else{
      pc = pOp->p2 - 1;
    }
  }else{
    ((pIn1)->flags = ((pIn1)->flags&~(0x00ff|0x4000))|0x0004);
  }
  break;
}
# 63775 "ext/sqlite3/libsqlite/sqlite3.c"
case 22: {
  pIn1 = &aMem[pOp->p1];
  if( pIn1->flags & 0x0004 ){
    sqlite3VdbeMemRealify(pIn1);
  }
  break;
}
# 63794 "ext/sqlite3/libsqlite/sqlite3.c"
case 141: {
  pIn1 = &aMem[pOp->p1];
                           ;
  if( pIn1->flags & 0x0001 ) break;
  ((void) (0));
  pIn1->flags |= (pIn1->flags&0x0010)>>3;
  applyAffinity(pIn1, 'a', encoding);
  rc = (((pIn1)->flags&0x4000)?sqlite3VdbeMemExpandBlob(pIn1):0);
  ((void) (0));
  pIn1->flags &= ~(0x0004|0x0008|0x0010|0x4000);
                           ;
  break;
}
# 63817 "ext/sqlite3/libsqlite/sqlite3.c"
case 142: {
  pIn1 = &aMem[pOp->p1];
  if( pIn1->flags & 0x0001 ) break;
  if( (pIn1->flags & 0x0010)==0 ){
    applyAffinity(pIn1, 'a', encoding);
    ((void) (0));
    ((pIn1)->flags = ((pIn1)->flags&~(0x00ff|0x4000))|0x0010);
  }else{
    pIn1->flags &= ~(0x00ff&~0x0010);
  }
                           ;
  break;
}
# 63841 "ext/sqlite3/libsqlite/sqlite3.c"
case 143: {
  pIn1 = &aMem[pOp->p1];
  sqlite3VdbeMemNumerify(pIn1);
  break;
}
# 63857 "ext/sqlite3/libsqlite/sqlite3.c"
case 144: {
  pIn1 = &aMem[pOp->p1];
  if( (pIn1->flags & 0x0001)==0 ){
    sqlite3VdbeMemIntegerify(pIn1);
  }
  break;
}
# 63875 "ext/sqlite3/libsqlite/sqlite3.c"
case 145: {
  pIn1 = &aMem[pOp->p1];
                           ;
  if( (pIn1->flags & 0x0001)==0 ){
    sqlite3VdbeMemRealify(pIn1);
  }
  break;
}
# 63957 "ext/sqlite3/libsqlite/sqlite3.c"
case 76:
case 75:
case 79:
case 78:
case 77:
case 80: {







  pIn1 = &aMem[pOp->p1];
  pIn3 = &aMem[pOp->p3];
  u.ai.flags1 = pIn1->flags;
  u.ai.flags3 = pIn3->flags;
  if( (pIn1->flags | pIn3->flags)&0x0001 ){

    if( pOp->p5 & 0x80 ){




      ((void) (0));
      u.ai.res = (pIn1->flags & pIn3->flags & 0x0001)==0;
    }else{




      if( pOp->p5 & 0x10 ){
        pOut = &aMem[pOp->p2];
        ((pOut)->flags = ((pOut)->flags&~(0x00ff|0x4000))|0x0001);
                                     ;
      }else if( pOp->p5 & 0x08 ){
        pc = pOp->p2-1;
      }
      break;
    }
  }else{

    u.ai.affinity = pOp->p5 & 0x67;
    if( u.ai.affinity ){
      applyAffinity(pIn1, u.ai.affinity, encoding);
      applyAffinity(pIn3, u.ai.affinity, encoding);
      if( db->mallocFailed ) goto no_mem;
    }

    ((void) (0));
    (((pIn1)->flags&0x4000)?sqlite3VdbeMemExpandBlob(pIn1):0);
    (((pIn3)->flags&0x4000)?sqlite3VdbeMemExpandBlob(pIn3):0);
    u.ai.res = sqlite3MemCompare(pIn3, pIn1, pOp->p4.pColl);
  }
  switch( pOp->opcode ){
    case 76: u.ai.res = u.ai.res==0; break;
    case 75: u.ai.res = u.ai.res!=0; break;
    case 79: u.ai.res = u.ai.res<0; break;
    case 78: u.ai.res = u.ai.res<=0; break;
    case 77: u.ai.res = u.ai.res>0; break;
    default: u.ai.res = u.ai.res>=0; break;
  }

  if( pOp->p5 & 0x10 ){
    pOut = &aMem[pOp->p2];
                             ;
    ((pOut)->flags = ((pOut)->flags&~(0x00ff|0x4000))|0x0004);
    pOut->u.i = u.ai.res;
                                 ;
  }else if( u.ai.res ){
    pc = pOp->p2-1;
  }


  pIn1->flags = (pIn1->flags&~0x00ff) | (u.ai.flags1&0x00ff);
  pIn3->flags = (pIn3->flags&~0x00ff) | (u.ai.flags3&0x00ff);
  break;
}
# 64045 "ext/sqlite3/libsqlite/sqlite3.c"
case 23: {
  ((void) (0));
  ((void) (0));
  aPermute = pOp->p4.ai;
  break;
}
# 64066 "ext/sqlite3/libsqlite/sqlite3.c"
case 24: {
# 64078 "ext/sqlite3/libsqlite/sqlite3.c"
  u.aj.n = pOp->p3;
  u.aj.pKeyInfo = pOp->p4.pKeyInfo;
  ((void) (0));
  ((void) (0));
  u.aj.p1 = pOp->p1;
  u.aj.p2 = pOp->p2;
# 64095 "ext/sqlite3/libsqlite/sqlite3.c"
  for(u.aj.i=0; u.aj.i<u.aj.n; u.aj.i++){
    u.aj.idx = aPermute ? aPermute[u.aj.i] : u.aj.i;
    ((void) (0));
    ((void) (0));
                                                             ;
                                                             ;
    ((void) (0));
    u.aj.pColl = u.aj.pKeyInfo->aColl[u.aj.i];
    u.aj.bRev = u.aj.pKeyInfo->aSortOrder[u.aj.i];
    iCompare = sqlite3MemCompare(&aMem[u.aj.p1+u.aj.idx], &aMem[u.aj.p2+u.aj.idx], u.aj.pColl);
    if( iCompare ){
      if( u.aj.bRev ) iCompare = -iCompare;
      break;
    }
  }
  aPermute = 0;
  break;
}







case 25: {
  if( iCompare<0 ){
    pc = pOp->p1 - 1;
  }else if( iCompare==0 ){
    pc = pOp->p2 - 1;
  }else{
    pc = pOp->p3 - 1;
  }
  break;
}
# 64149 "ext/sqlite3/libsqlite/sqlite3.c"
case 69:
case 68: {





  pIn1 = &aMem[pOp->p1];
  if( pIn1->flags & 0x0001 ){
    u.ak.v1 = 2;
  }else{
    u.ak.v1 = sqlite3VdbeIntValue(pIn1)!=0;
  }
  pIn2 = &aMem[pOp->p2];
  if( pIn2->flags & 0x0001 ){
    u.ak.v2 = 2;
  }else{
    u.ak.v2 = sqlite3VdbeIntValue(pIn2)!=0;
  }
  if( pOp->opcode==69 ){
    static const unsigned char and_logic[] = { 0, 0, 0, 0, 1, 2, 0, 2, 2 };
    u.ak.v1 = and_logic[u.ak.v1*3+u.ak.v2];
  }else{
    static const unsigned char or_logic[] = { 0, 1, 2, 1, 1, 1, 2, 1, 2 };
    u.ak.v1 = or_logic[u.ak.v1*3+u.ak.v2];
  }
  pOut = &aMem[pOp->p3];
  if( u.ak.v1==2 ){
    ((pOut)->flags = ((pOut)->flags&~(0x00ff|0x4000))|0x0001);
  }else{
    pOut->u.i = u.ak.v1;
    ((pOut)->flags = ((pOut)->flags&~(0x00ff|0x4000))|0x0004);
  }
  break;
}







case 19: {
  pIn1 = &aMem[pOp->p1];
  pOut = &aMem[pOp->p2];
  if( pIn1->flags & 0x0001 ){
    sqlite3VdbeMemSetNull(pOut);
  }else{
    sqlite3VdbeMemSetInt64(pOut, !sqlite3VdbeIntValue(pIn1));
  }
  break;
}







case 93: {
  pIn1 = &aMem[pOp->p1];
  pOut = &aMem[pOp->p2];
  if( pIn1->flags & 0x0001 ){
    sqlite3VdbeMemSetNull(pOut);
  }else{
    sqlite3VdbeMemSetInt64(pOut, ~sqlite3VdbeIntValue(pIn1));
  }
  break;
}
# 64231 "ext/sqlite3/libsqlite/sqlite3.c"
case 26:
case 27: {



  pIn1 = &aMem[pOp->p1];
  if( pIn1->flags & 0x0001 ){
    u.al.c = pOp->p3;
  }else{



    u.al.c = sqlite3VdbeRealValue(pIn1)!=0.0;

    if( pOp->opcode==27 ) u.al.c = !u.al.c;
  }
  if( u.al.c ){
    pc = pOp->p2-1;
  }
  break;
}





case 73: {
  pIn1 = &aMem[pOp->p1];
  if( (pIn1->flags & 0x0001)!=0 ){
    pc = pOp->p2 - 1;
  }
  break;
}





case 74: {
  pIn1 = &aMem[pOp->p1];
  if( (pIn1->flags & 0x0001)==0 ){
    pc = pOp->p2 - 1;
  }
  break;
}
# 64296 "ext/sqlite3/libsqlite/sqlite3.c"
case 28: {
# 64323 "ext/sqlite3/libsqlite/sqlite3.c"
  u.am.p1 = pOp->p1;
  u.am.p2 = pOp->p2;
  u.am.pC = 0;
  memset(&u.am.sMem, 0, sizeof(u.am.sMem));
  ((void) (0));
  ((void) (0));
  u.am.pDest = &aMem[pOp->p3];
                                 ;
  ((u.am.pDest)->flags = ((u.am.pDest)->flags&~(0x00ff|0x4000))|0x0001);
  u.am.zRec = 0;
# 64346 "ext/sqlite3/libsqlite/sqlite3.c"
  u.am.pC = p->apCsr[u.am.p1];
  ((void) (0));

  ((void) (0));

  u.am.pCrsr = u.am.pC->pCursor;
  if( u.am.pCrsr!=0 ){

    rc = sqlite3VdbeCursorMoveto(u.am.pC);
    if( rc ) goto abort_due_to_error;
    if( u.am.pC->nullRow ){
      u.am.payloadSize = 0;
    }else if( u.am.pC->cacheStatus==p->cacheCtr ){
      u.am.payloadSize = u.am.pC->payloadSize;
      u.am.zRec = (char*)u.am.pC->aRow;
    }else if( u.am.pC->isIndex ){
      ((void) (0));
      rc = sqlite3BtreeKeySize(u.am.pCrsr, &u.am.payloadSize64);
      ((void) (0));



      ((void) (0));
      u.am.payloadSize = (u32)u.am.payloadSize64;
    }else{
      ((void) (0));
      rc = sqlite3BtreeDataSize(u.am.pCrsr, &u.am.payloadSize);
      ((void) (0));
    }
  }else if( u.am.pC->pseudoTableReg>0 ){
    u.am.pReg = &aMem[u.am.pC->pseudoTableReg];
    ((void) (0));
    ((void) (0));
    u.am.payloadSize = u.am.pReg->n;
    u.am.zRec = u.am.pReg->z;
    u.am.pC->cacheStatus = (pOp->p5&0x20) ? 0 : p->cacheCtr;
    ((void) (0));
  }else{

    u.am.payloadSize = 0;
  }


  if( u.am.payloadSize==0 ){
    ((void) (0));
    goto op_column_out;
  }
  ((void) (0));
  if( u.am.payloadSize > (u32)db->aLimit[0] ){
    goto too_big;
  }

  u.am.nField = u.am.pC->nField;
  ((void) (0));




  u.am.aType = u.am.pC->aType;
  if( u.am.pC->cacheStatus==p->cacheCtr ){
    u.am.aOffset = u.am.pC->aOffset;
  }else{
    ((void) (0));
    u.am.avail = 0;
    u.am.pC->aOffset = u.am.aOffset = &u.am.aType[u.am.nField];
    u.am.pC->payloadSize = u.am.payloadSize;
    u.am.pC->cacheStatus = p->cacheCtr;


    if( u.am.zRec ){
      u.am.zData = u.am.zRec;
    }else{
      if( u.am.pC->isIndex ){
        u.am.zData = (char*)sqlite3BtreeKeyFetch(u.am.pCrsr, &u.am.avail);
      }else{
        u.am.zData = (char*)sqlite3BtreeDataFetch(u.am.pCrsr, &u.am.avail);
      }





      ((void) (0));
      if( u.am.payloadSize <= (u32)u.am.avail ){
        u.am.zRec = u.am.zData;
        u.am.pC->aRow = (u8*)u.am.zData;
      }else{
        u.am.pC->aRow = 0;
      }
    }



    u.am.szHdr = (u8)((*((u8*)u.am.zData)<(u8)0x80) ? ((u.am.offset) = (u32)*((u8*)u.am.zData)),1 : sqlite3GetVarint32(((u8*)u.am.zData), (u32 *)&(u.am.offset)));
# 64450 "ext/sqlite3/libsqlite/sqlite3.c"
    if( u.am.offset > 98307 ){
      rc = sqlite3CorruptError(64451);
      goto op_column_out;
    }
# 64468 "ext/sqlite3/libsqlite/sqlite3.c"
    u.am.len = u.am.nField*5 + 3;
    if( u.am.len > (int)u.am.offset ) u.am.len = (int)u.am.offset;







    if( !u.am.zRec && u.am.avail<u.am.len ){
      u.am.sMem.flags = 0;
      u.am.sMem.db = 0;
      rc = sqlite3VdbeMemFromBtree(u.am.pCrsr, 0, u.am.len, u.am.pC->isIndex, &u.am.sMem);
      if( rc!=0 ){
        goto op_column_out;
      }
      u.am.zData = u.am.sMem.z;
    }
    u.am.zEndHdr = (u8 *)&u.am.zData[u.am.len];
    u.am.zIdx = (u8 *)&u.am.zData[u.am.szHdr];






    for(u.am.i=0; u.am.i<u.am.nField; u.am.i++){
      if( u.am.zIdx<u.am.zEndHdr ){
        u.am.aOffset[u.am.i] = u.am.offset;
        u.am.zIdx += (u8)((*(u.am.zIdx)<(u8)0x80) ? ((u.am.aType[u.am.i]) = (u32)*(u.am.zIdx)),1 : sqlite3GetVarint32((u.am.zIdx), (u32 *)&(u.am.aType[u.am.i])));
        u.am.szField = sqlite3VdbeSerialTypeLen(u.am.aType[u.am.i]);
        u.am.offset += u.am.szField;
        if( u.am.offset<u.am.szField ){
          u.am.zIdx = &u.am.zEndHdr[1];
          break;
        }
      }else{






        u.am.aOffset[u.am.i] = 0;
      }
    }
    sqlite3VdbeMemRelease(&u.am.sMem);
    u.am.sMem.flags = 0x0001;







    if( (u.am.zIdx > u.am.zEndHdr) || (u.am.offset > u.am.payloadSize)
         || (u.am.zIdx==u.am.zEndHdr && u.am.offset!=u.am.payloadSize) ){
      rc = sqlite3CorruptError(64525);
      goto op_column_out;
    }
  }







  if( u.am.aOffset[u.am.p2] ){
    ((void) (0));
    if( u.am.zRec ){
      sqlite3VdbeMemReleaseExternal(u.am.pDest);
      sqlite3VdbeSerialGet((u8 *)&u.am.zRec[u.am.aOffset[u.am.p2]], u.am.aType[u.am.p2], u.am.pDest);
    }else{
      u.am.len = sqlite3VdbeSerialTypeLen(u.am.aType[u.am.p2]);
      sqlite3VdbeMemMove(&u.am.sMem, u.am.pDest);
      rc = sqlite3VdbeMemFromBtree(u.am.pCrsr, u.am.aOffset[u.am.p2], u.am.len, u.am.pC->isIndex, &u.am.sMem);
      if( rc!=0 ){
        goto op_column_out;
      }
      u.am.zData = u.am.sMem.z;
      sqlite3VdbeSerialGet((u8*)u.am.zData, u.am.aType[u.am.p2], u.am.pDest);
    }
    u.am.pDest->enc = encoding;
  }else{
    if( pOp->p4type==(-8) ){
      sqlite3VdbeMemShallowCopy(u.am.pDest, pOp->p4.pMem, 0x0800);
    }else{
      ((void) (0));
    }
  }






  if( u.am.sMem.zMalloc ){
    ((void) (0));
    ((void) (0));
    ((void) (0));
    u.am.pDest->flags &= ~(0x1000|0x0800);
    u.am.pDest->flags |= 0x0200;
    u.am.pDest->z = u.am.sMem.z;
    u.am.pDest->zMalloc = u.am.sMem.zMalloc;
  }

  rc = sqlite3VdbeMemMakeWriteable(u.am.pDest);

op_column_out:
                                 ;
                                     ;
  break;
}
# 64591 "ext/sqlite3/libsqlite/sqlite3.c"
case 29: {





  u.an.zAffinity = pOp->p4.z;
  ((void) (0));
  ((void) (0));
  pIn1 = &aMem[pOp->p1];
  while( (u.an.cAff = *(u.an.zAffinity++))!=0 ){
    ((void) (0));
    ((void) (0));
    (((pIn1)->flags&0x4000)?sqlite3VdbeMemExpandBlob(pIn1):0);
    applyAffinity(pIn1, u.an.cAff, encoding);
    pIn1++;
  }
  break;
}
# 64626 "ext/sqlite3/libsqlite/sqlite3.c"
case 30: {
# 64660 "ext/sqlite3/libsqlite/sqlite3.c"
  u.ao.nData = 0;
  u.ao.nHdr = 0;
  u.ao.nZero = 0;
  u.ao.nField = pOp->p1;
  u.ao.zAffinity = pOp->p4.z;
  ((void) (0));
  u.ao.pData0 = &aMem[u.ao.nField];
  u.ao.nField = pOp->p2;
  u.ao.pLast = &u.ao.pData0[u.ao.nField-1];
  u.ao.file_format = p->minWriteFileFormat;


  ((void) (0));
  pOut = &aMem[pOp->p3];
                           ;




  for(u.ao.pRec=u.ao.pData0; u.ao.pRec<=u.ao.pLast; u.ao.pRec++){
    ((void) (0));
    if( u.ao.zAffinity ){
      applyAffinity(u.ao.pRec, u.ao.zAffinity[u.ao.pRec-u.ao.pData0], encoding);
    }
    if( u.ao.pRec->flags&0x4000 && u.ao.pRec->n>0 ){
      sqlite3VdbeMemExpandBlob(u.ao.pRec);
    }
    u.ao.serial_type = sqlite3VdbeSerialType(u.ao.pRec, u.ao.file_format);
    u.ao.len = sqlite3VdbeSerialTypeLen(u.ao.serial_type);
    u.ao.nData += u.ao.len;
    u.ao.nHdr += sqlite3VarintLen(u.ao.serial_type);
    if( u.ao.pRec->flags & 0x4000 ){


      u.ao.nZero += u.ao.pRec->u.nZero;
    }else if( u.ao.len ){
      u.ao.nZero = 0;
    }
  }


  u.ao.nHdr += u.ao.nVarint = sqlite3VarintLen(u.ao.nHdr);
  if( u.ao.nVarint<sqlite3VarintLen(u.ao.nHdr) ){
    u.ao.nHdr++;
  }
  u.ao.nByte = u.ao.nHdr+u.ao.nData-u.ao.nZero;
  if( u.ao.nByte>db->aLimit[0] ){
    goto too_big;
  }






  if( sqlite3VdbeMemGrow(pOut, (int)u.ao.nByte, 0) ){
    goto no_mem;
  }
  u.ao.zNewRecord = (u8 *)pOut->z;


  u.ao.i = (u8)(((u32)(u.ao.nHdr)<(u32)0x80) ? (*(u.ao.zNewRecord) = (unsigned char)(u.ao.nHdr)),1 : sqlite3PutVarint32((u.ao.zNewRecord), (u.ao.nHdr)));
  for(u.ao.pRec=u.ao.pData0; u.ao.pRec<=u.ao.pLast; u.ao.pRec++){
    u.ao.serial_type = sqlite3VdbeSerialType(u.ao.pRec, u.ao.file_format);
    u.ao.i += (u8)(((u32)(u.ao.serial_type)<(u32)0x80) ? (*(&u.ao.zNewRecord[u.ao.i]) = (unsigned char)(u.ao.serial_type)),1 : sqlite3PutVarint32((&u.ao.zNewRecord[u.ao.i]), (u.ao.serial_type)));
  }
  for(u.ao.pRec=u.ao.pData0; u.ao.pRec<=u.ao.pLast; u.ao.pRec++){
    u.ao.i += sqlite3VdbeSerialPut(&u.ao.zNewRecord[u.ao.i], (int)(u.ao.nByte-u.ao.i), u.ao.pRec,u.ao.file_format);
  }
  ((void) (0));

  ((void) (0));
  pOut->n = (int)u.ao.nByte;
  pOut->flags = 0x0010 | 0x0400;
  pOut->xDel = 0;
  if( u.ao.nZero ){
    pOut->u.nZero = u.ao.nZero;
    pOut->flags |= 0x4000;
  }
  pOut->enc = 1;
                               ;
                           ;
  break;
}







case 31: {





  u.ap.pCrsr = p->apCsr[pOp->p1]->pCursor;
  if( u.ap.pCrsr ){
    rc = sqlite3BtreeCount(u.ap.pCrsr, &u.ap.nEntry);
  }else{
    u.ap.nEntry = 0;
  }
  pOut->u.i = u.ap.nEntry;
  break;
}
# 64774 "ext/sqlite3/libsqlite/sqlite3.c"
case 32: {
# 64786 "ext/sqlite3/libsqlite/sqlite3.c"
  u.aq.p1 = pOp->p1;
  u.aq.zName = pOp->p4.z;




  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( u.aq.p1==0 ){
    if( db->writeVdbeCnt>0 ){



      sqlite3SetString(&p->zErrMsg, db, "cannot open savepoint - "
        "SQL statements in progress");
      rc = 5;
    }else{
      u.aq.nName = sqlite3Strlen30(u.aq.zName);


      u.aq.pNew = sqlite3DbMallocRaw(db, sizeof(Savepoint)+u.aq.nName+1);
      if( u.aq.pNew ){
        u.aq.pNew->zName = (char *)&u.aq.pNew[1];
        memcpy(u.aq.pNew->zName, u.aq.zName, u.aq.nName+1);



        if( db->autoCommit ){
          db->autoCommit = 0;
          db->isTransactionSavepoint = 1;
        }else{
          db->nSavepoint++;
        }


        u.aq.pNew->pNext = db->pSavepoint;
        db->pSavepoint = u.aq.pNew;
        u.aq.pNew->nDeferredCons = db->nDeferredCons;
      }
    }
  }else{
    u.aq.iSavepoint = 0;



    for(
      u.aq.pSavepoint = db->pSavepoint;
      u.aq.pSavepoint && sqlite3StrICmp(u.aq.pSavepoint->zName, u.aq.zName);
      u.aq.pSavepoint = u.aq.pSavepoint->pNext
    ){
      u.aq.iSavepoint++;
    }
    if( !u.aq.pSavepoint ){
      sqlite3SetString(&p->zErrMsg, db, "no such savepoint: %s", u.aq.zName);
      rc = 1;
    }else if(
        db->writeVdbeCnt>0 || (u.aq.p1==2 && db->activeVdbeCnt>1)
    ){




      sqlite3SetString(&p->zErrMsg, db,
        "cannot %s savepoint - SQL statements in progress",
        (u.aq.p1==2 ? "rollback": "release")
      );
      rc = 5;
    }else{





      int isTransaction = u.aq.pSavepoint->pNext==0 && db->isTransactionSavepoint;
      if( isTransaction && u.aq.p1==1 ){
        if( (rc = sqlite3VdbeCheckFk(p, 1))!=0 ){
          goto vdbe_return;
        }
        db->autoCommit = 1;
        if( sqlite3VdbeHalt(p)==5 ){
          p->pc = pc;
          db->autoCommit = 0;
          p->rc = rc = 5;
          goto vdbe_return;
        }
        db->isTransactionSavepoint = 0;
        rc = p->rc;
      }else{
        u.aq.iSavepoint = db->nSavepoint - u.aq.iSavepoint - 1;
        for(u.aq.ii=0; u.aq.ii<db->nDb; u.aq.ii++){
          rc = sqlite3BtreeSavepoint(db->aDb[u.aq.ii].pBt, u.aq.p1, u.aq.iSavepoint);
          if( rc!=0 ){
            goto abort_due_to_error;
          }
        }
        if( u.aq.p1==2 && (db->flags&0x00000200)!=0 ){
          sqlite3ExpirePreparedStatements(db);
          sqlite3ResetInternalSchema(db, -1);
          db->flags = (db->flags | 0x00000200);
        }
      }



      while( db->pSavepoint!=u.aq.pSavepoint ){
        u.aq.pTmp = db->pSavepoint;
        db->pSavepoint = u.aq.pTmp->pNext;
        sqlite3DbFree(db, u.aq.pTmp);
        db->nSavepoint--;
      }





      if( u.aq.p1==1 ){
        ((void) (0));
        db->pSavepoint = u.aq.pSavepoint->pNext;
        sqlite3DbFree(db, u.aq.pSavepoint);
        if( !isTransaction ){
          db->nSavepoint--;
        }
      }else{
        db->nDeferredCons = u.aq.pSavepoint->nDeferredCons;
      }
    }
  }

  break;
}
# 64929 "ext/sqlite3/libsqlite/sqlite3.c"
case 33: {






  u.ar.desiredAutoCommit = pOp->p1;
  u.ar.iRollback = pOp->p2;
  u.ar.turnOnAC = u.ar.desiredAutoCommit && !db->autoCommit;
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( u.ar.turnOnAC && u.ar.iRollback && db->activeVdbeCnt>1 ){




    sqlite3SetString(&p->zErrMsg, db, "cannot rollback transaction - "
        "SQL statements in progress");
    rc = 5;
  }else if( u.ar.turnOnAC && !u.ar.iRollback && db->writeVdbeCnt>0 ){



    sqlite3SetString(&p->zErrMsg, db, "cannot commit transaction - "
        "SQL statements in progress");
    rc = 5;
  }else if( u.ar.desiredAutoCommit!=db->autoCommit ){
    if( u.ar.iRollback ){
      ((void) (0));
      sqlite3RollbackAll(db);
      db->autoCommit = 1;
    }else if( (rc = sqlite3VdbeCheckFk(p, 1))!=0 ){
      goto vdbe_return;
    }else{
      db->autoCommit = (u8)u.ar.desiredAutoCommit;
      if( sqlite3VdbeHalt(p)==5 ){
        p->pc = pc;
        db->autoCommit = (u8)(1-u.ar.desiredAutoCommit);
        p->rc = rc = 5;
        goto vdbe_return;
      }
    }
    ((void) (0));
    sqlite3CloseSavepoints(db);
    if( p->rc==0 ){
      rc = 101;
    }else{
      rc = 1;
    }
    goto vdbe_return;
  }else{
    sqlite3SetString(&p->zErrMsg, db,
        (!u.ar.desiredAutoCommit)?"cannot start a transaction within a transaction":(
        (u.ar.iRollback)?"cannot rollback - no transaction is active":
                   "cannot commit - no transaction is active"));

    rc = 1;
  }
  break;
}
# 65024 "ext/sqlite3/libsqlite/sqlite3.c"
case 34: {




  ((void) (0));
  ((void) (0));
  u.as.pBt = db->aDb[pOp->p1].pBt;

  if( u.as.pBt ){
    rc = sqlite3BtreeBeginTrans(u.as.pBt, pOp->p2);
    if( rc==5 ){
      p->pc = pc;
      p->rc = rc = 5;
      goto vdbe_return;
    }
    if( rc!=0 ){
      goto abort_due_to_error;
    }

    if( pOp->p2 && p->usesStmtJournal
     && (db->autoCommit==0 || db->activeVdbeCnt>1)
    ){
      ((void) (0));
      if( p->iStatement==0 ){
        ((void) (0));
        db->nStatement++;
        p->iStatement = db->nSavepoint + db->nStatement;
      }
      rc = sqlite3BtreeBeginStmt(u.as.pBt, p->iStatement);




      p->nStmtDefCons = db->nDeferredCons;
    }
  }
  break;
}
# 65076 "ext/sqlite3/libsqlite/sqlite3.c"
case 35: {






  u.at.iDb = pOp->p1;
  u.at.iCookie = pOp->p3;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  sqlite3BtreeGetMeta(db->aDb[u.at.iDb].pBt, u.at.iCookie, (u32 *)&u.at.iMeta);
  pOut->u.i = u.at.iMeta;
  break;
}
# 65105 "ext/sqlite3/libsqlite/sqlite3.c"
case 36: {



  ((void) (0));
  ((void) (0));
  ((void) (0));
  u.au.pDb = &db->aDb[pOp->p1];
  ((void) (0));
  ((void) (0));
  pIn3 = &aMem[pOp->p3];
  sqlite3VdbeMemIntegerify(pIn3);

  rc = sqlite3BtreeUpdateMeta(u.au.pDb->pBt, pOp->p2, (int)pIn3->u.i);
  if( pOp->p2==1 ){

    u.au.pDb->pSchema->schema_cookie = (int)pIn3->u.i;
    db->flags |= 0x00000200;
  }else if( pOp->p2==2 ){

    u.au.pDb->pSchema->file_format = (u8)pIn3->u.i;
  }
  if( pOp->p1==1 ){


    sqlite3ExpirePreparedStatements(db);
    p->expired = 0;
  }
  break;
}
# 65154 "ext/sqlite3/libsqlite/sqlite3.c"
case 37: {






  ((void) (0));
  ((void) (0));
  ((void) (0));
  u.av.pBt = db->aDb[pOp->p1].pBt;
  if( u.av.pBt ){
    sqlite3BtreeGetMeta(u.av.pBt, 1, (u32 *)&u.av.iMeta);
    u.av.iGen = db->aDb[pOp->p1].pSchema->iGeneration;
  }else{
    u.av.iGen = u.av.iMeta = 0;
  }
  if( u.av.iMeta!=pOp->p2 || u.av.iGen!=pOp->p3 ){
    sqlite3DbFree(db, p->zErrMsg);
    p->zErrMsg = sqlite3DbStrDup(db, "database schema has changed");
# 65187 "ext/sqlite3/libsqlite/sqlite3.c"
    if( db->aDb[pOp->p1].pSchema->schema_cookie!=u.av.iMeta ){
      sqlite3ResetInternalSchema(db, pOp->p1);
    }

    p->expired = 1;
    rc = 17;
  }
  break;
}
# 65246 "ext/sqlite3/libsqlite/sqlite3.c"
case 38:
case 39: {
# 65259 "ext/sqlite3/libsqlite/sqlite3.c"
  if( p->expired ){
    rc = 4;
    break;
  }

  u.aw.nField = 0;
  u.aw.pKeyInfo = 0;
  u.aw.p2 = pOp->p2;
  u.aw.iDb = pOp->p3;
  ((void) (0));
  ((void) (0));
  u.aw.pDb = &db->aDb[u.aw.iDb];
  u.aw.pX = u.aw.pDb->pBt;
  ((void) (0));
  if( pOp->opcode==39 ){
    u.aw.wrFlag = 1;
    ((void) (0));
    if( u.aw.pDb->pSchema->file_format < p->minWriteFileFormat ){
      p->minWriteFileFormat = u.aw.pDb->pSchema->file_format;
    }
  }else{
    u.aw.wrFlag = 0;
  }
  if( pOp->p5 ){
    ((void) (0));
    ((void) (0));
    pIn2 = &aMem[u.aw.p2];
    ((void) (0));
    ((void) (0));
    sqlite3VdbeMemIntegerify(pIn2);
    u.aw.p2 = (int)pIn2->u.i;




    if( (u.aw.p2<2) ) {
      rc = sqlite3CorruptError(65295);
      goto abort_due_to_error;
    }
  }
  if( pOp->p4type==(-6) ){
    u.aw.pKeyInfo = pOp->p4.pKeyInfo;
    u.aw.pKeyInfo->enc = ((p->db)->aDb[0].pSchema->enc);
    u.aw.nField = u.aw.pKeyInfo->nField+1;
  }else if( pOp->p4type==(-14) ){
    u.aw.nField = pOp->p4.i;
  }
  ((void) (0));
  u.aw.pCur = allocateCursor(p, pOp->p1, u.aw.nField, u.aw.iDb, 1);
  if( u.aw.pCur==0 ) goto no_mem;
  u.aw.pCur->nullRow = 1;
  u.aw.pCur->isOrdered = 1;
  rc = sqlite3BtreeCursor(u.aw.pX, u.aw.p2, u.aw.wrFlag, u.aw.pKeyInfo, u.aw.pCur->pCursor);
  u.aw.pCur->pKeyInfo = u.aw.pKeyInfo;





  ((void) (0));
  if( rc==16 ){
    u.aw.pCur->pCursor = 0;
    rc = 0;
  }





  u.aw.pCur->isTable = pOp->p4type!=(-6);
  u.aw.pCur->isIndex = !u.aw.pCur->isTable;
  break;
}
# 65358 "ext/sqlite3/libsqlite/sqlite3.c"
case 40:
case 41: {



  static const int vfsFlags =
      0x00000002 |
      0x00000004 |
      0x00000010 |
      0x00000008 |
      0x00000400;

  ((void) (0));
  u.ax.pCx = allocateCursor(p, pOp->p1, pOp->p2, -1, 1);
  if( u.ax.pCx==0 ) goto no_mem;
  u.ax.pCx->nullRow = 1;
  rc = sqlite3BtreeOpen(0, db, &u.ax.pCx->pBt,
                        1 | 8 | pOp->p5, vfsFlags);
  if( rc==0 ){
    rc = sqlite3BtreeBeginTrans(u.ax.pCx->pBt, 1);
  }
  if( rc==0 ){





    if( pOp->p4.pKeyInfo ){
      int pgno;
      ((void) (0));
      rc = sqlite3BtreeCreateTable(u.ax.pCx->pBt, &pgno, 2);
      if( rc==0 ){
        ((void) (0));
        rc = sqlite3BtreeCursor(u.ax.pCx->pBt, pgno, 1,
                                (KeyInfo*)pOp->p4.z, u.ax.pCx->pCursor);
        u.ax.pCx->pKeyInfo = pOp->p4.pKeyInfo;
        u.ax.pCx->pKeyInfo->enc = ((p->db)->aDb[0].pSchema->enc);
      }
      u.ax.pCx->isTable = 0;
    }else{
      rc = sqlite3BtreeCursor(u.ax.pCx->pBt, 1, 1, 0, u.ax.pCx->pCursor);
      u.ax.pCx->isTable = 1;
    }
  }
  u.ax.pCx->isOrdered = (pOp->p5!=16);
  u.ax.pCx->isIndex = !u.ax.pCx->isTable;
  break;
}
# 65422 "ext/sqlite3/libsqlite/sqlite3.c"
case 42: {




  ((void) (0));
  u.ay.pCx = allocateCursor(p, pOp->p1, pOp->p3, -1, 0);
  if( u.ay.pCx==0 ) goto no_mem;
  u.ay.pCx->nullRow = 1;
  u.ay.pCx->pseudoTableReg = pOp->p2;
  u.ay.pCx->isTable = 1;
  u.ay.pCx->isIndex = 0;
  break;
}






case 43: {
  ((void) (0));
  sqlite3VdbeFreeCursor(p, p->apCsr[pOp->p1]);
  p->apCsr[pOp->p1] = 0;
  break;
}
# 65501 "ext/sqlite3/libsqlite/sqlite3.c"
case 44:
case 45:
case 46:
case 47: {
# 65514 "ext/sqlite3/libsqlite/sqlite3.c"
  ((void) (0));
  ((void) (0));
  u.az.pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( u.az.pC->pCursor!=0 ){
    u.az.oc = pOp->opcode;
    u.az.pC->nullRow = 0;
    if( u.az.pC->isTable ){



      pIn3 = &aMem[pOp->p3];
      applyNumericAffinity(pIn3);
      u.az.iKey = sqlite3VdbeIntValue(pIn3);
      u.az.pC->rowidIsValid = 0;



      if( (pIn3->flags & 0x0004)==0 ){
        if( (pIn3->flags & 0x0008)==0 ){


          pc = pOp->p2 - 1;
          break;
        }


        ((void) (0));

        if( u.az.iKey==(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) && (pIn3->r<(double)u.az.iKey || pIn3->r>0) ){


          u.az.res = 1;
          if( pIn3->r<0 ){
            if( u.az.oc>=46 ){ ((void) (0));
              rc = sqlite3BtreeFirst(u.az.pC->pCursor, &u.az.res);
              if( rc!=0 ) goto abort_due_to_error;
            }
          }else{
            if( u.az.oc<=45 ){ ((void) (0));
              rc = sqlite3BtreeLast(u.az.pC->pCursor, &u.az.res);
              if( rc!=0 ) goto abort_due_to_error;
            }
          }
          if( u.az.res ){
            pc = pOp->p2 - 1;
          }
          break;
        }else if( u.az.oc==44 || u.az.oc==46 ){

          if( pIn3->r > (double)u.az.iKey ) u.az.iKey++;
        }else{

          ((void) (0));
          if( pIn3->r < (double)u.az.iKey ) u.az.iKey--;
        }
      }
      rc = sqlite3BtreeMovetoUnpacked(u.az.pC->pCursor, 0, (u64)u.az.iKey, 0, &u.az.res);
      if( rc!=0 ){
        goto abort_due_to_error;
      }
      if( u.az.res==0 ){
        u.az.pC->rowidIsValid = 1;
        u.az.pC->lastRowid = u.az.iKey;
      }
    }else{
      u.az.nField = pOp->p4.i;
      ((void) (0));
      ((void) (0));
      u.az.r.pKeyInfo = u.az.pC->pKeyInfo;
      u.az.r.nField = (u16)u.az.nField;
# 65598 "ext/sqlite3/libsqlite/sqlite3.c"
      u.az.r.flags = (u16)(0x0008 * (1 & (u.az.oc - 44)));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));

      u.az.r.aMem = &aMem[pOp->p3];



      (((u.az.r.aMem)->flags&0x4000)?sqlite3VdbeMemExpandBlob(u.az.r.aMem):0);
      rc = sqlite3BtreeMovetoUnpacked(u.az.pC->pCursor, &u.az.r, 0, 0, &u.az.res);
      if( rc!=0 ){
        goto abort_due_to_error;
      }
      u.az.pC->rowidIsValid = 0;
    }
    u.az.pC->deferredMoveto = 0;
    u.az.pC->cacheStatus = 0;



    if( u.az.oc>=46 ){ ((void) (0));
      if( u.az.res<0 || (u.az.res==0 && u.az.oc==47) ){
        rc = sqlite3BtreeNext(u.az.pC->pCursor, &u.az.res);
        if( rc!=0 ) goto abort_due_to_error;
        u.az.pC->rowidIsValid = 0;
      }else{
        u.az.res = 0;
      }
    }else{
      ((void) (0));
      if( u.az.res>0 || (u.az.res==0 && u.az.oc==44) ){
        rc = sqlite3BtreePrevious(u.az.pC->pCursor, &u.az.res);
        if( rc!=0 ) goto abort_due_to_error;
        u.az.pC->rowidIsValid = 0;
      }else{



        u.az.res = sqlite3BtreeEof(u.az.pC->pCursor);
      }
    }
    ((void) (0));
    if( u.az.res ){
      pc = pOp->p2 - 1;
    }
  }else{




    pc = pOp->p2 - 1;
  }
  break;
}
# 65664 "ext/sqlite3/libsqlite/sqlite3.c"
case 48: {




  ((void) (0));
  u.ba.pC = p->apCsr[pOp->p1];
  ((void) (0));
  if( (u.ba.pC->pCursor!=0) ){
    ((void) (0));
    u.ba.pC->nullRow = 0;
    pIn2 = &aMem[pOp->p2];
    u.ba.pC->movetoTarget = sqlite3VdbeIntValue(pIn2);
    u.ba.pC->rowidIsValid = 0;
    u.ba.pC->deferredMoveto = 1;
  }
  break;
}
# 65708 "ext/sqlite3/libsqlite/sqlite3.c"
case 49:
case 50: {
# 65723 "ext/sqlite3/libsqlite/sqlite3.c"
  u.bb.alreadyExists = 0;
  ((void) (0));
  ((void) (0));
  u.bb.pC = p->apCsr[pOp->p1];
  ((void) (0));
  pIn3 = &aMem[pOp->p3];
  if( (u.bb.pC->pCursor!=0) ){

    ((void) (0));
    if( pOp->p4.i>0 ){
      u.bb.r.pKeyInfo = u.bb.pC->pKeyInfo;
      u.bb.r.nField = (u16)pOp->p4.i;
      u.bb.r.aMem = pIn3;



      u.bb.r.flags = 0x0010;
      u.bb.pIdxKey = &u.bb.r;
    }else{
      ((void) (0));
      ((void) (0));
      u.bb.pIdxKey = sqlite3VdbeRecordUnpack(u.bb.pC->pKeyInfo, pIn3->n, pIn3->z,
                                        u.bb.aTempRec, sizeof(u.bb.aTempRec));
      if( u.bb.pIdxKey==0 ){
        goto no_mem;
      }
      u.bb.pIdxKey->flags |= 0x0010;
    }
    rc = sqlite3BtreeMovetoUnpacked(u.bb.pC->pCursor, u.bb.pIdxKey, 0, 0, &u.bb.res);
    if( pOp->p4.i==0 ){
      sqlite3VdbeDeleteUnpackedRecord(u.bb.pIdxKey);
    }
    if( rc!=0 ){
      break;
    }
    u.bb.alreadyExists = (u.bb.res==0);
    u.bb.pC->deferredMoveto = 0;
    u.bb.pC->cacheStatus = 0;
  }
  if( pOp->opcode==50 ){
    if( u.bb.alreadyExists ) pc = pOp->p2 - 1;
  }else{
    if( !u.bb.alreadyExists ) pc = pOp->p2 - 1;
  }
  break;
}
# 65796 "ext/sqlite3/libsqlite/sqlite3.c"
case 51: {
# 65807 "ext/sqlite3/libsqlite/sqlite3.c"
  pIn3 = &aMem[pOp->p3];
  u.bc.aMx = &aMem[pOp->p4.i];

  ((void) (0));
  ((void) (0));
  ((void) (0));


  u.bc.pCx = p->apCsr[pOp->p1];
  ((void) (0));
  u.bc.pCx->seekResult = 0;
  u.bc.pCx->cacheStatus = 0;
  u.bc.pCrsr = u.bc.pCx->pCursor;


  u.bc.nField = u.bc.pCx->pKeyInfo->nField;
  for(u.bc.ii=0; u.bc.ii<u.bc.nField; u.bc.ii++){
    if( u.bc.aMx[u.bc.ii].flags & 0x0001 ){
      pc = pOp->p2 - 1;
      u.bc.pCrsr = 0;
      break;
    }
  }
  ((void) (0));

  if( u.bc.pCrsr!=0 ){

    u.bc.r.pKeyInfo = u.bc.pCx->pKeyInfo;
    u.bc.r.nField = u.bc.nField + 1;
    u.bc.r.flags = 0x0020;
    u.bc.r.aMem = u.bc.aMx;





    sqlite3VdbeMemIntegerify(pIn3);
    u.bc.R = pIn3->u.i;




    rc = sqlite3BtreeMovetoUnpacked(u.bc.pCrsr, &u.bc.r, 0, 0, &u.bc.pCx->seekResult);
    if( (u.bc.r.flags & 0x0020) || u.bc.r.rowid==u.bc.R ){
      pc = pOp->p2 - 1;
    }else{
      pIn3->u.i = u.bc.r.rowid;
    }
  }
  break;
}
# 65873 "ext/sqlite3/libsqlite/sqlite3.c"
case 52: {







  pIn3 = &aMem[pOp->p3];
  ((void) (0));
  ((void) (0));
  u.bd.pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  ((void) (0));
  u.bd.pCrsr = u.bd.pC->pCursor;
  if( u.bd.pCrsr!=0 ){
    u.bd.res = 0;
    u.bd.iKey = pIn3->u.i;
    rc = sqlite3BtreeMovetoUnpacked(u.bd.pCrsr, 0, u.bd.iKey, 0, &u.bd.res);
    u.bd.pC->lastRowid = pIn3->u.i;
    u.bd.pC->rowidIsValid = u.bd.res==0 ?1:0;
    u.bd.pC->nullRow = 0;
    u.bd.pC->cacheStatus = 0;
    u.bd.pC->deferredMoveto = 0;
    if( u.bd.res!=0 ){
      pc = pOp->p2 - 1;
      ((void) (0));
    }
    u.bd.pC->seekResult = u.bd.res;
  }else{



    pc = pOp->p2 - 1;
    ((void) (0));
    u.bd.pC->seekResult = 0;
  }
  break;
}
# 65921 "ext/sqlite3/libsqlite/sqlite3.c"
case 53: {
  ((void) (0));
  ((void) (0));
  pOut->u.i = p->apCsr[pOp->p1]->seqCount++;
  break;
}
# 65943 "ext/sqlite3/libsqlite/sqlite3.c"
case 54: {
# 65953 "ext/sqlite3/libsqlite/sqlite3.c"
  u.be.v = 0;
  u.be.res = 0;
  ((void) (0));
  u.be.pC = p->apCsr[pOp->p1];
  ((void) (0));
  if( (u.be.pC->pCursor==0) ){

  }else{
# 65974 "ext/sqlite3/libsqlite/sqlite3.c"
    ((void) (0));
# 65986 "ext/sqlite3/libsqlite/sqlite3.c"
    if( !u.be.pC->useRandomRowid ){
      u.be.v = sqlite3BtreeGetCachedRowid(u.be.pC->pCursor);
      if( u.be.v==0 ){
        rc = sqlite3BtreeLast(u.be.pC->pCursor, &u.be.res);
        if( rc!=0 ){
          goto abort_due_to_error;
        }
        if( u.be.res ){
          u.be.v = 1;
        }else{
          ((void) (0));
          rc = sqlite3BtreeKeySize(u.be.pC->pCursor, &u.be.v);
          ((void) (0));
          if( u.be.v==(i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff ) ){
            u.be.pC->useRandomRowid = 1;
          }else{
            u.be.v++;
          }
        }
      }


      if( pOp->p3 ){

        ((void) (0));
        if( p->pFrame ){
          for(u.be.pFrame=p->pFrame; u.be.pFrame->pParent; u.be.pFrame=u.be.pFrame->pParent);

          ((void) (0));
          u.be.pMem = &u.be.pFrame->aMem[pOp->p3];
        }else{

          ((void) (0));
          u.be.pMem = &aMem[pOp->p3];
                                        ;
        }
        ((void) (0));

                                          ;
        sqlite3VdbeMemIntegerify(u.be.pMem);
        ((void) (0));
        if( u.be.pMem->u.i==(i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff ) || u.be.pC->useRandomRowid ){
          rc = 13;
          goto abort_due_to_error;
        }
        if( u.be.v<u.be.pMem->u.i+1 ){
          u.be.v = u.be.pMem->u.i + 1;
        }
        u.be.pMem->u.i = u.be.v;
      }


      sqlite3BtreeSetCachedRowid(u.be.pC->pCursor, u.be.v<(i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff ) ? u.be.v+1 : 0);
    }
    if( u.be.pC->useRandomRowid ){




      ((void) (0));


      u.be.v = db->lastRowid;
      u.be.v &= ((i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff )>>1);
      u.be.v++;
      u.be.cnt = 0;
      while( ((rc = sqlite3BtreeMovetoUnpacked(u.be.pC->pCursor, 0, (u64)u.be.v,
                                                 0, &u.be.res))==0)
            && (u.be.res==0)
            && (++u.be.cnt<100)){

        sqlite3_randomness(sizeof(u.be.v), &u.be.v);
        if( u.be.cnt<5 ){

          u.be.v &= 0xffffff;
        }else{
          u.be.v &= ((i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff )>>1);
        }
        u.be.v++;
      }
      if( rc==0 && u.be.res==0 ){
        rc = 13;
        goto abort_due_to_error;
      }
      ((void) (0));
    }
    u.be.pC->rowidIsValid = 0;
    u.be.pC->deferredMoveto = 0;
    u.be.pC->cacheStatus = 0;
  }
  pOut->u.i = u.be.v;
  break;
}
# 66124 "ext/sqlite3/libsqlite/sqlite3.c"
case 55:
case 56: {
# 66138 "ext/sqlite3/libsqlite/sqlite3.c"
  u.bf.pData = &aMem[pOp->p2];
  ((void) (0));
  ((void) (0));
  u.bf.pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
                                     ;

  if( pOp->opcode==55 ){
    u.bf.pKey = &aMem[pOp->p3];
    ((void) (0));
    ((void) (0));
                                      ;
    u.bf.iKey = u.bf.pKey->u.i;
  }else{
    ((void) (0));
    u.bf.iKey = pOp->p3;
  }

  if( pOp->p5 & 0x01 ) p->nChange++;
  if( pOp->p5 & 0x02 ) db->lastRowid = u.bf.iKey;
  if( u.bf.pData->flags & 0x0001 ){
    u.bf.pData->z = 0;
    u.bf.pData->n = 0;
  }else{
    ((void) (0));
  }
  u.bf.seekResult = ((pOp->p5 & 0x10) ? u.bf.pC->seekResult : 0);
  if( u.bf.pData->flags & 0x4000 ){
    u.bf.nZero = u.bf.pData->u.nZero;
  }else{
    u.bf.nZero = 0;
  }
  sqlite3BtreeSetCachedRowid(u.bf.pC->pCursor, 0);
  rc = sqlite3BtreeInsert(u.bf.pC->pCursor, 0, u.bf.iKey,
                          u.bf.pData->z, u.bf.pData->n, u.bf.nZero,
                          pOp->p5 & 0x08, u.bf.seekResult
  );
  u.bf.pC->rowidIsValid = 0;
  u.bf.pC->deferredMoveto = 0;
  u.bf.pC->cacheStatus = 0;


  if( rc==0 && db->xUpdateCallback && pOp->p4.z ){
    u.bf.zDb = db->aDb[u.bf.pC->iDb].zName;
    u.bf.zTbl = pOp->p4.z;
    u.bf.op = ((pOp->p5 & 0x04) ? 23 : 18);
    ((void) (0));
    db->xUpdateCallback(db->pUpdateArg, u.bf.op, u.bf.zDb, u.bf.zTbl, u.bf.iKey);
    ((void) (0));
  }
  break;
}
# 66214 "ext/sqlite3/libsqlite/sqlite3.c"
case 57: {





  u.bg.iKey = 0;
  ((void) (0));
  u.bg.pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));




  if( db->xUpdateCallback && pOp->p4.z ){
    ((void) (0));
    ((void) (0));
    u.bg.iKey = u.bg.pC->lastRowid;
  }
# 66242 "ext/sqlite3/libsqlite/sqlite3.c"
  ((void) (0));
  rc = sqlite3VdbeCursorMoveto(u.bg.pC);
  if( (rc!=0) ) goto abort_due_to_error;

  sqlite3BtreeSetCachedRowid(u.bg.pC->pCursor, 0);
  rc = sqlite3BtreeDelete(u.bg.pC->pCursor);
  u.bg.pC->cacheStatus = 0;


  if( rc==0 && db->xUpdateCallback && pOp->p4.z ){
    const char *zDb = db->aDb[u.bg.pC->iDb].zName;
    const char *zTbl = pOp->p4.z;
    db->xUpdateCallback(db->pUpdateArg, 9, zDb, zTbl, u.bg.iKey);
    ((void) (0));
  }
  if( pOp->p2 & 0x01 ) p->nChange++;
  break;
}







case 58: {
  sqlite3VdbeSetChanges(db, p->nChange);
  p->nChange = 0;
  break;
}
# 66293 "ext/sqlite3/libsqlite/sqlite3.c"
case 59:
case 60: {







  pOut = &aMem[pOp->p2];
                           ;


  ((void) (0));
  u.bh.pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  u.bh.pCrsr = u.bh.pC->pCursor;
  ((void) (0));






  ((void) (0));
  rc = sqlite3VdbeCursorMoveto(u.bh.pC);
  if( (rc!=0) ) goto abort_due_to_error;

  if( u.bh.pC->isIndex ){
    ((void) (0));
    rc = sqlite3BtreeKeySize(u.bh.pCrsr, &u.bh.n64);
    ((void) (0));
    if( u.bh.n64>db->aLimit[0] ){
      goto too_big;
    }
    u.bh.n = (u32)u.bh.n64;
  }else{
    rc = sqlite3BtreeDataSize(u.bh.pCrsr, &u.bh.n);
    ((void) (0));
    if( u.bh.n>(u32)db->aLimit[0] ){
      goto too_big;
    }
  }
  if( sqlite3VdbeMemGrow(pOut, u.bh.n, 0) ){
    goto no_mem;
  }
  pOut->n = u.bh.n;
  ((pOut)->flags = ((pOut)->flags&~(0x00ff|0x4000))|0x0010);
  if( u.bh.pC->isIndex ){
    rc = sqlite3BtreeKey(u.bh.pCrsr, 0, u.bh.n, pOut->z);
  }else{
    rc = sqlite3BtreeData(u.bh.pCrsr, 0, u.bh.n, pOut->z);
  }
  pOut->enc = 1;
                           ;
  break;
}
# 66365 "ext/sqlite3/libsqlite/sqlite3.c"
case 61: {







  ((void) (0));
  u.bi.pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  if( u.bi.pC->nullRow ){
    pOut->flags = 0x0001;
    break;
  }else if( u.bi.pC->deferredMoveto ){
    u.bi.v = u.bi.pC->movetoTarget;

  }else if( u.bi.pC->pVtabCursor ){
    u.bi.pVtab = u.bi.pC->pVtabCursor->pVtab;
    u.bi.pModule = u.bi.pVtab->pModule;
    ((void) (0));
    rc = u.bi.pModule->xRowid(u.bi.pC->pVtabCursor, &u.bi.v);
    importVtabErrMsg(p, u.bi.pVtab);

  }else{
    ((void) (0));
    rc = sqlite3VdbeCursorMoveto(u.bi.pC);
    if( rc ) goto abort_due_to_error;
    if( u.bi.pC->rowidIsValid ){
      u.bi.v = u.bi.pC->lastRowid;
    }else{
      rc = sqlite3BtreeKeySize(u.bi.pC->pCursor, &u.bi.v);
      ((void) (0));
    }
  }
  pOut->u.i = u.bi.v;
  break;
}







case 62: {




  ((void) (0));
  u.bj.pC = p->apCsr[pOp->p1];
  ((void) (0));
  u.bj.pC->nullRow = 1;
  u.bj.pC->rowidIsValid = 0;
  if( u.bj.pC->pCursor ){
    sqlite3BtreeClearCursor(u.bj.pC->pCursor);
  }
  break;
}
# 66435 "ext/sqlite3/libsqlite/sqlite3.c"
case 63: {






  ((void) (0));
  u.bk.pC = p->apCsr[pOp->p1];
  ((void) (0));
  u.bk.pCrsr = u.bk.pC->pCursor;
  if( u.bk.pCrsr==0 ){
    u.bk.res = 1;
  }else{
    rc = sqlite3BtreeLast(u.bk.pCrsr, &u.bk.res);
  }
  u.bk.pC->nullRow = (u8)u.bk.res;
  u.bk.pC->deferredMoveto = 0;
  u.bk.pC->rowidIsValid = 0;
  u.bk.pC->cacheStatus = 0;
  if( pOp->p2>0 && u.bk.res ){
    pc = pOp->p2 - 1;
  }
  break;
}
# 66474 "ext/sqlite3/libsqlite/sqlite3.c"
case 64: {




  p->aCounter[2 -1]++;

}
# 66490 "ext/sqlite3/libsqlite/sqlite3.c"
case 65: {






  ((void) (0));
  u.bl.pC = p->apCsr[pOp->p1];
  ((void) (0));
  u.bl.res = 1;
  if( (u.bl.pCrsr = u.bl.pC->pCursor)!=0 ){
    rc = sqlite3BtreeFirst(u.bl.pCrsr, &u.bl.res);
    u.bl.pC->atFirst = u.bl.res==0 ?1:0;
    u.bl.pC->deferredMoveto = 0;
    u.bl.pC->cacheStatus = 0;
    u.bl.pC->rowidIsValid = 0;
  }
  u.bl.pC->nullRow = (u8)u.bl.res;
  ((void) (0));
  if( u.bl.res ){
    pc = pOp->p2 - 1;
  }
  break;
}
# 66542 "ext/sqlite3/libsqlite/sqlite3.c"
case 66:
case 67: {






  if( db->u1.isInterrupted ) goto abort_due_to_interrupt;;
  ((void) (0));
  ((void) (0));
  u.bm.pC = p->apCsr[pOp->p1];
  if( u.bm.pC==0 ){
    break;
  }
  u.bm.pCrsr = u.bm.pC->pCursor;
  if( u.bm.pCrsr==0 ){
    u.bm.pC->nullRow = 1;
    break;
  }
  u.bm.res = 1;
  ((void) (0));
  rc = pOp->opcode==67 ? sqlite3BtreeNext(u.bm.pCrsr, &u.bm.res) :
                              sqlite3BtreePrevious(u.bm.pCrsr, &u.bm.res);
  u.bm.pC->nullRow = (u8)u.bm.res;
  u.bm.pC->cacheStatus = 0;
  if( u.bm.res==0 ){
    pc = pOp->p2 - 1;
    if( pOp->p5 ) p->aCounter[pOp->p5-1]++;



  }
  u.bm.pC->rowidIsValid = 0;
  break;
}
# 66591 "ext/sqlite3/libsqlite/sqlite3.c"
case 70: {







  ((void) (0));
  u.bn.pC = p->apCsr[pOp->p1];
  ((void) (0));
  pIn2 = &aMem[pOp->p2];
  ((void) (0));
  u.bn.pCrsr = u.bn.pC->pCursor;
  if( (u.bn.pCrsr!=0) ){
    ((void) (0));
    rc = (((pIn2)->flags&0x4000)?sqlite3VdbeMemExpandBlob(pIn2):0);
    if( rc==0 ){
      u.bn.nKey = pIn2->n;
      u.bn.zKey = pIn2->z;
      rc = sqlite3BtreeInsert(u.bn.pCrsr, u.bn.zKey, u.bn.nKey, "", 0, 0, pOp->p3,
          ((pOp->p5 & 0x10) ? u.bn.pC->seekResult : 0)
      );
      ((void) (0));
      u.bn.pC->cacheStatus = 0;
    }
  }
  break;
}







case 71: {







  ((void) (0));
  ((void) (0));
  ((void) (0));
  u.bo.pC = p->apCsr[pOp->p1];
  ((void) (0));
  u.bo.pCrsr = u.bo.pC->pCursor;
  if( (u.bo.pCrsr!=0) ){
    u.bo.r.pKeyInfo = u.bo.pC->pKeyInfo;
    u.bo.r.nField = (u16)pOp->p3;
    u.bo.r.flags = 0;
    u.bo.r.aMem = &aMem[pOp->p2];



    rc = sqlite3BtreeMovetoUnpacked(u.bo.pCrsr, &u.bo.r, 0, 0, &u.bo.res);
    if( rc==0 && u.bo.res==0 ){
      rc = sqlite3BtreeDelete(u.bo.pCrsr);
    }
    ((void) (0));
    u.bo.pC->cacheStatus = 0;
  }
  break;
}
# 66667 "ext/sqlite3/libsqlite/sqlite3.c"
case 72: {






  ((void) (0));
  u.bp.pC = p->apCsr[pOp->p1];
  ((void) (0));
  u.bp.pCrsr = u.bp.pC->pCursor;
  pOut->flags = 0x0001;
  if( (u.bp.pCrsr!=0) ){
    rc = sqlite3VdbeCursorMoveto(u.bp.pC);
    if( (rc) ) goto abort_due_to_error;
    ((void) (0));
    ((void) (0));
    if( !u.bp.pC->nullRow ){
      rc = sqlite3VdbeIdxRowid(db, u.bp.pCrsr, &u.bp.rowid);
      if( rc!=0 ){
        goto abort_due_to_error;
      }
      pOut->u.i = u.bp.rowid;
      pOut->flags = 0x0004;
    }
  }
  break;
}
# 66722 "ext/sqlite3/libsqlite/sqlite3.c"
case 81:
case 92: {






  ((void) (0));
  u.bq.pC = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  if( (u.bq.pC->pCursor!=0) ){
    ((void) (0));
    ((void) (0));
    ((void) (0));
    u.bq.r.pKeyInfo = u.bq.pC->pKeyInfo;
    u.bq.r.nField = (u16)pOp->p4.i;
    if( pOp->p5 ){
      u.bq.r.flags = 0x0008 | 0x0004;
    }else{
      u.bq.r.flags = 0x0004;
    }
    u.bq.r.aMem = &aMem[pOp->p3];



    rc = sqlite3VdbeIdxKeyCompare(u.bq.pC, &u.bq.r, &u.bq.res);
    if( pOp->opcode==81 ){
      u.bq.res = -u.bq.res;
    }else{
      ((void) (0));
      u.bq.res++;
    }
    if( u.bq.res>0 ){
      pc = pOp->p2 - 1 ;
    }
  }
  break;
}
# 66783 "ext/sqlite3/libsqlite/sqlite3.c"
case 95: {







  u.br.iCnt = 0;
  for(u.br.pVdbe=db->pVdbe; u.br.pVdbe; u.br.pVdbe = u.br.pVdbe->pNext){
    if( u.br.pVdbe->magic==0xbdf20da3 && u.br.pVdbe->inVtabMethod<2 && u.br.pVdbe->pc>=0 ){
      u.br.iCnt++;
    }
  }



  pOut->flags = 0x0001;
  if( u.br.iCnt>1 ){
    rc = 6;
    p->errorAction = 2;
  }else{
    u.br.iDb = pOp->p3;
    ((void) (0));
    ((void) (0));
    rc = sqlite3BtreeDropTable(db->aDb[u.br.iDb].pBt, pOp->p1, &u.br.iMoved);
    pOut->flags = 0x0004;
    pOut->u.i = u.br.iMoved;

    if( rc==0 && u.br.iMoved!=0 ){
      sqlite3RootPageMoved(db, u.br.iDb, u.br.iMoved, pOp->p1);

      ((void) (0));
      resetSchemaOnFault = u.br.iDb+1;
    }

  }
  break;
}
# 66841 "ext/sqlite3/libsqlite/sqlite3.c"
case 96: {




  u.bs.nChange = 0;
  ((void) (0));
  rc = sqlite3BtreeClearTable(
      db->aDb[pOp->p2].pBt, pOp->p1, (pOp->p3 ? &u.bs.nChange : 0)
  );
  if( pOp->p3 ){
    p->nChange += u.bs.nChange;
    if( pOp->p3>0 ){
      ((void) (0));
                                         ;
      aMem[pOp->p3].u.i += u.bs.nChange;
    }
  }
  break;
}
# 66884 "ext/sqlite3/libsqlite/sqlite3.c"
case 97:
case 98: {






  u.bt.pgno = 0;
  ((void) (0));
  ((void) (0));
  u.bt.pDb = &db->aDb[pOp->p1];
  ((void) (0));
  if( pOp->opcode==98 ){

    u.bt.flags = 1;
  }else{
    u.bt.flags = 2;
  }
  rc = sqlite3BtreeCreateTable(u.bt.pDb->pBt, &u.bt.pgno, u.bt.flags);
  pOut->u.i = u.bt.pgno;
  break;
}
# 66916 "ext/sqlite3/libsqlite/sqlite3.c"
case 99: {
# 66934 "ext/sqlite3/libsqlite/sqlite3.c"
  u.bu.iDb = pOp->p1;
  ((void) (0));
  ((void) (0));
                                 {
    u.bu.zMaster = ((!0)&&(u.bu.iDb==1)?"sqlite_temp_master":"sqlite_master");
    u.bu.initData.db = db;
    u.bu.initData.iDb = pOp->p1;
    u.bu.initData.pzErrMsg = &p->zErrMsg;
    u.bu.zSql = sqlite3MPrintf(db,
       "SELECT name, rootpage, sql FROM '%q'.%s WHERE %s ORDER BY rowid",
       db->aDb[u.bu.iDb].zName, u.bu.zMaster, pOp->p4.z);
    if( u.bu.zSql==0 ){
      rc = 7;
    }else{
      ((void) (0));
      db->init.busy = 1;
      u.bu.initData.rc = 0;
      ((void) (0));
      rc = sqlite3_exec(db, u.bu.zSql, sqlite3InitCallback, &u.bu.initData, 0);
      if( rc==0 ) rc = u.bu.initData.rc;
      sqlite3DbFree(db, u.bu.zSql);
      db->init.busy = 0;
    }
  }
  if( rc==7 ){
    goto no_mem;
  }
  break;
}
# 66971 "ext/sqlite3/libsqlite/sqlite3.c"
case 100: {
  ((void) (0));
  rc = sqlite3AnalysisLoad(db, pOp->p1);
  break;
}
# 66985 "ext/sqlite3/libsqlite/sqlite3.c"
case 101: {
  sqlite3UnlinkAndDeleteTable(db, pOp->p1, pOp->p4.z);
  break;
}
# 66997 "ext/sqlite3/libsqlite/sqlite3.c"
case 102: {
  sqlite3UnlinkAndDeleteIndex(db, pOp->p1, pOp->p4.z);
  break;
}
# 67009 "ext/sqlite3/libsqlite/sqlite3.c"
case 103: {
  sqlite3UnlinkAndDeleteTrigger(db, pOp->p1, pOp->p4.z);
  break;
}
# 67036 "ext/sqlite3/libsqlite/sqlite3.c"
case 104: {
# 67046 "ext/sqlite3/libsqlite/sqlite3.c"
  u.bv.nRoot = pOp->p2;
  ((void) (0));
  u.bv.aRoot = sqlite3DbMallocRaw(db, sizeof(int)*(u.bv.nRoot+1) );
  if( u.bv.aRoot==0 ) goto no_mem;
  ((void) (0));
  u.bv.pnErr = &aMem[pOp->p3];
  ((void) (0));
  ((void) (0));
  pIn1 = &aMem[pOp->p1];
  for(u.bv.j=0; u.bv.j<u.bv.nRoot; u.bv.j++){
    u.bv.aRoot[u.bv.j] = (int)sqlite3VdbeIntValue(&pIn1[u.bv.j]);
  }
  u.bv.aRoot[u.bv.j] = 0;
  ((void) (0));
  ((void) (0));
  u.bv.z = sqlite3BtreeIntegrityCheck(db->aDb[pOp->p5].pBt, u.bv.aRoot, u.bv.nRoot,
                                 (int)u.bv.pnErr->u.i, &u.bv.nErr);
  sqlite3DbFree(db, u.bv.aRoot);
  u.bv.pnErr->u.i -= u.bv.nErr;
  sqlite3VdbeMemSetNull(pIn1);
  if( u.bv.nErr==0 ){
    ((void) (0));
  }else if( u.bv.z==0 ){
    goto no_mem;
  }else{
    sqlite3VdbeMemSetStr(pIn1, u.bv.z, -1, 1, sqlite3_free);
  }
                           ;
  sqlite3VdbeChangeEncoding(pIn1, encoding);
  break;
}
# 67086 "ext/sqlite3/libsqlite/sqlite3.c"
case 105: {
  pIn1 = &aMem[pOp->p1];
  pIn2 = &aMem[pOp->p2];
  ((void) (0));
  if( (pIn1->flags & 0x0020)==0 ){
    sqlite3VdbeMemSetRowSet(pIn1);
    if( (pIn1->flags & 0x0020)==0 ) goto no_mem;
  }
  sqlite3RowSetInsert(pIn1->u.pRowSet, pIn2->u.i);
  break;
}







case 106: {



  if( db->u1.isInterrupted ) goto abort_due_to_interrupt;;
  pIn1 = &aMem[pOp->p1];
  if( (pIn1->flags & 0x0020)==0
   || sqlite3RowSetNext(pIn1->u.pRowSet, &u.bw.val)==0
  ){

    sqlite3VdbeMemSetNull(pIn1);
    pc = pOp->p2 - 1;
  }else{

    sqlite3VdbeMemSetInt64(&aMem[pOp->p3], u.bw.val);
  }
  break;
}
# 67146 "ext/sqlite3/libsqlite/sqlite3.c"
case 107: {





  pIn1 = &aMem[pOp->p1];
  pIn3 = &aMem[pOp->p3];
  u.bx.iSet = pOp->p4.i;
  ((void) (0));




  if( (pIn1->flags & 0x0020)==0 ){
    sqlite3VdbeMemSetRowSet(pIn1);
    if( (pIn1->flags & 0x0020)==0 ) goto no_mem;
  }

  ((void) (0));
  ((void) (0));
  if( u.bx.iSet ){
    u.bx.exists = sqlite3RowSetTest(pIn1->u.pRowSet,
                               (u8)(u.bx.iSet>=0 ? u.bx.iSet & 0xf : 0xff),
                               pIn3->u.i);
    if( u.bx.exists ){
      pc = pOp->p2 - 1;
      break;
    }
  }
  if( u.bx.iSet>=0 ){
    sqlite3RowSetInsert(pIn1->u.pRowSet, pIn3->u.i);
  }
  break;
}
# 67198 "ext/sqlite3/libsqlite/sqlite3.c"
case 108: {
# 67210 "ext/sqlite3/libsqlite/sqlite3.c"
  u.by.pProgram = pOp->p4.pProgram;
  u.by.pRt = &aMem[pOp->p3];
  ((void) (0));
  ((void) (0));
# 67226 "ext/sqlite3/libsqlite/sqlite3.c"
  if( pOp->p5 ){
    u.by.t = u.by.pProgram->token;
    for(u.by.pFrame=p->pFrame; u.by.pFrame && u.by.pFrame->token!=u.by.t; u.by.pFrame=u.by.pFrame->pParent);
    if( u.by.pFrame ) break;
  }

  if( p->nFrame>=db->aLimit[10] ){
    rc = 1;
    sqlite3SetString(&p->zErrMsg, db, "too many levels of trigger recursion");
    break;
  }





  if( (u.by.pRt->flags&0x0040)==0 ){





    u.by.nMem = u.by.pProgram->nMem + u.by.pProgram->nCsr;
    u.by.nByte = (((sizeof(VdbeFrame))+7)&~7)
              + u.by.nMem * sizeof(Mem)
              + u.by.pProgram->nCsr * sizeof(VdbeCursor *);
    u.by.pFrame = sqlite3DbMallocZero(db, u.by.nByte);
    if( !u.by.pFrame ){
      goto no_mem;
    }
    sqlite3VdbeMemRelease(u.by.pRt);
    u.by.pRt->flags = 0x0040;
    u.by.pRt->u.pFrame = u.by.pFrame;

    u.by.pFrame->v = p;
    u.by.pFrame->nChildMem = u.by.nMem;
    u.by.pFrame->nChildCsr = u.by.pProgram->nCsr;
    u.by.pFrame->pc = pc;
    u.by.pFrame->aMem = p->aMem;
    u.by.pFrame->nMem = p->nMem;
    u.by.pFrame->apCsr = p->apCsr;
    u.by.pFrame->nCursor = p->nCursor;
    u.by.pFrame->aOp = p->aOp;
    u.by.pFrame->nOp = p->nOp;
    u.by.pFrame->token = u.by.pProgram->token;

    u.by.pEnd = &((Mem *)&((u8 *)u.by.pFrame)[(((sizeof(VdbeFrame))+7)&~7)])[u.by.pFrame->nChildMem];
    for(u.by.pMem=((Mem *)&((u8 *)u.by.pFrame)[(((sizeof(VdbeFrame))+7)&~7)]); u.by.pMem!=u.by.pEnd; u.by.pMem++){
      u.by.pMem->flags = 0x0001;
      u.by.pMem->db = db;
    }
  }else{
    u.by.pFrame = u.by.pRt->u.pFrame;
    ((void) (0));
    ((void) (0));
    ((void) (0));
  }

  p->nFrame++;
  u.by.pFrame->pParent = p->pFrame;
  u.by.pFrame->lastRowid = db->lastRowid;
  u.by.pFrame->nChange = p->nChange;
  p->nChange = 0;
  p->pFrame = u.by.pFrame;
  p->aMem = aMem = &((Mem *)&((u8 *)u.by.pFrame)[(((sizeof(VdbeFrame))+7)&~7)])[-1];
  p->nMem = u.by.pFrame->nChildMem;
  p->nCursor = (u16)u.by.pFrame->nChildCsr;
  p->apCsr = (VdbeCursor **)&aMem[p->nMem+1];
  p->aOp = aOp = u.by.pProgram->aOp;
  p->nOp = u.by.pProgram->nOp;
  pc = -1;

  break;
}
# 67313 "ext/sqlite3/libsqlite/sqlite3.c"
case 109: {




  u.bz.pFrame = p->pFrame;
  u.bz.pIn = &u.bz.pFrame->aMem[pOp->p1 + u.bz.pFrame->aOp[u.bz.pFrame->pc].p1];
  sqlite3VdbeMemShallowCopy(pOut, u.bz.pIn, 0x1000);
  break;
}
# 67334 "ext/sqlite3/libsqlite/sqlite3.c"
case 110: {
  if( pOp->p1 ){
    db->nDeferredCons += pOp->p2;
  }else{
    p->nFkConstraint += pOp->p2;
  }
  break;
}
# 67354 "ext/sqlite3/libsqlite/sqlite3.c"
case 111: {
  if( pOp->p1 ){
    if( db->nDeferredCons==0 ) pc = pOp->p2-1;
  }else{
    if( p->nFkConstraint==0 ) pc = pOp->p2-1;
  }
  break;
}
# 67375 "ext/sqlite3/libsqlite/sqlite3.c"
case 112: {




  if( p->pFrame ){
    for(u.ca.pFrame=p->pFrame; u.ca.pFrame->pParent; u.ca.pFrame=u.ca.pFrame->pParent);
    u.ca.pIn1 = &u.ca.pFrame->aMem[pOp->p1];
  }else{
    u.ca.pIn1 = &aMem[pOp->p1];
  }
  ((void) (0));
  sqlite3VdbeMemIntegerify(u.ca.pIn1);
  pIn2 = &aMem[pOp->p2];
  sqlite3VdbeMemIntegerify(pIn2);
  if( u.ca.pIn1->u.i<pIn2->u.i){
    u.ca.pIn1->u.i = pIn2->u.i;
  }
  break;
}
# 67404 "ext/sqlite3/libsqlite/sqlite3.c"
case 113: {
  pIn1 = &aMem[pOp->p1];
  ((void) (0));
  if( pIn1->u.i>0 ){
     pc = pOp->p2 - 1;
  }
  break;
}
# 67420 "ext/sqlite3/libsqlite/sqlite3.c"
case 114: {
  pIn1 = &aMem[pOp->p1];
  ((void) (0));
  if( pIn1->u.i<0 ){
     pc = pOp->p2 - 1;
  }
  break;
}
# 67437 "ext/sqlite3/libsqlite/sqlite3.c"
case 115: {
  pIn1 = &aMem[pOp->p1];
  ((void) (0));
  pIn1->u.i += pOp->p3;
  if( pIn1->u.i==0 ){
     pc = pOp->p2 - 1;
  }
  break;
}
# 67457 "ext/sqlite3/libsqlite/sqlite3.c"
case 116: {
# 67467 "ext/sqlite3/libsqlite/sqlite3.c"
  u.cb.n = pOp->p5;
  ((void) (0));
  u.cb.pRec = &aMem[pOp->p2];
  u.cb.apVal = p->apArg;
  ((void) (0));
  for(u.cb.i=0; u.cb.i<u.cb.n; u.cb.i++, u.cb.pRec++){
    ((void) (0));
    u.cb.apVal[u.cb.i] = u.cb.pRec;
                                  ;
    sqlite3VdbeMemStoreType(u.cb.pRec);
  }
  u.cb.ctx.pFunc = pOp->p4.pFunc;
  ((void) (0));
  u.cb.ctx.pMem = u.cb.pMem = &aMem[pOp->p3];
  u.cb.pMem->n++;
  u.cb.ctx.s.flags = 0x0001;
  u.cb.ctx.s.z = 0;
  u.cb.ctx.s.zMalloc = 0;
  u.cb.ctx.s.xDel = 0;
  u.cb.ctx.s.db = db;
  u.cb.ctx.isError = 0;
  u.cb.ctx.pColl = 0;
  if( u.cb.ctx.pFunc->flags & 0x08 ){
    ((void) (0));
    ((void) (0));
    ((void) (0));
    u.cb.ctx.pColl = pOp[-1].p4.pColl;
  }
  (u.cb.ctx.pFunc->xStep)(&u.cb.ctx, u.cb.n, u.cb.apVal);
  if( u.cb.ctx.isError ){
    sqlite3SetString(&p->zErrMsg, db, "%s", sqlite3_value_text(&u.cb.ctx.s));
    rc = u.cb.ctx.isError;
  }

  sqlite3VdbeMemRelease(&u.cb.ctx.s);

  break;
}
# 67518 "ext/sqlite3/libsqlite/sqlite3.c"
case 117: {



  ((void) (0));
  u.cc.pMem = &aMem[pOp->p1];
  ((void) (0));
  rc = sqlite3VdbeMemFinalize(u.cc.pMem, pOp->p4.pFunc);
  if( rc ){
    sqlite3SetString(&p->zErrMsg, db, "%s", sqlite3_value_text(u.cc.pMem));
  }
  sqlite3VdbeChangeEncoding(u.cc.pMem, encoding);
                                ;
  if( sqlite3VdbeMemTooBig(u.cc.pMem) ){
    goto too_big;
  }
  break;
}
# 67549 "ext/sqlite3/libsqlite/sqlite3.c"
case 118: {






  u.cd.aRes[0] = 0;
  u.cd.aRes[1] = u.cd.aRes[2] = -1;
  ((void) (0));



  rc = sqlite3Checkpoint(db, pOp->p1, pOp->p2, &u.cd.aRes[1], &u.cd.aRes[2]);
  if( rc==5 ){
    rc = 0;
    u.cd.aRes[0] = 1;
  }
  for(u.cd.i=0, u.cd.pMem = &aMem[pOp->p3]; u.cd.i<3; u.cd.i++, u.cd.pMem++){
    sqlite3VdbeMemSetInt64(u.cd.pMem, (i64)u.cd.aRes[u.cd.i]);
  }
  break;
};
# 67586 "ext/sqlite3/libsqlite/sqlite3.c"
case 119: {
# 67595 "ext/sqlite3/libsqlite/sqlite3.c"
  u.ce.eNew = pOp->p3;
  ((void) (0));







  ((void) (0));

  u.ce.pBt = db->aDb[pOp->p1].pBt;
  u.ce.pPager = sqlite3BtreePager(u.ce.pBt);
  u.ce.eOld = sqlite3PagerGetJournalMode(u.ce.pPager);
  if( u.ce.eNew==(-1) ) u.ce.eNew = u.ce.eOld;
  if( !sqlite3PagerOkToChangeJournalMode(u.ce.pPager) ) u.ce.eNew = u.ce.eOld;


  u.ce.zFilename = sqlite3PagerFilename(u.ce.pPager);




  if( u.ce.eNew==5
   && (u.ce.zFilename[0]==0
       || !sqlite3PagerWalSupported(u.ce.pPager))
  ){
    u.ce.eNew = u.ce.eOld;
  }

  if( (u.ce.eNew!=u.ce.eOld)
   && (u.ce.eOld==5 || u.ce.eNew==5)
  ){
    if( !db->autoCommit || db->activeVdbeCnt>1 ){
      rc = 1;
      sqlite3SetString(&p->zErrMsg, db,
          "cannot change %s wal mode from within a transaction",
          (u.ce.eNew==5 ? "into" : "out of")
      );
      break;
    }else{

      if( u.ce.eOld==5 ){





        rc = sqlite3PagerCloseWal(u.ce.pPager);
        if( rc==0 ){
          sqlite3PagerSetJournalMode(u.ce.pPager, u.ce.eNew);
        }
      }else if( u.ce.eOld==4 ){


        sqlite3PagerSetJournalMode(u.ce.pPager, 2);
      }




      ((void) (0));
      if( rc==0 ){
        rc = sqlite3BtreeSetVersion(u.ce.pBt, (u.ce.eNew==5 ? 2 : 1));
      }
    }
  }


  if( rc ){
    u.ce.eNew = u.ce.eOld;
  }
  u.ce.eNew = sqlite3PagerSetJournalMode(u.ce.pPager, u.ce.eNew);

  pOut = &aMem[pOp->p2];
  pOut->flags = 0x0002|0x0800|0x0200;
  pOut->z = (char *)sqlite3JournalModename(u.ce.eNew);
  pOut->n = sqlite3Strlen30(pOut->z);
  pOut->enc = 1;
  sqlite3VdbeChangeEncoding(pOut, encoding);
  break;
};
# 67686 "ext/sqlite3/libsqlite/sqlite3.c"
case 120: {
  rc = sqlite3RunVacuum(&p->zErrMsg, db);
  break;
}
# 67699 "ext/sqlite3/libsqlite/sqlite3.c"
case 121: {




  ((void) (0));
  ((void) (0));
  u.cf.pBt = db->aDb[pOp->p1].pBt;
  rc = sqlite3BtreeIncrVacuum(u.cf.pBt);
  if( rc==101 ){
    pc = pOp->p2 - 1;
    rc = 0;
  }
  break;
}
# 67725 "ext/sqlite3/libsqlite/sqlite3.c"
case 122: {
  if( !pOp->p1 ){
    sqlite3ExpirePreparedStatements(db);
  }else{
    p->expired = 1;
  }
  break;
}
# 67749 "ext/sqlite3/libsqlite/sqlite3.c"
case 123: {
  u8 isWriteLock = (u8)pOp->p3;
  if( isWriteLock || 0==(db->flags&0x0080000) ){
    int p1 = pOp->p1;
    ((void) (0));
    ((void) (0));
    ((void) (0));
    rc = sqlite3BtreeLockTable(db->aDb[p1].pBt, pOp->p2, isWriteLock);
    if( (rc&0xFF)==6 ){
      const char *z = pOp->p4.z;
      sqlite3SetString(&p->zErrMsg, db, "database table is locked: %s", z);
    }
  }
  break;
}
# 67776 "ext/sqlite3/libsqlite/sqlite3.c"
case 124: {



  u.cg.pVTab = pOp->p4.pVtab;
  rc = sqlite3VtabBegin(db, u.cg.pVTab);
  if( u.cg.pVTab ) importVtabErrMsg(p, u.cg.pVTab->pVtab);
  break;
}
# 67793 "ext/sqlite3/libsqlite/sqlite3.c"
case 125: {
  rc = sqlite3VtabCallCreate(db, pOp->p1, pOp->p4.z, &p->zErrMsg);
  break;
}
# 67805 "ext/sqlite3/libsqlite/sqlite3.c"
case 126: {
  p->inVtabMethod = 2;
  rc = sqlite3VtabCallDestroy(db, pOp->p1, pOp->p4.z);
  p->inVtabMethod = 0;
  break;
}
# 67820 "ext/sqlite3/libsqlite/sqlite3.c"
case 127: {







  u.ch.pCur = 0;
  u.ch.pVtabCursor = 0;
  u.ch.pVtab = pOp->p4.pVtab->pVtab;
  u.ch.pModule = (sqlite3_module *)u.ch.pVtab->pModule;
  ((void) (0));
  rc = u.ch.pModule->xOpen(u.ch.pVtab, &u.ch.pVtabCursor);
  importVtabErrMsg(p, u.ch.pVtab);
  if( 0==rc ){

    u.ch.pVtabCursor->pVtab = u.ch.pVtab;


    u.ch.pCur = allocateCursor(p, pOp->p1, 0, -1, 0);
    if( u.ch.pCur ){
      u.ch.pCur->pVtabCursor = u.ch.pVtabCursor;
      u.ch.pCur->pModule = u.ch.pVtabCursor->pVtab->pModule;
    }else{
      db->mallocFailed = 1;
      u.ch.pModule->xClose(u.ch.pVtabCursor);
    }
  }
  break;
}
# 67872 "ext/sqlite3/libsqlite/sqlite3.c"
case 128: {
# 67887 "ext/sqlite3/libsqlite/sqlite3.c"
  u.ci.pQuery = &aMem[pOp->p3];
  u.ci.pArgc = &u.ci.pQuery[1];
  u.ci.pCur = p->apCsr[pOp->p1];
  ((void) (0));
                                      ;
  ((void) (0));
  u.ci.pVtabCursor = u.ci.pCur->pVtabCursor;
  u.ci.pVtab = u.ci.pVtabCursor->pVtab;
  u.ci.pModule = u.ci.pVtab->pModule;


  ((void) (0));
  u.ci.nArg = (int)u.ci.pArgc->u.i;
  u.ci.iQuery = (int)u.ci.pQuery->u.i;


  {
    u.ci.res = 0;
    u.ci.apArg = p->apArg;
    for(u.ci.i = 0; u.ci.i<u.ci.nArg; u.ci.i++){
      u.ci.apArg[u.ci.i] = &u.ci.pArgc[u.ci.i+1];
      sqlite3VdbeMemStoreType(u.ci.apArg[u.ci.i]);
    }

    p->inVtabMethod = 1;
    rc = u.ci.pModule->xFilter(u.ci.pVtabCursor, u.ci.iQuery, pOp->p4.z, u.ci.nArg, u.ci.apArg);
    p->inVtabMethod = 0;
    importVtabErrMsg(p, u.ci.pVtab);
    if( rc==0 ){
      u.ci.res = u.ci.pModule->xEof(u.ci.pVtabCursor);
    }

    if( u.ci.res ){
      pc = pOp->p2 - 1;
    }
  }
  u.ci.pCur->nullRow = 0;

  break;
}
# 67936 "ext/sqlite3/libsqlite/sqlite3.c"
case 129: {







  VdbeCursor *pCur = p->apCsr[pOp->p1];
  ((void) (0));
  ((void) (0));
  u.cj.pDest = &aMem[pOp->p3];
                                 ;
  if( pCur->nullRow ){
    sqlite3VdbeMemSetNull(u.cj.pDest);
    break;
  }
  u.cj.pVtab = pCur->pVtabCursor->pVtab;
  u.cj.pModule = u.cj.pVtab->pModule;
  ((void) (0));
  memset(&u.cj.sContext, 0, sizeof(u.cj.sContext));






  sqlite3VdbeMemMove(&u.cj.sContext.s, u.cj.pDest);
  ((&u.cj.sContext.s)->flags = ((&u.cj.sContext.s)->flags&~(0x00ff|0x4000))|0x0001);

  rc = u.cj.pModule->xColumn(pCur->pVtabCursor, &u.cj.sContext, pOp->p2);
  importVtabErrMsg(p, u.cj.pVtab);
  if( u.cj.sContext.isError ){
    rc = u.cj.sContext.isError;
  }





  sqlite3VdbeChangeEncoding(&u.cj.sContext.s, encoding);
  sqlite3VdbeMemMove(u.cj.pDest, &u.cj.sContext.s);
                                     ;
                                 ;

  if( sqlite3VdbeMemTooBig(u.cj.pDest) ){
    goto too_big;
  }
  break;
}
# 67995 "ext/sqlite3/libsqlite/sqlite3.c"
case 131: {







  u.ck.res = 0;
  u.ck.pCur = p->apCsr[pOp->p1];
  ((void) (0));
  if( u.ck.pCur->nullRow ){
    break;
  }
  u.ck.pVtab = u.ck.pCur->pVtabCursor->pVtab;
  u.ck.pModule = u.ck.pVtab->pModule;
  ((void) (0));







  p->inVtabMethod = 1;
  rc = u.ck.pModule->xNext(u.ck.pCur->pVtabCursor);
  p->inVtabMethod = 0;
  importVtabErrMsg(p, u.ck.pVtab);
  if( rc==0 ){
    u.ck.res = u.ck.pModule->xEof(u.ck.pCur->pVtabCursor);
  }

  if( !u.ck.res ){

    pc = pOp->p2 - 1;
  }
  break;
}
# 68042 "ext/sqlite3/libsqlite/sqlite3.c"
case 132: {





  u.cl.pVtab = pOp->p4.pVtab->pVtab;
  u.cl.pName = &aMem[pOp->p1];
  ((void) (0));
  ((void) (0));
                                     ;
  ((void) (0));
  rc = u.cl.pVtab->pModule->xRename(u.cl.pVtab, u.cl.pName->z);
  importVtabErrMsg(p, u.cl.pVtab);
  p->expired = 0;

  break;
}
# 68086 "ext/sqlite3/libsqlite/sqlite3.c"
case 133: {
# 68097 "ext/sqlite3/libsqlite/sqlite3.c"
  u.cm.pVtab = pOp->p4.pVtab->pVtab;
  u.cm.pModule = (sqlite3_module *)u.cm.pVtab->pModule;
  u.cm.nArg = pOp->p2;
  ((void) (0));
  if( (u.cm.pModule->xUpdate) ){
    u.cm.apArg = p->apArg;
    u.cm.pX = &aMem[pOp->p3];
    for(u.cm.i=0; u.cm.i<u.cm.nArg; u.cm.i++){
      ((void) (0));
                                  ;
      sqlite3VdbeMemStoreType(u.cm.pX);
      u.cm.apArg[u.cm.i] = u.cm.pX;
      u.cm.pX++;
    }
    rc = u.cm.pModule->xUpdate(u.cm.pVtab, u.cm.nArg, u.cm.apArg, &u.cm.rowid);
    importVtabErrMsg(p, u.cm.pVtab);
    if( rc==0 && pOp->p1 ){
      ((void) (0));
      db->lastRowid = u.cm.rowid;
    }
    p->nChange++;
  }
  break;
}







case 134: {
  pOut->u.i = sqlite3BtreeLastPage(db->aDb[pOp->p1].pBt);
  break;
}
# 68144 "ext/sqlite3/libsqlite/sqlite3.c"
case 135: {
  unsigned int newMax;
  Btree *pBt;

  pBt = db->aDb[pOp->p1].pBt;
  newMax = 0;
  if( pOp->p3 ){
    newMax = sqlite3BtreeLastPage(pBt);
    if( newMax < (unsigned)pOp->p3 ) newMax = (unsigned)pOp->p3;
  }
  pOut->u.i = sqlite3BtreeMaxPageCount(pBt, newMax);
  break;
}
# 68166 "ext/sqlite3/libsqlite/sqlite3.c"
case 136: {




  u.cn.zTrace = (pOp->p4.z ? pOp->p4.z : p->zSql);
  if( u.cn.zTrace ){
    if( db->xTrace ){
      char *z = sqlite3VdbeExpandSql(p, u.cn.zTrace);
      db->xTrace(db->pTraceArg, z);
      sqlite3DbFree(db, z);
    }





  }
  break;
}
# 68200 "ext/sqlite3/libsqlite/sqlite3.c"
default: {
  ((void) (0));
  break;
}







    }
# 68245 "ext/sqlite3/libsqlite/sqlite3.c"
  }




vdbe_error_halt:
  ((void) (0));
  p->rc = rc;
                                         ;
  sqlite3_log(rc, "statement aborts at %d: [%s] %s",
                   pc, p->zSql, p->zErrMsg);
  sqlite3VdbeHalt(p);
  if( rc==(10 | (12<<8)) ) db->mallocFailed = 1;
  rc = 1;
  if( resetSchemaOnFault>0 ){
    sqlite3ResetInternalSchema(db, resetSchemaOnFault-1);
  }




vdbe_return:
                     ;
  return rc;




too_big:
  sqlite3SetString(&p->zErrMsg, db, "string or blob too big");
  rc = 18;
  goto vdbe_error_halt;



no_mem:
  db->mallocFailed = 1;
  sqlite3SetString(&p->zErrMsg, db, "out of memory");
  rc = 7;
  goto vdbe_error_halt;




abort_due_to_error:
  ((void) (0));
  if( db->mallocFailed ) rc = 7;
  if( rc!=(10 | (12<<8)) ){
    sqlite3SetString(&p->zErrMsg, db, "%s", sqlite3ErrStr(rc));
  }
  goto vdbe_error_halt;




abort_due_to_interrupt:
  ((void) (0));
  rc = 9;
  p->rc = rc;
  sqlite3SetString(&p->zErrMsg, db, "%s", sqlite3ErrStr(rc));
  goto vdbe_error_halt;
}
# 68331 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct Incrblob Incrblob;
struct Incrblob {
  int flags;
  int nByte;
  int iOffset;
  int iCol;
  BtCursor *pCsr;
  sqlite3_stmt *pStmt;
  sqlite3 *db;
};
# 68360 "ext/sqlite3/libsqlite/sqlite3.c"
static int blobSeekToRow(Incrblob *p, sqlite3_int64 iRow, char **pzErr){
  int rc;
  char *zErr = 0;
  Vdbe *v = (Vdbe *)p->pStmt;





  ((void) (0));
  v->aVar[0].u.i = iRow;

  rc = sqlite3_step(p->pStmt);
  if( rc==100 ){
    u32 type = v->apCsr[0]->aType[p->iCol];
    if( type<12 ){
      zErr = sqlite3MPrintf(p->db, "cannot open value of type %s",
          type==0?"null": type==7?"real": "integer"
      );
      rc = 1;
      sqlite3_finalize(p->pStmt);
      p->pStmt = 0;
    }else{
      p->iOffset = v->apCsr[0]->aOffset[p->iCol];
      p->nByte = sqlite3VdbeSerialTypeLen(type);
      p->pCsr = v->apCsr[0]->pCursor;
                                      ;
      sqlite3BtreeCacheOverflow(p->pCsr);
                                      ;
    }
  }

  if( rc==100 ){
    rc = 0;
  }else if( p->pStmt ){
    rc = sqlite3_finalize(p->pStmt);
    p->pStmt = 0;
    if( rc==0 ){
      zErr = sqlite3MPrintf(p->db, "no such rowid: %lld", iRow);
      rc = 1;
    }else{
      zErr = sqlite3MPrintf(p->db, "%s", sqlite3_errmsg(p->db));
    }
  }

  ((void) (0));
  ((void) (0));

  *pzErr = zErr;
  return rc;
}




           int sqlite3_blob_open(
  sqlite3* db,
  const char *zDb,
  const char *zTable,
  const char *zColumn,
  sqlite_int64 iRow,
  int flags,
  sqlite3_blob **ppBlob
){
  int nAttempt = 0;
  int iCol;
# 68442 "ext/sqlite3/libsqlite/sqlite3.c"
  static const VdbeOpList openBlob[] = {
    {34, 0, 0, 0},
    {37, 0, 0, 0},
    {123, 0, 0, 0},


    {38, 0, 0, 0},
    {39, 0, 0, 0},

    {12, 1, 1, 1},
    {52, 0, 10, 1},
    {28, 0, 0, 1},
    {16, 1, 0, 0},
    {1, 0, 5, 0},
    {43, 0, 0, 0},
    {6, 0, 0, 0},
  };

  int rc = 0;
  char *zErr = 0;
  Table *pTab;
  Parse *pParse = 0;
  Incrblob *pBlob = 0;

  flags = !!flags;
  *ppBlob = 0;

                                ;

  pBlob = (Incrblob *)sqlite3DbMallocZero(db, sizeof(Incrblob));
  if( !pBlob ) goto blob_open_out;
  pParse = sqlite3DbMallocRaw(db,sizeof(*pParse));
  if( !pParse ) goto blob_open_out;

  do {
    memset(pParse, 0, sizeof(Parse));
    pParse->db = db;
    sqlite3DbFree(db, zErr);
    zErr = 0;

    sqlite3BtreeEnterAll(db);
    pTab = sqlite3LocateTable(pParse, 0, zTable, zDb);
    if( pTab && (((pTab)->tabFlags & 0x10)!=0) ){
      pTab = 0;
      sqlite3ErrorMsg(pParse, "cannot open virtual table: %s", zTable);
    }

    if( pTab && pTab->pSelect ){
      pTab = 0;
      sqlite3ErrorMsg(pParse, "cannot open view: %s", zTable);
    }

    if( !pTab ){
      if( pParse->zErrMsg ){
        sqlite3DbFree(db, zErr);
        zErr = pParse->zErrMsg;
        pParse->zErrMsg = 0;
      }
      rc = 1;
                              ;
      goto blob_open_out;
    }


    for(iCol=0; iCol<pTab->nCol; iCol++) {
      if( sqlite3StrICmp(pTab->aCol[iCol].zName, zColumn)==0 ){
        break;
      }
    }
    if( iCol==pTab->nCol ){
      sqlite3DbFree(db, zErr);
      zErr = sqlite3MPrintf(db, "no such column: \"%s\"", zColumn);
      rc = 1;
                              ;
      goto blob_open_out;
    }





    if( flags ){
      const char *zFault = 0;
      Index *pIdx;

      if( db->flags&0x04000000 ){




        FKey *pFKey;
        for(pFKey=pTab->pFKey; pFKey; pFKey=pFKey->pNextFrom){
          int j;
          for(j=0; j<pFKey->nCol; j++){
            if( pFKey->aCol[j].iFrom==iCol ){
              zFault = "foreign key";
            }
          }
        }
      }

      for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
        int j;
        for(j=0; j<pIdx->nColumn; j++){
          if( pIdx->aiColumn[j]==iCol ){
            zFault = "indexed";
          }
        }
      }
      if( zFault ){
        sqlite3DbFree(db, zErr);
        zErr = sqlite3MPrintf(db, "cannot open %s column for writing", zFault);
        rc = 1;
                                ;
        goto blob_open_out;
      }
    }

    pBlob->pStmt = (sqlite3_stmt *)sqlite3VdbeCreate(db);
    ((void) (0));
    if( pBlob->pStmt ){
      Vdbe *v = (Vdbe *)pBlob->pStmt;
      int iDb = sqlite3SchemaToIndex(db, pTab->pSchema);

      sqlite3VdbeAddOpList(v, sizeof(openBlob)/sizeof(VdbeOpList), openBlob);



      sqlite3VdbeChangeP1(v, 0, iDb);
      sqlite3VdbeChangeP2(v, 0, flags);


      sqlite3VdbeChangeP1(v, 1, iDb);
      sqlite3VdbeChangeP2(v, 1, pTab->pSchema->schema_cookie);
      sqlite3VdbeChangeP3(v, 1, pTab->pSchema->iGeneration);


      sqlite3VdbeUsesBtree(v, iDb);





      sqlite3VdbeChangeP1(v, 2, iDb);
      sqlite3VdbeChangeP2(v, 2, pTab->tnum);
      sqlite3VdbeChangeP3(v, 2, flags);
      sqlite3VdbeChangeP4(v, 2, pTab->zName, 0);




      sqlite3VdbeChangeToNoop(v, 4 - flags, 1);
      sqlite3VdbeChangeP2(v, 3 + flags, pTab->tnum);
      sqlite3VdbeChangeP3(v, 3 + flags, iDb);
# 68604 "ext/sqlite3/libsqlite/sqlite3.c"
      sqlite3VdbeChangeP4(v, 3+flags, ((void*)(long int)(pTab->nCol+1)),(-14));
      sqlite3VdbeChangeP2(v, 7, pTab->nCol);
      if( !db->mallocFailed ){
        sqlite3VdbeMakeReady(v, 1, 1, 1, 0, 0, 0);
      }
    }

    pBlob->flags = flags;
    pBlob->iCol = iCol;
    pBlob->db = db;
                            ;
    if( db->mallocFailed ){
      goto blob_open_out;
    }
    sqlite3_bind_int64(pBlob->pStmt, 1, iRow);
    rc = blobSeekToRow(pBlob, iRow, &zErr);
  } while( (++nAttempt)<5 && rc==17 );

blob_open_out:
  if( rc==0 && db->mallocFailed==0 ){
    *ppBlob = (sqlite3_blob *)pBlob;
  }else{
    if( pBlob && pBlob->pStmt ) sqlite3VdbeFinalize((Vdbe *)pBlob->pStmt);
    sqlite3DbFree(db, pBlob);
  }
  sqlite3Error(db, rc, (zErr ? "%s" : 0), zErr);
  sqlite3DbFree(db, zErr);
  sqlite3DbFree(db,pParse);
  rc = sqlite3ApiExit(db, rc);
                                ;
  return rc;
}





           int sqlite3_blob_close(sqlite3_blob *pBlob){
  Incrblob *p = (Incrblob *)pBlob;
  int rc;
  sqlite3 *db;

  if( p ){
    db = p->db;
                                  ;
    rc = sqlite3_finalize(p->pStmt);
    sqlite3DbFree(db, p);
                                  ;
  }else{
    rc = 0;
  }
  return rc;
}




static int blobReadWrite(
  sqlite3_blob *pBlob,
  void *z,
  int n,
  int iOffset,
  int (*xCall)(BtCursor*, u32, u32, void*)
){
  int rc;
  Incrblob *p = (Incrblob *)pBlob;
  Vdbe *v;
  sqlite3 *db;

  if( p==0 ) return sqlite3MisuseError(68673);
  db = p->db;
                                ;
  v = (Vdbe*)p->pStmt;

  if( n<0 || iOffset<0 || (iOffset+n)>p->nByte ){

    rc = 1;
    sqlite3Error(db, 1, 0);
  }else if( v==0 ){



    rc = 4;
  }else{



    ((void) (0));
                                    ;
    rc = xCall(p->pCsr, iOffset+p->iOffset, n, z);
                                    ;
    if( rc==4 ){
      sqlite3VdbeFinalize(v);
      p->pStmt = 0;
    }else{
      db->errCode = rc;
      v->rc = rc;
    }
  }
  rc = sqlite3ApiExit(db, rc);
                                ;
  return rc;
}




           int sqlite3_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset){
  return blobReadWrite(pBlob, z, n, iOffset, sqlite3BtreeData);
}




           int sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset){
  return blobReadWrite(pBlob, (void *)z, n, iOffset, sqlite3BtreePutData);
}







           int sqlite3_blob_bytes(sqlite3_blob *pBlob){
  Incrblob *p = (Incrblob *)pBlob;
  return (p && p->pStmt) ? p->nByte : 0;
}
# 68743 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_blob_reopen(sqlite3_blob *pBlob, sqlite3_int64 iRow){
  int rc;
  Incrblob *p = (Incrblob *)pBlob;
  sqlite3 *db;

  if( p==0 ) return sqlite3MisuseError(68748);
  db = p->db;
                                ;

  if( p->pStmt==0 ){



    rc = 4;
  }else{
    char *zErr;
    rc = blobSeekToRow(p, iRow, &zErr);
    if( rc!=0 ){
      sqlite3Error(db, rc, (zErr ? "%s" : 0), zErr);
      sqlite3DbFree(db, zErr);
    }
    ((void) (0));
  }

  rc = sqlite3ApiExit(db, rc);
  ((void) (0));
                                ;
  return rc;
}
# 69035 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct MemJournal MemJournal;
typedef struct FilePoint FilePoint;
typedef struct FileChunk FileChunk;
# 69058 "ext/sqlite3/libsqlite/sqlite3.c"
struct FileChunk {
  FileChunk *pNext;
  u8 zChunk[((int)(1024-sizeof(FileChunk*)))];
};





struct FilePoint {
  sqlite3_int64 iOffset;
  FileChunk *pChunk;
};





struct MemJournal {
  sqlite3_io_methods *pMethod;
  FileChunk *pFirst;
  FilePoint endpoint;
  FilePoint readpoint;
};





static int memjrnlRead(
  sqlite3_file *pJfd,
  void *zBuf,
  int iAmt,
  sqlite_int64 iOfst
){
  MemJournal *p = (MemJournal *)pJfd;
  u8 *zOut = zBuf;
  int nRead = iAmt;
  int iChunkOffset;
  FileChunk *pChunk;


  ((void) (0));

  if( p->readpoint.iOffset!=iOfst || iOfst==0 ){
    sqlite3_int64 iOff = 0;
    for(pChunk=p->pFirst;
        (pChunk) && (iOff+((int)(1024-sizeof(FileChunk*))))<=iOfst;
        pChunk=pChunk->pNext
    ){
      iOff += ((int)(1024-sizeof(FileChunk*)));
    }
  }else{
    pChunk = p->readpoint.pChunk;
  }

  iChunkOffset = (int)(iOfst%((int)(1024-sizeof(FileChunk*))));
  do {
    int iSpace = ((int)(1024-sizeof(FileChunk*))) - iChunkOffset;
    int nCopy = ((nRead)<((((int)(1024-sizeof(FileChunk*))) - iChunkOffset))?(nRead):((((int)(1024-sizeof(FileChunk*))) - iChunkOffset)));
    memcpy(zOut, &pChunk->zChunk[iChunkOffset], nCopy);
    zOut += nCopy;
    nRead -= iSpace;
    iChunkOffset = 0;
  } while( nRead>=0 && (pChunk=pChunk->pNext)!=0 && nRead>0 );
  p->readpoint.iOffset = iOfst+iAmt;
  p->readpoint.pChunk = pChunk;

  return 0;
}




static int memjrnlWrite(
  sqlite3_file *pJfd,
  const void *zBuf,
  int iAmt,
  sqlite_int64 iOfst
){
  MemJournal *p = (MemJournal *)pJfd;
  int nWrite = iAmt;
  u8 *zWrite = (u8 *)zBuf;




  ((void) (0));
  (void)(iOfst);

  while( nWrite>0 ){
    FileChunk *pChunk = p->endpoint.pChunk;
    int iChunkOffset = (int)(p->endpoint.iOffset%((int)(1024-sizeof(FileChunk*))));
    int iSpace = ((nWrite)<(((int)(1024-sizeof(FileChunk*))) - iChunkOffset)?(nWrite):(((int)(1024-sizeof(FileChunk*))) - iChunkOffset));

    if( iChunkOffset==0 ){

      FileChunk *pNew = sqlite3_malloc(sizeof(FileChunk));
      if( !pNew ){
        return (10 | (12<<8));
      }
      pNew->pNext = 0;
      if( pChunk ){
        ((void) (0));
        pChunk->pNext = pNew;
      }else{
        ((void) (0));
        p->pFirst = pNew;
      }
      p->endpoint.pChunk = pNew;
    }

    memcpy(&p->endpoint.pChunk->zChunk[iChunkOffset], zWrite, iSpace);
    zWrite += iSpace;
    nWrite -= iSpace;
    p->endpoint.iOffset += iSpace;
  }

  return 0;
}




static int memjrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size){
  MemJournal *p = (MemJournal *)pJfd;
  FileChunk *pChunk;
  ((void) (0));
  (void)(size);
  pChunk = p->pFirst;
  while( pChunk ){
    FileChunk *pTmp = pChunk;
    pChunk = pChunk->pNext;
    sqlite3_free(pTmp);
  }
  sqlite3MemJournalOpen(pJfd);
  return 0;
}




static int memjrnlClose(sqlite3_file *pJfd){
  memjrnlTruncate(pJfd, 0);
  return 0;
}
# 69214 "ext/sqlite3/libsqlite/sqlite3.c"
static int memjrnlSync(sqlite3_file *NotUsed, int NotUsed2){
  (void)(NotUsed),(void)(NotUsed2);
  return 0;
}




static int memjrnlFileSize(sqlite3_file *pJfd, sqlite_int64 *pSize){
  MemJournal *p = (MemJournal *)pJfd;
  *pSize = (sqlite_int64) p->endpoint.iOffset;
  return 0;
}




static const struct sqlite3_io_methods MemJournalMethods = {
  1,
  memjrnlClose,
  memjrnlRead,
  memjrnlWrite,
  memjrnlTruncate,
  memjrnlSync,
  memjrnlFileSize,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
};




static void sqlite3MemJournalOpen(sqlite3_file *pJfd){
  MemJournal *p = (MemJournal *)pJfd;
  ((void) (0));
  memset(p, 0, sqlite3MemJournalSize());
  p->pMethod = (sqlite3_io_methods*)&MemJournalMethods;
}





static int sqlite3IsMemJournal(sqlite3_file *pJfd){
  return pJfd->pMethods==&MemJournalMethods;
}




static int sqlite3MemJournalSize(void){
  return sizeof(MemJournal);
}
# 69313 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3WalkExpr(Walker *pWalker, Expr *pExpr){
  int rc;
  if( pExpr==0 ) return 0;
                                                  ;
                                                ;
  rc = pWalker->xExprCallback(pWalker, pExpr);
  if( rc==0
              && !(((pExpr)->flags&(0x2000))!=0) ){
    if( sqlite3WalkExpr(pWalker, pExpr->pLeft) ) return 2;
    if( sqlite3WalkExpr(pWalker, pExpr->pRight) ) return 2;
    if( (((pExpr)->flags&(0x0800))==(0x0800)) ){
      if( sqlite3WalkSelect(pWalker, pExpr->x.pSelect) ) return 2;
    }else{
      if( sqlite3WalkExprList(pWalker, pExpr->x.pList) ) return 2;
    }
  }
  return rc & 2;
}





static int sqlite3WalkExprList(Walker *pWalker, ExprList *p){
  int i;
  struct ExprList_item *pItem;
  if( p ){
    for(i=p->nExpr, pItem=p->a; i>0; i--, pItem++){
      if( sqlite3WalkExpr(pWalker, pItem->pExpr) ) return 2;
    }
  }
  return 0;
}







static int sqlite3WalkSelectExpr(Walker *pWalker, Select *p){
  if( sqlite3WalkExprList(pWalker, p->pEList) ) return 2;
  if( sqlite3WalkExpr(pWalker, p->pWhere) ) return 2;
  if( sqlite3WalkExprList(pWalker, p->pGroupBy) ) return 2;
  if( sqlite3WalkExpr(pWalker, p->pHaving) ) return 2;
  if( sqlite3WalkExprList(pWalker, p->pOrderBy) ) return 2;
  if( sqlite3WalkExpr(pWalker, p->pLimit) ) return 2;
  if( sqlite3WalkExpr(pWalker, p->pOffset) ) return 2;
  return 0;
}
# 69371 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3WalkSelectFrom(Walker *pWalker, Select *p){
  SrcList *pSrc;
  int i;
  struct SrcList_item *pItem;

  pSrc = p->pSrc;
  if( (pSrc) ){
    for(i=pSrc->nSrc, pItem=pSrc->a; i>0; i--, pItem++){
      if( sqlite3WalkSelect(pWalker, pItem->pSelect) ){
        return 2;
      }
    }
  }
  return 0;
}
# 69398 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3WalkSelect(Walker *pWalker, Select *p){
  int rc;
  if( p==0 || pWalker->xSelectCallback==0 ) return 0;
  rc = 0;
  while( p ){
    rc = pWalker->xSelectCallback(pWalker, p);
    if( rc ) break;
    if( sqlite3WalkSelectExpr(pWalker, p) ) return 2;
    if( sqlite3WalkSelectFrom(pWalker, p) ) return 2;
    p = p->pPrior;
  }
  return rc & 2;
}
# 69458 "ext/sqlite3/libsqlite/sqlite3.c"
static void resolveAlias(
  Parse *pParse,
  ExprList *pEList,
  int iCol,
  Expr *pExpr,
  const char *zType
){
  Expr *pOrig;
  Expr *pDup;
  sqlite3 *db;

  ((void) (0));
  pOrig = pEList->a[iCol].pExpr;
  ((void) (0));
  ((void) (0));
  db = pParse->db;
  if( pOrig->op!=152 && zType[0]!='G' ){
    pDup = sqlite3ExprDup(db, pOrig, 0);
    pDup = sqlite3PExpr(pParse, 24, pDup, 0, 0);
    if( pDup==0 ) return;
    if( pEList->a[iCol].iAlias==0 ){
      pEList->a[iCol].iAlias = (u16)(++pParse->nAlias);
    }
    pDup->iTable = pEList->a[iCol].iAlias;
  }else if( (((pOrig)->flags&(0x0400))==(0x0400)) || pOrig->u.zToken==0 ){
    pDup = sqlite3ExprDup(db, pOrig, 0);
    if( pDup==0 ) return;
  }else{
    char *zToken = pOrig->u.zToken;
    ((void) (0));
    pOrig->u.zToken = 0;
    pDup = sqlite3ExprDup(db, pOrig, 0);
    pOrig->u.zToken = zToken;
    if( pDup==0 ) return;
    ((void) (0));
    pDup->flags2 |= 0x0001;
    pDup->u.zToken = sqlite3DbStrDup(db, zToken);
  }
  if( pExpr->flags & 0x0100 ){
    pDup->pColl = pExpr->pColl;
    pDup->flags |= 0x0100;
  }





  (pExpr)->flags|=(0x4000);
  sqlite3ExprDelete(db, pExpr);
  memcpy(pExpr, pDup, sizeof(*pExpr));
  sqlite3DbFree(db, pDup);
}
# 69538 "ext/sqlite3/libsqlite/sqlite3.c"
static int lookupName(
  Parse *pParse,
  const char *zDb,
  const char *zTab,
  const char *zCol,
  NameContext *pNC,
  Expr *pExpr
){
  int i, j;
  int cnt = 0;
  int cntTab = 0;
  sqlite3 *db = pParse->db;
  struct SrcList_item *pItem;
  struct SrcList_item *pMatch = 0;
  NameContext *pTopNC = pNC;
  Schema *pSchema = 0;
  int isTrigger = 0;

  ((void) (0));
  ((void) (0));
  ((void) (0));


  pExpr->iTable = -1;
  pExpr->pTab = 0;
                           ;


  while( pNC && cnt==0 ){
    ExprList *pEList;
    SrcList *pSrcList = pNC->pSrcList;

    if( pSrcList ){
      for(i=0, pItem=pSrcList->a; i<pSrcList->nSrc; i++, pItem++){
        Table *pTab;
        int iDb;
        Column *pCol;

        pTab = pItem->pTab;
        ((void) (0));
        iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
        ((void) (0));
        if( zTab ){
          if( pItem->zAlias ){
            char *zTabName = pItem->zAlias;
            if( sqlite3StrICmp(zTabName, zTab)!=0 ) continue;
          }else{
            char *zTabName = pTab->zName;
            if( (zTabName==0) || sqlite3StrICmp(zTabName, zTab)!=0 ){
              continue;
            }
            if( zDb!=0 && sqlite3StrICmp(db->aDb[iDb].zName, zDb)!=0 ){
              continue;
            }
          }
        }
        if( 0==(cntTab++) ){
          pExpr->iTable = pItem->iCursor;
          pExpr->pTab = pTab;
          pSchema = pTab->pSchema;
          pMatch = pItem;
        }
        for(j=0, pCol=pTab->aCol; j<pTab->nCol; j++, pCol++){
          if( sqlite3StrICmp(pCol->zName, zCol)==0 ){
            IdList *pUsing;
            cnt++;
            pExpr->iTable = pItem->iCursor;
            pExpr->pTab = pTab;
            pMatch = pItem;
            pSchema = pTab->pSchema;

            pExpr->iColumn = j==pTab->iPKey ? -1 : (i16)j;
            if( i<pSrcList->nSrc-1 ){
              if( pItem[1].jointype & 0x0004 ){


                pItem++;
                i++;
              }else if( (pUsing = pItem[1].pUsing)!=0 ){



                int k;
                for(k=0; k<pUsing->nId; k++){
                  if( sqlite3StrICmp(pUsing->a[k].zName, zCol)==0 ){
                    pItem++;
                    i++;
                    break;
                  }
                }
              }
            }
            break;
          }
        }
      }
    }





    if( zDb==0 && zTab!=0 && cnt==0 && pParse->pTriggerTab!=0 ){
      int op = pParse->eTriggerOp;
      Table *pTab = 0;
      ((void) (0));
      if( op!=106 && sqlite3StrICmp("new",zTab) == 0 ){
        pExpr->iTable = 1;
        pTab = pParse->pTriggerTab;
      }else if( op!=105 && sqlite3StrICmp("old",zTab)==0 ){
        pExpr->iTable = 0;
        pTab = pParse->pTriggerTab;
      }

      if( pTab ){
        int iCol;
        pSchema = pTab->pSchema;
        cntTab++;
        for(iCol=0; iCol<pTab->nCol; iCol++){
          Column *pCol = &pTab->aCol[iCol];
          if( sqlite3StrICmp(pCol->zName, zCol)==0 ){
            if( iCol==pTab->iPKey ){
              iCol = -1;
            }
            break;
          }
        }
        if( iCol>=pTab->nCol && sqlite3IsRowid(zCol) ){
          iCol = -1;
        }
        if( iCol<pTab->nCol ){
          cnt++;
          if( iCol<0 ){
            pExpr->affinity = 'd';
          }else if( pExpr->iTable==0 ){
                                ;
                                ;
            pParse->oldmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));
          }else{
                                ;
                                ;
            pParse->newmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));
          }
          pExpr->iColumn = (i16)iCol;
          pExpr->pTab = pTab;
          isTrigger = 1;
        }
      }
    }





    if( cnt==0 && cntTab==1 && sqlite3IsRowid(zCol) ){
      cnt = 1;
      pExpr->iColumn = -1;
      pExpr->affinity = 'd';
    }
# 69710 "ext/sqlite3/libsqlite/sqlite3.c"
    if( cnt==0 && (pEList = pNC->pEList)!=0 && zTab==0 ){
      for(j=0; j<pEList->nExpr; j++){
        char *zAs = pEList->a[j].zName;
        if( zAs!=0 && sqlite3StrICmp(zAs, zCol)==0 ){
          Expr *pOrig;
          ((void) (0));
          ((void) (0));
          ((void) (0));
          pOrig = pEList->a[j].pExpr;
          if( !pNC->allowAgg && (((pOrig)->flags&(0x0002))==(0x0002)) ){
            sqlite3ErrorMsg(pParse, "misuse of aliased aggregate %s", zAs);
            return 2;
          }
          resolveAlias(pParse, pEList, j, pExpr, "");
          cnt = 1;
          pMatch = 0;
          ((void) (0));
          goto lookupname_end;
        }
      }
    }




    if( cnt==0 ){
      pNC = pNC->pNext;
    }
  }
# 69750 "ext/sqlite3/libsqlite/sqlite3.c"
  if( cnt==0 && zTab==0 && (((pExpr)->flags&(0x0040))==(0x0040)) ){
    pExpr->op = 94;
    pExpr->pTab = 0;
    return 1;
  }





  if( cnt!=1 ){
    const char *zErr;
    zErr = cnt==0 ? "no such column" : "ambiguous column name";
    if( zDb ){
      sqlite3ErrorMsg(pParse, "%s: %s.%s.%s", zErr, zDb, zTab, zCol);
    }else if( zTab ){
      sqlite3ErrorMsg(pParse, "%s: %s.%s", zErr, zTab, zCol);
    }else{
      sqlite3ErrorMsg(pParse, "%s: %s", zErr, zCol);
    }
    pParse->checkSchema = 1;
    pTopNC->nErr++;
  }







  if( pExpr->iColumn>=0 && pMatch!=0 ){
    int n = pExpr->iColumn;
                        ;
    if( n>=((int)(sizeof(Bitmask)*8)) ){
      n = ((int)(sizeof(Bitmask)*8))-1;
    }
    ((void) (0));
    pMatch->colUsed |= ((Bitmask)1)<<n;
  }



  sqlite3ExprDelete(db, pExpr->pLeft);
  pExpr->pLeft = 0;
  sqlite3ExprDelete(db, pExpr->pRight);
  pExpr->pRight = 0;
  pExpr->op = (isTrigger ? 60 : 152);
lookupname_end:
  if( cnt==1 ){
    ((void) (0));
    sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);


    for(;;){
      ((void) (0));
      pTopNC->nRef++;
      if( pTopNC==pNC ) break;
      pTopNC = pTopNC->pNext;
    }
    return 1;
  } else {
    return 2;
  }
}





static Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol){
  Expr *p = sqlite3ExprAlloc(db, 152, 0, 0);
  if( p ){
    struct SrcList_item *pItem = &pSrc->a[iSrc];
    p->pTab = pItem->pTab;
    p->iTable = pItem->iCursor;
    if( p->pTab->iPKey==iCol ){
      p->iColumn = -1;
    }else{
      p->iColumn = (ynVar)iCol;
                           ;
                             ;
      pItem->colUsed |= ((Bitmask)1)<<(iCol>=((int)(sizeof(Bitmask)*8)) ? ((int)(sizeof(Bitmask)*8))-1 : iCol);
    }
    (p)->flags|=(0x0004);
  }
  return p;
}
# 69849 "ext/sqlite3/libsqlite/sqlite3.c"
static int resolveExprStep(Walker *pWalker, Expr *pExpr){
  NameContext *pNC;
  Parse *pParse;

  pNC = pWalker->u.pNC;
  ((void) (0));
  pParse = pNC->pParse;
  ((void) (0));

  if( (((pExpr)->flags&(0x0004))!=0) ) return 1;
  (pExpr)->flags|=(0x0004);
# 69869 "ext/sqlite3/libsqlite/sqlite3.c"
  switch( pExpr->op ){
# 69892 "ext/sqlite3/libsqlite/sqlite3.c"
    case 26: {
      return lookupName(pParse, 0, 0, pExpr->u.zToken, pNC, pExpr);
    }




    case 118: {
      const char *zColumn;
      const char *zTable;
      const char *zDb;
      Expr *pRight;


      pRight = pExpr->pRight;
      if( pRight->op==26 ){
        zDb = 0;
        zTable = pExpr->pLeft->u.zToken;
        zColumn = pRight->u.zToken;
      }else{
        ((void) (0));
        zDb = pExpr->pLeft->u.zToken;
        zTable = pRight->pLeft->u.zToken;
        zColumn = pRight->pRight->u.zToken;
      }
      return lookupName(pParse, zDb, zTable, zColumn, pNC, pExpr);
    }



    case 155:
    case 151: {
      ExprList *pList = pExpr->x.pList;
      int n = pList ? pList->nExpr : 0;
      int no_such_func = 0;
      int wrong_num_args = 0;
      int is_agg = 0;
      int auth;
      int nId;
      const char *zId;
      FuncDef *pDef;
      u8 enc = ((pParse->db)->aDb[0].pSchema->enc);

                                          ;
      ((void) (0));
      zId = pExpr->u.zToken;
      nId = sqlite3Strlen30(zId);
      pDef = sqlite3FindFunction(pParse->db, zId, nId, n, enc, 0);
      if( pDef==0 ){
        pDef = sqlite3FindFunction(pParse->db, zId, nId, -1, enc, 0);
        if( pDef==0 ){
          no_such_func = 1;
        }else{
          wrong_num_args = 1;
        }
      }else{
        is_agg = pDef->xFunc==0;
      }

      if( pDef ){
        auth = sqlite3AuthCheck(pParse, 31, 0, pDef->zName, 0);
        if( auth!=0 ){
          if( auth==1 ){
            sqlite3ErrorMsg(pParse, "not authorized to use function: %s",
                                    pDef->zName);
            pNC->nErr++;
          }
          pExpr->op = 98;
          return 1;
        }
      }

      if( is_agg && !pNC->allowAgg ){
        sqlite3ErrorMsg(pParse, "misuse of aggregate function %.*s()", nId,zId);
        pNC->nErr++;
        is_agg = 0;
      }else if( no_such_func ){
        sqlite3ErrorMsg(pParse, "no such function: %.*s", nId, zId);
        pNC->nErr++;
      }else if( wrong_num_args ){
        sqlite3ErrorMsg(pParse,"wrong number of arguments to function %.*s()",
             nId, zId);
        pNC->nErr++;
      }
      if( is_agg ){
        pExpr->op = 153;
        pNC->hasAgg = 1;
      }
      if( is_agg ) pNC->allowAgg = 0;
      sqlite3WalkExprList(pWalker, pList);
      if( is_agg ) pNC->allowAgg = 1;



      return 1;
    }

    case 116:
    case 20: ;

    case 72: {
                                  ;
      if( (((pExpr)->flags&(0x0800))==(0x0800)) ){
        int nRef = pNC->nRef;

        if( pNC->isCheck ){
          sqlite3ErrorMsg(pParse,"subqueries prohibited in CHECK constraints");
        }

        sqlite3WalkSelect(pWalker, pExpr->x.pSelect);
        ((void) (0));
        if( nRef!=pNC->nRef ){
          (pExpr)->flags|=(0x0020);
        }
      }
      break;
    }

    case 133: {
      if( pNC->isCheck ){
        sqlite3ErrorMsg(pParse,"parameters prohibited in CHECK constraints");
      }
      break;
    }

  }
  return (pParse->nErr || pParse->db->mallocFailed) ? 2 : 0;
}
# 70033 "ext/sqlite3/libsqlite/sqlite3.c"
static int resolveAsName(
  Parse *pParse,
  ExprList *pEList,
  Expr *pE
){
  int i;

  (void)(pParse);

  if( pE->op==26 ){
    char *zCol = pE->u.zToken;
    for(i=0; i<pEList->nExpr; i++){
      char *zAs = pEList->a[i].zName;
      if( zAs!=0 && sqlite3StrICmp(zAs, zCol)==0 ){
        return i+1;
      }
    }
  }
  return 0;
}
# 70072 "ext/sqlite3/libsqlite/sqlite3.c"
static int resolveOrderByTermToExprList(
  Parse *pParse,
  Select *pSelect,
  Expr *pE
){
  int i;
  ExprList *pEList;
  NameContext nc;
  sqlite3 *db;
  int rc;
  u8 savedSuppErr;

  ((void) (0));
  pEList = pSelect->pEList;



  memset(&nc, 0, sizeof(nc));
  nc.pParse = pParse;
  nc.pSrcList = pSelect->pSrc;
  nc.pEList = pEList;
  nc.allowAgg = 1;
  nc.nErr = 0;
  db = pParse->db;
  savedSuppErr = db->suppressErr;
  db->suppressErr = 1;
  rc = sqlite3ResolveExprNames(&nc, pE);
  db->suppressErr = savedSuppErr;
  if( rc ) return 0;





  for(i=0; i<pEList->nExpr; i++){
    if( sqlite3ExprCompare(pEList->a[i].pExpr, pE)<2 ){
      return i+1;
    }
  }


  return 0;
}




static void resolveOutOfRangeError(
  Parse *pParse,
  const char *zType,
  int i,
  int mx
){
  sqlite3ErrorMsg(pParse,
    "%r %s BY term out of range - should be "
    "between 1 and %d", i, zType, mx);
}
# 70145 "ext/sqlite3/libsqlite/sqlite3.c"
static int resolveCompoundOrderBy(
  Parse *pParse,
  Select *pSelect
){
  int i;
  ExprList *pOrderBy;
  ExprList *pEList;
  sqlite3 *db;
  int moreToDo = 1;

  pOrderBy = pSelect->pOrderBy;
  if( pOrderBy==0 ) return 0;
  db = pParse->db;

  if( pOrderBy->nExpr>db->aLimit[2] ){
    sqlite3ErrorMsg(pParse, "too many terms in ORDER BY clause");
    return 1;
  }

  for(i=0; i<pOrderBy->nExpr; i++){
    pOrderBy->a[i].done = 0;
  }
  pSelect->pNext = 0;
  while( pSelect->pPrior ){
    pSelect->pPrior->pNext = pSelect;
    pSelect = pSelect->pPrior;
  }
  while( pSelect && moreToDo ){
    struct ExprList_item *pItem;
    moreToDo = 0;
    pEList = pSelect->pEList;
    ((void) (0));
    for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){
      int iCol = -1;
      Expr *pE, *pDup;
      if( pItem->done ) continue;
      pE = pItem->pExpr;
      if( sqlite3ExprIsInteger(pE, &iCol) ){
        if( iCol<=0 || iCol>pEList->nExpr ){
          resolveOutOfRangeError(pParse, "ORDER", i+1, pEList->nExpr);
          return 1;
        }
      }else{
        iCol = resolveAsName(pParse, pEList, pE);
        if( iCol==0 ){
          pDup = sqlite3ExprDup(db, pE, 0);
          if( !db->mallocFailed ){
            ((void) (0));
            iCol = resolveOrderByTermToExprList(pParse, pSelect, pDup);
          }
          sqlite3ExprDelete(db, pDup);
        }
      }
      if( iCol>0 ){
        CollSeq *pColl = pE->pColl;
        int flags = pE->flags & 0x0100;
        sqlite3ExprDelete(db, pE);
        pItem->pExpr = pE = sqlite3Expr(db, 129, 0);
        if( pE==0 ) return 1;
        pE->pColl = pColl;
        pE->flags |= 0x0400 | flags;
        pE->u.iValue = iCol;
        pItem->iCol = (u16)iCol;
        pItem->done = 1;
      }else{
        moreToDo = 1;
      }
    }
    pSelect = pSelect->pNext;
  }
  for(i=0; i<pOrderBy->nExpr; i++){
    if( pOrderBy->a[i].done==0 ){
      sqlite3ErrorMsg(pParse, "%r ORDER BY term does not match any "
            "column in the result set", i+1);
      return 1;
    }
  }
  return 0;
}
# 70235 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3ResolveOrderGroupBy(
  Parse *pParse,
  Select *pSelect,
  ExprList *pOrderBy,
  const char *zType
){
  int i;
  sqlite3 *db = pParse->db;
  ExprList *pEList;
  struct ExprList_item *pItem;

  if( pOrderBy==0 || pParse->db->mallocFailed ) return 0;

  if( pOrderBy->nExpr>db->aLimit[2] ){
    sqlite3ErrorMsg(pParse, "too many terms in %s BY clause", zType);
    return 1;
  }

  pEList = pSelect->pEList;
  ((void) (0));
  for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){
    if( pItem->iCol ){
      if( pItem->iCol>pEList->nExpr ){
        resolveOutOfRangeError(pParse, zType, i+1, pEList->nExpr);
        return 1;
      }
      resolveAlias(pParse, pEList, pItem->iCol-1, pItem->pExpr, zType);
    }
  }
  return 0;
}
# 70285 "ext/sqlite3/libsqlite/sqlite3.c"
static int resolveOrderGroupBy(
  NameContext *pNC,
  Select *pSelect,
  ExprList *pOrderBy,
  const char *zType
){
  int i;
  int iCol;
  struct ExprList_item *pItem;
  Parse *pParse;
  int nResult;

  if( pOrderBy==0 ) return 0;
  nResult = pSelect->pEList->nExpr;
  pParse = pNC->pParse;
  for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){
    Expr *pE = pItem->pExpr;
    iCol = resolveAsName(pParse, pSelect->pEList, pE);
    if( iCol>0 ){




      pItem->iCol = (u16)iCol;
      continue;
    }
    if( sqlite3ExprIsInteger(pE, &iCol) ){



      if( iCol<1 ){
        resolveOutOfRangeError(pParse, zType, i+1, nResult);
        return 1;
      }
      pItem->iCol = (u16)iCol;
      continue;
    }


    pItem->iCol = 0;
    if( sqlite3ResolveExprNames(pNC, pE) ){
      return 1;
    }
  }
  return sqlite3ResolveOrderGroupBy(pParse, pSelect, pOrderBy, zType);
}




static int resolveSelectStep(Walker *pWalker, Select *p){
  NameContext *pOuterNC;
  NameContext sNC;
  int isCompound;
  int nCompound;
  Parse *pParse;
  ExprList *pEList;
  int i;
  ExprList *pGroupBy;
  Select *pLeftmost;
  sqlite3 *db;


  ((void) (0));
  if( p->selFlags & 0x0002 ){
    return 1;
  }
  pOuterNC = pWalker->u.pNC;
  pParse = pWalker->pParse;
  db = pParse->db;
# 70364 "ext/sqlite3/libsqlite/sqlite3.c"
  if( (p->selFlags & 0x0010)==0 ){
    sqlite3SelectPrep(pParse, p, pOuterNC);
    return (pParse->nErr || db->mallocFailed) ? 2 : 1;
  }

  isCompound = p->pPrior!=0;
  nCompound = 0;
  pLeftmost = p;
  while( p ){
    ((void) (0));
    ((void) (0));
    p->selFlags |= 0x0002;




    memset(&sNC, 0, sizeof(sNC));
    sNC.pParse = pParse;
    if( sqlite3ResolveExprNames(&sNC, p->pLimit) ||
        sqlite3ResolveExprNames(&sNC, p->pOffset) ){
      return 2;
    }




    sNC.allowAgg = 1;
    sNC.pSrcList = p->pSrc;
    sNC.pNext = pOuterNC;


    pEList = p->pEList;
    ((void) (0));
    for(i=0; i<pEList->nExpr; i++){
      Expr *pX = pEList->a[i].pExpr;
      if( sqlite3ResolveExprNames(&sNC, pX) ){
        return 2;
      }
    }



    for(i=0; i<p->pSrc->nSrc; i++){
      struct SrcList_item *pItem = &p->pSrc->a[i];
      if( pItem->pSelect ){
        const char *zSavedContext = pParse->zAuthContext;
        if( pItem->zName ) pParse->zAuthContext = pItem->zName;
        sqlite3ResolveSelectNames(pParse, pItem->pSelect, pOuterNC);
        pParse->zAuthContext = zSavedContext;
        if( pParse->nErr || db->mallocFailed ) return 2;
      }
    }




    ((void) (0));
    pGroupBy = p->pGroupBy;
    if( pGroupBy || sNC.hasAgg ){
      p->selFlags |= 0x0004;
    }else{
      sNC.allowAgg = 0;
    }



    if( p->pHaving && !pGroupBy ){
      sqlite3ErrorMsg(pParse, "a GROUP BY clause is required before HAVING");
      return 2;
    }
# 70443 "ext/sqlite3/libsqlite/sqlite3.c"
    sNC.pEList = p->pEList;
    if( sqlite3ResolveExprNames(&sNC, p->pWhere) ||
       sqlite3ResolveExprNames(&sNC, p->pHaving)
    ){
      return 2;
    }




    sNC.pNext = 0;
    sNC.allowAgg = 1;






    if( !isCompound && resolveOrderGroupBy(&sNC, p, p->pOrderBy, "ORDER") ){
      return 2;
    }
    if( db->mallocFailed ){
      return 2;
    }




    if( pGroupBy ){
      struct ExprList_item *pItem;

      if( resolveOrderGroupBy(&sNC, p, pGroupBy, "GROUP") || db->mallocFailed ){
        return 2;
      }
      for(i=0, pItem=pGroupBy->a; i<pGroupBy->nExpr; i++, pItem++){
        if( (((pItem->pExpr)->flags&(0x0002))==(0x0002)) ){
          sqlite3ErrorMsg(pParse, "aggregate functions are not allowed in "
              "the GROUP BY clause");
          return 2;
        }
      }
    }



    p = p->pPrior;
    nCompound++;
  }




  if( isCompound && resolveCompoundOrderBy(pParse, pLeftmost) ){
    return 2;
  }

  return 1;
}
# 70550 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3ResolveExprNames(
  NameContext *pNC,
  Expr *pExpr
){
  int savedHasAgg;
  Walker w;

  if( pExpr==0 ) return 0;

  {
    Parse *pParse = pNC->pParse;
    if( sqlite3ExprCheckHeight(pParse, pExpr->nHeight+pNC->pParse->nHeight) ){
      return 1;
    }
    pParse->nHeight += pExpr->nHeight;
  }

  savedHasAgg = pNC->hasAgg;
  pNC->hasAgg = 0;
  w.xExprCallback = resolveExprStep;
  w.xSelectCallback = resolveSelectStep;
  w.pParse = pNC->pParse;
  w.u.pNC = pNC;
  sqlite3WalkExpr(&w, pExpr);

  pNC->pParse->nHeight -= pExpr->nHeight;

  if( pNC->nErr>0 || w.pParse->nErr>0 ){
    (pExpr)->flags|=(0x0008);
  }
  if( pNC->hasAgg ){
    (pExpr)->flags|=(0x0002);
  }else if( savedHasAgg ){
    pNC->hasAgg = 1;
  }
  return (((pExpr)->flags&(0x0008))==(0x0008));
}
# 70601 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3ResolveSelectNames(
  Parse *pParse,
  Select *p,
  NameContext *pOuterNC
){
  Walker w;

  ((void) (0));
  w.xExprCallback = resolveExprStep;
  w.xSelectCallback = resolveSelectStep;
  w.pParse = pParse;
  w.u.pNC = pOuterNC;
  sqlite3WalkSelect(&w, p);
}
# 70649 "ext/sqlite3/libsqlite/sqlite3.c"
static char sqlite3ExprAffinity(Expr *pExpr){
  int op = pExpr->op;
  if( op==116 ){
    ((void) (0));
    return sqlite3ExprAffinity(pExpr->x.pSelect->pEList->a[0].pExpr);
  }

  if( op==37 ){
    ((void) (0));
    return sqlite3AffinityType(pExpr->u.zToken);
  }

  if( (op==154 || op==152 || op==132)
   && pExpr->pTab!=0
  ){


    int j = pExpr->iColumn;
    if( j<0 ) return 'd';
    ((void) (0));
    return pExpr->pTab->aCol[j].affinity;
  }
  return pExpr->affinity;
}





static Expr *sqlite3ExprSetColl(Expr *pExpr, CollSeq *pColl){
  if( pExpr && pColl ){
    pExpr->pColl = pColl;
    pExpr->flags |= 0x0100;
  }
  return pExpr;
}
# 70693 "ext/sqlite3/libsqlite/sqlite3.c"
static Expr *sqlite3ExprSetCollByToken(Parse *pParse, Expr *pExpr, Token *pCollName){
  char *zColl = 0;
  CollSeq *pColl;
  sqlite3 *db = pParse->db;
  zColl = sqlite3NameFromToken(db, pCollName);
  pColl = sqlite3LocateCollSeq(pParse, zColl);
  sqlite3ExprSetColl(pExpr, pColl);
  sqlite3DbFree(db, zColl);
  return pExpr;
}





static CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr){
  CollSeq *pColl = 0;
  Expr *p = pExpr;
  while( p ){
    int op;
    pColl = p->pColl;
    if( pColl ) break;
    op = p->op;
    if( p->pTab!=0 && (
        op==154 || op==152 || op==132 || op==60
    )){


      const char *zColl;
      int j = p->iColumn;
      if( j>=0 ){
        sqlite3 *db = pParse->db;
        zColl = p->pTab->aCol[j].zColl;
        pColl = sqlite3FindCollSeq(db, ((db)->aDb[0].pSchema->enc), zColl, 0);
        pExpr->pColl = pColl;
      }
      break;
    }
    if( op!=37 && op!=157 ){
      break;
    }
    p = p->pLeft;
  }
  if( sqlite3CheckCollSeq(pParse, pColl) ){
    pColl = 0;
  }
  return pColl;
}






static char sqlite3CompareAffinity(Expr *pExpr, char aff2){
  char aff1 = sqlite3ExprAffinity(pExpr);
  if( aff1 && aff2 ){



    if( ((aff1)>='c') || ((aff2)>='c') ){
      return 'c';
    }else{
      return 'b';
    }
  }else if( !aff1 && !aff2 ){



    return 'b';
  }else{

    ((void) (0));
    return (aff1 + aff2);
  }
}





static char comparisonAffinity(Expr *pExpr){
  char aff;
  ((void) (0));


  ((void) (0));
  aff = sqlite3ExprAffinity(pExpr->pLeft);
  if( pExpr->pRight ){
    aff = sqlite3CompareAffinity(pExpr->pRight, aff);
  }else if( (((pExpr)->flags&(0x0800))==(0x0800)) ){
    aff = sqlite3CompareAffinity(pExpr->x.pSelect->pEList->a[0].pExpr, aff);
  }else if( !aff ){
    aff = 'b';
  }
  return aff;
}







static int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity){
  char aff = comparisonAffinity(pExpr);
  switch( aff ){
    case 'b':
      return 1;
    case 'a':
      return idx_affinity=='a';
    default:
      return ((idx_affinity)>='c');
  }
}





static u8 binaryCompareP5(Expr *pExpr1, Expr *pExpr2, int jumpIfNull){
  u8 aff = (char)sqlite3ExprAffinity(pExpr2);
  aff = (u8)sqlite3CompareAffinity(pExpr1, aff) | (u8)jumpIfNull;
  return aff;
}
# 70831 "ext/sqlite3/libsqlite/sqlite3.c"
static CollSeq *sqlite3BinaryCompareCollSeq(
  Parse *pParse,
  Expr *pLeft,
  Expr *pRight
){
  CollSeq *pColl;
  ((void) (0));
  if( pLeft->flags & 0x0100 ){
    ((void) (0));
    pColl = pLeft->pColl;
  }else if( pRight && pRight->flags & 0x0100 ){
    ((void) (0));
    pColl = pRight->pColl;
  }else{
    pColl = sqlite3ExprCollSeq(pParse, pLeft);
    if( !pColl ){
      pColl = sqlite3ExprCollSeq(pParse, pRight);
    }
  }
  return pColl;
}




static int codeCompare(
  Parse *pParse,
  Expr *pLeft,
  Expr *pRight,
  int opcode,
  int in1, int in2,
  int dest,
  int jumpIfNull
){
  int p5;
  int addr;
  CollSeq *p4;

  p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);
  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);
  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,
                           (void*)p4, (-4));
  sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);
  return addr;
}







static int sqlite3ExprCheckHeight(Parse *pParse, int nHeight){
  int rc = 0;
  int mxHeight = pParse->db->aLimit[3];
  if( nHeight>mxHeight ){
    sqlite3ErrorMsg(pParse,
       "Expression tree is too large (maximum depth %d)", mxHeight
    );
    rc = 1;
  }
  return rc;
}
# 70904 "ext/sqlite3/libsqlite/sqlite3.c"
static void heightOfExpr(Expr *p, int *pnHeight){
  if( p ){
    if( p->nHeight>*pnHeight ){
      *pnHeight = p->nHeight;
    }
  }
}
static void heightOfExprList(ExprList *p, int *pnHeight){
  if( p ){
    int i;
    for(i=0; i<p->nExpr; i++){
      heightOfExpr(p->a[i].pExpr, pnHeight);
    }
  }
}
static void heightOfSelect(Select *p, int *pnHeight){
  if( p ){
    heightOfExpr(p->pWhere, pnHeight);
    heightOfExpr(p->pHaving, pnHeight);
    heightOfExpr(p->pLimit, pnHeight);
    heightOfExpr(p->pOffset, pnHeight);
    heightOfExprList(p->pEList, pnHeight);
    heightOfExprList(p->pGroupBy, pnHeight);
    heightOfExprList(p->pOrderBy, pnHeight);
    heightOfSelect(p->pPrior, pnHeight);
  }
}
# 70939 "ext/sqlite3/libsqlite/sqlite3.c"
static void exprSetHeight(Expr *p){
  int nHeight = 0;
  heightOfExpr(p->pLeft, &nHeight);
  heightOfExpr(p->pRight, &nHeight);
  if( (((p)->flags&(0x0800))==(0x0800)) ){
    heightOfSelect(p->x.pSelect, &nHeight);
  }else{
    heightOfExprList(p->x.pList, &nHeight);
  }
  p->nHeight = nHeight + 1;
}






static void sqlite3ExprSetHeight(Parse *pParse, Expr *p){
  exprSetHeight(p);
  sqlite3ExprCheckHeight(pParse, p->nHeight);
}





static int sqlite3SelectExprHeight(Select *p){
  int nHeight = 0;
  heightOfSelect(p, &nHeight);
  return nHeight;
}
# 70994 "ext/sqlite3/libsqlite/sqlite3.c"
static Expr *sqlite3ExprAlloc(
  sqlite3 *db,
  int op,
  const Token *pToken,
  int dequote
){
  Expr *pNew;
  int nExtra = 0;
  int iValue = 0;

  if( pToken ){
    if( op!=129 || pToken->z==0
          || sqlite3GetInt32(pToken->z, &iValue)==0 ){
      nExtra = pToken->n+1;
      ((void) (0));
    }
  }
  pNew = sqlite3DbMallocZero(db, sizeof(Expr)+nExtra);
  if( pNew ){
    pNew->op = (u8)op;
    pNew->iAgg = -1;
    if( pToken ){
      if( nExtra==0 ){
        pNew->flags |= 0x0400;
        pNew->u.iValue = iValue;
      }else{
        int c;
        pNew->u.zToken = (char*)&pNew[1];
        memcpy(pNew->u.zToken, pToken->z, pToken->n);
        pNew->u.zToken[pToken->n] = 0;
        if( dequote && nExtra>=3
             && ((c = pToken->z[0])=='\'' || c=='"' || c=='[' || c=='`') ){
          sqlite3Dequote(pNew->u.zToken);
          if( c=='"' ) pNew->flags |= 0x0040;
        }
      }
    }

    pNew->nHeight = 1;

  }
  return pNew;
}





static Expr *sqlite3Expr(
  sqlite3 *db,
  int op,
  const char *zToken
){
  Token x;
  x.z = zToken;
  x.n = zToken ? sqlite3Strlen30(zToken) : 0;
  return sqlite3ExprAlloc(db, op, &x, 0);
}







static void sqlite3ExprAttachSubtrees(
  sqlite3 *db,
  Expr *pRoot,
  Expr *pLeft,
  Expr *pRight
){
  if( pRoot==0 ){
    ((void) (0));
    sqlite3ExprDelete(db, pLeft);
    sqlite3ExprDelete(db, pRight);
  }else{
    if( pRight ){
      pRoot->pRight = pRight;
      if( pRight->flags & 0x0100 ){
        pRoot->flags |= 0x0100;
        pRoot->pColl = pRight->pColl;
      }
    }
    if( pLeft ){
      pRoot->pLeft = pLeft;
      if( pLeft->flags & 0x0100 ){
        pRoot->flags |= 0x0100;
        pRoot->pColl = pLeft->pColl;
      }
    }
    exprSetHeight(pRoot);
  }
}
# 71095 "ext/sqlite3/libsqlite/sqlite3.c"
static Expr *sqlite3PExpr(
  Parse *pParse,
  int op,
  Expr *pLeft,
  Expr *pRight,
  const Token *pToken
){
  Expr *p = sqlite3ExprAlloc(pParse->db, op, pToken, 1);
  sqlite3ExprAttachSubtrees(pParse->db, p, pLeft, pRight);
  if( p ) {
    sqlite3ExprCheckHeight(pParse, p->nHeight);
  }
  return p;
}





static Expr *sqlite3ExprAnd(sqlite3 *db, Expr *pLeft, Expr *pRight){
  if( pLeft==0 ){
    return pRight;
  }else if( pRight==0 ){
    return pLeft;
  }else{
    Expr *pNew = sqlite3ExprAlloc(db, 69, 0, 0);
    sqlite3ExprAttachSubtrees(db, pNew, pLeft, pRight);
    return pNew;
  }
}





static Expr *sqlite3ExprFunction(Parse *pParse, ExprList *pList, Token *pToken){
  Expr *pNew;
  sqlite3 *db = pParse->db;
  ((void) (0));
  pNew = sqlite3ExprAlloc(db, 151, pToken, 1);
  if( pNew==0 ){
    sqlite3ExprListDelete(db, pList);
    return 0;
  }
  pNew->x.pList = pList;
  ((void) (0));
  sqlite3ExprSetHeight(pParse, pNew);
  return pNew;
}
# 71161 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3ExprAssignVarNumber(Parse *pParse, Expr *pExpr){
  sqlite3 *db = pParse->db;
  const char *z;

  if( pExpr==0 ) return;
  ((void) (0));
  z = pExpr->u.zToken;
  ((void) (0));
  ((void) (0));
  if( z[1]==0 ){

    ((void) (0));
    pExpr->iColumn = (ynVar)(++pParse->nVar);
  }else if( z[0]=='?' ){


    i64 i;
    int bOk = 0==sqlite3Atoi64(&z[1], &i, sqlite3Strlen30(&z[1]), 1);
    pExpr->iColumn = (ynVar)i;
                    ;
                    ;
                                                             ;
                                                           ;
    if( bOk==0 || i<1 || i>db->aLimit[9] ){
      sqlite3ErrorMsg(pParse, "variable number must be between ?1 and ?%d",
          db->aLimit[9]);
    }
    if( i>pParse->nVar ){
      pParse->nVar = (int)i;
    }
  }else{




    int i;
    u32 n;
    n = sqlite3Strlen30(z);
    for(i=0; i<pParse->nVarExpr; i++){
      Expr *pE = pParse->apVarExpr[i];
      ((void) (0));
      if( memcmp(pE->u.zToken, z, n)==0 && pE->u.zToken[n]==0 ){
        pExpr->iColumn = pE->iColumn;
        break;
      }
    }
    if( i>=pParse->nVarExpr ){
      pExpr->iColumn = (ynVar)(++pParse->nVar);
      if( pParse->nVarExpr>=pParse->nVarExprAlloc-1 ){
        pParse->nVarExprAlloc += pParse->nVarExprAlloc + 10;
        pParse->apVarExpr =
            sqlite3DbReallocOrFree(
              db,
              pParse->apVarExpr,
              pParse->nVarExprAlloc*sizeof(pParse->apVarExpr[0])
            );
      }
      if( !db->mallocFailed ){
        ((void) (0));
        pParse->apVarExpr[pParse->nVarExpr++] = pExpr;
      }
    }
  }
  if( !pParse->nErr && pParse->nVar>db->aLimit[9] ){
    sqlite3ErrorMsg(pParse, "too many SQL variables");
  }
}




static void sqlite3ExprDelete(sqlite3 *db, Expr *p){
  if( p==0 ) return;

  ((void) (0));
  if( !(((p)->flags&(0x2000))!=0) ){
    sqlite3ExprDelete(db, p->pLeft);
    sqlite3ExprDelete(db, p->pRight);
    if( !(((p)->flags&(0x1000))==(0x1000)) && (p->flags2 & 0x0001)!=0 ){
      sqlite3DbFree(db, p->u.zToken);
    }
    if( (((p)->flags&(0x0800))==(0x0800)) ){
      sqlite3SelectDelete(db, p->x.pSelect);
    }else{
      sqlite3ExprListDelete(db, p->x.pList);
    }
  }
  if( !(((p)->flags&(0x4000))==(0x4000)) ){
    sqlite3DbFree(db, p);
  }
}






static int exprStructSize(Expr *p){
  if( (((p)->flags&(0x2000))==(0x2000)) ) return __builtin_offsetof(Expr, pLeft);
  if( (((p)->flags&(0x1000))==(0x1000)) ) return __builtin_offsetof(Expr, iTable);
  return sizeof(Expr);
}
# 71298 "ext/sqlite3/libsqlite/sqlite3.c"
static int dupedExprStructSize(Expr *p, int flags){
  int nSize;
  ((void) (0));
  if( 0==(flags&0x0001) ){
    nSize = sizeof(Expr);
  }else{
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    if( p->pLeft || p->pRight || p->pColl || p->x.pList ){
      nSize = __builtin_offsetof(Expr, iTable) | 0x1000;
    }else{
      nSize = __builtin_offsetof(Expr, pLeft) | 0x2000;
    }
  }
  return nSize;
}






static int dupedExprNodeSize(Expr *p, int flags){
  int nByte = dupedExprStructSize(p, flags) & 0xfff;
  if( !(((p)->flags&(0x0400))==(0x0400)) && p->u.zToken ){
    nByte += sqlite3Strlen30(p->u.zToken)+1;
  }
  return (((nByte)+7)&~7);
}
# 71343 "ext/sqlite3/libsqlite/sqlite3.c"
static int dupedExprSize(Expr *p, int flags){
  int nByte = 0;
  if( p ){
    nByte = dupedExprNodeSize(p, flags);
    if( flags&0x0001 ){
      nByte += dupedExprSize(p->pLeft, flags) + dupedExprSize(p->pRight, flags);
    }
  }
  return nByte;
}
# 71362 "ext/sqlite3/libsqlite/sqlite3.c"
static Expr *exprDup(sqlite3 *db, Expr *p, int flags, u8 **pzBuffer){
  Expr *pNew = 0;
  if( p ){
    const int isReduced = (flags&0x0001);
    u8 *zAlloc;
    u32 staticFlag = 0;

    ((void) (0));


    if( pzBuffer ){
      zAlloc = *pzBuffer;
      staticFlag = 0x4000;
    }else{
      zAlloc = sqlite3DbMallocRaw(db, dupedExprSize(p, flags));
    }
    pNew = (Expr *)zAlloc;

    if( pNew ){





      const unsigned nStructSize = dupedExprStructSize(p, flags);
      const int nNewSize = nStructSize & 0xfff;
      int nToken;
      if( !(((p)->flags&(0x0400))==(0x0400)) && p->u.zToken ){
        nToken = sqlite3Strlen30(p->u.zToken) + 1;
      }else{
        nToken = 0;
      }
      if( isReduced ){
        ((void) (0));
        memcpy(zAlloc, p, nNewSize);
      }else{
        int nSize = exprStructSize(p);
        memcpy(zAlloc, p, nSize);
        memset(&zAlloc[nSize], 0, sizeof(Expr)-nSize);
      }


      pNew->flags &= ~(0x1000|0x2000|0x4000);
      pNew->flags |= nStructSize & (0x1000|0x2000);
      pNew->flags |= staticFlag;


      if( nToken ){
        char *zToken = pNew->u.zToken = (char*)&zAlloc[nNewSize];
        memcpy(zToken, p->u.zToken, nToken);
      }

      if( 0==((p->flags|pNew->flags) & 0x2000) ){

        if( (((p)->flags&(0x0800))==(0x0800)) ){
          pNew->x.pSelect = sqlite3SelectDup(db, p->x.pSelect, isReduced);
        }else{
          pNew->x.pList = sqlite3ExprListDup(db, p->x.pList, isReduced);
        }
      }


      if( (((pNew)->flags&(0x1000|0x2000))!=0) ){
        zAlloc += dupedExprNodeSize(p, flags);
        if( (((pNew)->flags&(0x1000))==(0x1000)) ){
          pNew->pLeft = exprDup(db, p->pLeft, 0x0001, &zAlloc);
          pNew->pRight = exprDup(db, p->pRight, 0x0001, &zAlloc);
        }
        if( pzBuffer ){
          *pzBuffer = zAlloc;
        }
      }else{
        pNew->flags2 = 0;
        if( !(((p)->flags&(0x2000))!=0) ){
          pNew->pLeft = sqlite3ExprDup(db, p->pLeft, 0);
          pNew->pRight = sqlite3ExprDup(db, p->pRight, 0);
        }
      }

    }
  }
  return pNew;
}
# 71463 "ext/sqlite3/libsqlite/sqlite3.c"
static Expr *sqlite3ExprDup(sqlite3 *db, Expr *p, int flags){
  return exprDup(db, p, flags, 0);
}
static ExprList *sqlite3ExprListDup(sqlite3 *db, ExprList *p, int flags){
  ExprList *pNew;
  struct ExprList_item *pItem, *pOldItem;
  int i;
  if( p==0 ) return 0;
  pNew = sqlite3DbMallocRaw(db, sizeof(*pNew) );
  if( pNew==0 ) return 0;
  pNew->iECursor = 0;
  pNew->nExpr = pNew->nAlloc = p->nExpr;
  pNew->a = pItem = sqlite3DbMallocRaw(db, p->nExpr*sizeof(p->a[0]) );
  if( pItem==0 ){
    sqlite3DbFree(db, pNew);
    return 0;
  }
  pOldItem = p->a;
  for(i=0; i<p->nExpr; i++, pItem++, pOldItem++){
    Expr *pOldExpr = pOldItem->pExpr;
    pItem->pExpr = sqlite3ExprDup(db, pOldExpr, flags);
    pItem->zName = sqlite3DbStrDup(db, pOldItem->zName);
    pItem->zSpan = sqlite3DbStrDup(db, pOldItem->zSpan);
    pItem->sortOrder = pOldItem->sortOrder;
    pItem->done = 0;
    pItem->iCol = pOldItem->iCol;
    pItem->iAlias = pOldItem->iAlias;
  }
  return pNew;
}
# 71502 "ext/sqlite3/libsqlite/sqlite3.c"
static SrcList *sqlite3SrcListDup(sqlite3 *db, SrcList *p, int flags){
  SrcList *pNew;
  int i;
  int nByte;
  if( p==0 ) return 0;
  nByte = sizeof(*p) + (p->nSrc>0 ? sizeof(p->a[0]) * (p->nSrc-1) : 0);
  pNew = sqlite3DbMallocRaw(db, nByte );
  if( pNew==0 ) return 0;
  pNew->nSrc = pNew->nAlloc = p->nSrc;
  for(i=0; i<p->nSrc; i++){
    struct SrcList_item *pNewItem = &pNew->a[i];
    struct SrcList_item *pOldItem = &p->a[i];
    Table *pTab;
    pNewItem->zDatabase = sqlite3DbStrDup(db, pOldItem->zDatabase);
    pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);
    pNewItem->zAlias = sqlite3DbStrDup(db, pOldItem->zAlias);
    pNewItem->jointype = pOldItem->jointype;
    pNewItem->iCursor = pOldItem->iCursor;
    pNewItem->isPopulated = pOldItem->isPopulated;
    pNewItem->zIndex = sqlite3DbStrDup(db, pOldItem->zIndex);
    pNewItem->notIndexed = pOldItem->notIndexed;
    pNewItem->pIndex = pOldItem->pIndex;
    pTab = pNewItem->pTab = pOldItem->pTab;
    if( pTab ){
      pTab->nRef++;
    }
    pNewItem->pSelect = sqlite3SelectDup(db, pOldItem->pSelect, flags);
    pNewItem->pOn = sqlite3ExprDup(db, pOldItem->pOn, flags);
    pNewItem->pUsing = sqlite3IdListDup(db, pOldItem->pUsing);
    pNewItem->colUsed = pOldItem->colUsed;
  }
  return pNew;
}
static IdList *sqlite3IdListDup(sqlite3 *db, IdList *p){
  IdList *pNew;
  int i;
  if( p==0 ) return 0;
  pNew = sqlite3DbMallocRaw(db, sizeof(*pNew) );
  if( pNew==0 ) return 0;
  pNew->nId = pNew->nAlloc = p->nId;
  pNew->a = sqlite3DbMallocRaw(db, p->nId*sizeof(p->a[0]) );
  if( pNew->a==0 ){
    sqlite3DbFree(db, pNew);
    return 0;
  }
  for(i=0; i<p->nId; i++){
    struct IdList_item *pNewItem = &pNew->a[i];
    struct IdList_item *pOldItem = &p->a[i];
    pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);
    pNewItem->idx = pOldItem->idx;
  }
  return pNew;
}
static Select *sqlite3SelectDup(sqlite3 *db, Select *p, int flags){
  Select *pNew;
  if( p==0 ) return 0;
  pNew = sqlite3DbMallocRaw(db, sizeof(*p) );
  if( pNew==0 ) return 0;
  pNew->pEList = sqlite3ExprListDup(db, p->pEList, flags);
  pNew->pSrc = sqlite3SrcListDup(db, p->pSrc, flags);
  pNew->pWhere = sqlite3ExprDup(db, p->pWhere, flags);
  pNew->pGroupBy = sqlite3ExprListDup(db, p->pGroupBy, flags);
  pNew->pHaving = sqlite3ExprDup(db, p->pHaving, flags);
  pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, flags);
  pNew->op = p->op;
  pNew->pPrior = sqlite3SelectDup(db, p->pPrior, flags);
  pNew->pLimit = sqlite3ExprDup(db, p->pLimit, flags);
  pNew->pOffset = sqlite3ExprDup(db, p->pOffset, flags);
  pNew->iLimit = 0;
  pNew->iOffset = 0;
  pNew->selFlags = p->selFlags & ~0x0008;
  pNew->pRightmost = 0;
  pNew->addrOpenEphm[0] = -1;
  pNew->addrOpenEphm[1] = -1;
  pNew->addrOpenEphm[2] = -1;
  return pNew;
}
# 71595 "ext/sqlite3/libsqlite/sqlite3.c"
static ExprList *sqlite3ExprListAppend(
  Parse *pParse,
  ExprList *pList,
  Expr *pExpr
){
  sqlite3 *db = pParse->db;
  if( pList==0 ){
    pList = sqlite3DbMallocZero(db, sizeof(ExprList) );
    if( pList==0 ){
      goto no_mem;
    }
    ((void) (0));
  }
  if( pList->nAlloc<=pList->nExpr ){
    struct ExprList_item *a;
    int n = pList->nAlloc*2 + 4;
    a = sqlite3DbRealloc(db, pList->a, n*sizeof(pList->a[0]));
    if( a==0 ){
      goto no_mem;
    }
    pList->a = a;
    pList->nAlloc = sqlite3DbMallocSize(db, a)/sizeof(a[0]);
  }
  ((void) (0));
  if( 1 ){
    struct ExprList_item *pItem = &pList->a[pList->nExpr++];
    memset(pItem, 0, sizeof(*pItem));
    pItem->pExpr = pExpr;
  }
  return pList;

no_mem:

  sqlite3ExprDelete(db, pExpr);
  sqlite3ExprListDelete(db, pList);
  return 0;
}
# 71641 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3ExprListSetName(
  Parse *pParse,
  ExprList *pList,
  Token *pName,
  int dequote
){
  ((void) (0));
  if( pList ){
    struct ExprList_item *pItem;
    ((void) (0));
    pItem = &pList->a[pList->nExpr-1];
    ((void) (0));
    pItem->zName = sqlite3DbStrNDup(pParse->db, pName->z, pName->n);
    if( dequote && pItem->zName ) sqlite3Dequote(pItem->zName);
  }
}
# 71666 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3ExprListSetSpan(
  Parse *pParse,
  ExprList *pList,
  ExprSpan *pSpan
){
  sqlite3 *db = pParse->db;
  ((void) (0));
  if( pList ){
    struct ExprList_item *pItem = &pList->a[pList->nExpr-1];
    ((void) (0));
    ((void) (0));
    sqlite3DbFree(db, pItem->zSpan);
    pItem->zSpan = sqlite3DbStrNDup(db, (char*)pSpan->zStart,
                                    (int)(pSpan->zEnd - pSpan->zStart));
  }
}





static void sqlite3ExprListCheckLength(
  Parse *pParse,
  ExprList *pEList,
  const char *zObject
){
  int mx = pParse->db->aLimit[2];
                                         ;
                                           ;
  if( pEList && pEList->nExpr>mx ){
    sqlite3ErrorMsg(pParse, "too many columns in %s", zObject);
  }
}




static void sqlite3ExprListDelete(sqlite3 *db, ExprList *pList){
  int i;
  struct ExprList_item *pItem;
  if( pList==0 ) return;
  ((void) (0));
  ((void) (0));
  for(pItem=pList->a, i=0; i<pList->nExpr; i++, pItem++){
    sqlite3ExprDelete(db, pItem->pExpr);
    sqlite3DbFree(db, pItem->zName);
    sqlite3DbFree(db, pItem->zSpan);
  }
  sqlite3DbFree(db, pList->a);
  sqlite3DbFree(db, pList);
}
# 71731 "ext/sqlite3/libsqlite/sqlite3.c"
static int exprNodeIsConstant(Walker *pWalker, Expr *pExpr){




  if( pWalker->u.i==3 && (((pExpr)->flags&(0x0001))!=0) ){
    pWalker->u.i = 0;
    return 2;
  }

  switch( pExpr->op ){


    case 151:
      if( pWalker->u.i==2 ) return 0;

    case 26:
    case 152:
    case 153:
    case 154:
                                  ;
                                      ;
                                            ;
                                          ;
      pWalker->u.i = 0;
      return 2;
    default:
                                      ;
                                      ;
      return 0;
  }
}
static int selectNodeIsConstant(Walker *pWalker, Select *NotUsed){
  (void)(NotUsed);
  pWalker->u.i = 0;
  return 2;
}
static int exprIsConst(Expr *p, int initFlag){
  Walker w;
  w.u.i = initFlag;
  w.xExprCallback = exprNodeIsConstant;
  w.xSelectCallback = selectNodeIsConstant;
  sqlite3WalkExpr(&w, p);
  return w.u.i;
}
# 71785 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3ExprIsConstant(Expr *p){
  return exprIsConst(p, 1);
}







static int sqlite3ExprIsConstantNotJoin(Expr *p){
  return exprIsConst(p, 3);
}
# 71808 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3ExprIsConstantOrFunction(Expr *p){
  return exprIsConst(p, 2);
}







static int sqlite3ExprIsInteger(Expr *p, int *pValue){
  int rc = 0;



  ((void) (0));


  if( p->flags & 0x0400 ){
    *pValue = p->u.iValue;
    return 1;
  }
  switch( p->op ){
    case 157: {
      rc = sqlite3ExprIsInteger(p->pLeft, pValue);
      break;
    }
    case 156: {
      int v;
      if( sqlite3ExprIsInteger(p->pLeft, &v) ){
        *pValue = -v;
        rc = 1;
      }
      break;
    }
    default: break;
  }
  return rc;
}
# 71862 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3ExprCanBeNull(const Expr *p){
  u8 op;
  while( p->op==157 || p->op==156 ){ p = p->pLeft; }
  op = p->op;
  if( op==132 ) op = p->op2;
  switch( op ){
    case 129:
    case 94:
    case 130:
    case 131:
      return 0;
    default:
      return 1;
  }
}
# 71885 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3ExprCodeIsNullJump(
  Vdbe *v,
  const Expr *pExpr,
  int iReg,
  int iDest
){
  if( sqlite3ExprCanBeNull(pExpr) ){
    sqlite3VdbeAddOp2(v, 73, iReg, iDest);
  }
}
# 71906 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3ExprNeedsNoAffinityChange(const Expr *p, char aff){
  u8 op;
  if( aff=='b' ) return 1;
  while( p->op==157 || p->op==156 ){ p = p->pLeft; }
  op = p->op;
  if( op==132 ) op = p->op2;
  switch( op ){
    case 129: {
      return aff=='d' || aff=='c';
    }
    case 130: {
      return aff=='e' || aff=='c';
    }
    case 94: {
      return aff=='a';
    }
    case 131: {
      return 1;
    }
    case 152: {
      ((void) (0));
      return p->iColumn<0
          && (aff=='d' || aff=='c');
    }
    default: {
      return 0;
    }
  }
}




static int sqlite3IsRowid(const char *z){
  if( sqlite3StrICmp(z, "_ROWID_")==0 ) return 1;
  if( sqlite3StrICmp(z, "ROWID")==0 ) return 1;
  if( sqlite3StrICmp(z, "OID")==0 ) return 1;
  return 0;
}
# 71959 "ext/sqlite3/libsqlite/sqlite3.c"
static int isCandidateForInOpt(Select *p){
  SrcList *pSrc;
  ExprList *pEList;
  Table *pTab;
  if( p==0 ) return 0;
  if( p->pPrior ) return 0;
  if( p->selFlags & (0x0001|0x0004) ){
                                                                       ;
                                                                        ;
    return 0;
  }
  ((void) (0));
  if( p->pLimit ) return 0;
  ((void) (0));
  if( p->pWhere ) return 0;
  pSrc = p->pSrc;
  ((void) (0));
  if( pSrc->nSrc!=1 ) return 0;
  if( pSrc->a[0].pSelect ) return 0;
  pTab = pSrc->a[0].pTab;
  if( (pTab==0) ) return 0;
  ((void) (0));
  if( (((pTab)->tabFlags & 0x10)!=0) ) return 0;
  pEList = p->pEList;
  if( pEList->nExpr!=1 ) return 0;
  if( pEList->a[0].pExpr->op!=152 ) return 0;
  return 1;
}
# 72044 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3FindInIndex(Parse *pParse, Expr *pX, int *prNotFound){
  Select *p;
  int eType = 0;
  int iTab = pParse->nTab++;
  int mustBeUnique = (prNotFound==0);

  ((void) (0));





  p = ((((pX)->flags&(0x0800))==(0x0800)) ? pX->x.pSelect : 0);
  if( (pParse->nErr==0) && isCandidateForInOpt(p) ){
    sqlite3 *db = pParse->db;
    Expr *pExpr = p->pEList->a[0].pExpr;
    int iCol = pExpr->iColumn;
    Vdbe *v = sqlite3GetVdbe(pParse);
    Table *pTab = p->pSrc->a[0].pTab;
    int iDb;


    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
    sqlite3CodeVerifySchema(pParse, iDb);
    sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);





    ((void) (0));
    if( iCol<0 ){
      int iMem = ++pParse->nMem;
      int iAddr;

      iAddr = sqlite3VdbeAddOp1(v, 26, iMem);
      sqlite3VdbeAddOp2(v, 7, 1, iMem);

      sqlite3OpenTable(pParse, iTab, iDb, pTab, 38);
      eType = 1;

      sqlite3VdbeJumpHere(v, iAddr);
    }else{
      Index *pIdx;




      CollSeq *pReq = sqlite3BinaryCompareCollSeq(pParse, pX->pLeft, pExpr);





      char aff = comparisonAffinity(pX);
      int affinity_ok = (pTab->aCol[iCol].affinity==aff||aff=='b');

      for(pIdx=pTab->pIndex; pIdx && eType==0 && affinity_ok; pIdx=pIdx->pNext){
        if( (pIdx->aiColumn[0]==iCol)
         && sqlite3FindCollSeq(db, ((db)->aDb[0].pSchema->enc), pIdx->azColl[0], 0)==pReq
         && (!mustBeUnique || (pIdx->nColumn==1 && pIdx->onError!=0))
        ){
          int iMem = ++pParse->nMem;
          int iAddr;
          char *pKey;

          pKey = (char *)sqlite3IndexKeyinfo(pParse, pIdx);
          iAddr = sqlite3VdbeAddOp1(v, 26, iMem);
          sqlite3VdbeAddOp2(v, 7, 1, iMem);

          sqlite3VdbeAddOp4(v, 38, iTab, pIdx->tnum, iDb,
                               pKey,(-16));
                                             ;
          eType = 3;

          sqlite3VdbeJumpHere(v, iAddr);
          if( prNotFound && !pTab->aCol[iCol].notNull ){
            *prNotFound = ++pParse->nMem;
          }
        }
      }
    }
  }

  if( eType==0 ){



    double savedNQueryLoop = pParse->nQueryLoop;
    int rMayHaveNull = 0;
    eType = 2;
    if( prNotFound ){
      *prNotFound = rMayHaveNull = ++pParse->nMem;
    }else{
                                              ;
      pParse->nQueryLoop = (double)1;
      if( pX->pLeft->iColumn<0 && !(((pX)->flags&(0x0800))!=0) ){
        eType = 1;
      }
    }
    sqlite3CodeSubselect(pParse, pX, rMayHaveNull, eType==1);
    pParse->nQueryLoop = savedNQueryLoop;
  }else{
    pX->iTable = iTab;
  }
  return eType;
}
# 72187 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3CodeSubselect(
  Parse *pParse,
  Expr *pExpr,
  int rMayHaveNull,
  int isRowid
){
  int testAddr = 0;
  int rReg = 0;
  Vdbe *v = sqlite3GetVdbe(pParse);
  if( (v==0) ) return 0;
  sqlite3ExprCachePush(pParse);
# 72209 "ext/sqlite3/libsqlite/sqlite3.c"
  if( !(((pExpr)->flags&(0x0020))!=0) && !pParse->pTriggerTab ){
    int mem = ++pParse->nMem;
    sqlite3VdbeAddOp1(v, 26, mem);
    testAddr = sqlite3VdbeAddOp2(v, 7, 1, mem);
    ((void) (0));
  }


  if( pParse->explain==2 ){
    char *zMsg = sqlite3MPrintf(
        pParse->db, "EXECUTE %s%s SUBQUERY %d", testAddr?"":"CORRELATED ",
        pExpr->op==72?"LIST":"SCALAR", pParse->iNextSelectId
    );
    sqlite3VdbeAddOp4(v, 138, pParse->iSelectId, 0, 0, zMsg, (-1));
  }


  switch( pExpr->op ){
    case 72: {
      char affinity;
      KeyInfo keyInfo;
      int addr;
      Expr *pLeft = pExpr->pLeft;

      if( rMayHaveNull ){
        sqlite3VdbeAddOp2(v, 10, 0, rMayHaveNull);
      }

      affinity = sqlite3ExprAffinity(pLeft);
# 72252 "ext/sqlite3/libsqlite/sqlite3.c"
      pExpr->iTable = pParse->nTab++;
      addr = sqlite3VdbeAddOp2(v, 41, pExpr->iTable, !isRowid);
      if( rMayHaveNull==0 ) sqlite3VdbeChangeP5(v, 16);
      memset(&keyInfo, 0, sizeof(keyInfo));
      keyInfo.nField = 1;

      if( (((pExpr)->flags&(0x0800))==(0x0800)) ){





        SelectDest dest;
        ExprList *pEList;

        ((void) (0));
        sqlite3SelectDestInit(&dest, 7, pExpr->iTable);
        dest.affinity = (u8)affinity;
        ((void) (0));
        pExpr->x.pSelect->iLimit = 0;
        if( sqlite3Select(pParse, pExpr->x.pSelect, &dest) ){
          return 0;
        }
        pEList = pExpr->x.pSelect->pEList;
        if( (pEList!=0 && pEList->nExpr>0) ){
          keyInfo.aColl[0] = sqlite3BinaryCompareCollSeq(pParse, pExpr->pLeft,
              pEList->a[0].pExpr);
        }
      }else if( (pExpr->x.pList!=0) ){







        int i;
        ExprList *pList = pExpr->x.pList;
        struct ExprList_item *pItem;
        int r1, r2, r3;

        if( !affinity ){
          affinity = 'b';
        }
        keyInfo.aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);


        r1 = sqlite3GetTempReg(pParse);
        r2 = sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp2(v, 10, 0, r2);
        for(i=pList->nExpr, pItem=pList->a; i>0; i--, pItem++){
          Expr *pE2 = pItem->pExpr;
          int iValToIns;






          if( testAddr && !sqlite3ExprIsConstant(pE2) ){
            sqlite3VdbeChangeToNoop(v, testAddr-1, 2);
            testAddr = 0;
          }


          if( isRowid && sqlite3ExprIsInteger(pE2, &iValToIns) ){
            sqlite3VdbeAddOp3(v, 56, pExpr->iTable, r2, iValToIns);
          }else{
            r3 = sqlite3ExprCodeTarget(pParse, pE2, r1);
            if( isRowid ){
              sqlite3VdbeAddOp2(v, 21, r3,
                                sqlite3VdbeCurrentAddr(v)+2);
              sqlite3VdbeAddOp3(v, 55, pExpr->iTable, r2, r3);
            }else{
              sqlite3VdbeAddOp4(v, 30, r3, 1, r2, &affinity, 1);
              sqlite3ExprCacheAffinityChange(pParse, r3, 1);
              sqlite3VdbeAddOp2(v, 70, pExpr->iTable, r2);
            }
          }
        }
        sqlite3ReleaseTempReg(pParse, r1);
        sqlite3ReleaseTempReg(pParse, r2);
      }
      if( !isRowid ){
        sqlite3VdbeChangeP4(v, addr, (void *)&keyInfo, (-6));
      }
      break;
    }

    case 20:
    case 116:
    default: {






      Select *pSel;
      SelectDest dest;

                                      ;
                                      ;
      ((void) (0));

      ((void) (0));
      pSel = pExpr->x.pSelect;
      sqlite3SelectDestInit(&dest, 0, ++pParse->nMem);
      if( pExpr->op==116 ){
        dest.eDest = 6;
        sqlite3VdbeAddOp2(v, 10, 0, dest.iParm);
                                                ;
      }else{
        dest.eDest = 3;
        sqlite3VdbeAddOp2(v, 7, 0, dest.iParm);
                                              ;
      }
      sqlite3ExprDelete(pParse->db, pSel->pLimit);
      pSel->pLimit = sqlite3PExpr(pParse, 129, 0, 0,
                                  &sqlite3IntTokens[1]);
      pSel->iLimit = 0;
      if( sqlite3Select(pParse, pSel, &dest) ){
        return 0;
      }
      rReg = dest.iParm;
                               ;
      break;
    }
  }

  if( testAddr ){
    sqlite3VdbeJumpHere(v, testAddr-1);
  }
  sqlite3ExprCachePop(pParse, 1);

  return rReg;
}
# 72409 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3ExprCodeIN(
  Parse *pParse,
  Expr *pExpr,
  int destIfFalse,
  int destIfNull
){
  int rRhsHasNull = 0;
  char affinity;
  int eType;
  int r1;
  Vdbe *v;




  v = pParse->pVdbe;
  ((void) (0));
                                       ;
  eType = sqlite3FindInIndex(pParse, pExpr, &rRhsHasNull);





  affinity = comparisonAffinity(pExpr);



  sqlite3ExprCachePush(pParse);
  r1 = sqlite3GetTempReg(pParse);
  sqlite3ExprCode(pParse, pExpr->pLeft, r1);




  if( destIfNull==destIfFalse ){


    sqlite3VdbeAddOp2(v, 73, r1, destIfNull);
  }else{
    int addr1 = sqlite3VdbeAddOp1(v, 74, r1);
    sqlite3VdbeAddOp2(v, 65, pExpr->iTable, destIfFalse);
    sqlite3VdbeAddOp2(v, 1, 0, destIfNull);
    sqlite3VdbeJumpHere(v, addr1);
  }

  if( eType==1 ){


    sqlite3VdbeAddOp2(v, 21, r1, destIfFalse);
    sqlite3VdbeAddOp3(v, 52, pExpr->iTable, destIfFalse, r1);
  }else{


    sqlite3VdbeAddOp4(v, 29, r1, 1, 0, &affinity, 1);







    if( rRhsHasNull==0 || destIfFalse==destIfNull ){







      sqlite3VdbeAddOp4Int(v, 49, pExpr->iTable, destIfFalse, r1, 1);

    }else{




      int j1, j2, j3;





      j1 = sqlite3VdbeAddOp4Int(v, 50, pExpr->iTable, 0, r1, 1);







      j2 = sqlite3VdbeAddOp1(v, 74, rRhsHasNull);
      j3 = sqlite3VdbeAddOp4Int(v, 50, pExpr->iTable, 0, rRhsHasNull, 1);
      sqlite3VdbeAddOp2(v, 7, -1, rRhsHasNull);
      sqlite3VdbeJumpHere(v, j3);
      sqlite3VdbeAddOp2(v, 20, rRhsHasNull, 1);
      sqlite3VdbeJumpHere(v, j2);




      sqlite3VdbeAddOp2(v, 26, rRhsHasNull, destIfNull);
      sqlite3VdbeAddOp2(v, 1, 0, destIfFalse);




      sqlite3VdbeJumpHere(v, j1);
    }
  }
  sqlite3ReleaseTempReg(pParse, r1);
  sqlite3ExprCachePop(pParse, 1);
                                 ;
}





static char *dup8bytes(Vdbe *v, const char *in){
  char *out = sqlite3DbMallocRaw(sqlite3VdbeDb(v), 8);
  if( out ){
    memcpy(out, in, 8);
  }
  return out;
}
# 72545 "ext/sqlite3/libsqlite/sqlite3.c"
static void codeReal(Vdbe *v, const char *z, int negateFlag, int iMem){
  if( (z!=0) ){
    double value;
    char *zV;
    sqlite3AtoF(z, &value, sqlite3Strlen30(z), 1);
    ((void) (0));
    if( negateFlag ) value = -value;
    zV = dup8bytes(v, (char*)&value);
    sqlite3VdbeAddOp4(v, 130, 0, iMem, 0, zV, (-12));
  }
}
# 72565 "ext/sqlite3/libsqlite/sqlite3.c"
static void codeInteger(Parse *pParse, Expr *pExpr, int negFlag, int iMem){
  Vdbe *v = pParse->pVdbe;
  if( pExpr->flags & 0x0400 ){
    int i = pExpr->u.iValue;
    ((void) (0));
    if( negFlag ) i = -i;
    sqlite3VdbeAddOp2(v, 7, i, iMem);
  }else{
    int c;
    i64 value;
    const char *z = pExpr->u.zToken;
    ((void) (0));
    c = sqlite3Atoi64(z, &value, sqlite3Strlen30(z), 1);
    if( c==0 || (c==2 && negFlag) ){
      char *zV;
      if( negFlag ){ value = c==2 ? (((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) : -value; }
      zV = dup8bytes(v, (char*)&value);
      sqlite3VdbeAddOp4(v, 8, 0, iMem, 0, zV, (-13));
    }else{



      codeReal(v, z, negFlag, iMem);

    }
  }
}




static void cacheEntryClear(Parse *pParse, struct yColCache *p){
  if( p->tempReg ){
    if( pParse->nTempReg<((int)(sizeof(pParse->aTempReg)/sizeof(pParse->aTempReg[0]))) ){
      pParse->aTempReg[pParse->nTempReg++] = p->iReg;
    }
    p->tempReg = 0;
  }
}






static void sqlite3ExprCacheStore(Parse *pParse, int iTab, int iCol, int iReg){
  int i;
  int minLru;
  int idxLru;
  struct yColCache *p;

  ((void) (0));
  ((void) (0));





  if( pParse->db->flags & 0x02 ) return;
# 72646 "ext/sqlite3/libsqlite/sqlite3.c"
  for(i=0, p=pParse->aColCache; i<10; i++, p++){
    if( p->iReg==0 ){
      p->iLevel = pParse->iCacheLevel;
      p->iTable = iTab;
      p->iColumn = iCol;
      p->iReg = iReg;
      p->tempReg = 0;
      p->lru = pParse->iCacheCnt++;
      return;
    }
  }


  minLru = 0x7fffffff;
  idxLru = -1;
  for(i=0, p=pParse->aColCache; i<10; i++, p++){
    if( p->lru<minLru ){
      idxLru = i;
      minLru = p->lru;
    }
  }
  if( (idxLru>=0) ){
    p = &pParse->aColCache[idxLru];
    p->iLevel = pParse->iCacheLevel;
    p->iTable = iTab;
    p->iColumn = iCol;
    p->iReg = iReg;
    p->tempReg = 0;
    p->lru = pParse->iCacheCnt++;
    return;
  }
}





static void sqlite3ExprCacheRemove(Parse *pParse, int iReg, int nReg){
  int i;
  int iLast = iReg + nReg - 1;
  struct yColCache *p;
  for(i=0, p=pParse->aColCache; i<10; i++, p++){
    int r = p->iReg;
    if( r>=iReg && r<=iLast ){
      cacheEntryClear(pParse, p);
      p->iReg = 0;
    }
  }
}






static void sqlite3ExprCachePush(Parse *pParse){
  pParse->iCacheLevel++;
}






static void sqlite3ExprCachePop(Parse *pParse, int N){
  int i;
  struct yColCache *p;
  ((void) (0));
  ((void) (0));
  pParse->iCacheLevel -= N;
  for(i=0, p=pParse->aColCache; i<10; i++, p++){
    if( p->iReg && p->iLevel>pParse->iCacheLevel ){
      cacheEntryClear(pParse, p);
      p->iReg = 0;
    }
  }
}







static void sqlite3ExprCachePinRegister(Parse *pParse, int iReg){
  int i;
  struct yColCache *p;
  for(i=0, p=pParse->aColCache; i<10; i++, p++){
    if( p->iReg==iReg ){
      p->tempReg = 0;
    }
  }
}




static void sqlite3ExprCodeGetColumnOfTable(
  Vdbe *v,
  Table *pTab,
  int iTabCur,
  int iCol,
  int regOut
){
  if( iCol<0 || iCol==pTab->iPKey ){
    sqlite3VdbeAddOp2(v, 61, iTabCur, regOut);
  }else{
    int op = (((pTab)->tabFlags & 0x10)!=0) ? 129 : 28;
    sqlite3VdbeAddOp3(v, op, iTabCur, iCol, regOut);
  }
  if( iCol>=0 ){
    sqlite3ColumnDefault(v, pTab, iCol, regOut);
  }
}
# 72770 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3ExprCodeGetColumn(
  Parse *pParse,
  Table *pTab,
  int iColumn,
  int iTable,
  int iReg
){
  Vdbe *v = pParse->pVdbe;
  int i;
  struct yColCache *p;

  for(i=0, p=pParse->aColCache; i<10; i++, p++){
    if( p->iReg>0 && p->iTable==iTable && p->iColumn==iColumn ){
      p->lru = pParse->iCacheCnt++;
      sqlite3ExprCachePinRegister(pParse, p->iReg);
      return p->iReg;
    }
  }
  ((void) (0));
  sqlite3ExprCodeGetColumnOfTable(v, pTab, iTable, iColumn, iReg);
  sqlite3ExprCacheStore(pParse, iTable, iColumn, iReg);
  return iReg;
}




static void sqlite3ExprCacheClear(Parse *pParse){
  int i;
  struct yColCache *p;

  for(i=0, p=pParse->aColCache; i<10; i++, p++){
    if( p->iReg ){
      cacheEntryClear(pParse, p);
      p->iReg = 0;
    }
  }
}





static void sqlite3ExprCacheAffinityChange(Parse *pParse, int iStart, int iCount){
  sqlite3ExprCacheRemove(pParse, iStart, iCount);
}





static void sqlite3ExprCodeMove(Parse *pParse, int iFrom, int iTo, int nReg){
  int i;
  struct yColCache *p;
  if( (iFrom==iTo) ) return;
  sqlite3VdbeAddOp3(pParse->pVdbe, 13, iFrom, iTo, nReg);
  for(i=0, p=pParse->aColCache; i<10; i++, p++){
    int x = p->iReg;
    if( x>=iFrom && x<iFrom+nReg ){
      p->iReg += iTo-iFrom;
    }
  }
}





static void sqlite3ExprCodeCopy(Parse *pParse, int iFrom, int iTo, int nReg){
  int i;
  if( (iFrom==iTo) ) return;
  for(i=0; i<nReg; i++){
    sqlite3VdbeAddOp2(pParse->pVdbe, 14, iFrom+i, iTo+i);
  }
}
# 72876 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target){
  Vdbe *v = pParse->pVdbe;
  int op;
  int inReg = target;
  int regFree1 = 0;
  int regFree2 = 0;
  int r1, r2, r3, r4;
  sqlite3 *db = pParse->db;

  ((void) (0));
  if( v==0 ){
    ((void) (0));
    return 0;
  }

  if( pExpr==0 ){
    op = 98;
  }else{
    op = pExpr->op;
  }
  switch( op ){
    case 154: {
      AggInfo *pAggInfo = pExpr->pAggInfo;
      struct AggInfo_col *pCol = &pAggInfo->aCol[pExpr->iAgg];
      if( !pAggInfo->directMode ){
        ((void) (0));
        inReg = pCol->iMem;
        break;
      }else if( pAggInfo->useSortingIdx ){
        sqlite3VdbeAddOp3(v, 28, pAggInfo->sortingIdx,
                              pCol->iSorterColumn, target);
        break;
      }

    }
    case 152: {
      if( pExpr->iTable<0 ){

        ((void) (0));
        inReg = pExpr->iColumn + pParse->ckBase;
      }else{
        inReg = sqlite3ExprCodeGetColumn(pParse, pExpr->pTab,
                                 pExpr->iColumn, pExpr->iTable, target);
      }
      break;
    }
    case 129: {
      codeInteger(pParse, pExpr, 0, target);
      break;
    }

    case 130: {
      ((void) (0));
      codeReal(v, pExpr->u.zToken, 0, target);
      break;
    }

    case 94: {
      ((void) (0));
      sqlite3VdbeAddOp4(v, 94, 0, target, 0, pExpr->u.zToken, 0);
      break;
    }
    case 98: {
      sqlite3VdbeAddOp2(v, 10, 0, target);
      break;
    }

    case 131: {
      int n;
      const char *z;
      char *zBlob;
      ((void) (0));
      ((void) (0));
      ((void) (0));
      z = &pExpr->u.zToken[2];
      n = sqlite3Strlen30(z) - 1;
      ((void) (0));
      zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, n);
      sqlite3VdbeAddOp4(v, 11, n/2, target, 0, zBlob, (-1));
      break;
    }

    case 133: {
      ((void) (0));
      ((void) (0));
      ((void) (0));
      sqlite3VdbeAddOp2(v, 12, pExpr->iColumn, target);
      if( pExpr->u.zToken[1]!=0 ){
        sqlite3VdbeChangeP4(v, -1, pExpr->u.zToken, 0);
      }
      break;
    }
    case 132: {
      inReg = pExpr->iTable;
      break;
    }
    case 24: {
      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);
      break;
    }

    case 37: {

      int aff, to_op;
      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);
      ((void) (0));
      aff = sqlite3AffinityType(pExpr->u.zToken);
      to_op = aff - 'a' + 141;
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
                                  ;
                                  ;
                                     ;
                                 ;
                                  ;
      if( inReg!=target ){
        sqlite3VdbeAddOp2(v, 15, inReg, target);
        inReg = target;
      }
      sqlite3VdbeAddOp1(v, to_op, inReg);
                                                         ;
      sqlite3ExprCacheAffinityChange(pParse, inReg, 1);
      break;
    }

    case 79:
    case 78:
    case 77:
    case 80:
    case 75:
    case 76: {
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
                           ;
                           ;
                           ;
                           ;
                           ;
                           ;
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,
                  r1, r2, inReg, 0x10);
                             ;
                             ;
      break;
    }
    case 70:
    case 146: {
                           ;
                              ;
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
      op = (op==70) ? 76 : 75;
      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,
                  r1, r2, inReg, 0x10 | 0x80);
                             ;
                             ;
      break;
    }
    case 69:
    case 68:
    case 86:
    case 88:
    case 87:
    case 90:
    case 82:
    case 83:
    case 89:
    case 84:
    case 85:
    case 91: {
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
                            ;
                           ;
                             ;
                              ;
                            ;
                               ;
                              ;
                              ;
                               ;
                               ;
                               ;
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
      sqlite3VdbeAddOp3(v, op, r2, r1, target);
                             ;
                             ;
      break;
    }
    case 156: {
      Expr *pLeft = pExpr->pLeft;
      ((void) (0));
      if( pLeft->op==129 ){
        codeInteger(pParse, pLeft, 1, target);

      }else if( pLeft->op==130 ){
        ((void) (0));
        codeReal(v, pLeft->u.zToken, 1, target);

      }else{
        regFree1 = r1 = sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp2(v, 7, 0, r1);
        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2);
        sqlite3VdbeAddOp3(v, 87, r2, r1, target);
                               ;
      }
      inReg = target;
      break;
    }
    case 93:
    case 19: {
      ((void) (0));
      ((void) (0));
                               ;
                            ;
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
                             ;
      inReg = target;
      sqlite3VdbeAddOp2(v, op, r1, inReg);
      break;
    }
    case 73:
    case 74: {
      int addr;
      ((void) (0));
      ((void) (0));
                               ;
                                ;
      sqlite3VdbeAddOp2(v, 7, 1, target);
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
                             ;
      addr = sqlite3VdbeAddOp1(v, op, r1);
      sqlite3VdbeAddOp2(v, 20, target, -1);
      sqlite3VdbeJumpHere(v, addr);
      break;
    }
    case 153: {
      AggInfo *pInfo = pExpr->pAggInfo;
      if( pInfo==0 ){
        ((void) (0));
        sqlite3ErrorMsg(pParse, "misuse of aggregate: %s()", pExpr->u.zToken);
      }else{
        inReg = pInfo->aFunc[pExpr->iAgg].iMem;
      }
      break;
    }
    case 155:
    case 151: {
      ExprList *pFarg;
      int nFarg;
      FuncDef *pDef;
      int nId;
      const char *zId;
      int constMask = 0;
      int i;
      u8 enc = ((db)->aDb[0].pSchema->enc);
      CollSeq *pColl = 0;

      ((void) (0));
                                   ;
                                 ;
      if( (((pExpr)->flags&(0x2000))!=0) ){
        pFarg = 0;
      }else{
        pFarg = pExpr->x.pList;
      }
      nFarg = pFarg ? pFarg->nExpr : 0;
      ((void) (0));
      zId = pExpr->u.zToken;
      nId = sqlite3Strlen30(zId);
      pDef = sqlite3FindFunction(db, zId, nId, nFarg, enc, 0);
      if( pDef==0 ){
        sqlite3ErrorMsg(pParse, "unknown function: %.*s()", nId, zId);
        break;
      }





      if( pDef->flags & 0x40 ){
        int endCoalesce = sqlite3VdbeMakeLabel(v);
        ((void) (0));
        sqlite3ExprCode(pParse, pFarg->a[0].pExpr, target);
        for(i=1; i<nFarg; i++){
          sqlite3VdbeAddOp2(v, 74, target, endCoalesce);
          sqlite3ExprCacheRemove(pParse, target, 1);
          sqlite3ExprCachePush(pParse);
          sqlite3ExprCode(pParse, pFarg->a[i].pExpr, target);
          sqlite3ExprCachePop(pParse, 1);
        }
        sqlite3VdbeResolveLabel(v, endCoalesce);
        break;
      }


      if( pFarg ){
        r1 = sqlite3GetTempRange(pParse, nFarg);
        sqlite3ExprCachePush(pParse);
        sqlite3ExprCodeExprList(pParse, pFarg, r1, 1);
        sqlite3ExprCachePop(pParse, 1);
      }else{
        r1 = 0;
      }
# 73212 "ext/sqlite3/libsqlite/sqlite3.c"
      if( nFarg>=2 && (pExpr->flags & 0x0080) ){
        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[1].pExpr);
      }else if( nFarg>0 ){
        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[0].pExpr);
      }

      for(i=0; i<nFarg; i++){
        if( i<32 && sqlite3ExprIsConstant(pFarg->a[i].pExpr) ){
          constMask |= (1<<i);
        }
        if( (pDef->flags & 0x08)!=0 && !pColl ){
          pColl = sqlite3ExprCollSeq(pParse, pFarg->a[i].pExpr);
        }
      }
      if( pDef->flags & 0x08 ){
        if( !pColl ) pColl = db->pDfltColl;
        sqlite3VdbeAddOp4(v, 17, 0, 0, 0, (char *)pColl, (-4));
      }
      sqlite3VdbeAddOp4(v, 18, constMask, r1, target,
                        (char*)pDef, (-5));
      sqlite3VdbeChangeP5(v, (u8)nFarg);
      if( nFarg ){
        sqlite3ReleaseTempRange(pParse, r1, nFarg);
      }
      break;
    }

    case 20:
    case 116: {
                               ;
                               ;
      inReg = sqlite3CodeSubselect(pParse, pExpr, 0, 0);
      break;
    }
    case 72: {
      int destIfFalse = sqlite3VdbeMakeLabel(v);
      int destIfNull = sqlite3VdbeMakeLabel(v);
      sqlite3VdbeAddOp2(v, 10, 0, target);
      sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);
      sqlite3VdbeAddOp2(v, 7, 1, target);
      sqlite3VdbeResolveLabel(v, destIfFalse);
      sqlite3VdbeAddOp2(v, 20, target, 0);
      sqlite3VdbeResolveLabel(v, destIfNull);
      break;
    }
# 73271 "ext/sqlite3/libsqlite/sqlite3.c"
    case 71: {
      Expr *pLeft = pExpr->pLeft;
      struct ExprList_item *pLItem = pExpr->x.pList->a;
      Expr *pRight = pLItem->pExpr;

      r1 = sqlite3ExprCodeTemp(pParse, pLeft, &regFree1);
      r2 = sqlite3ExprCodeTemp(pParse, pRight, &regFree2);
                             ;
                             ;
      r3 = sqlite3GetTempReg(pParse);
      r4 = sqlite3GetTempReg(pParse);
      codeCompare(pParse, pLeft, pRight, 80,
                  r1, r2, r3, 0x10);
      pLItem++;
      pRight = pLItem->pExpr;
      sqlite3ReleaseTempReg(pParse, regFree2);
      r2 = sqlite3ExprCodeTemp(pParse, pRight, &regFree2);
                             ;
      codeCompare(pParse, pLeft, pRight, 78, r1, r2, r4, 0x10);
      sqlite3VdbeAddOp3(v, 69, r3, r4, target);
      sqlite3ReleaseTempReg(pParse, r3);
      sqlite3ReleaseTempReg(pParse, r4);
      break;
    }
    case 157: {
      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);
      break;
    }

    case 60: {
# 73326 "ext/sqlite3/libsqlite/sqlite3.c"
      Table *pTab = pExpr->pTab;
      int p1 = pExpr->iTable * (pTab->nCol+1) + 1 + pExpr->iColumn;

      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));

      sqlite3VdbeAddOp2(v, 109, p1, target);




        ;




      if( pExpr->iColumn>=0
       && pTab->aCol[pExpr->iColumn].affinity=='e'
      ){
        sqlite3VdbeAddOp1(v, 22, target);
      }

      break;
    }
# 73375 "ext/sqlite3/libsqlite/sqlite3.c"
    default: ((void) (0)); {
      int endLabel;
      int nextCase;
      int nExpr;
      int i;
      ExprList *pEList;
      struct ExprList_item *aListelem;
      Expr opCompare;
      Expr cacheX;
      Expr *pX;
      Expr *pTest = 0;


      ((void) (0));
      ((void) (0));
      ((void) (0));
      pEList = pExpr->x.pList;
      aListelem = pEList->a;
      nExpr = pEList->nExpr;
      endLabel = sqlite3VdbeMakeLabel(v);
      if( (pX = pExpr->pLeft)!=0 ){
        cacheX = *pX;
                                     ;
                                       ;
        cacheX.iTable = sqlite3ExprCodeTemp(pParse, pX, &regFree1);
                               ;
        cacheX.op = 132;
        opCompare.op = 76;
        opCompare.pLeft = &cacheX;
        pTest = &opCompare;




        regFree1 = 0;
      }
      for(i=0; i<nExpr; i=i+2){
        sqlite3ExprCachePush(pParse);
        if( pX ){
          ((void) (0));
          opCompare.pRight = aListelem[i].pExpr;
        }else{
          pTest = aListelem[i].pExpr;
        }
        nextCase = sqlite3VdbeMakeLabel(v);
                                        ;
        sqlite3ExprIfFalse(pParse, pTest, nextCase, 0x08);
                                                       ;
                                                         ;
        sqlite3ExprCode(pParse, aListelem[i+1].pExpr, target);
        sqlite3VdbeAddOp2(v, 1, 0, endLabel);
        sqlite3ExprCachePop(pParse, 1);
        sqlite3VdbeResolveLabel(v, nextCase);
      }
      if( pExpr->pRight ){
        sqlite3ExprCachePush(pParse);
        sqlite3ExprCode(pParse, pExpr->pRight, target);
        sqlite3ExprCachePop(pParse, 1);
      }else{
        sqlite3VdbeAddOp2(v, 10, 0, target);
      }
      ((void) (0));

      sqlite3VdbeResolveLabel(v, endLabel);
      break;
    }

    case 56: {
      ((void) (0));




      if( !pParse->pTriggerTab ){
        sqlite3ErrorMsg(pParse,
                       "RAISE() may only be used within a trigger-program");
        return 0;
      }
      if( pExpr->affinity==2 ){
        sqlite3MayAbort(pParse);
      }
      ((void) (0));
      if( pExpr->affinity==4 ){
        sqlite3VdbeAddOp4(
            v, 6, 0, 4, 0, pExpr->u.zToken,0);
      }else{
        sqlite3HaltConstraint(pParse, pExpr->affinity, pExpr->u.zToken, 0);
      }

      break;
    }

  }
  sqlite3ReleaseTempReg(pParse, regFree1);
  sqlite3ReleaseTempReg(pParse, regFree2);
  return inReg;
}
# 73482 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3ExprCodeTemp(Parse *pParse, Expr *pExpr, int *pReg){
  int r1 = sqlite3GetTempReg(pParse);
  int r2 = sqlite3ExprCodeTarget(pParse, pExpr, r1);
  if( r2==r1 ){
    *pReg = r1;
  }else{
    sqlite3ReleaseTempReg(pParse, r1);
    *pReg = 0;
  }
  return r2;
}






static int sqlite3ExprCode(Parse *pParse, Expr *pExpr, int target){
  int inReg;

  ((void) (0));
  if( pExpr && pExpr->op==132 ){
    sqlite3VdbeAddOp2(pParse->pVdbe, 14, pExpr->iTable, target);
  }else{
    inReg = sqlite3ExprCodeTarget(pParse, pExpr, target);
    ((void) (0));
    if( inReg!=target && pParse->pVdbe ){
      sqlite3VdbeAddOp2(pParse->pVdbe, 15, inReg, target);
    }
  }
  return target;
}
# 73527 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3ExprCodeAndCache(Parse *pParse, Expr *pExpr, int target){
  Vdbe *v = pParse->pVdbe;
  int inReg;
  inReg = sqlite3ExprCode(pParse, pExpr, target);
  ((void) (0));






  if( (pExpr->op!=132) ){
    int iMem;
    iMem = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 14, inReg, iMem);
    pExpr->iTable = iMem;
    pExpr->op2 = pExpr->op;
    pExpr->op = 132;
  }
  return inReg;
}
# 73566 "ext/sqlite3/libsqlite/sqlite3.c"
static int isAppropriateForFactoring(Expr *p){
  if( !sqlite3ExprIsConstantNotJoin(p) ){
    return 0;
  }
  if( (p->flags & 0x0200)==0 ){
    return 1;
  }
  while( p->op==157 ) p = p->pLeft;
  switch( p->op ){

    case 131:

    case 133:
    case 129:
    case 130:
    case 98:
    case 94: {
                                ;
                                    ;
                                   ;
                                 ;
                                ;
                                  ;




      return 0;
    }
    case 156: {
      if( p->pLeft->op==130 || p->pLeft->op==129 ){
        return 0;
      }
      break;
    }
    default: {
      break;
    }
  }
  return 1;
}







static int evalConstExpr(Walker *pWalker, Expr *pExpr){
  Parse *pParse = pWalker->pParse;
  switch( pExpr->op ){
    case 72:
    case 132: {
      return 1;
    }
    case 151:
    case 153:
    case 155: {




      ExprList *pList = pExpr->x.pList;
      ((void) (0));
      if( pList ){
        int i = pList->nExpr;
        struct ExprList_item *pItem = pList->a;
        for(; i>0; i--, pItem++){
          if( (pItem->pExpr) ) pItem->pExpr->flags |= 0x0200;
        }
      }
      break;
    }
  }
  if( isAppropriateForFactoring(pExpr) ){
    int r1 = ++pParse->nMem;
    int r2;
    r2 = sqlite3ExprCodeTarget(pParse, pExpr, r1);
    if( (r1!=r2) ) sqlite3ReleaseTempReg(pParse, r1);
    pExpr->op2 = pExpr->op;
    pExpr->op = 132;
    pExpr->iTable = r2;
    return 1;
  }
  return 0;
}
# 73669 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3ExprCodeConstants(Parse *pParse, Expr *pExpr){
  Walker w;
  if( pParse->cookieGoto ) return;
  if( (pParse->db->flags & 0x40)!=0 ) return;
  w.xExprCallback = evalConstExpr;
  w.xSelectCallback = 0;
  w.pParse = pParse;
  sqlite3WalkExpr(&w, pExpr);
}
# 73686 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3ExprCodeExprList(
  Parse *pParse,
  ExprList *pList,
  int target,
  int doHardCopy
){
  struct ExprList_item *pItem;
  int i, n;
  ((void) (0));
  ((void) (0));
  ((void) (0));
  n = pList->nExpr;
  for(pItem=pList->a, i=0; i<n; i++, pItem++){
    Expr *pExpr = pItem->pExpr;
    int inReg = sqlite3ExprCodeTarget(pParse, pExpr, target+i);
    if( inReg!=target+i ){
      sqlite3VdbeAddOp2(pParse->pVdbe, doHardCopy ? 14 : 15,
                        inReg, target+i);
    }
  }
  return n;
}
# 73721 "ext/sqlite3/libsqlite/sqlite3.c"
static void exprCodeBetween(
  Parse *pParse,
  Expr *pExpr,
  int dest,
  int jumpIfTrue,
  int jumpIfNull
){
  Expr exprAnd;
  Expr compLeft;
  Expr compRight;
  Expr exprX;
  int regFree1 = 0;

  ((void) (0));
  exprX = *pExpr->pLeft;
  exprAnd.op = 69;
  exprAnd.pLeft = &compLeft;
  exprAnd.pRight = &compRight;
  compLeft.op = 80;
  compLeft.pLeft = &exprX;
  compLeft.pRight = pExpr->x.pList->a[0].pExpr;
  compRight.op = 78;
  compRight.pLeft = &exprX;
  compRight.pRight = pExpr->x.pList->a[1].pExpr;
  exprX.iTable = sqlite3ExprCodeTemp(pParse, &exprX, &regFree1);
  exprX.op = 132;
  if( jumpIfTrue ){
    sqlite3ExprIfTrue(pParse, &exprAnd, dest, jumpIfNull);
  }else{
    sqlite3ExprIfFalse(pParse, &exprAnd, dest, jumpIfNull);
  }
  sqlite3ReleaseTempReg(pParse, regFree1);


                                                           ;
                                                           ;
                                                           ;
                                                           ;
                                                           ;
                                                           ;
                                                           ;
                                                           ;
}
# 73779 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3ExprIfTrue(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){
  Vdbe *v = pParse->pVdbe;
  int op = 0;
  int regFree1 = 0;
  int regFree2 = 0;
  int r1, r2;

  ((void) (0));
  if( (v==0) ) return;
  if( (pExpr==0) ) return;
  op = pExpr->op;
  switch( op ){
    case 69: {
      int d2 = sqlite3VdbeMakeLabel(v);
                               ;
      sqlite3ExprCachePush(pParse);
      sqlite3ExprIfFalse(pParse, pExpr->pLeft, d2,jumpIfNull^0x08);
      sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);
      sqlite3VdbeResolveLabel(v, d2);
      sqlite3ExprCachePop(pParse, 1);
      break;
    }
    case 68: {
                               ;
      sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);
      sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);
      break;
    }
    case 19: {
                               ;
      sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);
      break;
    }
    case 79:
    case 78:
    case 77:
    case 80:
    case 75:
    case 76: {
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
      ((void) (0));
                           ;
                           ;
                           ;
                           ;
                           ;
                           ;
                               ;
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,
                  r1, r2, dest, jumpIfNull);
                             ;
                             ;
      break;
    }
    case 70:
    case 146: {
                           ;
                              ;
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
      op = (op==70) ? 76 : 75;
      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,
                  r1, r2, dest, 0x80);
                             ;
                             ;
      break;
    }
    case 73:
    case 74: {
      ((void) (0));
      ((void) (0));
                               ;
                                ;
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      sqlite3VdbeAddOp2(v, op, r1, dest);
                             ;
      break;
    }
    case 71: {
                               ;
      exprCodeBetween(pParse, pExpr, dest, 1, jumpIfNull);
      break;
    }

    case 72: {
      int destIfFalse = sqlite3VdbeMakeLabel(v);
      int destIfNull = jumpIfNull ? dest : destIfFalse;
      sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);
      sqlite3VdbeAddOp2(v, 1, 0, dest);
      sqlite3VdbeResolveLabel(v, destIfFalse);
      break;
    }

    default: {
      r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);
      sqlite3VdbeAddOp3(v, 26, r1, dest, jumpIfNull!=0);
                             ;
                               ;
      break;
    }
  }
  sqlite3ReleaseTempReg(pParse, regFree1);
  sqlite3ReleaseTempReg(pParse, regFree2);
}
# 73899 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3ExprIfFalse(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){
  Vdbe *v = pParse->pVdbe;
  int op = 0;
  int regFree1 = 0;
  int regFree2 = 0;
  int r1, r2;

  ((void) (0));
  if( (v==0) ) return;
  if( pExpr==0 ) return;
# 73928 "ext/sqlite3/libsqlite/sqlite3.c"
  op = ((pExpr->op+(73&1))^1)-(73&1);



  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  switch( pExpr->op ){
    case 69: {
                               ;
      sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);
      sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);
      break;
    }
    case 68: {
      int d2 = sqlite3VdbeMakeLabel(v);
                               ;
      sqlite3ExprCachePush(pParse);
      sqlite3ExprIfTrue(pParse, pExpr->pLeft, d2, jumpIfNull^0x08);
      sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);
      sqlite3VdbeResolveLabel(v, d2);
      sqlite3ExprCachePop(pParse, 1);
      break;
    }
    case 19: {
                               ;
      sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);
      break;
    }
    case 79:
    case 78:
    case 77:
    case 80:
    case 75:
    case 76: {
                           ;
                           ;
                           ;
                           ;
                           ;
                           ;
                               ;
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,
                  r1, r2, dest, jumpIfNull);
                             ;
                             ;
      break;
    }
    case 70:
    case 146: {
                                  ;
                                     ;
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
      op = (pExpr->op==70) ? 75 : 76;
      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,
                  r1, r2, dest, 0x80);
                             ;
                             ;
      break;
    }
    case 73:
    case 74: {
                               ;
                                ;
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      sqlite3VdbeAddOp2(v, op, r1, dest);
                             ;
      break;
    }
    case 71: {
                               ;
      exprCodeBetween(pParse, pExpr, dest, 0, jumpIfNull);
      break;
    }

    case 72: {
      if( jumpIfNull ){
        sqlite3ExprCodeIN(pParse, pExpr, dest, dest);
      }else{
        int destIfNull = sqlite3VdbeMakeLabel(v);
        sqlite3ExprCodeIN(pParse, pExpr, dest, destIfNull);
        sqlite3VdbeResolveLabel(v, destIfNull);
      }
      break;
    }

    default: {
      r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);
      sqlite3VdbeAddOp3(v, 27, r1, dest, jumpIfNull!=0);
                             ;
                               ;
      break;
    }
  }
  sqlite3ReleaseTempReg(pParse, regFree1);
  sqlite3ReleaseTempReg(pParse, regFree2);
}
# 74051 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3ExprCompare(Expr *pA, Expr *pB){
  if( pA==0||pB==0 ){
    return pB==pA ? 0 : 2;
  }
  ((void) (0));
  ((void) (0));
  if( (((pA)->flags&(0x0800))==(0x0800)) || (((pB)->flags&(0x0800))==(0x0800)) ){
    return 2;
  }
  if( (pA->flags & 0x0010)!=(pB->flags & 0x0010) ) return 2;
  if( pA->op!=pB->op ) return 2;
  if( sqlite3ExprCompare(pA->pLeft, pB->pLeft) ) return 2;
  if( sqlite3ExprCompare(pA->pRight, pB->pRight) ) return 2;
  if( sqlite3ExprListCompare(pA->x.pList, pB->x.pList) ) return 2;
  if( pA->iTable!=pB->iTable || pA->iColumn!=pB->iColumn ) return 2;
  if( (((pA)->flags&(0x0400))==(0x0400)) ){
    if( !(((pB)->flags&(0x0400))==(0x0400)) || pA->u.iValue!=pB->u.iValue ){
      return 2;
    }
  }else if( pA->op!=152 && pA->u.zToken ){
    if( (((pB)->flags&(0x0400))==(0x0400)) || (pB->u.zToken==0) ) return 2;
    if( sqlite3StrICmp(pA->u.zToken,pB->u.zToken)!=0 ){
      return 2;
    }
  }
  if( (pA->flags & 0x0100)!=(pB->flags & 0x0100) ) return 1;
  if( (pA->flags & 0x0100)!=0 && pA->pColl!=pB->pColl ) return 2;
  return 0;
}
# 74093 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3ExprListCompare(ExprList *pA, ExprList *pB){
  int i;
  if( pA==0 && pB==0 ) return 0;
  if( pA==0 || pB==0 ) return 1;
  if( pA->nExpr!=pB->nExpr ) return 1;
  for(i=0; i<pA->nExpr; i++){
    Expr *pExprA = pA->a[i].pExpr;
    Expr *pExprB = pB->a[i].pExpr;
    if( pA->a[i].sortOrder!=pB->a[i].sortOrder ) return 1;
    if( sqlite3ExprCompare(pExprA, pExprB) ) return 1;
  }
  return 0;
}





static int addAggInfoColumn(sqlite3 *db, AggInfo *pInfo){
  int i;
  pInfo->aCol = sqlite3ArrayAllocate(
       db,
       pInfo->aCol,
       sizeof(pInfo->aCol[0]),
       3,
       &pInfo->nColumn,
       &pInfo->nColumnAlloc,
       &i
  );
  return i;
}





static int addAggInfoFunc(sqlite3 *db, AggInfo *pInfo){
  int i;
  pInfo->aFunc = sqlite3ArrayAllocate(
       db,
       pInfo->aFunc,
       sizeof(pInfo->aFunc[0]),
       3,
       &pInfo->nFunc,
       &pInfo->nFuncAlloc,
       &i
  );
  return i;
}






static int analyzeAggregate(Walker *pWalker, Expr *pExpr){
  int i;
  NameContext *pNC = pWalker->u.pNC;
  Parse *pParse = pNC->pParse;
  SrcList *pSrcList = pNC->pSrcList;
  AggInfo *pAggInfo = pNC->pAggInfo;

  switch( pExpr->op ){
    case 154:
    case 152: {
                                          ;
                                      ;


      if( (pSrcList!=0) ){
        struct SrcList_item *pItem = pSrcList->a;
        for(i=0; i<pSrcList->nSrc; i++, pItem++){
          struct AggInfo_col *pCol;
          ((void) (0));
          if( pExpr->iTable==pItem->iCursor ){






            int k;
            pCol = pAggInfo->aCol;
            for(k=0; k<pAggInfo->nColumn; k++, pCol++){
              if( pCol->iTable==pExpr->iTable &&
                  pCol->iColumn==pExpr->iColumn ){
                break;
              }
            }
            if( (k>=pAggInfo->nColumn)
             && (k = addAggInfoColumn(pParse->db, pAggInfo))>=0
            ){
              pCol = &pAggInfo->aCol[k];
              pCol->pTab = pExpr->pTab;
              pCol->iTable = pExpr->iTable;
              pCol->iColumn = pExpr->iColumn;
              pCol->iMem = ++pParse->nMem;
              pCol->iSorterColumn = -1;
              pCol->pExpr = pExpr;
              if( pAggInfo->pGroupBy ){
                int j, n;
                ExprList *pGB = pAggInfo->pGroupBy;
                struct ExprList_item *pTerm = pGB->a;
                n = pGB->nExpr;
                for(j=0; j<n; j++, pTerm++){
                  Expr *pE = pTerm->pExpr;
                  if( pE->op==152 && pE->iTable==pExpr->iTable &&
                      pE->iColumn==pExpr->iColumn ){
                    pCol->iSorterColumn = j;
                    break;
                  }
                }
              }
              if( pCol->iSorterColumn<0 ){
                pCol->iSorterColumn = pAggInfo->nSortingColumn++;
              }
            }





                                     ;
            pExpr->pAggInfo = pAggInfo;
            pExpr->op = 154;
            pExpr->iAgg = (i16)k;
            break;
          }
        }
      }
      return 1;
    }
    case 153: {


      if( pNC->nDepth==0 ){



        struct AggInfo_func *pItem = pAggInfo->aFunc;
        for(i=0; i<pAggInfo->nFunc; i++, pItem++){
          if( sqlite3ExprCompare(pItem->pExpr, pExpr)==0 ){
            break;
          }
        }
        if( i>=pAggInfo->nFunc ){


          u8 enc = ((pParse->db)->aDb[0].pSchema->enc);
          i = addAggInfoFunc(pParse->db, pAggInfo);
          if( i>=0 ){
            ((void) (0));
            pItem = &pAggInfo->aFunc[i];
            pItem->pExpr = pExpr;
            pItem->iMem = ++pParse->nMem;
            ((void) (0));
            pItem->pFunc = sqlite3FindFunction(pParse->db,
                   pExpr->u.zToken, sqlite3Strlen30(pExpr->u.zToken),
                   pExpr->x.pList ? pExpr->x.pList->nExpr : 0, enc, 0);
            if( pExpr->flags & 0x0010 ){
              pItem->iDistinct = pParse->nTab++;
            }else{
              pItem->iDistinct = -1;
            }
          }
        }


        ((void) (0));
                                 ;
        pExpr->iAgg = (i16)i;
        pExpr->pAggInfo = pAggInfo;
        return 1;
      }
    }
  }
  return 0;
}
static int analyzeAggregatesInSelect(Walker *pWalker, Select *pSelect){
  NameContext *pNC = pWalker->u.pNC;
  if( pNC->nDepth==0 ){
    pNC->nDepth++;
    sqlite3WalkSelect(pWalker, pSelect);
    pNC->nDepth--;
    return 1;
  }else{
    return 0;
  }
}
# 74291 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3ExprAnalyzeAggregates(NameContext *pNC, Expr *pExpr){
  Walker w;
  w.xExprCallback = analyzeAggregate;
  w.xSelectCallback = analyzeAggregatesInSelect;
  w.u.pNC = pNC;
  ((void) (0));
  sqlite3WalkExpr(&w, pExpr);
}







static void sqlite3ExprAnalyzeAggList(NameContext *pNC, ExprList *pList){
  struct ExprList_item *pItem;
  int i;
  if( pList ){
    for(pItem=pList->a, i=0; i<pList->nExpr; i++, pItem++){
      sqlite3ExprAnalyzeAggregates(pNC, pItem->pExpr);
    }
  }
}




static int sqlite3GetTempReg(Parse *pParse){
  if( pParse->nTempReg==0 ){
    return ++pParse->nMem;
  }
  return pParse->aTempReg[--pParse->nTempReg];
}
# 74334 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3ReleaseTempReg(Parse *pParse, int iReg){
  if( iReg && pParse->nTempReg<((int)(sizeof(pParse->aTempReg)/sizeof(pParse->aTempReg[0]))) ){
    int i;
    struct yColCache *p;
    for(i=0, p=pParse->aColCache; i<10; i++, p++){
      if( p->iReg==iReg ){
        p->tempReg = 1;
        return;
      }
    }
    pParse->aTempReg[pParse->nTempReg++] = iReg;
  }
}




static int sqlite3GetTempRange(Parse *pParse, int nReg){
  int i, n;
  i = pParse->iRangeReg;
  n = pParse->nRangeReg;
  if( nReg<=n ){
    ((void) (0));
    pParse->iRangeReg += nReg;
    pParse->nRangeReg -= nReg;
  }else{
    i = pParse->nMem+1;
    pParse->nMem += nReg;
  }
  return i;
}
static void sqlite3ReleaseTempRange(Parse *pParse, int iReg, int nReg){
  sqlite3ExprCacheRemove(pParse, iReg, nReg);
  if( nReg>pParse->nRangeReg ){
    pParse->nRangeReg = nReg;
    pParse->iRangeReg = iReg;
  }
}
# 74410 "ext/sqlite3/libsqlite/sqlite3.c"
static void renameTableFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  unsigned char const *zSql = sqlite3_value_text(argv[0]);
  unsigned char const *zTableName = sqlite3_value_text(argv[1]);

  int token;
  Token tname;
  unsigned char const *zCsr = zSql;
  int len = 0;
  char *zRet;

  sqlite3 *db = sqlite3_context_db_handle(context);

  (void)(NotUsed);





  if( zSql ){
    do {
      if( !*zCsr ){

        return;
      }


      tname.z = (char*)zCsr;
      tname.n = len;




      do {
        zCsr += len;
        len = sqlite3GetToken(zCsr, &token);
      } while( token==149 );
      ((void) (0));
    } while( token!=22 && token!=121 );

    zRet = sqlite3MPrintf(db, "%.*s\"%w\"%s", ((u8*)tname.z) - zSql, zSql,
       zTableName, tname.z+tname.n);
    sqlite3_result_text(context, zRet, -1, ((sqlite3_destructor_type)sqlite3DbFree));
  }
}
# 74475 "ext/sqlite3/libsqlite/sqlite3.c"
static void renameParentFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  char *zOutput = 0;
  char *zResult;
  unsigned char const *zInput = sqlite3_value_text(argv[0]);
  unsigned char const *zOld = sqlite3_value_text(argv[1]);
  unsigned char const *zNew = sqlite3_value_text(argv[2]);

  unsigned const char *z;
  int n;
  int token;

  (void)(NotUsed);
  for(z=zInput; *z; z=z+n){
    n = sqlite3GetToken(z, &token);
    if( token==102 ){
      char *zParent;
      do {
        z += n;
        n = sqlite3GetToken(z, &token);
      }while( token==149 );

      zParent = sqlite3DbStrNDup(db, (const char *)z, n);
      if( zParent==0 ) break;
      sqlite3Dequote(zParent);
      if( 0==sqlite3StrICmp((const char *)zOld, zParent) ){
        char *zOut = sqlite3MPrintf(db, "%s%.*s\"%w\"",
            (zOutput?zOutput:""), z-zInput, zInput, (const char *)zNew
        );
        sqlite3DbFree(db, zOutput);
        zOutput = zOut;
        zInput = &z[n];
      }
      sqlite3DbFree(db, zParent);
    }
  }

  zResult = sqlite3MPrintf(db, "%s%s", (zOutput?zOutput:""), zInput),
  sqlite3_result_text(context, zResult, -1, ((sqlite3_destructor_type)sqlite3DbFree));
  sqlite3DbFree(db, zOutput);
}
# 74530 "ext/sqlite3/libsqlite/sqlite3.c"
static void renameTriggerFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  unsigned char const *zSql = sqlite3_value_text(argv[0]);
  unsigned char const *zTableName = sqlite3_value_text(argv[1]);

  int token;
  Token tname;
  int dist = 3;
  unsigned char const *zCsr = zSql;
  int len = 0;
  char *zRet;
  sqlite3 *db = sqlite3_context_db_handle(context);

  (void)(NotUsed);






  if( zSql ){
    do {

      if( !*zCsr ){

        return;
      }


      tname.z = (char*)zCsr;
      tname.n = len;




      do {
        zCsr += len;
        len = sqlite3GetToken(zCsr, &token);
      }while( token==149 );
      ((void) (0));
# 74583 "ext/sqlite3/libsqlite/sqlite3.c"
      dist++;
      if( token==118 || token==104 ){
        dist = 0;
      }
    } while( dist!=2 || (token!=135 && token!=45 && token!=5) );




    zRet = sqlite3MPrintf(db, "%.*s\"%w\"%s", ((u8*)tname.z) - zSql, zSql,
       zTableName, tname.z+tname.n);
    sqlite3_result_text(context, zRet, -1, ((sqlite3_destructor_type)sqlite3DbFree));
  }
}





static void sqlite3AlterFunctions(void){
  static FuncDef aAlterTableFuncs[] = {
    {2, 1, 0*0x08, ((void*)(long int)(0)), 0, renameTableFunc, 0, 0, "sqlite_rename_table", 0, 0},

    {2, 1, 0*0x08, ((void*)(long int)(0)), 0, renameTriggerFunc, 0, 0, "sqlite_rename_trigger", 0, 0},


    {3, 1, 0*0x08, ((void*)(long int)(0)), 0, renameParentFunc, 0, 0, "sqlite_rename_parent", 0, 0},

  };
  int i;
  FuncDefHash *pHash = &sqlite3GlobalFunctions;
  FuncDef *aFunc = (FuncDef*)&aAlterTableFuncs;

  for(i=0; i<((int)(sizeof(aAlterTableFuncs)/sizeof(aAlterTableFuncs[0]))); i++){
    sqlite3FuncDefInsert(pHash, &aFunc[i]);
  }
}
# 74637 "ext/sqlite3/libsqlite/sqlite3.c"
static char *whereOrName(sqlite3 *db, char *zWhere, char *zConstant){
  char *zNew;
  if( !zWhere ){
    zNew = sqlite3MPrintf(db, "name=%Q", zConstant);
  }else{
    zNew = sqlite3MPrintf(db, "%s OR name=%Q", zWhere, zConstant);
    sqlite3DbFree(db, zWhere);
  }
  return zNew;
}
# 74655 "ext/sqlite3/libsqlite/sqlite3.c"
static char *whereForeignKeys(Parse *pParse, Table *pTab){
  FKey *p;
  char *zWhere = 0;
  for(p=sqlite3FkReferences(pTab); p; p=p->pNextTo){
    zWhere = whereOrName(pParse->db, zWhere, p->pFrom->zName);
  }
  return zWhere;
}
# 74671 "ext/sqlite3/libsqlite/sqlite3.c"
static char *whereTempTriggers(Parse *pParse, Table *pTab){
  Trigger *pTrig;
  char *zWhere = 0;
  const Schema *pTempSchema = pParse->db->aDb[1].pSchema;






  if( pTab->pSchema!=pTempSchema ){
    sqlite3 *db = pParse->db;
    for(pTrig=sqlite3TriggerList(pParse, pTab); pTrig; pTrig=pTrig->pNext){
      if( pTrig->pSchema==pTempSchema ){
        zWhere = whereOrName(db, zWhere, pTrig->zName);
      }
    }
  }
  if( zWhere ){
    char *zNew = sqlite3MPrintf(pParse->db, "type='trigger' AND (%s)", zWhere);
    sqlite3DbFree(pParse->db, zWhere);
    zWhere = zNew;
  }
  return zWhere;
}
# 74705 "ext/sqlite3/libsqlite/sqlite3.c"
static void reloadTableSchema(Parse *pParse, Table *pTab, const char *zName){
  Vdbe *v;
  char *zWhere;
  int iDb;

  Trigger *pTrig;


  v = sqlite3GetVdbe(pParse);
  if( (v==0) ) return;
  ((void) (0));
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
  ((void) (0));



  for(pTrig=sqlite3TriggerList(pParse, pTab); pTrig; pTrig=pTrig->pNext){
    int iTrigDb = sqlite3SchemaToIndex(pParse->db, pTrig->pSchema);
    ((void) (0));
    sqlite3VdbeAddOp4(v, 103, iTrigDb, 0, 0, pTrig->zName, 0);
  }



  sqlite3VdbeAddOp4(v, 101, iDb, 0, 0, pTab->zName, 0);


  zWhere = sqlite3MPrintf(pParse->db, "tbl_name=%Q", zName);
  if( !zWhere ) return;
  sqlite3VdbeAddOp4(v, 99, iDb, 0, 0, zWhere, (-1));





  if( (zWhere=whereTempTriggers(pParse, pTab))!=0 ){
    sqlite3VdbeAddOp4(v, 99, 1, 0, 0, zWhere, (-1));
  }

}
# 74754 "ext/sqlite3/libsqlite/sqlite3.c"
static int isSystemTable(Parse *pParse, const char *zName){
  if( sqlite3Strlen30(zName)>6 && 0==sqlite3_strnicmp(zName, "sqlite_", 7) ){
    sqlite3ErrorMsg(pParse, "table %s may not be altered", zName);
    return 1;
  }
  return 0;
}





static void sqlite3AlterRenameTable(
  Parse *pParse,
  SrcList *pSrc,
  Token *pName
){
  int iDb;
  char *zDb;
  Table *pTab;
  char *zName = 0;
  sqlite3 *db = pParse->db;
  int nTabName;
  const char *zTabName;
  Vdbe *v;

  char *zWhere = 0;

  VTable *pVTab = 0;
  int savedDbFlags;

  savedDbFlags = db->flags;
  if( (db->mallocFailed) ) goto exit_rename_table;
  ((void) (0));
  ((void) (0));

  pTab = sqlite3LocateTable(pParse, 0, pSrc->a[0].zName, pSrc->a[0].zDatabase);
  if( !pTab ) goto exit_rename_table;
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
  zDb = db->aDb[iDb].zName;
  db->flags |= 0x10000000;


  zName = sqlite3NameFromToken(db, pName);
  if( !zName ) goto exit_rename_table;




  if( sqlite3FindTable(db, zName, zDb) || sqlite3FindIndex(db, zName, zDb) ){
    sqlite3ErrorMsg(pParse,
        "there is already another table or index with this name: %s", zName);
    goto exit_rename_table;
  }




  if( 0!=isSystemTable(pParse, pTab->zName) ){
    goto exit_rename_table;
  }
  if( 0!=sqlite3CheckObjectName(pParse, zName) ){ goto
    exit_rename_table;
  }


  if( pTab->pSelect ){
    sqlite3ErrorMsg(pParse, "view %s may not be altered", pTab->zName);
    goto exit_rename_table;
  }




  if( sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, 0) ){
    goto exit_rename_table;
  }



  if( sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto exit_rename_table;
  }
  if( (((pTab)->tabFlags & 0x10)!=0) ){
    pVTab = sqlite3GetVTable(db, pTab);
    if( pVTab->pVtab->pModule->xRename==0 ){
      pVTab = 0;
    }
  }







  v = sqlite3GetVdbe(pParse);
  if( v==0 ){
    goto exit_rename_table;
  }
  sqlite3BeginWriteOperation(pParse, pVTab!=0, iDb);
  sqlite3ChangeCookie(pParse, iDb);







  if( pVTab ){
    int i = ++pParse->nMem;
    sqlite3VdbeAddOp4(v, 94, 0, i, 0, zName, 0);
    sqlite3VdbeAddOp4(v, 132, i, 0, 0,(const char*)pVTab, (-10));
    sqlite3MayAbort(pParse);
  }



  zTabName = pTab->zName;
  nTabName = sqlite3Utf8CharLen(zTabName, -1);


  if( db->flags&0x04000000 ){



    if( (zWhere=whereForeignKeys(pParse, pTab))!=0 ){
      sqlite3NestedParse(pParse,
          "UPDATE \"%w\".%s SET "
              "sql = sqlite_rename_parent(sql, %Q, %Q) "
              "WHERE %s;", zDb, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"), zTabName, zName, zWhere);
      sqlite3DbFree(db, zWhere);
    }
  }



  sqlite3NestedParse(pParse,
      "UPDATE %Q.%s SET "



          "sql = CASE "
            "WHEN type = 'trigger' THEN sqlite_rename_trigger(sql, %Q)"
            "ELSE sqlite_rename_table(sql, %Q) END, "

          "tbl_name = %Q, "
          "name = CASE "
            "WHEN type='table' THEN %Q "
            "WHEN name LIKE 'sqlite_autoindex%%' AND type='index' THEN "
             "'sqlite_autoindex_' || %Q || substr(name,%d+18) "
            "ELSE name END "
      "WHERE tbl_name=%Q AND "
          "(type='table' OR type='index' OR type='trigger');",
      zDb, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"), zName, zName, zName,

      zName,

      zName, nTabName, zTabName
  );





  if( sqlite3FindTable(db, "sqlite_sequence", zDb) ){
    sqlite3NestedParse(pParse,
        "UPDATE \"%w\".sqlite_sequence set name = %Q WHERE name = %Q",
        zDb, zName, pTab->zName);
  }







  if( (zWhere=whereTempTriggers(pParse, pTab))!=0 ){
    sqlite3NestedParse(pParse,
        "UPDATE sqlite_temp_master SET "
            "sql = sqlite_rename_trigger(sql, %Q), "
            "tbl_name = %Q "
            "WHERE %s;", zName, zName, zWhere);
    sqlite3DbFree(db, zWhere);
  }



  if( db->flags&0x04000000 ){
    FKey *p;
    for(p=sqlite3FkReferences(pTab); p; p=p->pNextTo){
      Table *pFrom = p->pFrom;
      if( pFrom!=pTab ){
        reloadTableSchema(pParse, p->pFrom, pFrom->zName);
      }
    }
  }



  reloadTableSchema(pParse, pTab, zName);

exit_rename_table:
  sqlite3SrcListDelete(db, pSrc);
  sqlite3DbFree(db, zName);
  db->flags = savedDbFlags;
}






static void sqlite3MinimumFileFormat(Parse *pParse, int iDb, int minFormat){
  Vdbe *v;
  v = sqlite3GetVdbe(pParse);



  if( (v) ){
    int r1 = sqlite3GetTempReg(pParse);
    int r2 = sqlite3GetTempReg(pParse);
    int j1;
    sqlite3VdbeAddOp3(v, 35, iDb, r1, 2);
    sqlite3VdbeUsesBtree(v, iDb);
    sqlite3VdbeAddOp2(v, 7, minFormat, r2);
    j1 = sqlite3VdbeAddOp3(v, 80, r2, 0, r1);
    sqlite3VdbeAddOp3(v, 36, iDb, 2, r2);
    sqlite3VdbeJumpHere(v, j1);
    sqlite3ReleaseTempReg(pParse, r1);
    sqlite3ReleaseTempReg(pParse, r2);
  }
}
# 74996 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3AlterFinishAddColumn(Parse *pParse, Token *pColDef){
  Table *pNew;
  Table *pTab;
  int iDb;
  const char *zDb;
  const char *zTab;
  char *zCol;
  Column *pCol;
  Expr *pDflt;
  sqlite3 *db;

  db = pParse->db;
  if( pParse->nErr || db->mallocFailed ) return;
  pNew = pParse->pNewTable;
  ((void) (0));

  ((void) (0));
  iDb = sqlite3SchemaToIndex(db, pNew->pSchema);
  zDb = db->aDb[iDb].zName;
  zTab = &pNew->zName[16];
  pCol = &pNew->aCol[pNew->nCol-1];
  pDflt = pCol->pDflt;
  pTab = sqlite3FindTable(db, zTab, zDb);
  ((void) (0));



  if( sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, 0) ){
    return;
  }






  if( pDflt && pDflt->op==98 ){
    pDflt = 0;
  }





  if( pCol->isPrimKey ){
    sqlite3ErrorMsg(pParse, "Cannot add a PRIMARY KEY column");
    return;
  }
  if( pNew->pIndex ){
    sqlite3ErrorMsg(pParse, "Cannot add a UNIQUE column");
    return;
  }
  if( (db->flags&0x04000000) && pNew->pFKey && pDflt ){
    sqlite3ErrorMsg(pParse,
        "Cannot add a REFERENCES column with non-NULL default value");
    return;
  }
  if( pCol->notNull && !pDflt ){
    sqlite3ErrorMsg(pParse,
        "Cannot add a NOT NULL column with default value NULL");
    return;
  }




  if( pDflt ){
    sqlite3_value *pVal;
    if( sqlite3ValueFromExpr(db, pDflt, 1, 'b', &pVal) ){
      db->mallocFailed = 1;
      return;
    }
    if( !pVal ){
      sqlite3ErrorMsg(pParse, "Cannot add a column with non-constant default");
      return;
    }
    sqlite3ValueFree(pVal);
  }


  zCol = sqlite3DbStrNDup(db, (char*)pColDef->z, pColDef->n);
  if( zCol ){
    char *zEnd = &zCol[pColDef->n-1];
    int savedDbFlags = db->flags;
    while( zEnd>zCol && (*zEnd==';' || (sqlite3CtypeMap[(unsigned char)(*zEnd)]&0x01)) ){
      *zEnd-- = '\0';
    }
    db->flags |= 0x10000000;
    sqlite3NestedParse(pParse,
        "UPDATE \"%w\".%s SET "
          "sql = substr(sql,1,%d) || ', ' || %Q || substr(sql,%d) "
        "WHERE type = 'table' AND name = %Q",
      zDb, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"), pNew->addColOffset, zCol, pNew->addColOffset+1,
      zTab
    );
    sqlite3DbFree(db, zCol);
    db->flags = savedDbFlags;
  }





  sqlite3MinimumFileFormat(pParse, iDb, pDflt ? 3 : 2);


  reloadTableSchema(pParse, pTab, pTab->zName);
}
# 75120 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3AlterBeginAddColumn(Parse *pParse, SrcList *pSrc){
  Table *pNew;
  Table *pTab;
  Vdbe *v;
  int iDb;
  int i;
  int nAlloc;
  sqlite3 *db = pParse->db;


  ((void) (0));
  ((void) (0));
  if( db->mallocFailed ) goto exit_begin_add_column;
  pTab = sqlite3LocateTable(pParse, 0, pSrc->a[0].zName, pSrc->a[0].zDatabase);
  if( !pTab ) goto exit_begin_add_column;


  if( (((pTab)->tabFlags & 0x10)!=0) ){
    sqlite3ErrorMsg(pParse, "virtual tables may not be altered");
    goto exit_begin_add_column;
  }



  if( pTab->pSelect ){
    sqlite3ErrorMsg(pParse, "Cannot add a column to a view");
    goto exit_begin_add_column;
  }
  if( 0!=isSystemTable(pParse, pTab->zName) ){
    goto exit_begin_add_column;
  }

  ((void) (0));
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
# 75162 "ext/sqlite3/libsqlite/sqlite3.c"
  pNew = (Table*)sqlite3DbMallocZero(db, sizeof(Table));
  if( !pNew ) goto exit_begin_add_column;
  pParse->pNewTable = pNew;
  pNew->nRef = 1;
  pNew->nCol = pTab->nCol;
  ((void) (0));
  nAlloc = (((pNew->nCol-1)/8)*8)+8;
  ((void) (0));
  pNew->aCol = (Column*)sqlite3DbMallocZero(db, sizeof(Column)*nAlloc);
  pNew->zName = sqlite3MPrintf(db, "sqlite_altertab_%s", pTab->zName);
  if( !pNew->aCol || !pNew->zName ){
    db->mallocFailed = 1;
    goto exit_begin_add_column;
  }
  memcpy(pNew->aCol, pTab->aCol, sizeof(Column)*pNew->nCol);
  for(i=0; i<pNew->nCol; i++){
    Column *pCol = &pNew->aCol[i];
    pCol->zName = sqlite3DbStrDup(db, pCol->zName);
    pCol->zColl = 0;
    pCol->zType = 0;
    pCol->pDflt = 0;
    pCol->zDflt = 0;
  }
  pNew->pSchema = db->aDb[iDb].pSchema;
  pNew->addColOffset = pTab->addColOffset;
  pNew->nRef = 1;


  sqlite3BeginWriteOperation(pParse, 0, iDb);
  v = sqlite3GetVdbe(pParse);
  if( !v ) goto exit_begin_add_column;
  sqlite3ChangeCookie(pParse, iDb);

exit_begin_add_column:
  sqlite3SrcListDelete(db, pSrc);
  return;
}
# 75234 "ext/sqlite3/libsqlite/sqlite3.c"
static void openStatTable(
  Parse *pParse,
  int iDb,
  int iStatCur,
  const char *zWhere,
  const char *zWhereType
){
  static const struct {
    const char *zName;
    const char *zCols;
  } aTable[] = {
    { "sqlite_stat1", "tbl,idx,stat" },



  };

  int aRoot[] = {0, 0};
  u8 aCreateTbl[] = {0, 0};

  int i;
  sqlite3 *db = pParse->db;
  Db *pDb;
  Vdbe *v = sqlite3GetVdbe(pParse);
  if( v==0 ) return;
  ((void) (0));
  ((void) (0));
  pDb = &db->aDb[iDb];

  for(i=0; i<((int)(sizeof(aTable)/sizeof(aTable[0]))); i++){
    const char *zTab = aTable[i].zName;
    Table *pStat;
    if( (pStat = sqlite3FindTable(db, zTab, pDb->zName))==0 ){




      sqlite3NestedParse(pParse,
          "CREATE TABLE %Q.%s(%s)", pDb->zName, zTab, aTable[i].zCols
      );
      aRoot[i] = pParse->regRoot;
      aCreateTbl[i] = 1;
    }else{



      aRoot[i] = pStat->tnum;
      sqlite3TableLock(pParse, iDb, aRoot[i], 1, zTab);
      if( zWhere ){
        sqlite3NestedParse(pParse,
           "DELETE FROM %Q.%s WHERE %s=%Q", pDb->zName, zTab, zWhereType, zWhere
        );
      }else{

        sqlite3VdbeAddOp2(v, 96, aRoot[i], iDb);
      }
    }
  }


  for(i=0; i<((int)(sizeof(aTable)/sizeof(aTable[0]))); i++){
    sqlite3VdbeAddOp3(v, 39, iStatCur+i, aRoot[i], iDb);
    sqlite3VdbeChangeP4(v, -1, (char *)3, (-14));
    sqlite3VdbeChangeP5(v, aCreateTbl[i]);
  }
}





static void analyzeOneTable(
  Parse *pParse,
  Table *pTab,
  Index *pOnlyIdx,
  int iStatCur,
  int iMem
){
  sqlite3 *db = pParse->db;
  Index *pIdx;
  int iIdxCur;
  Vdbe *v;
  int i;
  int topOfLoop;
  int endOfLoop;
  int jZeroRows = -1;
  int iDb;
  int regTabname = iMem++;
  int regIdxname = iMem++;
  int regSampleno = iMem++;
  int regCol = iMem++;
  int regRec = iMem++;
  int regTemp = iMem++;
  int regRowid = iMem++;
# 75338 "ext/sqlite3/libsqlite/sqlite3.c"
  v = sqlite3GetVdbe(pParse);
  if( v==0 || (pTab==0) ){
    return;
  }
  if( pTab->tnum==0 ){

    return;
  }
  if( memcmp(pTab->zName, "sqlite_", 7)==0 ){

    return;
  }
  ((void) (0));
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  ((void) (0));
  ((void) (0));

  if( sqlite3AuthCheck(pParse, 28, pTab->zName, 0,
      db->aDb[iDb].zName ) ){
    return;
  }



  sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);

  iIdxCur = pParse->nTab++;
  sqlite3VdbeAddOp4(v, 94, 0, regTabname, 0, pTab->zName, 0);
  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
    int nCol;
    KeyInfo *pKey;

    if( pOnlyIdx && pOnlyIdx!=pIdx ) continue;
    nCol = pIdx->nColumn;
    pKey = sqlite3IndexKeyinfo(pParse, pIdx);
    if( iMem+1+(nCol*2)>pParse->nMem ){
      pParse->nMem = iMem+1+(nCol*2);
    }


    ((void) (0));
    sqlite3VdbeAddOp4(v, 38, iIdxCur, pIdx->tnum, iDb,
        (char *)pKey, (-16));
                                       ;


    sqlite3VdbeAddOp4(v, 94, 0, regIdxname, 0, pIdx->zName, 0);
# 75428 "ext/sqlite3/libsqlite/sqlite3.c"
    for(i=0; i<=nCol; i++){
      sqlite3VdbeAddOp2(v, 7, 0, iMem+i);
    }
    for(i=0; i<nCol; i++){
      sqlite3VdbeAddOp2(v, 10, 0, iMem+nCol+i+1);
    }



    endOfLoop = sqlite3VdbeMakeLabel(v);
    sqlite3VdbeAddOp2(v, 65, iIdxCur, endOfLoop);
    topOfLoop = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeAddOp2(v, 20, iMem, 1);

    for(i=0; i<nCol; i++){
      CollSeq *pColl;
      sqlite3VdbeAddOp3(v, 28, iIdxCur, i, regCol);
      if( i==0 ){
# 75478 "ext/sqlite3/libsqlite/sqlite3.c"
        sqlite3VdbeAddOp1(v, 27, iMem+1);
      }
      ((void) (0));
      ((void) (0));
      pColl = sqlite3LocateCollSeq(pParse, pIdx->azColl[i]);
      sqlite3VdbeAddOp4(v, 75, regCol, 0, iMem+nCol+i+1,
                       (char*)pColl, (-4));
      sqlite3VdbeChangeP5(v, 0x80);
    }
    if( db->mallocFailed ){




      return;
    }
    sqlite3VdbeAddOp2(v, 1, 0, endOfLoop);
    for(i=0; i<nCol; i++){
      int addr2 = sqlite3VdbeCurrentAddr(v) - (nCol*2);
      if( i==0 ){
        sqlite3VdbeJumpHere(v, addr2-1);
      }
      sqlite3VdbeJumpHere(v, addr2);
      sqlite3VdbeAddOp2(v, 20, iMem+i+1, 1);
      sqlite3VdbeAddOp3(v, 28, iIdxCur, i, iMem+nCol+i+1);
    }


    sqlite3VdbeResolveLabel(v, endOfLoop);
    sqlite3VdbeAddOp2(v, 67, iIdxCur, topOfLoop);
    sqlite3VdbeAddOp1(v, 43, iIdxCur);
# 75528 "ext/sqlite3/libsqlite/sqlite3.c"
    sqlite3VdbeAddOp2(v, 15, iMem, regSampleno);
    if( jZeroRows<0 ){
      jZeroRows = sqlite3VdbeAddOp1(v, 27, iMem);
    }
    for(i=0; i<nCol; i++){
      sqlite3VdbeAddOp4(v, 94, 0, regTemp, 0, " ", 0);
      sqlite3VdbeAddOp3(v, 91, regTemp, regSampleno, regSampleno);
      sqlite3VdbeAddOp3(v, 86, iMem, iMem+i+1, regTemp);
      sqlite3VdbeAddOp2(v, 20, regTemp, -1);
      sqlite3VdbeAddOp3(v, 89, iMem+i+1, regTemp, regTemp);
      sqlite3VdbeAddOp1(v, 144, regTemp);
      sqlite3VdbeAddOp3(v, 91, regTemp, regSampleno, regSampleno);
    }
    sqlite3VdbeAddOp4(v, 30, regTabname, 3, regRec, "aaa", 0);
    sqlite3VdbeAddOp2(v, 54, iStatCur, regRowid);
    sqlite3VdbeAddOp3(v, 55, iStatCur, regRec, regRowid);
    sqlite3VdbeChangeP5(v, 0x08);
  }




  if( pTab->pIndex==0 ){
    sqlite3VdbeAddOp3(v, 38, iIdxCur, pTab->tnum, iDb);
                                       ;
    sqlite3VdbeAddOp2(v, 31, iIdxCur, regSampleno);
    sqlite3VdbeAddOp1(v, 43, iIdxCur);
    jZeroRows = sqlite3VdbeAddOp1(v, 27, regSampleno);
  }else{
    sqlite3VdbeJumpHere(v, jZeroRows);
    jZeroRows = sqlite3VdbeAddOp0(v, 1);
  }
  sqlite3VdbeAddOp2(v, 10, 0, regIdxname);
  sqlite3VdbeAddOp4(v, 30, regTabname, 3, regRec, "aaa", 0);
  sqlite3VdbeAddOp2(v, 54, iStatCur, regRowid);
  sqlite3VdbeAddOp3(v, 55, iStatCur, regRec, regRowid);
  sqlite3VdbeChangeP5(v, 0x08);
  if( pParse->nMem<regRec ) pParse->nMem = regRec;
  sqlite3VdbeJumpHere(v, jZeroRows);
}





static void loadAnalysis(Parse *pParse, int iDb){
  Vdbe *v = sqlite3GetVdbe(pParse);
  if( v ){
    sqlite3VdbeAddOp1(v, 100, iDb);
  }
}




static void analyzeDatabase(Parse *pParse, int iDb){
  sqlite3 *db = pParse->db;
  Schema *pSchema = db->aDb[iDb].pSchema;
  HashElem *k;
  int iStatCur;
  int iMem;

  sqlite3BeginWriteOperation(pParse, 0, iDb);
  iStatCur = pParse->nTab;
  pParse->nTab += 2;
  openStatTable(pParse, iDb, iStatCur, 0, 0);
  iMem = pParse->nMem+1;
  ((void) (0));
  for(k=((&pSchema->tblHash)->first); k; k=((k)->next)){
    Table *pTab = (Table*)((k)->data);
    analyzeOneTable(pParse, pTab, 0, iStatCur, iMem);
  }
  loadAnalysis(pParse, iDb);
}






static void analyzeTable(Parse *pParse, Table *pTab, Index *pOnlyIdx){
  int iDb;
  int iStatCur;

  ((void) (0));
  ((void) (0));
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
  sqlite3BeginWriteOperation(pParse, 0, iDb);
  iStatCur = pParse->nTab;
  pParse->nTab += 2;
  if( pOnlyIdx ){
    openStatTable(pParse, iDb, iStatCur, pOnlyIdx->zName, "idx");
  }else{
    openStatTable(pParse, iDb, iStatCur, pTab->zName, "tbl");
  }
  analyzeOneTable(pParse, pTab, pOnlyIdx, iStatCur, pParse->nMem+1);
  loadAnalysis(pParse, iDb);
}
# 75639 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3Analyze(Parse *pParse, Token *pName1, Token *pName2){
  sqlite3 *db = pParse->db;
  int iDb;
  int i;
  char *z, *zDb;
  Table *pTab;
  Index *pIdx;
  Token *pTableName;



  ((void) (0));
  if( 0!=sqlite3ReadSchema(pParse) ){
    return;
  }

  ((void) (0));
  if( pName1==0 ){

    for(i=0; i<db->nDb; i++){
      if( i==1 ) continue;
      analyzeDatabase(pParse, i);
    }
  }else if( pName2->n==0 ){

    iDb = sqlite3FindDb(db, pName1);
    if( iDb>=0 ){
      analyzeDatabase(pParse, iDb);
    }else{
      z = sqlite3NameFromToken(db, pName1);
      if( z ){
        if( (pIdx = sqlite3FindIndex(db, z, 0))!=0 ){
          analyzeTable(pParse, pIdx->pTable, pIdx);
        }else if( (pTab = sqlite3LocateTable(pParse, 0, z, 0))!=0 ){
          analyzeTable(pParse, pTab, 0);
        }
        sqlite3DbFree(db, z);
      }
    }
  }else{

    iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pTableName);
    if( iDb>=0 ){
      zDb = db->aDb[iDb].zName;
      z = sqlite3NameFromToken(db, pTableName);
      if( z ){
        if( (pIdx = sqlite3FindIndex(db, z, zDb))!=0 ){
          analyzeTable(pParse, pIdx->pTable, pIdx);
        }else if( (pTab = sqlite3LocateTable(pParse, 0, z, zDb))!=0 ){
          analyzeTable(pParse, pTab, 0);
        }
        sqlite3DbFree(db, z);
      }
    }
  }
}





typedef struct analysisInfo analysisInfo;
struct analysisInfo {
  sqlite3 *db;
  const char *zDatabase;
};
# 75717 "ext/sqlite3/libsqlite/sqlite3.c"
static int analysisLoader(void *pData, int argc, char **argv, char **NotUsed){
  analysisInfo *pInfo = (analysisInfo*)pData;
  Index *pIndex;
  Table *pTable;
  int i, c, n;
  unsigned int v;
  const char *z;

  ((void) (0));
  (void)(NotUsed),(void)(argc);

  if( argv==0 || argv[0]==0 || argv[2]==0 ){
    return 0;
  }
  pTable = sqlite3FindTable(pInfo->db, argv[0], pInfo->zDatabase);
  if( pTable==0 ){
    return 0;
  }
  if( argv[1] ){
    pIndex = sqlite3FindIndex(pInfo->db, argv[1], pInfo->zDatabase);
  }else{
    pIndex = 0;
  }
  n = pIndex ? pIndex->nColumn : 0;
  z = argv[2];
  for(i=0; *z && i<=n; i++){
    v = 0;
    while( (c=z[0])>='0' && c<='9' ){
      v = v*10 + c - '0';
      z++;
    }
    if( i==0 ) pTable->nRowEst = v;
    if( pIndex==0 ) break;
    pIndex->aiRowEst[i] = v;
    if( *z==' ' ) z++;
    if( memcmp(z, "unordered", 10)==0 ){
      pIndex->bUnordered = 1;
      break;
    }
  }
  return 0;
}





static void sqlite3DeleteIndexSamples(sqlite3 *db, Index *pIdx){
# 75777 "ext/sqlite3/libsqlite/sqlite3.c"
  (void)(db);
  (void)(pIdx);

}
# 75802 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3AnalysisLoad(sqlite3 *db, int iDb){
  analysisInfo sInfo;
  HashElem *i;
  char *zSql;
  int rc;

  ((void) (0));
  ((void) (0));


  ((void) (0));
  for(i=((&db->aDb[iDb].pSchema->idxHash)->first);i;i=((i)->next)){
    Index *pIdx = ((i)->data);
    sqlite3DefaultRowEst(pIdx);
    sqlite3DeleteIndexSamples(db, pIdx);
    pIdx->aSample = 0;
  }


  sInfo.db = db;
  sInfo.zDatabase = db->aDb[iDb].zName;
  if( sqlite3FindTable(db, "sqlite_stat1", sInfo.zDatabase)==0 ){
    return 1;
  }


  zSql = sqlite3MPrintf(db,
      "SELECT tbl, idx, stat FROM %Q.sqlite_stat1", sInfo.zDatabase);
  if( zSql==0 ){
    rc = 7;
  }else{
    rc = sqlite3_exec(db, zSql, analysisLoader, &sInfo, 0);
    sqlite3DbFree(db, zSql);
  }
# 75913 "ext/sqlite3/libsqlite/sqlite3.c"
  if( rc==7 ){
    db->mallocFailed = 1;
  }
  return rc;
}
# 75957 "ext/sqlite3/libsqlite/sqlite3.c"
static int resolveAttachExpr(NameContext *pName, Expr *pExpr)
{
  int rc = 0;
  if( pExpr ){
    if( pExpr->op!=26 ){
      rc = sqlite3ResolveExprNames(pName, pExpr);
      if( rc==0 && !sqlite3ExprIsConstant(pExpr) ){
        sqlite3ErrorMsg(pName->pParse, "invalid name: \"%s\"", pExpr->u.zToken);
        return 1;
      }
    }else{
      pExpr->op = 94;
    }
  }
  return rc;
}
# 75985 "ext/sqlite3/libsqlite/sqlite3.c"
static void attachFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  int i;
  int rc = 0;
  sqlite3 *db = sqlite3_context_db_handle(context);
  const char *zName;
  const char *zFile;
  Db *aNew;
  char *zErrDyn = 0;

  (void)(NotUsed);

  zFile = (const char *)sqlite3_value_text(argv[0]);
  zName = (const char *)sqlite3_value_text(argv[1]);
  if( zFile==0 ) zFile = "";
  if( zName==0 ) zName = "";







  if( db->nDb>=db->aLimit[7]+2 ){
    zErrDyn = sqlite3MPrintf(db, "too many attached databases - max %d",
      db->aLimit[7]
    );
    goto attach_error;
  }
  if( !db->autoCommit ){
    zErrDyn = sqlite3MPrintf(db, "cannot ATTACH database within transaction");
    goto attach_error;
  }
  for(i=0; i<db->nDb; i++){
    char *z = db->aDb[i].zName;
    ((void) (0));
    if( sqlite3StrICmp(z, zName)==0 ){
      zErrDyn = sqlite3MPrintf(db, "database %s is already in use", zName);
      goto attach_error;
    }
  }




  if( db->aDb==db->aDbStatic ){
    aNew = sqlite3DbMallocRaw(db, sizeof(db->aDb[0])*3 );
    if( aNew==0 ) return;
    memcpy(aNew, db->aDb, sizeof(db->aDb[0])*2);
  }else{
    aNew = sqlite3DbRealloc(db, db->aDb, sizeof(db->aDb[0])*(db->nDb+1) );
    if( aNew==0 ) return;
  }
  db->aDb = aNew;
  aNew = &db->aDb[db->nDb];
  memset(aNew, 0, sizeof(*aNew));





  rc = sqlite3BtreeOpen(zFile, db, &aNew->pBt, 0,
                        db->openFlags | 0x00000100);
  db->nDb++;
  if( rc==19 ){
    rc = 1;
    zErrDyn = sqlite3MPrintf(db, "database is already attached");
  }else if( rc==0 ){
    Pager *pPager;
    aNew->pSchema = sqlite3SchemaGet(db, aNew->pBt);
    if( !aNew->pSchema ){
      rc = 7;
    }else if( aNew->pSchema->file_format && aNew->pSchema->enc!=((db)->aDb[0].pSchema->enc) ){
      zErrDyn = sqlite3MPrintf(db,
        "attached databases must use the same text encoding as main database");
      rc = 1;
    }
    pPager = sqlite3BtreePager(aNew->pBt);
    sqlite3PagerLockingMode(pPager, db->dfltLockMode);
    sqlite3BtreeSecureDelete(aNew->pBt,
                             sqlite3BtreeSecureDelete(db->aDb[0].pBt,-1) );
  }
  aNew->safety_level = 3;
  aNew->zName = sqlite3DbStrDup(db, zName);
  if( rc==0 && aNew->zName==0 ){
    rc = 7;
  }
# 76114 "ext/sqlite3/libsqlite/sqlite3.c"
  if( rc==0 ){
    sqlite3BtreeEnterAll(db);
    rc = sqlite3Init(db, &zErrDyn);
                            ;
  }
  if( rc ){
    int iDb = db->nDb - 1;
    ((void) (0));
    if( db->aDb[iDb].pBt ){
      sqlite3BtreeClose(db->aDb[iDb].pBt);
      db->aDb[iDb].pBt = 0;
      db->aDb[iDb].pSchema = 0;
    }
    sqlite3ResetInternalSchema(db, -1);
    db->nDb = iDb;
    if( rc==7 || rc==(10 | (12<<8)) ){
      db->mallocFailed = 1;
      sqlite3DbFree(db, zErrDyn);
      zErrDyn = sqlite3MPrintf(db, "out of memory");
    }else if( zErrDyn==0 ){
      zErrDyn = sqlite3MPrintf(db, "unable to open database: %s", zFile);
    }
    goto attach_error;
  }

  return;

attach_error:

  if( zErrDyn ){
    sqlite3_result_error(context, zErrDyn, -1);
    sqlite3DbFree(db, zErrDyn);
  }
  if( rc ) sqlite3_result_error_code(context, rc);
}
# 76158 "ext/sqlite3/libsqlite/sqlite3.c"
static void detachFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  const char *zName = (const char *)sqlite3_value_text(argv[0]);
  sqlite3 *db = sqlite3_context_db_handle(context);
  int i;
  Db *pDb = 0;
  char zErr[128];

  (void)(NotUsed);

  if( zName==0 ) zName = "";
  for(i=0; i<db->nDb; i++){
    pDb = &db->aDb[i];
    if( pDb->pBt==0 ) continue;
    if( sqlite3StrICmp(pDb->zName, zName)==0 ) break;
  }

  if( i>=db->nDb ){
    sqlite3_snprintf(sizeof(zErr),zErr, "no such database: %s", zName);
    goto detach_error;
  }
  if( i<2 ){
    sqlite3_snprintf(sizeof(zErr),zErr, "cannot detach database %s", zName);
    goto detach_error;
  }
  if( !db->autoCommit ){
    sqlite3_snprintf(sizeof(zErr), zErr,
                     "cannot DETACH database within transaction");
    goto detach_error;
  }
  if( sqlite3BtreeIsInReadTrans(pDb->pBt) || sqlite3BtreeIsInBackup(pDb->pBt) ){
    sqlite3_snprintf(sizeof(zErr),zErr, "database %s is locked", zName);
    goto detach_error;
  }

  sqlite3BtreeClose(pDb->pBt);
  pDb->pBt = 0;
  pDb->pSchema = 0;
  sqlite3ResetInternalSchema(db, -1);
  return;

detach_error:
  sqlite3_result_error(context, zErr, -1);
}





static void codeAttach(
  Parse *pParse,
  int type,
  FuncDef const *pFunc,
  Expr *pAuthArg,
  Expr *pFilename,
  Expr *pDbname,
  Expr *pKey
){
  int rc;
  NameContext sName;
  Vdbe *v;
  sqlite3* db = pParse->db;
  int regArgs;

  memset(&sName, 0, sizeof(NameContext));
  sName.pParse = pParse;

  if(
      0!=(rc = resolveAttachExpr(&sName, pFilename)) ||
      0!=(rc = resolveAttachExpr(&sName, pDbname)) ||
      0!=(rc = resolveAttachExpr(&sName, pKey))
  ){
    pParse->nErr++;
    goto attach_end;
  }


  if( pAuthArg ){
    char *zAuthArg;
    if( pAuthArg->op==94 ){
      zAuthArg = pAuthArg->u.zToken;
    }else{
      zAuthArg = 0;
    }
    rc = sqlite3AuthCheck(pParse, type, zAuthArg, 0, 0);
    if(rc!=0 ){
      goto attach_end;
    }
  }



  v = sqlite3GetVdbe(pParse);
  regArgs = sqlite3GetTempRange(pParse, 4);
  sqlite3ExprCode(pParse, pFilename, regArgs);
  sqlite3ExprCode(pParse, pDbname, regArgs+1);
  sqlite3ExprCode(pParse, pKey, regArgs+2);

  ((void) (0));
  if( v ){
    sqlite3VdbeAddOp3(v, 18, 0, regArgs+3-pFunc->nArg, regArgs+3);
    ((void) (0));
    sqlite3VdbeChangeP5(v, (u8)(pFunc->nArg));
    sqlite3VdbeChangeP4(v, -1, (char *)pFunc, (-5));





    sqlite3VdbeAddOp1(v, 122, (type==24));
  }

attach_end:
  sqlite3ExprDelete(db, pFilename);
  sqlite3ExprDelete(db, pDbname);
  sqlite3ExprDelete(db, pKey);
}






static void sqlite3Detach(Parse *pParse, Expr *pDbname){
  static const FuncDef detach_func = {
    1,
    1,
    0,
    0,
    0,
    detachFunc,
    0,
    0,
    "sqlite_detach",
    0,
    0
  };
  codeAttach(pParse, 25, &detach_func, pDbname, 0, 0, pDbname);
}






static void sqlite3Attach(Parse *pParse, Expr *p, Expr *pDbname, Expr *pKey){
  static const FuncDef attach_func = {
    3,
    1,
    0,
    0,
    0,
    attachFunc,
    0,
    0,
    "sqlite_attach",
    0,
    0
  };
  codeAttach(pParse, 24, &attach_func, p, p, pDbname, pKey);
}
# 76331 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3FixInit(
  DbFixer *pFix,
  Parse *pParse,
  int iDb,
  const char *zType,
  const Token *pName
){
  sqlite3 *db;

  if( (iDb<0) || iDb==1 ) return 0;
  db = pParse->db;
  ((void) (0));
  pFix->pParse = pParse;
  pFix->zDb = db->aDb[iDb].zName;
  pFix->zType = zType;
  pFix->pName = pName;
  return 1;
}
# 76364 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3FixSrcList(
  DbFixer *pFix,
  SrcList *pList
){
  int i;
  const char *zDb;
  struct SrcList_item *pItem;

  if( (pList==0) ) return 0;
  zDb = pFix->zDb;
  for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){
    if( pItem->zDatabase==0 ){
      pItem->zDatabase = sqlite3DbStrDup(pFix->pParse->db, zDb);
    }else if( sqlite3StrICmp(pItem->zDatabase,zDb)!=0 ){
      sqlite3ErrorMsg(pFix->pParse,
         "%s %T cannot reference objects in database %s",
         pFix->zType, pFix->pName, pItem->zDatabase);
      return 1;
    }

    if( sqlite3FixSelect(pFix, pItem->pSelect) ) return 1;
    if( sqlite3FixExpr(pFix, pItem->pOn) ) return 1;

  }
  return 0;
}

static int sqlite3FixSelect(
  DbFixer *pFix,
  Select *pSelect
){
  while( pSelect ){
    if( sqlite3FixExprList(pFix, pSelect->pEList) ){
      return 1;
    }
    if( sqlite3FixSrcList(pFix, pSelect->pSrc) ){
      return 1;
    }
    if( sqlite3FixExpr(pFix, pSelect->pWhere) ){
      return 1;
    }
    if( sqlite3FixExpr(pFix, pSelect->pHaving) ){
      return 1;
    }
    pSelect = pSelect->pPrior;
  }
  return 0;
}
static int sqlite3FixExpr(
  DbFixer *pFix,
  Expr *pExpr
){
  while( pExpr ){
    if( (((pExpr)->flags&(0x2000))!=0) ) break;
    if( (((pExpr)->flags&(0x0800))==(0x0800)) ){
      if( sqlite3FixSelect(pFix, pExpr->x.pSelect) ) return 1;
    }else{
      if( sqlite3FixExprList(pFix, pExpr->x.pList) ) return 1;
    }
    if( sqlite3FixExpr(pFix, pExpr->pRight) ){
      return 1;
    }
    pExpr = pExpr->pLeft;
  }
  return 0;
}
static int sqlite3FixExprList(
  DbFixer *pFix,
  ExprList *pList
){
  int i;
  struct ExprList_item *pItem;
  if( pList==0 ) return 0;
  for(i=0, pItem=pList->a; i<pList->nExpr; i++, pItem++){
    if( sqlite3FixExpr(pFix, pItem->pExpr) ){
      return 1;
    }
  }
  return 0;
}



static int sqlite3FixTriggerStep(
  DbFixer *pFix,
  TriggerStep *pStep
){
  while( pStep ){
    if( sqlite3FixSelect(pFix, pStep->pSelect) ){
      return 1;
    }
    if( sqlite3FixExpr(pFix, pStep->pWhere) ){
      return 1;
    }
    if( sqlite3FixExprList(pFix, pStep->pExprList) ){
      return 1;
    }
    pStep = pStep->pNext;
  }
  return 0;
}
# 76537 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_set_authorizer(
  sqlite3 *db,
  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),
  void *pArg
){
                                ;
  db->xAuth = xAuth;
  db->pAuthArg = pArg;
  sqlite3ExpirePreparedStatements(db);
                                ;
  return 0;
}





static void sqliteAuthBadReturnCode(Parse *pParse){
  sqlite3ErrorMsg(pParse, "authorizer malfunction");
  pParse->rc = 1;
}
# 76568 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3AuthReadCol(
  Parse *pParse,
  const char *zTab,
  const char *zCol,
  int iDb
){
  sqlite3 *db = pParse->db;
  char *zDb = db->aDb[iDb].zName;
  int rc;

  rc = db->xAuth(db->pAuthArg, 20, zTab,zCol,zDb,pParse->zAuthContext);
  if( rc==1 ){
    if( db->nDb>2 || iDb!=0 ){
      sqlite3ErrorMsg(pParse, "access to %s.%s.%s is prohibited",zDb,zTab,zCol);
    }else{
      sqlite3ErrorMsg(pParse, "access to %s.%s is prohibited", zTab, zCol);
    }
    pParse->rc = 23;
  }else if( rc!=2 && rc!=0 ){
    sqliteAuthBadReturnCode(pParse);
  }
  return rc;
}
# 76601 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3AuthRead(
  Parse *pParse,
  Expr *pExpr,
  Schema *pSchema,
  SrcList *pTabList
){
  sqlite3 *db = pParse->db;
  Table *pTab = 0;
  const char *zCol;
  int iSrc;
  int iDb;
  int iCol;

  if( db->xAuth==0 ) return;
  iDb = sqlite3SchemaToIndex(pParse->db, pSchema);
  if( iDb<0 ){


    return;
  }

  ((void) (0));
  if( pExpr->op==60 ){
    pTab = pParse->pTriggerTab;
  }else{
    ((void) (0));
    for(iSrc=0; (iSrc<pTabList->nSrc); iSrc++){
      if( pExpr->iTable==pTabList->a[iSrc].iCursor ){
        pTab = pTabList->a[iSrc].pTab;
        break;
      }
    }
  }
  iCol = pExpr->iColumn;
  if( (pTab==0) ) return;

  if( iCol>=0 ){
    ((void) (0));
    zCol = pTab->aCol[iCol].zName;
  }else if( pTab->iPKey>=0 ){
    ((void) (0));
    zCol = pTab->aCol[pTab->iPKey].zName;
  }else{
    zCol = "ROWID";
  }
  ((void) (0));
  if( 2==sqlite3AuthReadCol(pParse, pTab->zName, zCol, iDb) ){
    pExpr->op = 98;
  }
}







static int sqlite3AuthCheck(
  Parse *pParse,
  int code,
  const char *zArg1,
  const char *zArg2,
  const char *zArg3
){
  sqlite3 *db = pParse->db;
  int rc;




  if( db->init.busy || (pParse->declareVtab) ){
    return 0;
  }

  if( db->xAuth==0 ){
    return 0;
  }
  rc = db->xAuth(db->pAuthArg, code, zArg1, zArg2, zArg3, pParse->zAuthContext);
  if( rc==1 ){
    sqlite3ErrorMsg(pParse, "not authorized");
    pParse->rc = 23;
  }else if( rc!=0 && rc!=2 ){
    rc = 1;
    sqliteAuthBadReturnCode(pParse);
  }
  return rc;
}






static void sqlite3AuthContextPush(
  Parse *pParse,
  AuthContext *pContext,
  const char *zContext
){
  ((void) (0));
  pContext->pParse = pParse;
  pContext->zAuthContext = pParse->zAuthContext;
  pParse->zAuthContext = zContext;
}





static void sqlite3AuthContextPop(AuthContext *pContext){
  if( pContext->pParse ){
    pContext->pParse->zAuthContext = pContext->zAuthContext;
    pContext->pParse = 0;
  }
}
# 76749 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3BeginParse(Parse *pParse, int explainFlag){
  pParse->explain = (u8)explainFlag;
  pParse->nVar = 0;
}






struct TableLock {
  int iDb;
  int iTab;
  u8 isWriteLock;
  const char *zName;
};
# 76776 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3TableLock(
  Parse *pParse,
  int iDb,
  int iTab,
  u8 isWriteLock,
  const char *zName
){
  Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  int i;
  int nBytes;
  TableLock *p;
  ((void) (0));

  for(i=0; i<pToplevel->nTableLock; i++){
    p = &pToplevel->aTableLock[i];
    if( p->iDb==iDb && p->iTab==iTab ){
      p->isWriteLock = (p->isWriteLock || isWriteLock);
      return;
    }
  }

  nBytes = sizeof(TableLock) * (pToplevel->nTableLock+1);
  pToplevel->aTableLock =
      sqlite3DbReallocOrFree(pToplevel->db, pToplevel->aTableLock, nBytes);
  if( pToplevel->aTableLock ){
    p = &pToplevel->aTableLock[pToplevel->nTableLock++];
    p->iDb = iDb;
    p->iTab = iTab;
    p->isWriteLock = isWriteLock;
    p->zName = zName;
  }else{
    pToplevel->nTableLock = 0;
    pToplevel->db->mallocFailed = 1;
  }
}





static void codeTableLocks(Parse *pParse){
  int i;
  Vdbe *pVdbe;

  pVdbe = sqlite3GetVdbe(pParse);
  ((void) (0));

  for(i=0; i<pParse->nTableLock; i++){
    TableLock *p = &pParse->aTableLock[i];
    int p1 = p->iDb;
    sqlite3VdbeAddOp4(pVdbe, 123, p1, p->iTab, p->isWriteLock,
                      p->zName, (-2));
  }
}
# 76844 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3FinishCoding(Parse *pParse){
  sqlite3 *db;
  Vdbe *v;

  db = pParse->db;
  if( db->mallocFailed ) return;
  if( pParse->nested ) return;
  if( pParse->nErr ) return;




  v = sqlite3GetVdbe(pParse);
  ((void) (0));

  if( v ){
    sqlite3VdbeAddOp0(v, 6);







    if( pParse->cookieGoto>0 ){
      yDbMask mask;
      int iDb;
      sqlite3VdbeJumpHere(v, pParse->cookieGoto-1);
      for(iDb=0, mask=1; iDb<db->nDb; mask<<=1, iDb++){
        if( (mask & pParse->cookieMask)==0 ) continue;
        sqlite3VdbeUsesBtree(v, iDb);
        sqlite3VdbeAddOp2(v,34, iDb, (mask & pParse->writeMask)!=0);
        if( db->init.busy==0 ){
          ((void) (0));
          sqlite3VdbeAddOp3(v, 37,
                            iDb, pParse->cookieValue[iDb],
                            db->aDb[iDb].pSchema->iGeneration);
        }
      }

      {
        int i;
        for(i=0; i<pParse->nVtabLock; i++){
          char *vtab = (char *)sqlite3GetVTable(db, pParse->apVtabLock[i]);
          sqlite3VdbeAddOp4(v, 124, 0, 0, 0, vtab, (-10));
        }
        pParse->nVtabLock = 0;
      }






      codeTableLocks(pParse);



      sqlite3AutoincrementBegin(pParse);


      sqlite3VdbeAddOp2(v, 1, 0, pParse->cookieGoto);
    }
  }




  if( v && (pParse->nErr==0) && !db->mallocFailed ){




    ((void) (0));


    if( pParse->pAinc!=0 && pParse->nTab==0 ) pParse->nTab = 1;
    sqlite3VdbeMakeReady(v, pParse->nVar, pParse->nMem,
                         pParse->nTab, pParse->nMaxArg, pParse->explain,
                         pParse->isMultiWrite && pParse->mayAbort);
    pParse->rc = 101;
    pParse->colNamesSet = 0;
  }else{
    pParse->rc = 1;
  }
  pParse->nTab = 0;
  pParse->nMem = 0;
  pParse->nSet = 0;
  pParse->nVar = 0;
  pParse->cookieMask = 0;
  pParse->cookieGoto = 0;
}
# 76949 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3NestedParse(Parse *pParse, const char *zFormat, ...){
  va_list ap;
  char *zSql;
  char *zErrMsg = 0;
  sqlite3 *db = pParse->db;

  char saveBuf[(sizeof(Parse) - __builtin_offsetof(Parse, nVar))];

  if( pParse->nErr ) return;
  ((void) (0));
  __builtin_va_start(ap, zFormat);
  zSql = sqlite3VMPrintf(db, zFormat, ap);
  __builtin_va_end(ap);
  if( zSql==0 ){
    return;
  }
  pParse->nested++;
  memcpy(saveBuf, &pParse->nVar, (sizeof(Parse) - __builtin_offsetof(Parse, nVar)));
  memset(&pParse->nVar, 0, (sizeof(Parse) - __builtin_offsetof(Parse, nVar)));
  sqlite3RunParser(pParse, zSql, &zErrMsg);
  sqlite3DbFree(db, zErrMsg);
  sqlite3DbFree(db, zSql);
  memcpy(&pParse->nVar, saveBuf, (sizeof(Parse) - __builtin_offsetof(Parse, nVar)));
  pParse->nested--;
}
# 76987 "ext/sqlite3/libsqlite/sqlite3.c"
static Table *sqlite3FindTable(sqlite3 *db, const char *zName, const char *zDatabase){
  Table *p = 0;
  int i;
  int nName;
  ((void) (0));
  nName = sqlite3Strlen30(zName);

  ((void) (0));
  for(i=0; i<db->nDb; i++){
    int j = (i<2) ? i^1 : i;
    if( zDatabase!=0 && sqlite3StrICmp(zDatabase, db->aDb[j].zName) ) continue;
    ((void) (0));
    p = sqlite3HashFind(&db->aDb[j].pSchema->tblHash, zName, nName);
    if( p ) break;
  }
  return p;
}
# 77015 "ext/sqlite3/libsqlite/sqlite3.c"
static Table *sqlite3LocateTable(
  Parse *pParse,
  int isView,
  const char *zName,
  const char *zDbase
){
  Table *p;



  if( 0!=sqlite3ReadSchema(pParse) ){
    return 0;
  }

  p = sqlite3FindTable(pParse->db, zName, zDbase);
  if( p==0 ){
    const char *zMsg = isView ? "no such view" : "no such table";
    if( zDbase ){
      sqlite3ErrorMsg(pParse, "%s: %s.%s", zMsg, zDbase, zName);
    }else{
      sqlite3ErrorMsg(pParse, "%s: %s", zMsg, zName);
    }
    pParse->checkSchema = 1;
  }
  return p;
}
# 77054 "ext/sqlite3/libsqlite/sqlite3.c"
static Index *sqlite3FindIndex(sqlite3 *db, const char *zName, const char *zDb){
  Index *p = 0;
  int i;
  int nName = sqlite3Strlen30(zName);

  ((void) (0));
  for(i=0; i<db->nDb; i++){
    int j = (i<2) ? i^1 : i;
    Schema *pSchema = db->aDb[j].pSchema;
    ((void) (0));
    if( zDb && sqlite3StrICmp(zDb, db->aDb[j].zName) ) continue;
    ((void) (0));
    p = sqlite3HashFind(&pSchema->idxHash, zName, nName);
    if( p ) break;
  }
  return p;
}




static void freeIndex(sqlite3 *db, Index *p){

  sqlite3DeleteIndexSamples(db, p);

  sqlite3DbFree(db, p->zColAff);
  sqlite3DbFree(db, p);
}







static void sqlite3UnlinkAndDeleteIndex(sqlite3 *db, int iDb, const char *zIdxName){
  Index *pIndex;
  int len;
  Hash *pHash;

  ((void) (0));
  pHash = &db->aDb[iDb].pSchema->idxHash;
  len = sqlite3Strlen30(zIdxName);
  pIndex = sqlite3HashInsert(pHash, zIdxName, len, 0);
  if( (pIndex) ){
    if( pIndex->pTable->pIndex==pIndex ){
      pIndex->pTable->pIndex = pIndex->pNext;
    }else{
      Index *p;


      p = pIndex->pTable->pIndex;
      while( (p) && p->pNext!=pIndex ){ p = p->pNext; }
      if( (p && p->pNext==pIndex) ){
        p->pNext = pIndex->pNext;
      }
    }
    freeIndex(db, pIndex);
  }
  db->flags |= 0x00000200;
}
# 77127 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3ResetInternalSchema(sqlite3 *db, int iDb){
  int i, j;
  ((void) (0));

  if( iDb>=0 ){

    Db *pDb = &db->aDb[iDb];
    ((void) (0));
    ((void) (0));
    sqlite3SchemaClear(pDb->pSchema);





    if( iDb!=1 ){
      pDb = &db->aDb[1];
      ((void) (0));
      sqlite3SchemaClear(pDb->pSchema);
    }
    return;
  }


  ((void) (0));
  sqlite3BtreeEnterAll(db);
  for(i=0; i<db->nDb; i++){
    Db *pDb = &db->aDb[i];
    if( pDb->pSchema ){
      sqlite3SchemaClear(pDb->pSchema);
    }
  }
  db->flags &= ~0x00000200;
  sqlite3VtabUnlockList(db);
                          ;







  for(i=j=2; i<db->nDb; i++){
    struct Db *pDb = &db->aDb[i];
    if( pDb->pBt==0 ){
      sqlite3DbFree(db, pDb->zName);
      pDb->zName = 0;
      continue;
    }
    if( j<i ){
      db->aDb[j] = db->aDb[i];
    }
    j++;
  }
  memset(&db->aDb[j], 0, (db->nDb-j)*sizeof(db->aDb[j]));
  db->nDb = j;
  if( db->nDb<=2 && db->aDb!=db->aDbStatic ){
    memcpy(db->aDbStatic, db->aDb, 2*sizeof(db->aDb[0]));
    sqlite3DbFree(db, db->aDb);
    db->aDb = db->aDbStatic;
  }
}




static void sqlite3CommitInternalChanges(sqlite3 *db){
  db->flags &= ~0x00000200;
}





static void sqliteDeleteColumnNames(sqlite3 *db, Table *pTable){
  int i;
  Column *pCol;
  ((void) (0));
  if( (pCol = pTable->aCol)!=0 ){
    for(i=0; i<pTable->nCol; i++, pCol++){
      sqlite3DbFree(db, pCol->zName);
      sqlite3ExprDelete(db, pCol->pDflt);
      sqlite3DbFree(db, pCol->zDflt);
      sqlite3DbFree(db, pCol->zType);
      sqlite3DbFree(db, pCol->zColl);
    }
    sqlite3DbFree(db, pTable->aCol);
  }
}
# 77226 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3DeleteTable(sqlite3 *db, Table *pTable){
  Index *pIndex, *pNext;

  ((void) (0));


  if( !pTable ) return;
  if( ((!db || db->pnBytesFreed==0) && (--pTable->nRef)>0) ) return;


  for(pIndex = pTable->pIndex; pIndex; pIndex=pNext){
    pNext = pIndex->pNext;
    ((void) (0));
    if( !db || db->pnBytesFreed==0 ){
      char *zName = pIndex->zName;
                                 sqlite3HashInsert(
   &pIndex->pSchema->idxHash, zName, sqlite3Strlen30(zName), 0
      );
      ((void) (0));
      ((void) (0));
    }
    freeIndex(db, pIndex);
  }


  sqlite3FkDelete(db, pTable);



  sqliteDeleteColumnNames(db, pTable);
  sqlite3DbFree(db, pTable->zName);
  sqlite3DbFree(db, pTable->zColAff);
  sqlite3SelectDelete(db, pTable->pSelect);

  sqlite3ExprDelete(db, pTable->pCheck);


  sqlite3VtabClear(db, pTable);

  sqlite3DbFree(db, pTable);
}





static void sqlite3UnlinkAndDeleteTable(sqlite3 *db, int iDb, const char *zTabName){
  Table *p;
  Db *pDb;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
                            ;
  pDb = &db->aDb[iDb];
  p = sqlite3HashInsert(&pDb->pSchema->tblHash, zTabName,
                        sqlite3Strlen30(zTabName),0);
  sqlite3DeleteTable(db, p);
  db->flags |= 0x00000200;
}
# 77301 "ext/sqlite3/libsqlite/sqlite3.c"
static char *sqlite3NameFromToken(sqlite3 *db, Token *pName){
  char *zName;
  if( pName ){
    zName = sqlite3DbStrNDup(db, (char*)pName->z, pName->n);
    sqlite3Dequote(zName);
  }else{
    zName = 0;
  }
  return zName;
}





static void sqlite3OpenMasterTable(Parse *p, int iDb){
  Vdbe *v = sqlite3GetVdbe(p);
  sqlite3TableLock(p, iDb, 1, 1, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"));
  sqlite3VdbeAddOp3(v, 39, 0, 1, iDb);
  sqlite3VdbeChangeP4(v, -1, (char *)5, (-14));
  if( p->nTab==0 ){
    p->nTab = 1;
  }
}







static int sqlite3FindDbName(sqlite3 *db, const char *zName){
  int i = -1;
  if( zName ){
    Db *pDb;
    int n = sqlite3Strlen30(zName);
    for(i=(db->nDb-1), pDb=&db->aDb[i]; i>=0; i--, pDb--){
      if( (!0 || i!=1 ) && n==sqlite3Strlen30(pDb->zName) &&
          0==sqlite3StrICmp(pDb->zName, zName) ){
        break;
      }
    }
  }
  return i;
}







static int sqlite3FindDb(sqlite3 *db, Token *pName){
  int i;
  char *zName;
  zName = sqlite3NameFromToken(db, pName);
  i = sqlite3FindDbName(db, zName);
  sqlite3DbFree(db, zName);
  return i;
}
# 77378 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3TwoPartName(
  Parse *pParse,
  Token *pName1,
  Token *pName2,
  Token **pUnqual
){
  int iDb;
  sqlite3 *db = pParse->db;

  if( (pName2!=0) && pName2->n>0 ){
    if( db->init.busy ) {
      sqlite3ErrorMsg(pParse, "corrupt database");
      pParse->nErr++;
      return -1;
    }
    *pUnqual = pName2;
    iDb = sqlite3FindDb(db, pName1);
    if( iDb<0 ){
      sqlite3ErrorMsg(pParse, "unknown database %T", pName1);
      pParse->nErr++;
      return -1;
    }
  }else{
    ((void) (0));
    iDb = db->init.iDb;
    *pUnqual = pName1;
  }
  return iDb;
}
# 77415 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3CheckObjectName(Parse *pParse, const char *zName){
  if( !pParse->db->init.busy && pParse->nested==0
          && (pParse->db->flags & 0x00010000)==0
          && 0==sqlite3_strnicmp(zName, "sqlite_", 7) ){
    sqlite3ErrorMsg(pParse, "object name reserved for internal use: %s", zName);
    return 1;
  }
  return 0;
}
# 77441 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3StartTable(
  Parse *pParse,
  Token *pName1,
  Token *pName2,
  int isTemp,
  int isView,
  int isVirtual,
  int noErr
){
  Table *pTable;
  char *zName = 0;
  sqlite3 *db = pParse->db;
  Vdbe *v;
  int iDb;
  Token *pName;
# 77474 "ext/sqlite3/libsqlite/sqlite3.c"
  iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);
  if( iDb<0 ) return;
  if( !0 && isTemp && pName2->n>0 && iDb!=1 ){


    sqlite3ErrorMsg(pParse, "temporary table name must be unqualified");
    return;
  }
  if( !0 && isTemp ) iDb = 1;

  pParse->sNameToken = *pName;
  zName = sqlite3NameFromToken(db, pName);
  if( zName==0 ) return;
  if( 0!=sqlite3CheckObjectName(pParse, zName) ){
    goto begin_table_error;
  }
  if( db->init.iDb==1 ) isTemp = 1;

  ((void) (0));
  {
    int code;
    char *zDb = db->aDb[iDb].zName;
    if( sqlite3AuthCheck(pParse, 18, ((!0)&&(isTemp==1)?"sqlite_temp_master":"sqlite_master"), 0, zDb) ){
      goto begin_table_error;
    }
    if( isView ){
      if( !0 && isTemp ){
        code = 6;
      }else{
        code = 8;
      }
    }else{
      if( !0 && isTemp ){
        code = 4;
      }else{
        code = 2;
      }
    }
    if( !isVirtual && sqlite3AuthCheck(pParse, code, zName, 0, zDb) ){
      goto begin_table_error;
    }
  }
# 77525 "ext/sqlite3/libsqlite/sqlite3.c"
  if( !(pParse->declareVtab) ){
    char *zDb = db->aDb[iDb].zName;
    if( 0!=sqlite3ReadSchema(pParse) ){
      goto begin_table_error;
    }
    pTable = sqlite3FindTable(db, zName, zDb);
    if( pTable ){
      if( !noErr ){
        sqlite3ErrorMsg(pParse, "table %T already exists", pName);
      }else{
        ((void) (0));
        sqlite3CodeVerifySchema(pParse, iDb);
      }
      goto begin_table_error;
    }
    if( sqlite3FindIndex(db, zName, zDb)!=0 ){
      sqlite3ErrorMsg(pParse, "there is already an index named %s", zName);
      goto begin_table_error;
    }
  }

  pTable = sqlite3DbMallocZero(db, sizeof(Table));
  if( pTable==0 ){
    db->mallocFailed = 1;
    pParse->rc = 7;
    pParse->nErr++;
    goto begin_table_error;
  }
  pTable->zName = zName;
  pTable->iPKey = -1;
  pTable->pSchema = db->aDb[iDb].pSchema;
  pTable->nRef = 1;
  pTable->nRowEst = 1000000;
  ((void) (0));
  pParse->pNewTable = pTable;






  if( !pParse->nested && __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (zName) && __builtin_constant_p ("sqlite_sequence") && (__s1_len = __builtin_strlen (zName), __s2_len = __builtin_strlen ("sqlite_sequence"), (!((size_t)(const void *)((zName) + 1) - (size_t)(const void *)(zName) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("sqlite_sequence") + 1) - (size_t)(const void *)("sqlite_sequence") == 1) || __s2_len >= 4)) ? __builtin_strcmp (zName, "sqlite_sequence") : (__builtin_constant_p (zName) && ((size_t)(const void *)((zName) + 1) - (size_t)(const void *)(zName) == 1) && (__s1_len = __builtin_strlen (zName), __s1_len < 4) ? (__builtin_constant_p ("sqlite_sequence") && ((size_t)(const void *)(("sqlite_sequence") + 1) - (size_t)(const void *)("sqlite_sequence") == 1) ? __builtin_strcmp (zName, "sqlite_sequence") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("sqlite_sequence"); int __result = (((const unsigned char *) (const char *) (zName))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (zName))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (zName))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (zName))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("sqlite_sequence") && ((size_t)(const void *)(("sqlite_sequence") + 1) - (size_t)(const void *)("sqlite_sequence") == 1) && (__s2_len = __builtin_strlen ("sqlite_sequence"), __s2_len < 4) ? (__builtin_constant_p (zName) && ((size_t)(const void *)((zName) + 1) - (size_t)(const void *)(zName) == 1) ? __builtin_strcmp (zName, "sqlite_sequence") : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (zName); int __result = (((const unsigned char *) (const char *) ("sqlite_sequence"))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ("sqlite_sequence"))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ("sqlite_sequence"))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ("sqlite_sequence"))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (zName, "sqlite_sequence")))); })==0 ){
    ((void) (0));
    pTable->pSchema->pSeqTab = pTable;
  }
# 77580 "ext/sqlite3/libsqlite/sqlite3.c"
  if( !db->init.busy && (v = sqlite3GetVdbe(pParse))!=0 ){
    int j1;
    int fileFormat;
    int reg1, reg2, reg3;
    sqlite3BeginWriteOperation(pParse, 0, iDb);


    if( isVirtual ){
      sqlite3VdbeAddOp0(v, 124);
    }





    reg1 = pParse->regRowid = ++pParse->nMem;
    reg2 = pParse->regRoot = ++pParse->nMem;
    reg3 = ++pParse->nMem;
    sqlite3VdbeAddOp3(v, 35, iDb, reg3, 2);
    sqlite3VdbeUsesBtree(v, iDb);
    j1 = sqlite3VdbeAddOp1(v, 26, reg3);
    fileFormat = (db->flags & 0x00100000)!=0 ?
                  1 : 4;
    sqlite3VdbeAddOp2(v, 7, fileFormat, reg3);
    sqlite3VdbeAddOp3(v, 36, iDb, 2, reg3);
    sqlite3VdbeAddOp2(v, 7, ((db)->aDb[0].pSchema->enc), reg3);
    sqlite3VdbeAddOp3(v, 36, iDb, 5, reg3);
    sqlite3VdbeJumpHere(v, j1);
# 77619 "ext/sqlite3/libsqlite/sqlite3.c"
    if( isView || isVirtual ){
      sqlite3VdbeAddOp2(v, 7, 0, reg2);
    }else

    {
      sqlite3VdbeAddOp2(v, 98, iDb, reg2);
    }
    sqlite3OpenMasterTable(pParse, iDb);
    sqlite3VdbeAddOp2(v, 54, 0, reg1);
    sqlite3VdbeAddOp2(v, 10, 0, reg3);
    sqlite3VdbeAddOp3(v, 55, 0, reg3, reg1);
    sqlite3VdbeChangeP5(v, 0x08);
    sqlite3VdbeAddOp0(v, 43);
  }


  return;


begin_table_error:
  sqlite3DbFree(db, zName);
  return;
}
# 77664 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3AddColumn(Parse *pParse, Token *pName){
  Table *p;
  int i;
  char *z;
  Column *pCol;
  sqlite3 *db = pParse->db;
  if( (p = pParse->pNewTable)==0 ) return;

  if( p->nCol+1>db->aLimit[2] ){
    sqlite3ErrorMsg(pParse, "too many columns on %s", p->zName);
    return;
  }

  z = sqlite3NameFromToken(db, pName);
  if( z==0 ) return;
  for(i=0; i<p->nCol; i++){
    if( (sqlite3UpperToLower[*(unsigned char *)(z)]== sqlite3UpperToLower[*(unsigned char *)(p->aCol[i].zName)] && sqlite3StrICmp((z)+1,(p->aCol[i].zName)+1)==0 ) ){
      sqlite3ErrorMsg(pParse, "duplicate column name: %s", z);
      sqlite3DbFree(db, z);
      return;
    }
  }
  if( (p->nCol & 0x7)==0 ){
    Column *aNew;
    aNew = sqlite3DbRealloc(db,p->aCol,(p->nCol+8)*sizeof(p->aCol[0]));
    if( aNew==0 ){
      sqlite3DbFree(db, z);
      return;
    }
    p->aCol = aNew;
  }
  pCol = &p->aCol[p->nCol];
  memset(pCol, 0, sizeof(p->aCol[0]));
  pCol->zName = z;





  pCol->affinity = 'b';
  p->nCol++;
}







static void sqlite3AddNotNull(Parse *pParse, int onError){
  Table *p;
  p = pParse->pNewTable;
  if( p==0 || (p->nCol<1) ) return;
  p->aCol[p->nCol-1].notNull = (u8)onError;
}
# 77745 "ext/sqlite3/libsqlite/sqlite3.c"
static char sqlite3AffinityType(const char *zIn){
  u32 h = 0;
  char aff = 'c';

  if( zIn ) while( zIn[0] ){
    h = (h<<8) + sqlite3UpperToLower[(*zIn)&0xff];
    zIn++;
    if( h==(('c'<<24)+('h'<<16)+('a'<<8)+'r') ){
      aff = 'a';
    }else if( h==(('c'<<24)+('l'<<16)+('o'<<8)+'b') ){
      aff = 'a';
    }else if( h==(('t'<<24)+('e'<<16)+('x'<<8)+'t') ){
      aff = 'a';
    }else if( h==(('b'<<24)+('l'<<16)+('o'<<8)+'b')
        && (aff=='c' || aff=='e') ){
      aff = 'b';

    }else if( h==(('r'<<24)+('e'<<16)+('a'<<8)+'l')
        && aff=='c' ){
      aff = 'e';
    }else if( h==(('f'<<24)+('l'<<16)+('o'<<8)+'a')
        && aff=='c' ){
      aff = 'e';
    }else if( h==(('d'<<24)+('o'<<16)+('u'<<8)+'b')
        && aff=='c' ){
      aff = 'e';

    }else if( (h&0x00FFFFFF)==(('i'<<16)+('n'<<8)+'t') ){
      aff = 'd';
      break;
    }
  }

  return aff;
}
# 77790 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3AddColumnType(Parse *pParse, Token *pType){
  Table *p;
  Column *pCol;

  p = pParse->pNewTable;
  if( p==0 || (p->nCol<1) ) return;
  pCol = &p->aCol[p->nCol-1];
  ((void) (0));
  pCol->zType = sqlite3NameFromToken(pParse->db, pType);
  pCol->affinity = sqlite3AffinityType(pCol->zType);
}
# 77812 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3AddDefaultValue(Parse *pParse, ExprSpan *pSpan){
  Table *p;
  Column *pCol;
  sqlite3 *db = pParse->db;
  p = pParse->pNewTable;
  if( p!=0 ){
    pCol = &(p->aCol[p->nCol-1]);
    if( !sqlite3ExprIsConstantOrFunction(pSpan->pExpr) ){
      sqlite3ErrorMsg(pParse, "default value of column [%s] is not constant",
          pCol->zName);
    }else{




      sqlite3ExprDelete(db, pCol->pDflt);
      pCol->pDflt = sqlite3ExprDup(db, pSpan->pExpr, 0x0001);
      sqlite3DbFree(db, pCol->zDflt);
      pCol->zDflt = sqlite3DbStrNDup(db, (char*)pSpan->zStart,
                                     (int)(pSpan->zEnd - pSpan->zStart));
    }
  }
  sqlite3ExprDelete(db, pSpan->pExpr);
}
# 77855 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3AddPrimaryKey(
  Parse *pParse,
  ExprList *pList,
  int onError,
  int autoInc,
  int sortOrder
){
  Table *pTab = pParse->pNewTable;
  char *zType = 0;
  int iCol = -1, i;
  if( pTab==0 || (pParse->declareVtab) ) goto primary_key_exit;
  if( pTab->tabFlags & 0x04 ){
    sqlite3ErrorMsg(pParse,
      "table \"%s\" has more than one primary key", pTab->zName);
    goto primary_key_exit;
  }
  pTab->tabFlags |= 0x04;
  if( pList==0 ){
    iCol = pTab->nCol - 1;
    pTab->aCol[iCol].isPrimKey = 1;
  }else{
    for(i=0; i<pList->nExpr; i++){
      for(iCol=0; iCol<pTab->nCol; iCol++){
        if( sqlite3StrICmp(pList->a[i].zName, pTab->aCol[iCol].zName)==0 ){
          break;
        }
      }
      if( iCol<pTab->nCol ){
        pTab->aCol[iCol].isPrimKey = 1;
      }
    }
    if( pList->nExpr>1 ) iCol = -1;
  }
  if( iCol>=0 && iCol<pTab->nCol ){
    zType = pTab->aCol[iCol].zType;
  }
  if( zType && sqlite3StrICmp(zType, "INTEGER")==0
        && sortOrder==0 ){
    pTab->iPKey = iCol;
    pTab->keyConf = (u8)onError;
    ((void) (0));
    pTab->tabFlags |= autoInc*0x08;
  }else if( autoInc ){

    sqlite3ErrorMsg(pParse, "AUTOINCREMENT is only allowed on an "
       "INTEGER PRIMARY KEY");

  }else{
    Index *p;
    p = sqlite3CreateIndex(pParse, 0, 0, 0, pList, onError, 0, 0, sortOrder, 0);
    if( p ){
      p->autoIndex = 2;
    }
    pList = 0;
  }

primary_key_exit:
  sqlite3ExprListDelete(pParse->db, pList);
  return;
}




static void sqlite3AddCheckConstraint(
  Parse *pParse,
  Expr *pCheckExpr
){
  sqlite3 *db = pParse->db;

  Table *pTab = pParse->pNewTable;
  if( pTab && !(pParse->declareVtab) ){
    pTab->pCheck = sqlite3ExprAnd(db, pTab->pCheck, pCheckExpr);
  }else

  {
    sqlite3ExprDelete(db, pCheckExpr);
  }
}





static void sqlite3AddCollateType(Parse *pParse, Token *pToken){
  Table *p;
  int i;
  char *zColl;
  sqlite3 *db;

  if( (p = pParse->pNewTable)==0 ) return;
  i = p->nCol-1;
  db = pParse->db;
  zColl = sqlite3NameFromToken(db, pToken);
  if( !zColl ) return;

  if( sqlite3LocateCollSeq(pParse, zColl) ){
    Index *pIdx;
    p->aCol[i].zColl = zColl;





    for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){
      ((void) (0));
      if( pIdx->aiColumn[0]==i ){
        pIdx->azColl[0] = p->aCol[i].zColl;
      }
    }
  }else{
    sqlite3DbFree(db, zColl);
  }
}
# 77990 "ext/sqlite3/libsqlite/sqlite3.c"
static CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char *zName){
  sqlite3 *db = pParse->db;
  u8 enc = ((db)->aDb[0].pSchema->enc);
  u8 initbusy = db->init.busy;
  CollSeq *pColl;

  pColl = sqlite3FindCollSeq(db, enc, zName, initbusy);
  if( !initbusy && (!pColl || !pColl->xCmp) ){
    pColl = sqlite3GetCollSeq(db, enc, pColl, zName);
    if( !pColl ){
      sqlite3ErrorMsg(pParse, "no such collation sequence: %s", zName);
    }
  }

  return pColl;
}
# 78024 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3ChangeCookie(Parse *pParse, int iDb){
  int r1 = sqlite3GetTempReg(pParse);
  sqlite3 *db = pParse->db;
  Vdbe *v = pParse->pVdbe;
  ((void) (0));
  sqlite3VdbeAddOp2(v, 7, db->aDb[iDb].pSchema->schema_cookie+1, r1);
  sqlite3VdbeAddOp3(v, 36, iDb, 1, r1);
  sqlite3ReleaseTempReg(pParse, r1);
}
# 78042 "ext/sqlite3/libsqlite/sqlite3.c"
static int identLength(const char *z){
  int n;
  for(n=0; *z; n++, z++){
    if( *z=='"' ){ n++; }
  }
  return n + 2;
}
# 78063 "ext/sqlite3/libsqlite/sqlite3.c"
static void identPut(char *z, int *pIdx, char *zSignedIdent){
  unsigned char *zIdent = (unsigned char*)zSignedIdent;
  int i, j, needQuote;
  i = *pIdx;

  for(j=0; zIdent[j]; j++){
    if( !(sqlite3CtypeMap[(unsigned char)(zIdent[j])]&0x06) && zIdent[j]!='_' ) break;
  }
  needQuote = (sqlite3CtypeMap[(unsigned char)(zIdent[0])]&0x04) || sqlite3KeywordCode(zIdent, j)!=26;
  if( !needQuote ){
    needQuote = zIdent[j];
  }

  if( needQuote ) z[i++] = '"';
  for(j=0; zIdent[j]; j++){
    z[i++] = zIdent[j];
    if( zIdent[j]=='"' ) z[i++] = '"';
  }
  if( needQuote ) z[i++] = '"';
  z[i] = 0;
  *pIdx = i;
}






static char *createTableStmt(sqlite3 *db, Table *p){
  int i, k, n;
  char *zStmt;
  char *zSep, *zSep2, *zEnd;
  Column *pCol;
  n = 0;
  for(pCol = p->aCol, i=0; i<p->nCol; i++, pCol++){
    n += identLength(pCol->zName) + 5;
  }
  n += identLength(p->zName);
  if( n<50 ){
    zSep = "";
    zSep2 = ",";
    zEnd = ")";
  }else{
    zSep = "\n  ";
    zSep2 = ",\n  ";
    zEnd = "\n)";
  }
  n += 35 + 6*p->nCol;
  zStmt = sqlite3DbMallocRaw(0, n);
  if( zStmt==0 ){
    db->mallocFailed = 1;
    return 0;
  }
  sqlite3_snprintf(n, zStmt, "CREATE TABLE ");
  k = sqlite3Strlen30(zStmt);
  identPut(zStmt, &k, p->zName);
  zStmt[k++] = '(';
  for(pCol=p->aCol, i=0; i<p->nCol; i++, pCol++){
    static const char * const azType[] = {
                                 " TEXT",
                                 "",
                                 " NUM",
                                 " INT",
                                 " REAL"
    };
    int len;
    const char *zType;

    sqlite3_snprintf(n-k, &zStmt[k], zSep);
    k += sqlite3Strlen30(&zStmt[k]);
    zSep = zSep2;
    identPut(zStmt, &k, pCol->zName);
    ((void) (0));
    ((void) (0));
                                               ;
                                               ;
                                                  ;
                                                  ;
                                               ;

    zType = azType[pCol->affinity - 'a'];
    len = sqlite3Strlen30(zType);
    ((void) (0));

    memcpy(&zStmt[k], zType, len);
    k += len;
    ((void) (0));
  }
  sqlite3_snprintf(n-k, &zStmt[k], "%s", zEnd);
  return zStmt;
}
# 78175 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3EndTable(
  Parse *pParse,
  Token *pCons,
  Token *pEnd,
  Select *pSelect
){
  Table *p;
  sqlite3 *db = pParse->db;
  int iDb;

  if( (pEnd==0 && pSelect==0) || db->mallocFailed ){
    return;
  }
  p = pParse->pNewTable;
  if( p==0 ) return;

  ((void) (0));

  iDb = sqlite3SchemaToIndex(db, p->pSchema);




  if( p->pCheck ){
    SrcList sSrc;
    NameContext sNC;

    memset(&sNC, 0, sizeof(sNC));
    memset(&sSrc, 0, sizeof(sSrc));
    sSrc.nSrc = 1;
    sSrc.a[0].zName = p->zName;
    sSrc.a[0].pTab = p;
    sSrc.a[0].iCursor = -1;
    sNC.pParse = pParse;
    sNC.pSrcList = &sSrc;
    sNC.isCheck = 1;
    if( sqlite3ResolveExprNames(&sNC, p->pCheck) ){
      return;
    }
  }
# 78223 "ext/sqlite3/libsqlite/sqlite3.c"
  if( db->init.busy ){
    p->tnum = db->init.newTnum;
  }







  if( !db->init.busy ){
    int n;
    Vdbe *v;
    char *zType;
    char *zType2;
    char *zStmt;

    v = sqlite3GetVdbe(pParse);
    if( (v==0) ) return;

    sqlite3VdbeAddOp1(v, 43, 0);




    if( p->pSelect==0 ){

      zType = "table";
      zType2 = "TABLE";

    }else{

      zType = "view";
      zType2 = "VIEW";

    }
# 78273 "ext/sqlite3/libsqlite/sqlite3.c"
    if( pSelect ){
      SelectDest dest;
      Table *pSelTab;

      ((void) (0));
      sqlite3VdbeAddOp3(v, 39, 1, pParse->regRoot, iDb);
      sqlite3VdbeChangeP5(v, 1);
      pParse->nTab = 2;
      sqlite3SelectDestInit(&dest, 8, 1);
      sqlite3Select(pParse, pSelect, &dest);
      sqlite3VdbeAddOp1(v, 43, 1);
      if( pParse->nErr==0 ){
        pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect);
        if( pSelTab==0 ) return;
        ((void) (0));
        p->nCol = pSelTab->nCol;
        p->aCol = pSelTab->aCol;
        pSelTab->nCol = 0;
        pSelTab->aCol = 0;
        sqlite3DeleteTable(db, pSelTab);
      }
    }


    if( pSelect ){
      zStmt = createTableStmt(db, p);
    }else{
      n = (int)(pEnd->z - pParse->sNameToken.z) + 1;
      zStmt = sqlite3MPrintf(db,
          "CREATE %s %.*s", zType2, n, pParse->sNameToken.z
      );
    }





    sqlite3NestedParse(pParse,
      "UPDATE %Q.%s "
         "SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q "
       "WHERE rowid=#%d",
      db->aDb[iDb].zName, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"),
      zType,
      p->zName,
      p->zName,
      pParse->regRoot,
      zStmt,
      pParse->regRowid
    );
    sqlite3DbFree(db, zStmt);
    sqlite3ChangeCookie(pParse, iDb);





    if( p->tabFlags & 0x08 ){
      Db *pDb = &db->aDb[iDb];
      ((void) (0));
      if( pDb->pSchema->pSeqTab==0 ){
        sqlite3NestedParse(pParse,
          "CREATE TABLE %Q.sqlite_sequence(name,seq)",
          pDb->zName
        );
      }
    }



    sqlite3VdbeAddOp4(v, 99, iDb, 0, 0,
        sqlite3MPrintf(db, "tbl_name='%q'",p->zName), (-1));
  }




  if( db->init.busy ){
    Table *pOld;
    Schema *pSchema = p->pSchema;
    ((void) (0));
    pOld = sqlite3HashInsert(&pSchema->tblHash, p->zName,
                             sqlite3Strlen30(p->zName),p);
    if( pOld ){
      ((void) (0));
      db->mallocFailed = 1;
      return;
    }
    pParse->pNewTable = 0;
    db->nTable++;
    db->flags |= 0x00000200;


    if( !p->pSelect ){
      const char *zName = (const char *)pParse->sNameToken.z;
      int nName;
      ((void) (0));
      if( pCons->z==0 ){
        pCons = pEnd;
      }
      nName = (int)((const char *)pCons->z - zName);
      p->addColOffset = 13 + sqlite3Utf8CharLen(zName, nName);
    }

  }
}





static void sqlite3CreateView(
  Parse *pParse,
  Token *pBegin,
  Token *pName1,
  Token *pName2,
  Select *pSelect,
  int isTemp,
  int noErr
){
  Table *p;
  int n;
  const char *z;
  Token sEnd;
  DbFixer sFix;
  Token *pName;
  int iDb;
  sqlite3 *db = pParse->db;

  if( pParse->nVar>0 ){
    sqlite3ErrorMsg(pParse, "parameters are not allowed in views");
    sqlite3SelectDelete(db, pSelect);
    return;
  }
  sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr);
  p = pParse->pNewTable;
  if( p==0 || pParse->nErr ){
    sqlite3SelectDelete(db, pSelect);
    return;
  }
  sqlite3TwoPartName(pParse, pName1, pName2, &pName);
  iDb = sqlite3SchemaToIndex(db, p->pSchema);
  if( sqlite3FixInit(&sFix, pParse, iDb, "view", pName)
    && sqlite3FixSelect(&sFix, pSelect)
  ){
    sqlite3SelectDelete(db, pSelect);
    return;
  }






  p->pSelect = sqlite3SelectDup(db, pSelect, 0x0001);
  sqlite3SelectDelete(db, pSelect);
  if( db->mallocFailed ){
    return;
  }
  if( !db->init.busy ){
    sqlite3ViewGetColumnNames(pParse, p);
  }




  sEnd = pParse->sLastToken;
  if( (sEnd.z[0]!=0) && sEnd.z[0]!=';' ){
    sEnd.z += sEnd.n;
  }
  sEnd.n = 0;
  n = (int)(sEnd.z - pBegin->z);
  z = pBegin->z;
  while( (n>0) && (sqlite3CtypeMap[(unsigned char)(z[n-1])]&0x01) ){ n--; }
  sEnd.z = &z[n-1];
  sEnd.n = 1;


  sqlite3EndTable(pParse, 0, &sEnd, 0);
  return;
}
# 78461 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable){
  Table *pSelTab;
  Select *pSel;
  int nErr = 0;
  int n;
  sqlite3 *db = pParse->db;
  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*);

  ((void) (0));


  if( sqlite3VtabCallConnect(pParse, pTable) ){
    return 1;
  }
  if( (((pTable)->tabFlags & 0x10)!=0) ) return 0;






  if( pTable->nCol>0 ) return 0;
# 78499 "ext/sqlite3/libsqlite/sqlite3.c"
  if( pTable->nCol<0 ){
    sqlite3ErrorMsg(pParse, "view %s is circularly defined", pTable->zName);
    return 1;
  }
  ((void) (0));
# 78512 "ext/sqlite3/libsqlite/sqlite3.c"
  ((void) (0));
  pSel = sqlite3SelectDup(db, pTable->pSelect, 0);
  if( pSel ){
    u8 enableLookaside = db->lookaside.bEnabled;
    n = pParse->nTab;
    sqlite3SrcListAssignCursors(pParse, pSel->pSrc);
    pTable->nCol = -1;
    db->lookaside.bEnabled = 0;

    xAuth = db->xAuth;
    db->xAuth = 0;
    pSelTab = sqlite3ResultSetOfSelect(pParse, pSel);
    db->xAuth = xAuth;



    db->lookaside.bEnabled = enableLookaside;
    pParse->nTab = n;
    if( pSelTab ){
      ((void) (0));
      pTable->nCol = pSelTab->nCol;
      pTable->aCol = pSelTab->aCol;
      pSelTab->nCol = 0;
      pSelTab->aCol = 0;
      sqlite3DeleteTable(db, pSelTab);
      ((void) (0));
      pTable->pSchema->flags |= 0x0002;
    }else{
      pTable->nCol = 0;
      nErr++;
    }
    sqlite3SelectDelete(db, pSel);
  } else {
    nErr++;
  }

  return nErr;
}






static void sqliteViewResetAll(sqlite3 *db, int idx){
  HashElem *i;
  ((void) (0));
  if( !(((db)->aDb[idx].pSchema->flags&(0x0002))==(0x0002)) ) return;
  for(i=((&db->aDb[idx].pSchema->tblHash)->first); i;i=((i)->next)){
    Table *pTab = ((i)->data);
    if( pTab->pSelect ){
      sqliteDeleteColumnNames(db, pTab);
      pTab->aCol = 0;
      pTab->nCol = 0;
    }
  }
  (db)->aDb[idx].pSchema->flags&=~(0x0002);
}
# 78592 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3RootPageMoved(sqlite3 *db, int iDb, int iFrom, int iTo){
  HashElem *pElem;
  Hash *pHash;
  Db *pDb;

  ((void) (0));
  pDb = &db->aDb[iDb];
  pHash = &pDb->pSchema->tblHash;
  for(pElem=((pHash)->first); pElem; pElem=((pElem)->next)){
    Table *pTab = ((pElem)->data);
    if( pTab->tnum==iFrom ){
      pTab->tnum = iTo;
    }
  }
  pHash = &pDb->pSchema->idxHash;
  for(pElem=((pHash)->first); pElem; pElem=((pElem)->next)){
    Index *pIdx = ((pElem)->data);
    if( pIdx->tnum==iFrom ){
      pIdx->tnum = iTo;
    }
  }
}
# 78622 "ext/sqlite3/libsqlite/sqlite3.c"
static void destroyRootPage(Parse *pParse, int iTable, int iDb){
  Vdbe *v = sqlite3GetVdbe(pParse);
  int r1 = sqlite3GetTempReg(pParse);
  sqlite3VdbeAddOp3(v, 95, iTable, r1, iDb);
  sqlite3MayAbort(pParse);
# 78637 "ext/sqlite3/libsqlite/sqlite3.c"
  sqlite3NestedParse(pParse,
     "UPDATE %Q.%s SET rootpage=%d WHERE #%d AND rootpage=#%d",
     pParse->db->aDb[iDb].zName, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"), iTable, r1, r1);

  sqlite3ReleaseTempReg(pParse, r1);
}







static void destroyTable(Parse *pParse, Table *pTab){
# 78675 "ext/sqlite3/libsqlite/sqlite3.c"
  int iTab = pTab->tnum;
  int iDestroyed = 0;

  while( 1 ){
    Index *pIdx;
    int iLargest = 0;

    if( iDestroyed==0 || iTab<iDestroyed ){
      iLargest = iTab;
    }
    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
      int iIdx = pIdx->tnum;
      ((void) (0));
      if( (iDestroyed==0 || (iIdx<iDestroyed)) && iIdx>iLargest ){
        iLargest = iIdx;
      }
    }
    if( iLargest==0 ){
      return;
    }else{
      int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
      destroyRootPage(pParse, iLargest, iDb);
      iDestroyed = iLargest;
    }
  }

}





static void sqlite3DropTable(Parse *pParse, SrcList *pName, int isView, int noErr){
  Table *pTab;
  Vdbe *v;
  sqlite3 *db = pParse->db;
  int iDb;

  if( db->mallocFailed ){
    goto exit_drop_table;
  }
  ((void) (0));
  ((void) (0));
  if( noErr ) db->suppressErr++;
  pTab = sqlite3LocateTable(pParse, isView,
                            pName->a[0].zName, pName->a[0].zDatabase);
  if( noErr ) db->suppressErr--;

  if( pTab==0 ){
    if( noErr ) sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);
    goto exit_drop_table;
  }
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  ((void) (0));




  if( (((pTab)->tabFlags & 0x10)!=0) && sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto exit_drop_table;
  }

  {
    int code;
    const char *zTab = ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master");
    const char *zDb = db->aDb[iDb].zName;
    const char *zArg2 = 0;
    if( sqlite3AuthCheck(pParse, 9, zTab, 0, zDb)){
      goto exit_drop_table;
    }
    if( isView ){
      if( !0 && iDb==1 ){
        code = 15;
      }else{
        code = 17;
      }

    }else if( (((pTab)->tabFlags & 0x10)!=0) ){
      code = 30;
      zArg2 = sqlite3GetVTable(db, pTab)->pMod->zName;

    }else{
      if( !0 && iDb==1 ){
        code = 13;
      }else{
        code = 11;
      }
    }
    if( sqlite3AuthCheck(pParse, code, pTab->zName, zArg2, zDb) ){
      goto exit_drop_table;
    }
    if( sqlite3AuthCheck(pParse, 9, pTab->zName, 0, zDb) ){
      goto exit_drop_table;
    }
  }

  if( sqlite3_strnicmp(pTab->zName, "sqlite_", 7)==0 ){
    sqlite3ErrorMsg(pParse, "table %s may not be dropped", pTab->zName);
    goto exit_drop_table;
  }





  if( isView && pTab->pSelect==0 ){
    sqlite3ErrorMsg(pParse, "use DROP TABLE to delete table %s", pTab->zName);
    goto exit_drop_table;
  }
  if( !isView && pTab->pSelect ){
    sqlite3ErrorMsg(pParse, "use DROP VIEW to delete view %s", pTab->zName);
    goto exit_drop_table;
  }





  v = sqlite3GetVdbe(pParse);
  if( v ){
    Trigger *pTrigger;
    Db *pDb = &db->aDb[iDb];
    sqlite3BeginWriteOperation(pParse, 1, iDb);


    if( (((pTab)->tabFlags & 0x10)!=0) ){
      sqlite3VdbeAddOp0(v, 124);
    }

    sqlite3FkDropTable(pParse, pName, pTab);





    pTrigger = sqlite3TriggerList(pParse, pTab);
    while( pTrigger ){
      ((void) (0));

      sqlite3DropTriggerPtr(pParse, pTrigger);
      pTrigger = pTrigger->pNext;
    }







    if( pTab->tabFlags & 0x08 ){
      sqlite3NestedParse(pParse,
        "DELETE FROM %s.sqlite_sequence WHERE name=%Q",
        pDb->zName, pTab->zName
      );
    }
# 78839 "ext/sqlite3/libsqlite/sqlite3.c"
    sqlite3NestedParse(pParse,
        "DELETE FROM %Q.%s WHERE tbl_name=%Q and type!='trigger'",
        pDb->zName, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"), pTab->zName);


    if( sqlite3FindTable(db, "sqlite_stat1", db->aDb[iDb].zName) ){
      sqlite3NestedParse(pParse,
        "DELETE FROM %Q.sqlite_stat1 WHERE tbl=%Q", pDb->zName, pTab->zName
      );
    }

    if( !isView && !(((pTab)->tabFlags & 0x10)!=0) ){
      destroyTable(pParse, pTab);
    }




    if( (((pTab)->tabFlags & 0x10)!=0) ){
      sqlite3VdbeAddOp4(v, 126, iDb, 0, 0, pTab->zName, 0);
    }
    sqlite3VdbeAddOp4(v, 101, iDb, 0, 0, pTab->zName, 0);
    sqlite3ChangeCookie(pParse, iDb);
  }
  sqliteViewResetAll(db, iDb);

exit_drop_table:
  sqlite3SrcListDelete(db, pName);
}
# 78885 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3CreateForeignKey(
  Parse *pParse,
  ExprList *pFromCol,
  Token *pTo,
  ExprList *pToCol,
  int flags
){
  sqlite3 *db = pParse->db;

  FKey *pFKey = 0;
  FKey *pNextTo;
  Table *p = pParse->pNewTable;
  int nByte;
  int i;
  int nCol;
  char *z;

  ((void) (0));
  if( p==0 || (pParse->declareVtab) ) goto fk_end;
  if( pFromCol==0 ){
    int iCol = p->nCol-1;
    if( (iCol<0) ) goto fk_end;
    if( pToCol && pToCol->nExpr!=1 ){
      sqlite3ErrorMsg(pParse, "foreign key on %s"
         " should reference only one column of table %T",
         p->aCol[iCol].zName, pTo);
      goto fk_end;
    }
    nCol = 1;
  }else if( pToCol && pToCol->nExpr!=pFromCol->nExpr ){
    sqlite3ErrorMsg(pParse,
        "number of columns in foreign key does not match the number of "
        "columns in the referenced table");
    goto fk_end;
  }else{
    nCol = pFromCol->nExpr;
  }
  nByte = sizeof(*pFKey) + (nCol-1)*sizeof(pFKey->aCol[0]) + pTo->n + 1;
  if( pToCol ){
    for(i=0; i<pToCol->nExpr; i++){
      nByte += sqlite3Strlen30(pToCol->a[i].zName) + 1;
    }
  }
  pFKey = sqlite3DbMallocZero(db, nByte );
  if( pFKey==0 ){
    goto fk_end;
  }
  pFKey->pFrom = p;
  pFKey->pNextFrom = p->pFKey;
  z = (char*)&pFKey->aCol[nCol];
  pFKey->zTo = z;
  memcpy(z, pTo->z, pTo->n);
  z[pTo->n] = 0;
  sqlite3Dequote(z);
  z += pTo->n+1;
  pFKey->nCol = nCol;
  if( pFromCol==0 ){
    pFKey->aCol[0].iFrom = p->nCol-1;
  }else{
    for(i=0; i<nCol; i++){
      int j;
      for(j=0; j<p->nCol; j++){
        if( sqlite3StrICmp(p->aCol[j].zName, pFromCol->a[i].zName)==0 ){
          pFKey->aCol[i].iFrom = j;
          break;
        }
      }
      if( j>=p->nCol ){
        sqlite3ErrorMsg(pParse,
          "unknown column \"%s\" in foreign key definition",
          pFromCol->a[i].zName);
        goto fk_end;
      }
    }
  }
  if( pToCol ){
    for(i=0; i<nCol; i++){
      int n = sqlite3Strlen30(pToCol->a[i].zName);
      pFKey->aCol[i].zCol = z;
      memcpy(z, pToCol->a[i].zName, n);
      z[n] = 0;
      z += n+1;
    }
  }
  pFKey->isDeferred = 0;
  pFKey->aAction[0] = (u8)(flags & 0xff);
  pFKey->aAction[1] = (u8)((flags >> 8 ) & 0xff);

  ((void) (0));
  pNextTo = (FKey *)sqlite3HashInsert(&p->pSchema->fkeyHash,
      pFKey->zTo, sqlite3Strlen30(pFKey->zTo), (void *)pFKey
  );
  if( pNextTo==pFKey ){
    db->mallocFailed = 1;
    goto fk_end;
  }
  if( pNextTo ){
    ((void) (0));
    pFKey->pNextTo = pNextTo;
    pNextTo->pPrevTo = pFKey;
  }



  p->pFKey = pFKey;
  pFKey = 0;

fk_end:
  sqlite3DbFree(db, pFKey);

  sqlite3ExprListDelete(db, pFromCol);
  sqlite3ExprListDelete(db, pToCol);
}
# 79006 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3DeferForeignKey(Parse *pParse, int isDeferred){

  Table *pTab;
  FKey *pFKey;
  if( (pTab = pParse->pNewTable)==0 || (pFKey = pTab->pFKey)==0 ) return;
  ((void) (0));
  pFKey->isDeferred = (u8)isDeferred;

}
# 79027 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3RefillIndex(Parse *pParse, Index *pIndex, int memRootPage){
  Table *pTab = pIndex->pTable;
  int iTab = pParse->nTab++;
  int iIdx = pParse->nTab++;
  int addr1;
  int tnum;
  Vdbe *v;
  KeyInfo *pKey;
  int regIdxKey;
  int regRecord;
  sqlite3 *db = pParse->db;
  int iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);


  if( sqlite3AuthCheck(pParse, 27, pIndex->zName, 0,
      db->aDb[iDb].zName ) ){
    return;
  }



  sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);

  v = sqlite3GetVdbe(pParse);
  if( v==0 ) return;
  if( memRootPage>=0 ){
    tnum = memRootPage;
  }else{
    tnum = pIndex->tnum;
    sqlite3VdbeAddOp2(v, 96, tnum, iDb);
  }
  pKey = sqlite3IndexKeyinfo(pParse, pIndex);
  sqlite3VdbeAddOp4(v, 39, iIdx, tnum, iDb,
                    (char *)pKey, (-16));
  if( memRootPage>=0 ){
    sqlite3VdbeChangeP5(v, 1);
  }
  sqlite3OpenTable(pParse, iTab, iDb, pTab, 38);
  addr1 = sqlite3VdbeAddOp2(v, 65, iTab, 0);
  regRecord = sqlite3GetTempReg(pParse);
  regIdxKey = sqlite3GenerateIndexKey(pParse, pIndex, iTab, regRecord, 1);
  if( pIndex->onError!=0 ){
    const int regRowid = regIdxKey + pIndex->nColumn;
    const int j2 = sqlite3VdbeCurrentAddr(v) + 2;
    void * const pRegKey = ((void*)(long int)(regIdxKey));
# 79082 "ext/sqlite3/libsqlite/sqlite3.c"
    sqlite3VdbeAddOp4(v, 51, iIdx, j2, regRowid, pRegKey, (-14));
    sqlite3HaltConstraint(
        pParse, 2, "indexed columns are not unique", (-2));
  }
  sqlite3VdbeAddOp2(v, 70, iIdx, regRecord);
  sqlite3VdbeChangeP5(v, 0x10);
  sqlite3ReleaseTempReg(pParse, regRecord);
  sqlite3VdbeAddOp2(v, 67, iTab, addr1+1);
  sqlite3VdbeJumpHere(v, addr1);
  sqlite3VdbeAddOp1(v, 43, iTab);
  sqlite3VdbeAddOp1(v, 43, iIdx);
}
# 79111 "ext/sqlite3/libsqlite/sqlite3.c"
static Index *sqlite3CreateIndex(
  Parse *pParse,
  Token *pName1,
  Token *pName2,
  SrcList *pTblName,
  ExprList *pList,
  int onError,
  Token *pStart,
  Token *pEnd,
  int sortOrder,
  int ifNotExist
){
  Index *pRet = 0;
  Table *pTab = 0;
  Index *pIndex = 0;
  char *zName = 0;
  int nName;
  int i, j;
  Token nullId;
  DbFixer sFix;
  int sortOrderMask;
  sqlite3 *db = pParse->db;
  Db *pDb;
  int iDb;
  Token *pName = 0;
  struct ExprList_item *pListItem;
  int nCol;
  int nExtra = 0;
  char *zExtra;

  ((void) (0));
  ((void) (0));
  if( db->mallocFailed || (pParse->declareVtab) ){
    goto exit_create_index;
  }
  if( 0!=sqlite3ReadSchema(pParse) ){
    goto exit_create_index;
  }




  if( pTblName!=0 ){





    ((void) (0));
    iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);
    if( iDb<0 ) goto exit_create_index;






    if( !db->init.busy ){
      pTab = sqlite3SrcListLookup(pParse, pTblName);
      if( pName2->n==0 && pTab && pTab->pSchema==db->aDb[1].pSchema ){
        iDb = 1;
      }
    }


    if( sqlite3FixInit(&sFix, pParse, iDb, "index", pName) &&
        sqlite3FixSrcList(&sFix, pTblName)
    ){


      ((void) (0));
    }
    pTab = sqlite3LocateTable(pParse, 0, pTblName->a[0].zName,
        pTblName->a[0].zDatabase);
    if( !pTab || db->mallocFailed ) goto exit_create_index;
    ((void) (0));
  }else{
    ((void) (0));
    pTab = pParse->pNewTable;
    if( !pTab ) goto exit_create_index;
    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  }
  pDb = &db->aDb[iDb];

  ((void) (0));
  ((void) (0));
  if( sqlite3_strnicmp(pTab->zName, "sqlite_", 7)==0
       && memcmp(&pTab->zName[7],"altertab_",9)!=0 ){
    sqlite3ErrorMsg(pParse, "table %s may not be indexed", pTab->zName);
    goto exit_create_index;
  }

  if( pTab->pSelect ){
    sqlite3ErrorMsg(pParse, "views may not be indexed");
    goto exit_create_index;
  }


  if( (((pTab)->tabFlags & 0x10)!=0) ){
    sqlite3ErrorMsg(pParse, "virtual tables may not be indexed");
    goto exit_create_index;
  }
# 79228 "ext/sqlite3/libsqlite/sqlite3.c"
  if( pName ){
    zName = sqlite3NameFromToken(db, pName);
    if( zName==0 ) goto exit_create_index;
    if( 0!=sqlite3CheckObjectName(pParse, zName) ){
      goto exit_create_index;
    }
    if( !db->init.busy ){
      if( sqlite3FindTable(db, zName, 0)!=0 ){
        sqlite3ErrorMsg(pParse, "there is already a table named %s", zName);
        goto exit_create_index;
      }
    }
    if( sqlite3FindIndex(db, zName, pDb->zName)!=0 ){
      if( !ifNotExist ){
        sqlite3ErrorMsg(pParse, "index %s already exists", zName);
      }else{
        ((void) (0));
        sqlite3CodeVerifySchema(pParse, iDb);
      }
      goto exit_create_index;
    }
  }else{
    int n;
    Index *pLoop;
    for(pLoop=pTab->pIndex, n=1; pLoop; pLoop=pLoop->pNext, n++){}
    zName = sqlite3MPrintf(db, "sqlite_autoindex_%s_%d", pTab->zName, n);
    if( zName==0 ){
      goto exit_create_index;
    }
  }




  {
    const char *zDb = pDb->zName;
    if( sqlite3AuthCheck(pParse, 18, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"), 0, zDb) ){
      goto exit_create_index;
    }
    i = 1;
    if( !0 && iDb==1 ) i = 3;
    if( sqlite3AuthCheck(pParse, i, zName, pTab->zName, zDb) ){
      goto exit_create_index;
    }
  }






  if( pList==0 ){
    nullId.z = pTab->aCol[pTab->nCol-1].zName;
    nullId.n = sqlite3Strlen30((char*)nullId.z);
    pList = sqlite3ExprListAppend(pParse, 0, 0);
    if( pList==0 ) goto exit_create_index;
    sqlite3ExprListSetName(pParse, pList, &nullId, 0);
    pList->a[0].sortOrder = (u8)sortOrder;
  }




  for(i=0; i<pList->nExpr; i++){
    Expr *pExpr = pList->a[i].pExpr;
    if( pExpr ){
      CollSeq *pColl = pExpr->pColl;


      if( (pColl) ){
        nExtra += (1 + sqlite3Strlen30(pColl->zName));
      }
    }
  }




  nName = sqlite3Strlen30(zName);
  nCol = pList->nExpr;
  pIndex = sqlite3DbMallocZero(db,
      sizeof(Index) +
      sizeof(int)*nCol +
      sizeof(int)*(nCol+1) +
      sizeof(char *)*nCol +
      sizeof(u8)*nCol +
      nName + 1 +
      nExtra
  );
  if( db->mallocFailed ){
    goto exit_create_index;
  }
  pIndex->azColl = (char**)(&pIndex[1]);
  pIndex->aiColumn = (int *)(&pIndex->azColl[nCol]);
  pIndex->aiRowEst = (unsigned *)(&pIndex->aiColumn[nCol]);
  pIndex->aSortOrder = (u8 *)(&pIndex->aiRowEst[nCol+1]);
  pIndex->zName = (char *)(&pIndex->aSortOrder[nCol]);
  zExtra = (char *)(&pIndex->zName[nName+1]);
  memcpy(pIndex->zName, zName, nName+1);
  pIndex->pTable = pTab;
  pIndex->nColumn = pList->nExpr;
  pIndex->onError = (u8)onError;
  pIndex->autoIndex = (u8)(pName==0);
  pIndex->pSchema = db->aDb[iDb].pSchema;
  ((void) (0));



  if( pDb->pSchema->file_format>=4 ){
    sortOrderMask = -1;
  }else{
    sortOrderMask = 0;
  }
# 79352 "ext/sqlite3/libsqlite/sqlite3.c"
  for(i=0, pListItem=pList->a; i<pList->nExpr; i++, pListItem++){
    const char *zColName = pListItem->zName;
    Column *pTabCol;
    int requestedSortOrder;
    char *zColl;

    for(j=0, pTabCol=pTab->aCol; j<pTab->nCol; j++, pTabCol++){
      if( sqlite3StrICmp(zColName, pTabCol->zName)==0 ) break;
    }
    if( j>=pTab->nCol ){
      sqlite3ErrorMsg(pParse, "table %s has no column named %s",
        pTab->zName, zColName);
      pParse->checkSchema = 1;
      goto exit_create_index;
    }
    pIndex->aiColumn[i] = j;





    if( pListItem->pExpr && (pListItem->pExpr->pColl) ){
      int nColl;
      zColl = pListItem->pExpr->pColl->zName;
      nColl = sqlite3Strlen30(zColl) + 1;
      ((void) (0));
      memcpy(zExtra, zColl, nColl);
      zColl = zExtra;
      zExtra += nColl;
      nExtra -= nColl;
    }else{
      zColl = pTab->aCol[j].zColl;
      if( !zColl ){
        zColl = db->pDfltColl->zName;
      }
    }
    if( !db->init.busy && !sqlite3LocateCollSeq(pParse, zColl) ){
      goto exit_create_index;
    }
    pIndex->azColl[i] = zColl;
    requestedSortOrder = pListItem->sortOrder & sortOrderMask;
    pIndex->aSortOrder[i] = (u8)requestedSortOrder;
  }
  sqlite3DefaultRowEst(pIndex);

  if( pTab==pParse->pNewTable ){
# 79419 "ext/sqlite3/libsqlite/sqlite3.c"
    Index *pIdx;
    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
      int k;
      ((void) (0));
      ((void) (0));
      ((void) (0));

      if( pIdx->nColumn!=pIndex->nColumn ) continue;
      for(k=0; k<pIdx->nColumn; k++){
        const char *z1;
        const char *z2;
        if( pIdx->aiColumn[k]!=pIndex->aiColumn[k] ) break;
        z1 = pIdx->azColl[k];
        z2 = pIndex->azColl[k];
        if( z1!=z2 && sqlite3StrICmp(z1, z2) ) break;
      }
      if( k==pIdx->nColumn ){
        if( pIdx->onError!=pIndex->onError ){







          if( !(pIdx->onError==99 || pIndex->onError==99) ){
            sqlite3ErrorMsg(pParse,
                "conflicting ON CONFLICT clauses specified", 0);
          }
          if( pIdx->onError==99 ){
            pIdx->onError = pIndex->onError;
          }
        }
        goto exit_create_index;
      }
    }
  }




  if( db->init.busy ){
    Index *p;
    ((void) (0));
    p = sqlite3HashInsert(&pIndex->pSchema->idxHash,
                          pIndex->zName, sqlite3Strlen30(pIndex->zName),
                          pIndex);
    if( p ){
      ((void) (0));
      db->mallocFailed = 1;
      goto exit_create_index;
    }
    db->flags |= 0x00000200;
    if( pTblName!=0 ){
      pIndex->tnum = db->init.newTnum;
    }
  }
# 79492 "ext/sqlite3/libsqlite/sqlite3.c"
  else{
    Vdbe *v;
    char *zStmt;
    int iMem = ++pParse->nMem;

    v = sqlite3GetVdbe(pParse);
    if( v==0 ) goto exit_create_index;




    sqlite3BeginWriteOperation(pParse, 1, iDb);
    sqlite3VdbeAddOp2(v, 97, iDb, iMem);




    if( pStart ){
      ((void) (0));

      zStmt = sqlite3MPrintf(db, "CREATE%s INDEX %.*s",
        onError==0 ? "" : " UNIQUE",
        pEnd->z - pName->z + 1,
        pName->z);
    }else{


      zStmt = 0;
    }



    sqlite3NestedParse(pParse,
        "INSERT INTO %Q.%s VALUES('index',%Q,%Q,#%d,%Q);",
        db->aDb[iDb].zName, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"),
        pIndex->zName,
        pTab->zName,
        iMem,
        zStmt
    );
    sqlite3DbFree(db, zStmt);




    if( pTblName ){
      sqlite3RefillIndex(pParse, pIndex, iMem);
      sqlite3ChangeCookie(pParse, iDb);
      sqlite3VdbeAddOp4(v, 99, iDb, 0, 0,
         sqlite3MPrintf(db, "name='%q' AND type='index'", pIndex->zName),
         (-1));
      sqlite3VdbeAddOp1(v, 122, 0);
    }
  }







  if( db->init.busy || pTblName==0 ){
    if( onError!=5 || pTab->pIndex==0
         || pTab->pIndex->onError==5){
      pIndex->pNext = pTab->pIndex;
      pTab->pIndex = pIndex;
    }else{
      Index *pOther = pTab->pIndex;
      while( pOther->pNext && pOther->pNext->onError!=5 ){
        pOther = pOther->pNext;
      }
      pIndex->pNext = pOther->pNext;
      pOther->pNext = pIndex;
    }
    pRet = pIndex;
    pIndex = 0;
  }


exit_create_index:
  if( pIndex ){
    sqlite3DbFree(db, pIndex->zColAff);
    sqlite3DbFree(db, pIndex);
  }
  sqlite3ExprListDelete(db, pList);
  sqlite3SrcListDelete(db, pTblName);
  sqlite3DbFree(db, zName);
  return pRet;
}
# 79600 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3DefaultRowEst(Index *pIdx){
  unsigned *a = pIdx->aiRowEst;
  int i;
  unsigned n;
  ((void) (0));
  a[0] = pIdx->pTable->nRowEst;
  if( a[0]<10 ) a[0] = 10;
  n = 10;
  for(i=1; i<=pIdx->nColumn; i++){
    a[i] = n;
    if( n>5 ) n--;
  }
  if( pIdx->onError!=0 ){
    a[pIdx->nColumn] = 1;
  }
}





static void sqlite3DropIndex(Parse *pParse, SrcList *pName, int ifExists){
  Index *pIndex;
  Vdbe *v;
  sqlite3 *db = pParse->db;
  int iDb;

  ((void) (0));
  if( db->mallocFailed ){
    goto exit_drop_index;
  }
  ((void) (0));
  if( 0!=sqlite3ReadSchema(pParse) ){
    goto exit_drop_index;
  }
  pIndex = sqlite3FindIndex(db, pName->a[0].zName, pName->a[0].zDatabase);
  if( pIndex==0 ){
    if( !ifExists ){
      sqlite3ErrorMsg(pParse, "no such index: %S", pName, 0);
    }else{
      sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);
    }
    pParse->checkSchema = 1;
    goto exit_drop_index;
  }
  if( pIndex->autoIndex ){
    sqlite3ErrorMsg(pParse, "index associated with UNIQUE "
      "or PRIMARY KEY constraint cannot be dropped", 0);
    goto exit_drop_index;
  }
  iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);

  {
    int code = 10;
    Table *pTab = pIndex->pTable;
    const char *zDb = db->aDb[iDb].zName;
    const char *zTab = ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master");
    if( sqlite3AuthCheck(pParse, 9, zTab, 0, zDb) ){
      goto exit_drop_index;
    }
    if( !0 && iDb ) code = 12;
    if( sqlite3AuthCheck(pParse, code, pIndex->zName, pTab->zName, zDb) ){
      goto exit_drop_index;
    }
  }



  v = sqlite3GetVdbe(pParse);
  if( v ){
    sqlite3BeginWriteOperation(pParse, 1, iDb);
    sqlite3NestedParse(pParse,
       "DELETE FROM %Q.%s WHERE name=%Q AND type='index'",
       db->aDb[iDb].zName, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"),
       pIndex->zName
    );
    if( sqlite3FindTable(db, "sqlite_stat1", db->aDb[iDb].zName) ){
      sqlite3NestedParse(pParse,
        "DELETE FROM %Q.sqlite_stat1 WHERE idx=%Q",
        db->aDb[iDb].zName, pIndex->zName
      );
    }
    sqlite3ChangeCookie(pParse, iDb);
    destroyRootPage(pParse, pIndex->tnum, iDb);
    sqlite3VdbeAddOp4(v, 102, iDb, 0, 0, pIndex->zName, 0);
  }

exit_drop_index:
  sqlite3SrcListDelete(db, pName);
}
# 79706 "ext/sqlite3/libsqlite/sqlite3.c"
static void *sqlite3ArrayAllocate(
  sqlite3 *db,
  void *pArray,
  int szEntry,
  int initSize,
  int *pnEntry,
  int *pnAlloc,
  int *pIdx
){
  char *z;
  if( *pnEntry >= *pnAlloc ){
    void *pNew;
    int newSize;
    newSize = (*pnAlloc)*2 + initSize;
    pNew = sqlite3DbRealloc(db, pArray, newSize*szEntry);
    if( pNew==0 ){
      *pIdx = -1;
      return pArray;
    }
    *pnAlloc = sqlite3DbMallocSize(db, pNew)/szEntry;
    pArray = pNew;
  }
  z = (char*)pArray;
  memset(&z[*pnEntry * szEntry], 0, szEntry);
  *pIdx = *pnEntry;
  ++*pnEntry;
  return pArray;
}







static IdList *sqlite3IdListAppend(sqlite3 *db, IdList *pList, Token *pToken){
  int i;
  if( pList==0 ){
    pList = sqlite3DbMallocZero(db, sizeof(IdList) );
    if( pList==0 ) return 0;
    pList->nAlloc = 0;
  }
  pList->a = sqlite3ArrayAllocate(
      db,
      pList->a,
      sizeof(pList->a[0]),
      5,
      &pList->nId,
      &pList->nAlloc,
      &i
  );
  if( i<0 ){
    sqlite3IdListDelete(db, pList);
    return 0;
  }
  pList->a[i].zName = sqlite3NameFromToken(db, pToken);
  return pList;
}




static void sqlite3IdListDelete(sqlite3 *db, IdList *pList){
  int i;
  if( pList==0 ) return;
  for(i=0; i<pList->nId; i++){
    sqlite3DbFree(db, pList->a[i].zName);
  }
  sqlite3DbFree(db, pList->a);
  sqlite3DbFree(db, pList);
}





static int sqlite3IdListIndex(IdList *pList, const char *zName){
  int i;
  if( pList==0 ) return -1;
  for(i=0; i<pList->nId; i++){
    if( sqlite3StrICmp(pList->a[i].zName, zName)==0 ) return i;
  }
  return -1;
}
# 79810 "ext/sqlite3/libsqlite/sqlite3.c"
static SrcList *sqlite3SrcListEnlarge(
  sqlite3 *db,
  SrcList *pSrc,
  int nExtra,
  int iStart
){
  int i;


  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));


  if( pSrc->nSrc+nExtra>pSrc->nAlloc ){
    SrcList *pNew;
    int nAlloc = pSrc->nSrc+nExtra;
    int nGot;
    pNew = sqlite3DbRealloc(db, pSrc,
               sizeof(*pSrc) + (nAlloc-1)*sizeof(pSrc->a[0]) );
    if( pNew==0 ){
      ((void) (0));
      return pSrc;
    }
    pSrc = pNew;
    nGot = (sqlite3DbMallocSize(db, pNew) - sizeof(*pSrc))/sizeof(pSrc->a[0])+1;
    pSrc->nAlloc = (u16)nGot;
  }



  for(i=pSrc->nSrc-1; i>=iStart; i--){
    pSrc->a[i+nExtra] = pSrc->a[i];
  }
  pSrc->nSrc += (i16)nExtra;


  memset(&pSrc->a[iStart], 0, sizeof(pSrc->a[0])*nExtra);
  for(i=iStart; i<iStart+nExtra; i++){
    pSrc->a[i].iCursor = -1;
  }


  return pSrc;
}
# 79892 "ext/sqlite3/libsqlite/sqlite3.c"
static SrcList *sqlite3SrcListAppend(
  sqlite3 *db,
  SrcList *pList,
  Token *pTable,
  Token *pDatabase
){
  struct SrcList_item *pItem;
  ((void) (0));
  if( pList==0 ){
    pList = sqlite3DbMallocZero(db, sizeof(SrcList) );
    if( pList==0 ) return 0;
    pList->nAlloc = 1;
  }
  pList = sqlite3SrcListEnlarge(db, pList, 1, pList->nSrc);
  if( db->mallocFailed ){
    sqlite3SrcListDelete(db, pList);
    return 0;
  }
  pItem = &pList->a[pList->nSrc-1];
  if( pDatabase && pDatabase->z==0 ){
    pDatabase = 0;
  }
  if( pDatabase ){
    Token *pTemp = pDatabase;
    pDatabase = pTable;
    pTable = pTemp;
  }
  pItem->zName = sqlite3NameFromToken(db, pTable);
  pItem->zDatabase = sqlite3NameFromToken(db, pDatabase);
  return pList;
}




static void sqlite3SrcListAssignCursors(Parse *pParse, SrcList *pList){
  int i;
  struct SrcList_item *pItem;
  ((void) (0));
  if( pList ){
    for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){
      if( pItem->iCursor>=0 ) break;
      pItem->iCursor = pParse->nTab++;
      if( pItem->pSelect ){
        sqlite3SrcListAssignCursors(pParse, pItem->pSelect->pSrc);
      }
    }
  }
}




static void sqlite3SrcListDelete(sqlite3 *db, SrcList *pList){
  int i;
  struct SrcList_item *pItem;
  if( pList==0 ) return;
  for(pItem=pList->a, i=0; i<pList->nSrc; i++, pItem++){
    sqlite3DbFree(db, pItem->zDatabase);
    sqlite3DbFree(db, pItem->zName);
    sqlite3DbFree(db, pItem->zAlias);
    sqlite3DbFree(db, pItem->zIndex);
    sqlite3DeleteTable(db, pItem->pTab);
    sqlite3SelectDelete(db, pItem->pSelect);
    sqlite3ExprDelete(db, pItem->pOn);
    sqlite3IdListDelete(db, pItem->pUsing);
  }
  sqlite3DbFree(db, pList);
}
# 79978 "ext/sqlite3/libsqlite/sqlite3.c"
static SrcList *sqlite3SrcListAppendFromTerm(
  Parse *pParse,
  SrcList *p,
  Token *pTable,
  Token *pDatabase,
  Token *pAlias,
  Select *pSubquery,
  Expr *pOn,
  IdList *pUsing
){
  struct SrcList_item *pItem;
  sqlite3 *db = pParse->db;
  if( !p && (pOn || pUsing) ){
    sqlite3ErrorMsg(pParse, "a JOIN clause is required before %s",
      (pOn ? "ON" : "USING")
    );
    goto append_from_error;
  }
  p = sqlite3SrcListAppend(db, p, pTable, pDatabase);
  if( p==0 || (p->nSrc==0) ){
    goto append_from_error;
  }
  pItem = &p->a[p->nSrc-1];
  ((void) (0));
  if( pAlias->n ){
    pItem->zAlias = sqlite3NameFromToken(db, pAlias);
  }
  pItem->pSelect = pSubquery;
  pItem->pOn = pOn;
  pItem->pUsing = pUsing;
  return p;

 append_from_error:
  ((void) (0));
  sqlite3ExprDelete(db, pOn);
  sqlite3IdListDelete(db, pUsing);
  sqlite3SelectDelete(db, pSubquery);
  return 0;
}





static void sqlite3SrcListIndexedBy(Parse *pParse, SrcList *p, Token *pIndexedBy){
  ((void) (0));
  if( p && (p->nSrc>0) ){
    struct SrcList_item *pItem = &p->a[p->nSrc-1];
    ((void) (0));
    if( pIndexedBy->n==1 && !pIndexedBy->z ){


      pItem->notIndexed = 1;
    }else{
      pItem->zIndex = sqlite3NameFromToken(pParse->db, pIndexedBy);
    }
  }
}
# 80052 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3SrcListShiftJoinType(SrcList *p){
  if( p && p->a ){
    int i;
    for(i=p->nSrc-1; i>0; i--){
      p->a[i].jointype = p->a[i-1].jointype;
    }
    p->a[0].jointype = 0;
  }
}




static void sqlite3BeginTransaction(Parse *pParse, int type){
  sqlite3 *db;
  Vdbe *v;
  int i;

  ((void) (0));
  db = pParse->db;
  ((void) (0));

  if( sqlite3AuthCheck(pParse, 22, "BEGIN", 0, 0) ){
    return;
  }
  v = sqlite3GetVdbe(pParse);
  if( !v ) return;
  if( type!=7 ){
    for(i=0; i<db->nDb; i++){
      sqlite3VdbeAddOp2(v, 34, i, (type==9)+1);
      sqlite3VdbeUsesBtree(v, i);
    }
  }
  sqlite3VdbeAddOp2(v, 33, 0, 0);
}




static void sqlite3CommitTransaction(Parse *pParse){
  sqlite3 *db;
  Vdbe *v;

  ((void) (0));
  db = pParse->db;
  ((void) (0));

  if( sqlite3AuthCheck(pParse, 22, "COMMIT", 0, 0) ){
    return;
  }
  v = sqlite3GetVdbe(pParse);
  if( v ){
    sqlite3VdbeAddOp2(v, 33, 1, 0);
  }
}




static void sqlite3RollbackTransaction(Parse *pParse){
  sqlite3 *db;
  Vdbe *v;

  ((void) (0));
  db = pParse->db;
  ((void) (0));

  if( sqlite3AuthCheck(pParse, 22, "ROLLBACK", 0, 0) ){
    return;
  }
  v = sqlite3GetVdbe(pParse);
  if( v ){
    sqlite3VdbeAddOp2(v, 33, 1, 1);
  }
}





static void sqlite3Savepoint(Parse *pParse, int op, Token *pName){
  char *zName = sqlite3NameFromToken(pParse->db, pName);
  if( zName ){
    Vdbe *v = sqlite3GetVdbe(pParse);

    static const char * const az[] = { "BEGIN", "RELEASE", "ROLLBACK" };
    ((void) (0));

    if( !v || sqlite3AuthCheck(pParse, 32, az[op], zName, 0) ){
      sqlite3DbFree(pParse->db, zName);
      return;
    }
    sqlite3VdbeAddOp4(v, 32, op, 0, 0, zName, (-1));
  }
}





static int sqlite3OpenTempDatabase(Parse *pParse){
  sqlite3 *db = pParse->db;
  if( db->aDb[1].pBt==0 && !pParse->explain ){
    int rc;
    Btree *pBt;
    static const int flags =
          0x00000002 |
          0x00000004 |
          0x00000010 |
          0x00000008 |
          0x00000200;

    rc = sqlite3BtreeOpen(0, db, &pBt, 0, flags);
    if( rc!=0 ){
      sqlite3ErrorMsg(pParse, "unable to open a temporary database "
        "file for storing temporary tables");
      pParse->rc = rc;
      return 1;
    }
    db->aDb[1].pBt = pBt;
    ((void) (0));
    if( 7==sqlite3BtreeSetPageSize(pBt, db->nextPagesize, -1, 0) ){
      db->mallocFailed = 1;
      return 1;
    }
  }
  return 0;
}
# 80203 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3CodeVerifySchema(Parse *pParse, int iDb){
  Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));

  if( pToplevel->cookieGoto==0 ){
    Vdbe *v = sqlite3GetVdbe(pToplevel);
    if( v==0 ) return;
    pToplevel->cookieGoto = sqlite3VdbeAddOp2(v, 1, 0, 0)+1;
  }
  if( iDb>=0 ){
    sqlite3 *db = pToplevel->db;
    yDbMask mask;

    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    mask = ((yDbMask)1)<<iDb;
    if( (pToplevel->cookieMask & mask)==0 ){
      pToplevel->cookieMask |= mask;
      pToplevel->cookieValue[iDb] = db->aDb[iDb].pSchema->schema_cookie;
      if( !0 && iDb==1 ){
        sqlite3OpenTempDatabase(pToplevel);
      }
    }
  }
}





static void sqlite3CodeVerifyNamedSchema(Parse *pParse, const char *zDb){
  sqlite3 *db = pParse->db;
  int i;
  for(i=0; i<db->nDb; i++){
    Db *pDb = &db->aDb[i];
    if( pDb->pBt && (!zDb || 0==sqlite3StrICmp(zDb, pDb->zName)) ){
      sqlite3CodeVerifySchema(pParse, i);
    }
  }
}
# 80258 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3BeginWriteOperation(Parse *pParse, int setStatement, int iDb){
  Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  sqlite3CodeVerifySchema(pParse, iDb);
  pToplevel->writeMask |= ((yDbMask)1)<<iDb;
  pToplevel->isMultiWrite |= setStatement;
}
# 80272 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3MultiWrite(Parse *pParse){
  Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  pToplevel->isMultiWrite = 1;
}
# 80293 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3MayAbort(Parse *pParse){
  Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  pToplevel->mayAbort = 1;
}






static void sqlite3HaltConstraint(Parse *pParse, int onError, char *p4, int p4type){
  Vdbe *v = sqlite3GetVdbe(pParse);
  if( onError==2 ){
    sqlite3MayAbort(pParse);
  }
  sqlite3VdbeAddOp4(v, 6, 19, onError, 0, p4, p4type);
}






static int collationMatch(const char *zColl, Index *pIndex){
  int i;
  ((void) (0));
  for(i=0; i<pIndex->nColumn; i++){
    const char *z = pIndex->azColl[i];
    ((void) (0));
    if( 0==sqlite3StrICmp(z, zColl) ){
      return 1;
    }
  }
  return 0;
}







static void reindexTable(Parse *pParse, Table *pTab, char const *zColl){
  Index *pIndex;

  for(pIndex=pTab->pIndex; pIndex; pIndex=pIndex->pNext){
    if( zColl==0 || collationMatch(zColl, pIndex) ){
      int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
      sqlite3BeginWriteOperation(pParse, 0, iDb);
      sqlite3RefillIndex(pParse, pIndex, -1);
    }
  }
}
# 80354 "ext/sqlite3/libsqlite/sqlite3.c"
static void reindexDatabases(Parse *pParse, char const *zColl){
  Db *pDb;
  int iDb;
  sqlite3 *db = pParse->db;
  HashElem *k;
  Table *pTab;

  ((void) (0));
  for(iDb=0, pDb=db->aDb; iDb<db->nDb; iDb++, pDb++){
    ((void) (0));
    for(k=((&pDb->pSchema->tblHash)->first); k; k=((k)->next)){
      pTab = (Table*)((k)->data);
      reindexTable(pParse, pTab, zColl);
    }
  }
}
# 80386 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3Reindex(Parse *pParse, Token *pName1, Token *pName2){
  CollSeq *pColl;
  char *z;
  const char *zDb;
  Table *pTab;
  Index *pIndex;
  int iDb;
  sqlite3 *db = pParse->db;
  Token *pObjName;



  if( 0!=sqlite3ReadSchema(pParse) ){
    return;
  }

  if( pName1==0 ){
    reindexDatabases(pParse, 0);
    return;
  }else if( (pName2==0) || pName2->z==0 ){
    char *zColl;
    ((void) (0));
    zColl = sqlite3NameFromToken(pParse->db, pName1);
    if( !zColl ) return;
    pColl = sqlite3FindCollSeq(db, ((db)->aDb[0].pSchema->enc), zColl, 0);
    if( pColl ){
      reindexDatabases(pParse, zColl);
      sqlite3DbFree(db, zColl);
      return;
    }
    sqlite3DbFree(db, zColl);
  }
  iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pObjName);
  if( iDb<0 ) return;
  z = sqlite3NameFromToken(db, pObjName);
  if( z==0 ) return;
  zDb = db->aDb[iDb].zName;
  pTab = sqlite3FindTable(db, z, zDb);
  if( pTab ){
    reindexTable(pParse, pTab, 0);
    sqlite3DbFree(db, z);
    return;
  }
  pIndex = sqlite3FindIndex(db, z, zDb);
  sqlite3DbFree(db, z);
  if( pIndex ){
    sqlite3BeginWriteOperation(pParse, 0, iDb);
    sqlite3RefillIndex(pParse, pIndex, -1);
    return;
  }
  sqlite3ErrorMsg(pParse, "unable to identify the object to be reindexed");
}
# 80450 "ext/sqlite3/libsqlite/sqlite3.c"
static KeyInfo *sqlite3IndexKeyinfo(Parse *pParse, Index *pIdx){
  int i;
  int nCol = pIdx->nColumn;
  int nBytes = sizeof(KeyInfo) + (nCol-1)*sizeof(CollSeq*) + nCol;
  sqlite3 *db = pParse->db;
  KeyInfo *pKey = (KeyInfo *)sqlite3DbMallocZero(db, nBytes);

  if( pKey ){
    pKey->db = pParse->db;
    pKey->aSortOrder = (u8 *)&(pKey->aColl[nCol]);
    ((void) (0));
    for(i=0; i<nCol; i++){
      char *zColl = pIdx->azColl[i];
      ((void) (0));
      pKey->aColl[i] = sqlite3LocateCollSeq(pParse, zColl);
      pKey->aSortOrder[i] = pIdx->aSortOrder[i];
    }
    pKey->nField = (u16)nCol;
  }

  if( pParse->nErr ){
    sqlite3DbFree(db, pKey);
    pKey = 0;
  }
  return pKey;
}
# 80500 "ext/sqlite3/libsqlite/sqlite3.c"
static void callCollNeeded(sqlite3 *db, int enc, const char *zName){
  ((void) (0));
  if( db->xCollNeeded ){
    char *zExternal = sqlite3DbStrDup(db, zName);
    if( !zExternal ) return;
    db->xCollNeeded(db->pCollNeededArg, db, enc, zExternal);
    sqlite3DbFree(db, zExternal);
  }

  if( db->xCollNeeded16 ){
    char const *zExternal;
    sqlite3_value *pTmp = sqlite3ValueNew(db);
    sqlite3ValueSetStr(pTmp, -1, zName, 1, ((sqlite3_destructor_type)0));
    zExternal = sqlite3ValueText(pTmp, 2);
    if( zExternal ){
      db->xCollNeeded16(db->pCollNeededArg, db, (int)((db)->aDb[0].pSchema->enc), zExternal);
    }
    sqlite3ValueFree(pTmp);
  }

}
# 80529 "ext/sqlite3/libsqlite/sqlite3.c"
static int synthCollSeq(sqlite3 *db, CollSeq *pColl){
  CollSeq *pColl2;
  char *z = pColl->zName;
  int i;
  static const u8 aEnc[] = { 3, 2, 1 };
  for(i=0; i<3; i++){
    pColl2 = sqlite3FindCollSeq(db, aEnc[i], z, 0);
    if( pColl2->xCmp!=0 ){
      memcpy(pColl, pColl2, sizeof(CollSeq));
      pColl->xDel = 0;
      return 0;
    }
  }
  return 1;
}
# 80559 "ext/sqlite3/libsqlite/sqlite3.c"
static CollSeq *sqlite3GetCollSeq(
  sqlite3* db,
  u8 enc,
  CollSeq *pColl,
  const char *zName
){
  CollSeq *p;

  p = pColl;
  if( !p ){
    p = sqlite3FindCollSeq(db, enc, zName, 0);
  }
  if( !p || !p->xCmp ){



    callCollNeeded(db, enc, zName);
    p = sqlite3FindCollSeq(db, enc, zName, 0);
  }
  if( p && !p->xCmp && synthCollSeq(db, p) ){
    p = 0;
  }
  ((void) (0));
  return p;
}
# 80596 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3CheckCollSeq(Parse *pParse, CollSeq *pColl){
  if( pColl ){
    const char *zName = pColl->zName;
    sqlite3 *db = pParse->db;
    CollSeq *p = sqlite3GetCollSeq(db, ((db)->aDb[0].pSchema->enc), pColl, zName);
    if( !p ){
      sqlite3ErrorMsg(pParse, "no such collation sequence: %s", zName);
      pParse->nErr++;
      return 1;
    }
    ((void) (0));
  }
  return 0;
}
# 80626 "ext/sqlite3/libsqlite/sqlite3.c"
static CollSeq *findCollSeqEntry(
  sqlite3 *db,
  const char *zName,
  int create
){
  CollSeq *pColl;
  int nName = sqlite3Strlen30(zName);
  pColl = sqlite3HashFind(&db->aCollSeq, zName, nName);

  if( 0==pColl && create ){
    pColl = sqlite3DbMallocZero(db, 3*sizeof(*pColl) + nName + 1 );
    if( pColl ){
      CollSeq *pDel = 0;
      pColl[0].zName = (char*)&pColl[3];
      pColl[0].enc = 1;
      pColl[1].zName = (char*)&pColl[3];
      pColl[1].enc = 2;
      pColl[2].zName = (char*)&pColl[3];
      pColl[2].enc = 3;
      memcpy(pColl[0].zName, zName, nName);
      pColl[0].zName[nName] = 0;
      pDel = sqlite3HashInsert(&db->aCollSeq, pColl[0].zName, nName, pColl);





      ((void) (0));
      if( pDel!=0 ){
        db->mallocFailed = 1;
        sqlite3DbFree(db, pDel);
        pColl = 0;
      }
    }
  }
  return pColl;
}
# 80679 "ext/sqlite3/libsqlite/sqlite3.c"
static CollSeq *sqlite3FindCollSeq(
  sqlite3 *db,
  u8 enc,
  const char *zName,
  int create
){
  CollSeq *pColl;
  if( zName ){
    pColl = findCollSeqEntry(db, zName, create);
  }else{
    pColl = db->pDfltColl;
  }
  ((void) (0));
  ((void) (0));
  if( pColl ) pColl += enc-1;
  return pColl;
}
# 80718 "ext/sqlite3/libsqlite/sqlite3.c"
static int matchQuality(FuncDef *p, int nArg, u8 enc){
  int match = 0;
  if( p->nArg==-1 || p->nArg==nArg
   || (nArg==-1 && (p->xFunc!=0 || p->xStep!=0))
  ){
    match = 1;
    if( p->nArg==nArg || nArg==-1 ){
      match = 4;
    }
    if( enc==p->iPrefEnc ){
      match += 2;
    }
    else if( (enc==2 && p->iPrefEnc==3) ||
             (enc==3 && p->iPrefEnc==2) ){
      match += 1;
    }
  }
  return match;
}





static FuncDef *functionSearch(
  FuncDefHash *pHash,
  int h,
  const char *zFunc,
  int nFunc
){
  FuncDef *p;
  for(p=pHash->a[h]; p; p=p->pHash){
    if( sqlite3_strnicmp(p->zName, zFunc, nFunc)==0 && p->zName[nFunc]==0 ){
      return p;
    }
  }
  return 0;
}




static void sqlite3FuncDefInsert(
  FuncDefHash *pHash,
  FuncDef *pDef
){
  FuncDef *pOther;
  int nName = sqlite3Strlen30(pDef->zName);
  u8 c1 = (u8)pDef->zName[0];
  int h = (sqlite3UpperToLower[c1] + nName) % ((int)(sizeof(pHash->a)/sizeof(pHash->a[0])));
  pOther = functionSearch(pHash, h, pDef->zName, nName);
  if( pOther ){
    ((void) (0));
    pDef->pNext = pOther->pNext;
    pOther->pNext = pDef;
  }else{
    pDef->pNext = 0;
    pDef->pHash = pHash->a[h];
    pHash->a[h] = pDef;
  }
}
# 80802 "ext/sqlite3/libsqlite/sqlite3.c"
static FuncDef *sqlite3FindFunction(
  sqlite3 *db,
  const char *zName,
  int nName,
  int nArg,
  u8 enc,
  int createFlag
){
  FuncDef *p;
  FuncDef *pBest = 0;
  int bestScore = 0;
  int h;


  ((void) (0));
  h = (sqlite3UpperToLower[(u8)zName[0]] + nName) % ((int)(sizeof(db->aFunc.a)/sizeof(db->aFunc.a[0])));



  p = functionSearch(&db->aFunc, h, zName, nName);
  while( p ){
    int score = matchQuality(p, nArg, enc);
    if( score>bestScore ){
      pBest = p;
      bestScore = score;
    }
    p = p->pNext;
  }
# 80843 "ext/sqlite3/libsqlite/sqlite3.c"
  if( !createFlag && (pBest==0 || (db->flags & 0x10000000)!=0) ){
    FuncDefHash *pHash = &sqlite3GlobalFunctions;
    bestScore = 0;
    p = functionSearch(pHash, h, zName, nName);
    while( p ){
      int score = matchQuality(p, nArg, enc);
      if( score>bestScore ){
        pBest = p;
        bestScore = score;
      }
      p = p->pNext;
    }
  }





  if( createFlag && (bestScore<6 || pBest->nArg!=nArg) &&
      (pBest = sqlite3DbMallocZero(db, sizeof(*pBest)+nName+1))!=0 ){
    pBest->zName = (char *)&pBest[1];
    pBest->nArg = (u16)nArg;
    pBest->iPrefEnc = enc;
    memcpy(pBest->zName, zName, nName);
    pBest->zName[nName] = 0;
    sqlite3FuncDefInsert(&db->aFunc, pBest);
  }

  if( pBest && (pBest->xStep || pBest->xFunc || createFlag) ){
    return pBest;
  }
  return 0;
}
# 80885 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3SchemaClear(void *p){
  Hash temp1;
  Hash temp2;
  HashElem *pElem;
  Schema *pSchema = (Schema *)p;

  temp1 = pSchema->tblHash;
  temp2 = pSchema->trigHash;
  sqlite3HashInit(&pSchema->trigHash);
  sqlite3HashClear(&pSchema->idxHash);
  for(pElem=((&temp2)->first); pElem; pElem=((pElem)->next)){
    sqlite3DeleteTrigger(0, (Trigger*)((pElem)->data));
  }
  sqlite3HashClear(&temp2);
  sqlite3HashInit(&pSchema->tblHash);
  for(pElem=((&temp1)->first); pElem; pElem=((pElem)->next)){
    Table *pTab = ((pElem)->data);
    sqlite3DeleteTable(0, pTab);
  }
  sqlite3HashClear(&temp1);
  sqlite3HashClear(&pSchema->fkeyHash);
  pSchema->pSeqTab = 0;
  if( pSchema->flags & 0x0001 ){
    pSchema->iGeneration++;
    pSchema->flags &= ~0x0001;
  }
}





static Schema *sqlite3SchemaGet(sqlite3 *db, Btree *pBt){
  Schema * p;
  if( pBt ){
    p = (Schema *)sqlite3BtreeSchema(pBt, sizeof(Schema), sqlite3SchemaClear);
  }else{
    p = (Schema *)sqlite3DbMallocZero(0, sizeof(Schema));
  }
  if( !p ){
    db->mallocFailed = 1;
  }else if ( 0==p->file_format ){
    sqlite3HashInit(&p->tblHash);
    sqlite3HashInit(&p->idxHash);
    sqlite3HashInit(&p->trigHash);
    sqlite3HashInit(&p->fkeyHash);
    p->enc = 1;
  }
  return p;
}
# 80967 "ext/sqlite3/libsqlite/sqlite3.c"
static Table *sqlite3SrcListLookup(Parse *pParse, SrcList *pSrc){
  struct SrcList_item *pItem = pSrc->a;
  Table *pTab;
  ((void) (0));
  pTab = sqlite3LocateTable(pParse, 0, pItem->zName, pItem->zDatabase);
  sqlite3DeleteTable(pParse->db, pItem->pTab);
  pItem->pTab = pTab;
  if( pTab ){
    pTab->nRef++;
  }
  if( sqlite3IndexedByLookup(pParse, pItem) ){
    pTab = 0;
  }
  return pTab;
}






static int sqlite3IsReadOnly(Parse *pParse, Table *pTab, int viewOk){
# 80999 "ext/sqlite3/libsqlite/sqlite3.c"
  if( ( (((pTab)->tabFlags & 0x10)!=0)
     && sqlite3GetVTable(pParse->db, pTab)->pMod->pModule->xUpdate==0 )
   || ( (pTab->tabFlags & 0x01)!=0
     && (pParse->db->flags & 0x00010000)==0
     && pParse->nested==0 )
  ){
    sqlite3ErrorMsg(pParse, "table %s may not be modified", pTab->zName);
    return 1;
  }


  if( !viewOk && pTab->pSelect ){
    sqlite3ErrorMsg(pParse,"cannot modify %s because it is a view",pTab->zName);
    return 1;
  }

  return 0;
}
# 81025 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3MaterializeView(
  Parse *pParse,
  Table *pView,
  Expr *pWhere,
  int iCur
){
  SelectDest dest;
  Select *pDup;
  sqlite3 *db = pParse->db;

  pDup = sqlite3SelectDup(db, pView->pSelect, 0);
  if( pWhere ){
    SrcList *pFrom;

    pWhere = sqlite3ExprDup(db, pWhere, 0);
    pFrom = sqlite3SrcListAppend(db, 0, 0, 0);
    if( pFrom ){
      ((void) (0));
      pFrom->a[0].zAlias = sqlite3DbStrDup(db, pView->zName);
      pFrom->a[0].pSelect = pDup;
      ((void) (0));
      ((void) (0));
    }else{
      sqlite3SelectDelete(db, pDup);
    }
    pDup = sqlite3SelectNew(pParse, 0, pFrom, pWhere, 0, 0, 0, 0, 0, 0);
  }
  sqlite3SelectDestInit(&dest, 9, iCur);
  sqlite3Select(pParse, pDup, &dest);
  sqlite3SelectDelete(db, pDup);
}
# 81159 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3DeleteFrom(
  Parse *pParse,
  SrcList *pTabList,
  Expr *pWhere
){
  Vdbe *v;
  Table *pTab;
  const char *zDb;
  int end, addr = 0;
  int i;
  WhereInfo *pWInfo;
  Index *pIdx;
  int iCur;
  sqlite3 *db;
  AuthContext sContext;
  NameContext sNC;
  int iDb;
  int memCnt = -1;
  int rcauth;


  int isView;
  Trigger *pTrigger;


  memset(&sContext, 0, sizeof(sContext));
  db = pParse->db;
  if( pParse->nErr || db->mallocFailed ){
    goto delete_from_cleanup;
  }
  ((void) (0));






  pTab = sqlite3SrcListLookup(pParse, pTabList);
  if( pTab==0 ) goto delete_from_cleanup;





  pTrigger = sqlite3TriggersExist(pParse, pTab, 106, 0, 0);
  isView = pTab->pSelect!=0;
# 81216 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto delete_from_cleanup;
  }

  if( sqlite3IsReadOnly(pParse, pTab, (pTrigger?1:0)) ){
    goto delete_from_cleanup;
  }
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  ((void) (0));
  zDb = db->aDb[iDb].zName;
  rcauth = sqlite3AuthCheck(pParse, 9, pTab->zName, 0, zDb);
  ((void) (0));
  if( rcauth==1 ){
    goto delete_from_cleanup;
  }
  ((void) (0));



  ((void) (0));
  iCur = pTabList->a[0].iCursor = pParse->nTab++;
  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
    pParse->nTab++;
  }



  if( isView ){
    sqlite3AuthContextPush(pParse, &sContext, pTab->zName);
  }



  v = sqlite3GetVdbe(pParse);
  if( v==0 ){
    goto delete_from_cleanup;
  }
  if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);
  sqlite3BeginWriteOperation(pParse, 1, iDb);





  if( isView ){
    sqlite3MaterializeView(pParse, pTab, pWhere, iCur);
  }




  memset(&sNC, 0, sizeof(sNC));
  sNC.pParse = pParse;
  sNC.pSrcList = pTabList;
  if( sqlite3ResolveExprNames(&sNC, pWhere) ){
    goto delete_from_cleanup;
  }




  if( db->flags & 0x00001000 ){
    memCnt = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 7, 0, memCnt);
  }






  if( rcauth==0 && pWhere==0 && !pTrigger && !(((pTab)->tabFlags & 0x10)!=0)
   && 0==sqlite3FkRequired(pParse, pTab, 0, 0)
  ){
    ((void) (0));
    sqlite3VdbeAddOp4(v, 96, pTab->tnum, iDb, memCnt,
                      pTab->zName, (-2));
    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
      ((void) (0));
      sqlite3VdbeAddOp2(v, 96, pIdx->tnum, iDb);
    }
  }else




  {
    int iRowSet = ++pParse->nMem;
    int iRowid = ++pParse->nMem;
    int regRowid;



    sqlite3VdbeAddOp2(v, 10, 0, iRowSet);
    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere,0,0x0008);
    if( pWInfo==0 ) goto delete_from_cleanup;
    regRowid = sqlite3ExprCodeGetColumn(pParse, pTab, -1, iCur, iRowid);
    sqlite3VdbeAddOp2(v, 105, iRowSet, regRowid);
    if( db->flags & 0x00001000 ){
      sqlite3VdbeAddOp2(v, 20, memCnt, 1);
    }
    sqlite3WhereEnd(pWInfo);




    end = sqlite3VdbeMakeLabel(v);





    if( !isView ){
      sqlite3OpenTableAndIndices(pParse, pTab, iCur, 39);
    }

    addr = sqlite3VdbeAddOp3(v, 106, iRowSet, end, iRowid);



    if( (((pTab)->tabFlags & 0x10)!=0) ){
      const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);
      sqlite3VtabMakeWritable(pParse, pTab);
      sqlite3VdbeAddOp4(v, 133, 0, 1, iRowid, pVTab, (-10));
      sqlite3MayAbort(pParse);
    }else

    {
      int count = (pParse->nested==0);
      sqlite3GenerateRowDelete(pParse, pTab, iCur, iRowid, count, pTrigger, 99);
    }


    sqlite3VdbeAddOp2(v, 1, 0, addr);
    sqlite3VdbeResolveLabel(v, end);


    if( !isView && !(((pTab)->tabFlags & 0x10)!=0) ){
      for(i=1, pIdx=pTab->pIndex; pIdx; i++, pIdx=pIdx->pNext){
        sqlite3VdbeAddOp2(v, 43, iCur + i, pIdx->tnum);
      }
      sqlite3VdbeAddOp1(v, 43, iCur);
    }
  }





  if( pParse->nested==0 && pParse->pTriggerTab==0 ){
    sqlite3AutoincrementEnd(pParse);
  }





  if( (db->flags&0x00001000) && !pParse->nested && !pParse->pTriggerTab ){
    sqlite3VdbeAddOp2(v, 16, memCnt, 1);
    sqlite3VdbeSetNumCols(v, 1);
    sqlite3VdbeSetColName(v, 0, 0, "rows deleted", ((sqlite3_destructor_type)0));
  }

delete_from_cleanup:
  sqlite3AuthContextPop(&sContext);
  sqlite3SrcListDelete(db, pTabList);
  sqlite3ExprDelete(db, pWhere);
  return;
}
# 81414 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3GenerateRowDelete(
  Parse *pParse,
  Table *pTab,
  int iCur,
  int iRowid,
  int count,
  Trigger *pTrigger,
  int onconf
){
  Vdbe *v = pParse->pVdbe;
  int iOld = 0;
  int iLabel;


  ((void) (0));




  iLabel = sqlite3VdbeMakeLabel(v);
  sqlite3VdbeAddOp3(v, 52, iCur, iLabel, iRowid);



  if( sqlite3FkRequired(pParse, pTab, 0, 0) || pTrigger ){
    u32 mask;
    int iCol;



    mask = sqlite3TriggerColmask(
        pParse, pTrigger, 0, 0, 1|2, pTab, onconf
    );
    mask |= sqlite3FkOldmask(pParse, pTab);
    iOld = pParse->nMem+1;
    pParse->nMem += (1 + pTab->nCol);



    sqlite3VdbeAddOp2(v, 14, iRowid, iOld);
    for(iCol=0; iCol<pTab->nCol; iCol++){
      if( mask==0xffffffff || mask&(1<<iCol) ){
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol, iOld+iCol+1);
      }
    }


    sqlite3CodeRowTrigger(pParse, pTrigger,
        106, 0, 1, pTab, iOld, onconf, iLabel
    );





    sqlite3VdbeAddOp3(v, 52, iCur, iLabel, iRowid);




    sqlite3FkCheck(pParse, pTab, iOld, 0);
  }




  if( pTab->pSelect==0 ){
    sqlite3GenerateRowIndexDelete(pParse, pTab, iCur, 0);
    sqlite3VdbeAddOp2(v, 57, iCur, (count?0x01:0));
    if( count ){
      sqlite3VdbeChangeP4(v, -1, pTab->zName, 0);
    }
  }




  sqlite3FkActions(pParse, pTab, 0, iOld);


  sqlite3CodeRowTrigger(pParse, pTrigger,
      106, 0, 2, pTab, iOld, onconf, iLabel
  );




  sqlite3VdbeResolveLabel(v, iLabel);
}
# 81520 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3GenerateRowIndexDelete(
  Parse *pParse,
  Table *pTab,
  int iCur,
  int *aRegIdx
){
  int i;
  Index *pIdx;
  int r1;

  for(i=1, pIdx=pTab->pIndex; pIdx; i++, pIdx=pIdx->pNext){
    if( aRegIdx!=0 && aRegIdx[i-1]==0 ) continue;
    r1 = sqlite3GenerateIndexKey(pParse, pIdx, iCur, 0, 0);
    sqlite3VdbeAddOp3(pParse->pVdbe, 71, iCur+i, r1,pIdx->nColumn+1);
  }
}
# 81548 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3GenerateIndexKey(
  Parse *pParse,
  Index *pIdx,
  int iCur,
  int regOut,
  int doMakeRec
){
  Vdbe *v = pParse->pVdbe;
  int j;
  Table *pTab = pIdx->pTable;
  int regBase;
  int nCol;

  nCol = pIdx->nColumn;
  regBase = sqlite3GetTempRange(pParse, nCol+1);
  sqlite3VdbeAddOp2(v, 61, iCur, regBase+nCol);
  for(j=0; j<nCol; j++){
    int idx = pIdx->aiColumn[j];
    if( idx==pTab->iPKey ){
      sqlite3VdbeAddOp2(v, 15, regBase+nCol, regBase+j);
    }else{
      sqlite3VdbeAddOp3(v, 28, iCur, idx, regBase+j);
      sqlite3ColumnDefault(v, pTab, idx, -1);
    }
  }
  if( doMakeRec ){
    sqlite3VdbeAddOp3(v, 30, regBase, nCol+1, regOut);
    sqlite3VdbeChangeP4(v, -1, sqlite3IndexAffinityStr(v, pIdx), 0);
  }
  sqlite3ReleaseTempRange(pParse, regBase, nCol+1);
  return regBase;
}
# 81605 "ext/sqlite3/libsqlite/sqlite3.c"
static CollSeq *sqlite3GetFuncCollSeq(sqlite3_context *context){
  return context->pColl;
}




static void minmaxFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int i;
  int mask;
  int iBest;
  CollSeq *pColl;

  ((void) (0));
  mask = sqlite3_user_data(context)==0 ? 0 : -1;
  pColl = sqlite3GetFuncCollSeq(context);
  ((void) (0));
  ((void) (0));
  iBest = 0;
  if( sqlite3_value_type(argv[0])==5 ) return;
  for(i=1; i<argc; i++){
    if( sqlite3_value_type(argv[i])==5 ) return;
    if( (sqlite3MemCompare(argv[iBest], argv[i], pColl)^mask)>=0 ){
                         ;
      iBest = i;
    }
  }
  sqlite3_result_value(context, argv[iBest]);
}




static void typeofFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  const char *z = 0;
  (void)(NotUsed);
  switch( sqlite3_value_type(argv[0]) ){
    case 1: z = "integer"; break;
    case 3: z = "text"; break;
    case 2: z = "real"; break;
    case 4: z = "blob"; break;
    default: z = "null"; break;
  }
  sqlite3_result_text(context, z, -1, ((sqlite3_destructor_type)0));
}





static void lengthFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int len;

  ((void) (0));
  (void)(argc);
  switch( sqlite3_value_type(argv[0]) ){
    case 4:
    case 1:
    case 2: {
      sqlite3_result_int(context, sqlite3_value_bytes(argv[0]));
      break;
    }
    case 3: {
      const unsigned char *z = sqlite3_value_text(argv[0]);
      if( z==0 ) return;
      len = 0;
      while( *z ){
        len++;
        { if( (*(z++))>=0xc0 ){ while( (*z & 0xc0)==0x80 ){ z++; } } };
      }
      sqlite3_result_int(context, len);
      break;
    }
    default: {
      sqlite3_result_null(context);
      break;
    }
  }
}







static void absFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  ((void) (0));
  (void)(argc);
  switch( sqlite3_value_type(argv[0]) ){
    case 1: {
      i64 iVal = sqlite3_value_int64(argv[0]);
      if( iVal<0 ){
        if( (iVal<<1)==0 ){



          sqlite3_result_error(context, "integer overflow", -1);
          return;
        }
        iVal = -iVal;
      }
      sqlite3_result_int64(context, iVal);
      break;
    }
    case 5: {

      sqlite3_result_null(context);
      break;
    }
    default: {





      double rVal = sqlite3_value_double(argv[0]);
      if( rVal<0 ) rVal = -rVal;
      sqlite3_result_double(context, rVal);
      break;
    }
  }
}
# 81753 "ext/sqlite3/libsqlite/sqlite3.c"
static void substrFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *z;
  const unsigned char *z2;
  int len;
  int p0type;
  i64 p1, p2;
  int negP2 = 0;

  ((void) (0));
  if( sqlite3_value_type(argv[1])==5
   || (argc==3 && sqlite3_value_type(argv[2])==5)
  ){
    return;
  }
  p0type = sqlite3_value_type(argv[0]);
  p1 = sqlite3_value_int(argv[1]);
  if( p0type==4 ){
    len = sqlite3_value_bytes(argv[0]);
    z = sqlite3_value_blob(argv[0]);
    if( z==0 ) return;
    ((void) (0));
  }else{
    z = sqlite3_value_text(argv[0]);
    if( z==0 ) return;
    len = 0;
    if( p1<0 ){
      for(z2=z; *z2; len++){
        { if( (*(z2++))>=0xc0 ){ while( (*z2 & 0xc0)==0x80 ){ z2++; } } };
      }
    }
  }
  if( argc==3 ){
    p2 = sqlite3_value_int(argv[2]);
    if( p2<0 ){
      p2 = -p2;
      negP2 = 1;
    }
  }else{
    p2 = sqlite3_context_db_handle(context)->aLimit[0];
  }
  if( p1<0 ){
    p1 += len;
    if( p1<0 ){
      p2 += p1;
      if( p2<0 ) p2 = 0;
      p1 = 0;
    }
  }else if( p1>0 ){
    p1--;
  }else if( p2>0 ){
    p2--;
  }
  if( negP2 ){
    p1 -= p2;
    if( p1<0 ){
      p2 += p1;
      p1 = 0;
    }
  }
  ((void) (0));
  if( p0type!=4 ){
    while( *z && p1 ){
      { if( (*(z++))>=0xc0 ){ while( (*z & 0xc0)==0x80 ){ z++; } } };
      p1--;
    }
    for(z2=z; *z2 && p2; p2--){
      { if( (*(z2++))>=0xc0 ){ while( (*z2 & 0xc0)==0x80 ){ z2++; } } };
    }
    sqlite3_result_text(context, (char*)z, (int)(z2-z), ((sqlite3_destructor_type)-1));
  }else{
    if( p1+p2>len ){
      p2 = len-p1;
      if( p2<0 ) p2 = 0;
    }
    sqlite3_result_blob(context, (char*)&z[p1], (int)p2, ((sqlite3_destructor_type)-1));
  }
}





static void roundFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  int n = 0;
  double r;
  char *zBuf;
  ((void) (0));
  if( argc==2 ){
    if( 5==sqlite3_value_type(argv[1]) ) return;
    n = sqlite3_value_int(argv[1]);
    if( n>30 ) n = 30;
    if( n<0 ) n = 0;
  }
  if( sqlite3_value_type(argv[0])==5 ) return;
  r = sqlite3_value_double(argv[0]);




  if( n==0 && r>=0 && r<(0xffffffff|(((i64)0x7fffffff)<<32))-1 ){
    r = (double)((sqlite_int64)(r+0.5));
  }else if( n==0 && r<0 && (-r)<(0xffffffff|(((i64)0x7fffffff)<<32))-1 ){
    r = -(double)((sqlite_int64)((-r)+0.5));
  }else{
    zBuf = sqlite3_mprintf("%.*f",n,r);
    if( zBuf==0 ){
      sqlite3_result_error_nomem(context);
      return;
    }
    sqlite3AtoF(zBuf, &r, sqlite3Strlen30(zBuf), 1);
    sqlite3_free(zBuf);
  }
  sqlite3_result_double(context, r);
}
# 81880 "ext/sqlite3/libsqlite/sqlite3.c"
static void *contextMalloc(sqlite3_context *context, i64 nByte){
  char *z;
  sqlite3 *db = sqlite3_context_db_handle(context);
  ((void) (0));
                                                    ;
                                                      ;
  if( nByte>db->aLimit[0] ){
    sqlite3_result_error_toobig(context);
    z = 0;
  }else{
    z = sqlite3Malloc((int)nByte);
    if( !z ){
      sqlite3_result_error_nomem(context);
    }
  }
  return z;
}




static void upperFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  char *z1;
  const char *z2;
  int i, n;
  (void)(argc);
  z2 = (char*)sqlite3_value_text(argv[0]);
  n = sqlite3_value_bytes(argv[0]);

  ((void) (0));
  if( z2 ){
    z1 = contextMalloc(context, ((i64)n)+1);
    if( z1 ){
      memcpy(z1, z2, n+1);
      for(i=0; z1[i]; i++){
        z1[i] = (char)((z1[i])&~(sqlite3CtypeMap[(unsigned char)(z1[i])]&0x20));
      }
      sqlite3_result_text(context, z1, -1, sqlite3_free);
    }
  }
}
static void lowerFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  u8 *z1;
  const char *z2;
  int i, n;
  (void)(argc);
  z2 = (char*)sqlite3_value_text(argv[0]);
  n = sqlite3_value_bytes(argv[0]);

  ((void) (0));
  if( z2 ){
    z1 = contextMalloc(context, ((i64)n)+1);
    if( z1 ){
      memcpy(z1, z2, n+1);
      for(i=0; z1[i]; i++){
        z1[i] = (sqlite3UpperToLower[(unsigned char)(z1[i])]);
      }
      sqlite3_result_text(context, (char *)z1, -1, sqlite3_free);
    }
  }
}
# 81974 "ext/sqlite3/libsqlite/sqlite3.c"
static void randomFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  sqlite_int64 r;
  (void)(NotUsed),(void)(NotUsed2);
  sqlite3_randomness(sizeof(r), &r);
  if( r<0 ){
# 81991 "ext/sqlite3/libsqlite/sqlite3.c"
    r = -(r ^ (((sqlite3_int64)1)<<63));
  }
  sqlite3_result_int64(context, r);
}





static void randomBlob(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int n;
  unsigned char *p;
  ((void) (0));
  (void)(argc);
  n = sqlite3_value_int(argv[0]);
  if( n<1 ){
    n = 1;
  }
  p = contextMalloc(context, n);
  if( p ){
    sqlite3_randomness(n, p);
    sqlite3_result_blob(context, (char*)p, n, sqlite3_free);
  }
}





static void last_insert_rowid(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  (void)(NotUsed),(void)(NotUsed2);



  sqlite3_result_int64(context, sqlite3_last_insert_rowid(db));
}
# 82044 "ext/sqlite3/libsqlite/sqlite3.c"
static void changes(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  (void)(NotUsed),(void)(NotUsed2);
  sqlite3_result_int(context, sqlite3_changes(db));
}





static void total_changes(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  (void)(NotUsed),(void)(NotUsed2);


  sqlite3_result_int(context, sqlite3_total_changes(db));
}




struct compareInfo {
  u8 matchAll;
  u8 matchOne;
  u8 matchSet;
  u8 noCase;
};
# 82093 "ext/sqlite3/libsqlite/sqlite3.c"
static const struct compareInfo globInfo = { '*', '?', '[', 0 };


static const struct compareInfo likeInfoNorm = { '%', '_', 0, 1 };


static const struct compareInfo likeInfoAlt = { '%', '_', 0, 0 };
# 82129 "ext/sqlite3/libsqlite/sqlite3.c"
static int patternCompare(
  const u8 *zPattern,
  const u8 *zString,
  const struct compareInfo *pInfo,
  const int esc
){
  int c, c2;
  int invert;
  int seen;
  u8 matchOne = pInfo->matchOne;
  u8 matchAll = pInfo->matchAll;
  u8 matchSet = pInfo->matchSet;
  u8 noCase = pInfo->noCase;
  int prevEscape = 0;

  while( (c = sqlite3Utf8Read(zPattern,&zPattern))!=0 ){
    if( !prevEscape && c==matchAll ){
      while( (c=sqlite3Utf8Read(zPattern,&zPattern)) == matchAll
               || c == matchOne ){
        if( c==matchOne && sqlite3Utf8Read(zString, &zString)==0 ){
          return 0;
        }
      }
      if( c==0 ){
        return 1;
      }else if( c==esc ){
        c = sqlite3Utf8Read(zPattern, &zPattern);
        if( c==0 ){
          return 0;
        }
      }else if( c==matchSet ){
        ((void) (0));
        ((void) (0));
        while( *zString && patternCompare(&zPattern[-1],zString,pInfo,esc)==0 ){
          { if( (*(zString++))>=0xc0 ){ while( (*zString & 0xc0)==0x80 ){ zString++; } } };
        }
        return *zString!=0;
      }
      while( (c2 = sqlite3Utf8Read(zString,&zString))!=0 ){
        if( noCase ){
          if( c2<0x80 ){ c2 = sqlite3UpperToLower[c2]; };
          if( c<0x80 ){ c = sqlite3UpperToLower[c]; };
          while( c2 != 0 && c2 != c ){
            c2 = sqlite3Utf8Read(zString, &zString);
            if( c2<0x80 ){ c2 = sqlite3UpperToLower[c2]; };
          }
        }else{
          while( c2 != 0 && c2 != c ){
            c2 = sqlite3Utf8Read(zString, &zString);
          }
        }
        if( c2==0 ) return 0;
        if( patternCompare(zPattern,zString,pInfo,esc) ) return 1;
      }
      return 0;
    }else if( !prevEscape && c==matchOne ){
      if( sqlite3Utf8Read(zString, &zString)==0 ){
        return 0;
      }
    }else if( c==matchSet ){
      int prior_c = 0;
      ((void) (0));
      seen = 0;
      invert = 0;
      c = sqlite3Utf8Read(zString, &zString);
      if( c==0 ) return 0;
      c2 = sqlite3Utf8Read(zPattern, &zPattern);
      if( c2=='^' ){
        invert = 1;
        c2 = sqlite3Utf8Read(zPattern, &zPattern);
      }
      if( c2==']' ){
        if( c==']' ) seen = 1;
        c2 = sqlite3Utf8Read(zPattern, &zPattern);
      }
      while( c2 && c2!=']' ){
        if( c2=='-' && zPattern[0]!=']' && zPattern[0]!=0 && prior_c>0 ){
          c2 = sqlite3Utf8Read(zPattern, &zPattern);
          if( c>=prior_c && c<=c2 ) seen = 1;
          prior_c = 0;
        }else{
          if( c==c2 ){
            seen = 1;
          }
          prior_c = c2;
        }
        c2 = sqlite3Utf8Read(zPattern, &zPattern);
      }
      if( c2==0 || (seen ^ invert)==0 ){
        return 0;
      }
    }else if( esc==c && !prevEscape ){
      prevEscape = 1;
    }else{
      c2 = sqlite3Utf8Read(zString, &zString);
      if( noCase ){
        if( c<0x80 ){ c = sqlite3UpperToLower[c]; };
        if( c2<0x80 ){ c2 = sqlite3UpperToLower[c2]; };
      }
      if( c!=c2 ){
        return 0;
      }
      prevEscape = 0;
    }
  }
  return *zString==0;
}
# 82259 "ext/sqlite3/libsqlite/sqlite3.c"
static void likeFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *zA, *zB;
  int escape = 0;
  int nPat;
  sqlite3 *db = sqlite3_context_db_handle(context);

  zB = sqlite3_value_text(argv[0]);
  zA = sqlite3_value_text(argv[1]);




  nPat = sqlite3_value_bytes(argv[0]);
                                                                ;
                                                                  ;
  if( nPat > db->aLimit[8] ){
    sqlite3_result_error(context, "LIKE or GLOB pattern too complex", -1);
    return;
  }
  ((void) (0));

  if( argc==3 ){



    const unsigned char *zEsc = sqlite3_value_text(argv[2]);
    if( zEsc==0 ) return;
    if( sqlite3Utf8CharLen((char*)zEsc, -1)!=1 ){
      sqlite3_result_error(context,
          "ESCAPE expression must be a single character", -1);
      return;
    }
    escape = sqlite3Utf8Read(zEsc, &zEsc);
  }
  if( zA && zB ){
    struct compareInfo *pInfo = sqlite3_user_data(context);




    sqlite3_result_int(context, patternCompare(zB, zA, pInfo, escape));
  }
}






static void nullifFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  CollSeq *pColl = sqlite3GetFuncCollSeq(context);
  (void)(NotUsed);
  if( sqlite3MemCompare(argv[0], argv[1], pColl)!=0 ){
    sqlite3_result_value(context, argv[0]);
  }
}





static void versionFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  (void)(NotUsed),(void)(NotUsed2);


  sqlite3_result_text(context, sqlite3_libversion(), -1, ((sqlite3_destructor_type)0));
}






static void sourceidFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  (void)(NotUsed),(void)(NotUsed2);


  sqlite3_result_text(context, sqlite3_sourceid(), -1, ((sqlite3_destructor_type)0));
}







static void compileoptionusedFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const char *zOptName;
  ((void) (0));
  (void)(argc);




  if( (zOptName = (const char*)sqlite3_value_text(argv[0]))!=0 ){
    sqlite3_result_int(context, sqlite3_compileoption_used(zOptName));
  }
}
# 82385 "ext/sqlite3/libsqlite/sqlite3.c"
static void compileoptiongetFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int n;
  ((void) (0));
  (void)(argc);



  n = sqlite3_value_int(argv[0]);
  sqlite3_result_text(context, sqlite3_compileoption_get(n), -1, ((sqlite3_destructor_type)0));
}




static const char hexdigits[] = {
  '0', '1', '2', '3', '4', '5', '6', '7',
  '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
};
# 82419 "ext/sqlite3/libsqlite/sqlite3.c"
static void quoteFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  ((void) (0));
  (void)(argc);
  switch( sqlite3_value_type(argv[0]) ){
    case 1:
    case 2: {
      sqlite3_result_value(context, argv[0]);
      break;
    }
    case 4: {
      char *zText = 0;
      char const *zBlob = sqlite3_value_blob(argv[0]);
      int nBlob = sqlite3_value_bytes(argv[0]);
      ((void) (0));
      zText = (char *)contextMalloc(context, (2*(i64)nBlob)+4);
      if( zText ){
        int i;
        for(i=0; i<nBlob; i++){
          zText[(i*2)+2] = hexdigits[(zBlob[i]>>4)&0x0F];
          zText[(i*2)+3] = hexdigits[(zBlob[i])&0x0F];
        }
        zText[(nBlob*2)+2] = '\'';
        zText[(nBlob*2)+3] = '\0';
        zText[0] = 'X';
        zText[1] = '\'';
        sqlite3_result_text(context, zText, -1, ((sqlite3_destructor_type)-1));
        sqlite3_free(zText);
      }
      break;
    }
    case 3: {
      int i,j;
      u64 n;
      const unsigned char *zArg = sqlite3_value_text(argv[0]);
      char *z;

      if( zArg==0 ) return;
      for(i=0, n=0; zArg[i]; i++){ if( zArg[i]=='\'' ) n++; }
      z = contextMalloc(context, ((i64)i)+((i64)n)+3);
      if( z ){
        z[0] = '\'';
        for(i=0, j=1; zArg[i]; i++){
          z[j++] = zArg[i];
          if( zArg[i]=='\'' ){
            z[j++] = '\'';
          }
        }
        z[j++] = '\'';
        z[j] = 0;
        sqlite3_result_text(context, z, j, sqlite3_free);
      }
      break;
    }
    default: {
      ((void) (0));
      sqlite3_result_text(context, "NULL", 4, ((sqlite3_destructor_type)0));
      break;
    }
  }
}





static void hexFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int i, n;
  const unsigned char *pBlob;
  char *zHex, *z;
  ((void) (0));
  (void)(argc);
  pBlob = sqlite3_value_blob(argv[0]);
  n = sqlite3_value_bytes(argv[0]);
  ((void) (0));
  z = zHex = contextMalloc(context, ((i64)n)*2 + 1);
  if( zHex ){
    for(i=0; i<n; i++, pBlob++){
      unsigned char c = *pBlob;
      *(z++) = hexdigits[(c>>4)&0xf];
      *(z++) = hexdigits[c&0xf];
    }
    *z = 0;
    sqlite3_result_text(context, zHex, n*2, sqlite3_free);
  }
}




static void zeroblobFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  i64 n;
  sqlite3 *db = sqlite3_context_db_handle(context);
  ((void) (0));
  (void)(argc);
  n = sqlite3_value_int64(argv[0]);
                                                ;
                                                  ;
  if( n>db->aLimit[0] ){
    sqlite3_result_error_toobig(context);
  }else{
    sqlite3_result_zeroblob(context, (int)n);
  }
}







static void replaceFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *zStr;
  const unsigned char *zPattern;
  const unsigned char *zRep;
  unsigned char *zOut;
  int nStr;
  int nPattern;
  int nRep;
  i64 nOut;
  int loopLimit;
  int i, j;

  ((void) (0));
  (void)(argc);
  zStr = sqlite3_value_text(argv[0]);
  if( zStr==0 ) return;
  nStr = sqlite3_value_bytes(argv[0]);
  ((void) (0));
  zPattern = sqlite3_value_text(argv[1]);
  if( zPattern==0 ){
    ((void) (0));

    return;
  }
  if( zPattern[0]==0 ){
    ((void) (0));
    sqlite3_result_value(context, argv[0]);
    return;
  }
  nPattern = sqlite3_value_bytes(argv[1]);
  ((void) (0));
  zRep = sqlite3_value_text(argv[2]);
  if( zRep==0 ) return;
  nRep = sqlite3_value_bytes(argv[2]);
  ((void) (0));
  nOut = nStr + 1;
  ((void) (0));
  zOut = contextMalloc(context, (i64)nOut);
  if( zOut==0 ){
    return;
  }
  loopLimit = nStr - nPattern;
  for(i=j=0; i<=loopLimit; i++){
    if( zStr[i]!=zPattern[0] || memcmp(&zStr[i], zPattern, nPattern) ){
      zOut[j++] = zStr[i];
    }else{
      u8 *zOld;
      sqlite3 *db = sqlite3_context_db_handle(context);
      nOut += nRep - nPattern;
                                                         ;
                                                         ;
      if( nOut-1>db->aLimit[0] ){
        sqlite3_result_error_toobig(context);
        sqlite3_free(zOut);
        return;
      }
      zOld = zOut;
      zOut = sqlite3_realloc(zOut, (int)nOut);
      if( zOut==0 ){
        sqlite3_result_error_nomem(context);
        sqlite3_free(zOld);
        return;
      }
      memcpy(&zOut[j], zRep, nRep);
      j += nRep;
      i += nPattern-1;
    }
  }
  ((void) (0));
  memcpy(&zOut[j], &zStr[i], nStr-i);
  j += nStr - i;
  ((void) (0));
  zOut[j] = 0;
  sqlite3_result_text(context, (char*)zOut, j, sqlite3_free);
}





static void trimFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *zIn;
  const unsigned char *zCharSet;
  int nIn;
  int flags;
  int i;
  unsigned char *aLen = 0;
  unsigned char **azChar = 0;
  int nChar;

  if( sqlite3_value_type(argv[0])==5 ){
    return;
  }
  zIn = sqlite3_value_text(argv[0]);
  if( zIn==0 ) return;
  nIn = sqlite3_value_bytes(argv[0]);
  ((void) (0));
  if( argc==1 ){
    static const unsigned char lenOne[] = { 1 };
    static unsigned char * const azOne[] = { (u8*)" " };
    nChar = 1;
    aLen = (u8*)lenOne;
    azChar = (unsigned char **)azOne;
    zCharSet = 0;
  }else if( (zCharSet = sqlite3_value_text(argv[1]))==0 ){
    return;
  }else{
    const unsigned char *z;
    for(z=zCharSet, nChar=0; *z; nChar++){
      { if( (*(z++))>=0xc0 ){ while( (*z & 0xc0)==0x80 ){ z++; } } };
    }
    if( nChar>0 ){
      azChar = contextMalloc(context, ((i64)nChar)*(sizeof(char*)+1));
      if( azChar==0 ){
        return;
      }
      aLen = (unsigned char*)&azChar[nChar];
      for(z=zCharSet, nChar=0; *z; nChar++){
        azChar[nChar] = (unsigned char *)z;
        { if( (*(z++))>=0xc0 ){ while( (*z & 0xc0)==0x80 ){ z++; } } };
        aLen[nChar] = (u8)(z - azChar[nChar]);
      }
    }
  }
  if( nChar>0 ){
    flags = ((int)(long int)(sqlite3_user_data(context)));
    if( flags & 1 ){
      while( nIn>0 ){
        int len = 0;
        for(i=0; i<nChar; i++){
          len = aLen[i];
          if( len<=nIn && memcmp(zIn, azChar[i], len)==0 ) break;
        }
        if( i>=nChar ) break;
        zIn += len;
        nIn -= len;
      }
    }
    if( flags & 2 ){
      while( nIn>0 ){
        int len = 0;
        for(i=0; i<nChar; i++){
          len = aLen[i];
          if( len<=nIn && memcmp(&zIn[nIn-len],azChar[i],len)==0 ) break;
        }
        if( i>=nChar ) break;
        nIn -= len;
      }
    }
    if( zCharSet ){
      sqlite3_free(azChar);
    }
  }
  sqlite3_result_text(context, (char*)zIn, nIn, ((sqlite3_destructor_type)-1));
}
# 82766 "ext/sqlite3/libsqlite/sqlite3.c"
static void loadExt(sqlite3_context *context, int argc, sqlite3_value **argv){
  const char *zFile = (const char *)sqlite3_value_text(argv[0]);
  const char *zProc;
  sqlite3 *db = sqlite3_context_db_handle(context);
  char *zErrMsg = 0;

  if( argc==2 ){
    zProc = (const char *)sqlite3_value_text(argv[1]);
  }else{
    zProc = 0;
  }
  if( zFile && sqlite3_load_extension(db, zFile, zProc, &zErrMsg) ){
    sqlite3_result_error(context, zErrMsg, -1);
    sqlite3_free(zErrMsg);
  }
}







typedef struct SumCtx SumCtx;
struct SumCtx {
  double rSum;
  i64 iSum;
  i64 cnt;
  u8 overflow;
  u8 approx;
};
# 82808 "ext/sqlite3/libsqlite/sqlite3.c"
static void sumStep(sqlite3_context *context, int argc, sqlite3_value **argv){
  SumCtx *p;
  int type;
  ((void) (0));
  (void)(argc);
  p = sqlite3_aggregate_context(context, sizeof(*p));
  type = sqlite3_value_numeric_type(argv[0]);
  if( p && type!=5 ){
    p->cnt++;
    if( type==1 ){
      i64 v = sqlite3_value_int64(argv[0]);
      p->rSum += v;
      if( (p->approx|p->overflow)==0 && sqlite3AddInt64(&p->iSum, v) ){
        p->overflow = 1;
      }
    }else{
      p->rSum += sqlite3_value_double(argv[0]);
      p->approx = 1;
    }
  }
}
static void sumFinalize(sqlite3_context *context){
  SumCtx *p;
  p = sqlite3_aggregate_context(context, 0);
  if( p && p->cnt>0 ){
    if( p->overflow ){
      sqlite3_result_error(context,"integer overflow",-1);
    }else if( p->approx ){
      sqlite3_result_double(context, p->rSum);
    }else{
      sqlite3_result_int64(context, p->iSum);
    }
  }
}
static void avgFinalize(sqlite3_context *context){
  SumCtx *p;
  p = sqlite3_aggregate_context(context, 0);
  if( p && p->cnt>0 ){
    sqlite3_result_double(context, p->rSum/(double)p->cnt);
  }
}
static void totalFinalize(sqlite3_context *context){
  SumCtx *p;
  p = sqlite3_aggregate_context(context, 0);

  sqlite3_result_double(context, p ? p->rSum : (double)0);
}





typedef struct CountCtx CountCtx;
struct CountCtx {
  i64 n;
};




static void countStep(sqlite3_context *context, int argc, sqlite3_value **argv){
  CountCtx *p;
  p = sqlite3_aggregate_context(context, sizeof(*p));
  if( (argc==0 || 5!=sqlite3_value_type(argv[0])) && p ){
    p->n++;
  }






  ((void) (0));


}
static void countFinalize(sqlite3_context *context){
  CountCtx *p;
  p = sqlite3_aggregate_context(context, 0);
  sqlite3_result_int64(context, p ? p->n : 0);
}




static void minmaxStep(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  Mem *pArg = (Mem *)argv[0];
  Mem *pBest;
  (void)(NotUsed);

  if( sqlite3_value_type(argv[0])==5 ) return;
  pBest = (Mem *)sqlite3_aggregate_context(context, sizeof(*pBest));
  if( !pBest ) return;

  if( pBest->flags ){
    int max;
    int cmp;
    CollSeq *pColl = sqlite3GetFuncCollSeq(context);
# 82918 "ext/sqlite3/libsqlite/sqlite3.c"
    max = sqlite3_user_data(context)!=0;
    cmp = sqlite3MemCompare(pBest, pArg, pColl);
    if( (max && cmp<0) || (!max && cmp>0) ){
      sqlite3VdbeMemCopy(pBest, pArg);
    }
  }else{
    sqlite3VdbeMemCopy(pBest, pArg);
  }
}
static void minMaxFinalize(sqlite3_context *context){
  sqlite3_value *pRes;
  pRes = (sqlite3_value *)sqlite3_aggregate_context(context, 0);
  if( pRes ){
    if( (pRes->flags) ){
      sqlite3_result_value(context, pRes);
    }
    sqlite3VdbeMemRelease(pRes);
  }
}




static void groupConcatStep(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const char *zVal;
  StrAccum *pAccum;
  const char *zSep;
  int nVal, nSep;
  ((void) (0));
  if( sqlite3_value_type(argv[0])==5 ) return;
  pAccum = (StrAccum*)sqlite3_aggregate_context(context, sizeof(*pAccum));

  if( pAccum ){
    sqlite3 *db = sqlite3_context_db_handle(context);
    int firstTerm = pAccum->useMalloc==0;
    pAccum->useMalloc = 2;
    pAccum->mxAlloc = db->aLimit[0];
    if( !firstTerm ){
      if( argc==2 ){
        zSep = (char*)sqlite3_value_text(argv[1]);
        nSep = sqlite3_value_bytes(argv[1]);
      }else{
        zSep = ",";
        nSep = 1;
      }
      sqlite3StrAccumAppend(pAccum, zSep, nSep);
    }
    zVal = (char*)sqlite3_value_text(argv[0]);
    nVal = sqlite3_value_bytes(argv[0]);
    sqlite3StrAccumAppend(pAccum, zVal, nVal);
  }
}
static void groupConcatFinalize(sqlite3_context *context){
  StrAccum *pAccum;
  pAccum = sqlite3_aggregate_context(context, 0);
  if( pAccum ){
    if( pAccum->tooBig ){
      sqlite3_result_error_toobig(context);
    }else if( pAccum->mallocFailed ){
      sqlite3_result_error_nomem(context);
    }else{
      sqlite3_result_text(context, sqlite3StrAccumFinish(pAccum), -1,
                          sqlite3_free);
    }
  }
}






static void sqlite3RegisterBuiltinFunctions(sqlite3 *db){
  int rc = sqlite3_overload_function(db, "MATCH", 2);
  ((void) (0));
  if( rc==7 ){
    db->mallocFailed = 1;
  }
}




static void setLikeOptFlag(sqlite3 *db, const char *zName, u8 flagVal){
  FuncDef *pDef;
  pDef = sqlite3FindFunction(db, zName, sqlite3Strlen30(zName),
                             2, 1, 0);
  if( (pDef) ){
    pDef->flags = flagVal;
  }
}






static void sqlite3RegisterLikeFunctions(sqlite3 *db, int caseSensitive){
  struct compareInfo *pInfo;
  if( caseSensitive ){
    pInfo = (struct compareInfo*)&likeInfoAlt;
  }else{
    pInfo = (struct compareInfo*)&likeInfoNorm;
  }
  sqlite3CreateFunc(db, "like", 2, 1, pInfo, likeFunc, 0, 0, 0);
  sqlite3CreateFunc(db, "like", 3, 1, pInfo, likeFunc, 0, 0, 0);
  sqlite3CreateFunc(db, "glob", 2, 1,
      (struct compareInfo*)&globInfo, likeFunc, 0, 0, 0);
  setLikeOptFlag(db, "glob", 0x01 | 0x02);
  setLikeOptFlag(db, "like",
      caseSensitive ? (0x01 | 0x02) : 0x01);
}
# 83042 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3IsLikeFunction(sqlite3 *db, Expr *pExpr, int *pIsNocase, char *aWc){
  FuncDef *pDef;
  if( pExpr->op!=151
   || !pExpr->x.pList
   || pExpr->x.pList->nExpr!=2
  ){
    return 0;
  }
  ((void) (0));
  pDef = sqlite3FindFunction(db, pExpr->u.zToken,
                             sqlite3Strlen30(pExpr->u.zToken),
                             2, 1, 0);
  if( (pDef==0) || (pDef->flags & 0x01)==0 ){
    return 0;
  }





  memcpy(aWc, pDef->pUserData, 3);
  ((void) (0));
  ((void) (0));
  ((void) (0));
  *pIsNocase = (pDef->flags & 0x02)==0;
  return 1;
}
# 83077 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3RegisterGlobalFunctions(void){
# 83086 "ext/sqlite3/libsqlite/sqlite3.c"
  static FuncDef aBuiltinFunc[] = {
    {1, 1, 0*0x08, ((void*)(long int)(1)), 0, trimFunc, 0, 0, "ltrim", 0, 0},
    {2, 1, 0*0x08, ((void*)(long int)(1)), 0, trimFunc, 0, 0, "ltrim", 0, 0},
    {1, 1, 0*0x08, ((void*)(long int)(2)), 0, trimFunc, 0, 0, "rtrim", 0, 0},
    {2, 1, 0*0x08, ((void*)(long int)(2)), 0, trimFunc, 0, 0, "rtrim", 0, 0},
    {1, 1, 0*0x08, ((void*)(long int)(3)), 0, trimFunc, 0, 0, "trim", 0, 0},
    {2, 1, 0*0x08, ((void*)(long int)(3)), 0, trimFunc, 0, 0, "trim", 0, 0},
    {-1, 1, 1*0x08, ((void*)(long int)(0)), 0, minmaxFunc, 0, 0, "min", 0, 0},
    {0, 1, 1*0x08, ((void*)(long int)(0)), 0, 0, 0, 0, "min", 0, 0},
    {1, 1, 1*0x08, ((void*)(long int)(0)), 0, 0, minmaxStep,minMaxFinalize,"min",0,0},
    {-1, 1, 1*0x08, ((void*)(long int)(1)), 0, minmaxFunc, 0, 0, "max", 0, 0},
    {0, 1, 1*0x08, ((void*)(long int)(1)), 0, 0, 0, 0, "max", 0, 0},
    {1, 1, 1*0x08, ((void*)(long int)(1)), 0, 0, minmaxStep,minMaxFinalize,"max",0,0},
    {1, 1, 0*0x08, ((void*)(long int)(0)), 0, typeofFunc, 0, 0, "typeof", 0, 0},
    {1, 1, 0*0x08, ((void*)(long int)(0)), 0, lengthFunc, 0, 0, "length", 0, 0},
    {2, 1, 0*0x08, ((void*)(long int)(0)), 0, substrFunc, 0, 0, "substr", 0, 0},
    {3, 1, 0*0x08, ((void*)(long int)(0)), 0, substrFunc, 0, 0, "substr", 0, 0},
    {1, 1, 0*0x08, ((void*)(long int)(0)), 0, absFunc, 0, 0, "abs", 0, 0},

    {1, 1, 0*0x08, ((void*)(long int)(0)), 0, roundFunc, 0, 0, "round", 0, 0},
    {2, 1, 0*0x08, ((void*)(long int)(0)), 0, roundFunc, 0, 0, "round", 0, 0},

    {1, 1, 0*0x08, ((void*)(long int)(0)), 0, upperFunc, 0, 0, "upper", 0, 0},
    {1, 1, 0*0x08, ((void*)(long int)(0)), 0, lowerFunc, 0, 0, "lower", 0, 0},
    {1, 1, 0*0x08, ((void*)(long int)(0)), 0, 0, 0, 0, "coalesce", 0, 0},
    {0, 1, 0*0x08, ((void*)(long int)(0)), 0, 0, 0, 0, "coalesce", 0, 0},

    {-1,1,0x40,0,0,versionFunc,0,0,"coalesce",0,0},
    {1, 1, 0*0x08, ((void*)(long int)(0)), 0, hexFunc, 0, 0, "hex", 0, 0},

    {2,1,0x40,0,0,versionFunc,0,0,"ifnull",0,0},
    {0, 1, 0*0x08, ((void*)(long int)(0)), 0, randomFunc, 0, 0, "random", 0, 0},
    {1, 1, 0*0x08, ((void*)(long int)(0)), 0, randomBlob, 0, 0, "randomblob", 0, 0},
    {2, 1, 1*0x08, ((void*)(long int)(0)), 0, nullifFunc, 0, 0, "nullif", 0, 0},
    {0, 1, 0*0x08, ((void*)(long int)(0)), 0, versionFunc, 0, 0, "sqlite_version", 0, 0},
    {0, 1, 0*0x08, ((void*)(long int)(0)), 0, sourceidFunc, 0, 0, "sqlite_source_id", 0, 0},

    {1, 1, 0*0x08, ((void*)(long int)(0)), 0, compileoptionusedFunc, 0, 0, "sqlite_compileoption_used", 0, 0},
    {1, 1, 0*0x08, ((void*)(long int)(0)), 0, compileoptiongetFunc, 0, 0, "sqlite_compileoption_get", 0, 0},

    {1, 1, 0*0x08, ((void*)(long int)(0)), 0, quoteFunc, 0, 0, "quote", 0, 0},
    {0, 1, 0*0x08, ((void*)(long int)(0)), 0, last_insert_rowid, 0, 0, "last_insert_rowid", 0, 0},
    {0, 1, 0*0x08, ((void*)(long int)(0)), 0, changes, 0, 0, "changes", 0, 0},
    {0, 1, 0*0x08, ((void*)(long int)(0)), 0, total_changes, 0, 0, "total_changes", 0, 0},
    {3, 1, 0*0x08, ((void*)(long int)(0)), 0, replaceFunc, 0, 0, "replace", 0, 0},
    {1, 1, 0*0x08, ((void*)(long int)(0)), 0, zeroblobFunc, 0, 0, "zeroblob", 0, 0},




    {1, 1, 0*0x08, ((void*)(long int)(0)), 0, loadExt, 0, 0, "load_extension", 0, 0},
    {2, 1, 0*0x08, ((void*)(long int)(0)), 0, loadExt, 0, 0, "load_extension", 0, 0},

    {1, 1, 0*0x08, ((void*)(long int)(0)), 0, 0, sumStep,sumFinalize,"sum",0,0},
    {1, 1, 0*0x08, ((void*)(long int)(0)), 0, 0, sumStep,totalFinalize,"total",0,0},
    {1, 1, 0*0x08, ((void*)(long int)(0)), 0, 0, sumStep,avgFinalize,"avg",0,0},

    {0,1,0x20,0,0,0,countStep,countFinalize,"count",0,0},
    {1, 1, 0*0x08, ((void*)(long int)(0)), 0, 0, countStep,countFinalize,"count",0,0},
    {1, 1, 0*0x08, ((void*)(long int)(0)), 0, 0, groupConcatStep,groupConcatFinalize,"group_concat",0,0},
    {2, 1, 0*0x08, ((void*)(long int)(0)), 0, 0, groupConcatStep,groupConcatFinalize,"group_concat",0,0},

    {2, 1, 0x01|0x02, (void *)&globInfo, 0, likeFunc, 0, 0, "glob", 0, 0},




    {2, 1, 0x01, (void *)&likeInfoNorm, 0, likeFunc, 0, 0, "like", 0, 0},
    {3, 1, 0x01, (void *)&likeInfoNorm, 0, likeFunc, 0, 0, "like", 0, 0},

  };

  int i;
  FuncDefHash *pHash = &sqlite3GlobalFunctions;
  FuncDef *aFunc = (FuncDef*)&aBuiltinFunc;

  for(i=0; i<((int)(sizeof(aBuiltinFunc)/sizeof(aBuiltinFunc[0]))); i++){
    sqlite3FuncDefInsert(pHash, &aFunc[i]);
  }
  sqlite3RegisterDateTimeFunctions();

  sqlite3AlterFunctions();

}
# 83352 "ext/sqlite3/libsqlite/sqlite3.c"
static int locateFkeyIndex(
  Parse *pParse,
  Table *pParent,
  FKey *pFKey,
  Index **ppIdx,
  int **paiCol
){
  Index *pIdx = 0;
  int *aiCol = 0;
  int nCol = pFKey->nCol;
  char *zKey = pFKey->aCol[0].zCol;


  ((void) (0));
  ((void) (0));
  ((void) (0));
# 83377 "ext/sqlite3/libsqlite/sqlite3.c"
  if( nCol==1 ){







    if( pParent->iPKey>=0 ){
      if( !zKey ) return 0;
      if( !sqlite3StrICmp(pParent->aCol[pParent->iPKey].zName, zKey) ) return 0;
    }
  }else if( paiCol ){
    ((void) (0));
    aiCol = (int *)sqlite3DbMallocRaw(pParse->db, nCol*sizeof(int));
    if( !aiCol ) return 1;
    *paiCol = aiCol;
  }

  for(pIdx=pParent->pIndex; pIdx; pIdx=pIdx->pNext){
    if( pIdx->nColumn==nCol && pIdx->onError!=0 ){




      if( zKey==0 ){



        if( pIdx->autoIndex==2 ){
          if( aiCol ){
            int i;
            for(i=0; i<nCol; i++) aiCol[i] = pFKey->aCol[i].iFrom;
          }
          break;
        }
      }else{




        int i, j;
        for(i=0; i<nCol; i++){
          int iCol = pIdx->aiColumn[i];
          char *zDfltColl;
          char *zIdxCol;




          zDfltColl = pParent->aCol[iCol].zColl;
          if( !zDfltColl ){
            zDfltColl = "BINARY";
          }
          if( sqlite3StrICmp(pIdx->azColl[i], zDfltColl) ) break;

          zIdxCol = pParent->aCol[iCol].zName;
          for(j=0; j<nCol; j++){
            if( sqlite3StrICmp(pFKey->aCol[j].zCol, zIdxCol)==0 ){
              if( aiCol ) aiCol[i] = pFKey->aCol[j].iFrom;
              break;
            }
          }
          if( j==nCol ) break;
        }
        if( i==nCol ) break;
      }
    }
  }

  if( !pIdx ){
    if( !pParse->disableTriggers ){
      sqlite3ErrorMsg(pParse, "foreign key mismatch");
    }
    sqlite3DbFree(pParse->db, aiCol);
    return 1;
  }

  *ppIdx = pIdx;
  return 0;
}
# 83485 "ext/sqlite3/libsqlite/sqlite3.c"
static void fkLookupParent(
  Parse *pParse,
  int iDb,
  Table *pTab,
  Index *pIdx,
  FKey *pFKey,
  int *aiCol,
  int regData,
  int nIncr,
  int isIgnore
){
  int i;
  Vdbe *v = sqlite3GetVdbe(pParse);
  int iCur = pParse->nTab - 1;
  int iOk = sqlite3VdbeMakeLabel(v);
# 83508 "ext/sqlite3/libsqlite/sqlite3.c"
  if( nIncr<0 ){
    sqlite3VdbeAddOp2(v, 111, pFKey->isDeferred, iOk);
  }
  for(i=0; i<pFKey->nCol; i++){
    int iReg = aiCol[i] + regData + 1;
    sqlite3VdbeAddOp2(v, 73, iReg, iOk);
  }

  if( isIgnore==0 ){
    if( pIdx==0 ){


      int iMustBeInt;
      int regTemp = sqlite3GetTempReg(pParse);






      sqlite3VdbeAddOp2(v, 15, aiCol[0]+1+regData, regTemp);
      iMustBeInt = sqlite3VdbeAddOp2(v, 21, regTemp, 0);





      if( pTab==pFKey->pFrom && nIncr==1 ){
        sqlite3VdbeAddOp3(v, 76, regData, iOk, regTemp);
      }

      sqlite3OpenTable(pParse, iCur, iDb, pTab, 38);
      sqlite3VdbeAddOp3(v, 52, iCur, 0, regTemp);
      sqlite3VdbeAddOp2(v, 1, 0, iOk);
      sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);
      sqlite3VdbeJumpHere(v, iMustBeInt);
      sqlite3ReleaseTempReg(pParse, regTemp);
    }else{
      int nCol = pFKey->nCol;
      int regTemp = sqlite3GetTempRange(pParse, nCol);
      int regRec = sqlite3GetTempReg(pParse);
      KeyInfo *pKey = sqlite3IndexKeyinfo(pParse, pIdx);

      sqlite3VdbeAddOp3(v, 38, iCur, pIdx->tnum, iDb);
      sqlite3VdbeChangeP4(v, -1, (char*)pKey, (-16));
      for(i=0; i<nCol; i++){
        sqlite3VdbeAddOp2(v, 14, aiCol[i]+1+regData, regTemp+i);
      }





      if( pTab==pFKey->pFrom && nIncr==1 ){
        int iJump = sqlite3VdbeCurrentAddr(v) + nCol + 1;
        for(i=0; i<nCol; i++){
          int iChild = aiCol[i]+1+regData;
          int iParent = pIdx->aiColumn[i]+1+regData;
          sqlite3VdbeAddOp3(v, 75, iChild, iJump, iParent);
        }
        sqlite3VdbeAddOp2(v, 1, 0, iOk);
      }

      sqlite3VdbeAddOp3(v, 30, regTemp, nCol, regRec);
      sqlite3VdbeChangeP4(v, -1, sqlite3IndexAffinityStr(v,pIdx), 0);
      sqlite3VdbeAddOp4Int(v, 50, iCur, iOk, regRec, 0);

      sqlite3ReleaseTempReg(pParse, regRec);
      sqlite3ReleaseTempRange(pParse, regTemp, nCol);
    }
  }

  if( !pFKey->isDeferred && !pParse->pToplevel && !pParse->isMultiWrite ){




    ((void) (0));
    sqlite3HaltConstraint(
        pParse, 2, "foreign key constraint failed", (-2)
    );
  }else{
    if( nIncr>0 && pFKey->isDeferred==0 ){
      ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse))->mayAbort = 1;
    }
    sqlite3VdbeAddOp2(v, 110, pFKey->isDeferred, nIncr);
  }

  sqlite3VdbeResolveLabel(v, iOk);
  sqlite3VdbeAddOp1(v, 43, iCur);
}
# 83628 "ext/sqlite3/libsqlite/sqlite3.c"
static void fkScanChildren(
  Parse *pParse,
  SrcList *pSrc,
  Table *pTab,
  Index *pIdx,
  FKey *pFKey,
  int *aiCol,
  int regData,
  int nIncr
){
  sqlite3 *db = pParse->db;
  int i;
  Expr *pWhere = 0;
  NameContext sNameContext;
  WhereInfo *pWInfo;
  int iFkIfZero = 0;
  Vdbe *v = sqlite3GetVdbe(pParse);

  ((void) (0));

  if( nIncr<0 ){
    iFkIfZero = sqlite3VdbeAddOp2(v, 111, pFKey->isDeferred, 0);
  }
# 83660 "ext/sqlite3/libsqlite/sqlite3.c"
  for(i=0; i<pFKey->nCol; i++){
    Expr *pLeft;
    Expr *pRight;
    Expr *pEq;
    int iCol;
    const char *zCol;

    pLeft = sqlite3Expr(db, 132, 0);
    if( pLeft ){


      if( pIdx ){
        Column *pCol;
        iCol = pIdx->aiColumn[i];
        pCol = &pTab->aCol[iCol];
        if( pTab->iPKey==iCol ) iCol = -1;
        pLeft->iTable = regData+iCol+1;
        pLeft->affinity = pCol->affinity;
        pLeft->pColl = sqlite3LocateCollSeq(pParse, pCol->zColl);
      }else{
        pLeft->iTable = regData;
        pLeft->affinity = 'd';
      }
    }
    iCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;
    ((void) (0));
    zCol = pFKey->pFrom->aCol[iCol].zName;
    pRight = sqlite3Expr(db, 26, zCol);
    pEq = sqlite3PExpr(pParse, 76, pLeft, pRight, 0);
    pWhere = sqlite3ExprAnd(db, pWhere, pEq);
  }





  if( pTab==pFKey->pFrom && nIncr>0 ){
    Expr *pEq;
    Expr *pLeft;
    Expr *pRight;
    pLeft = sqlite3Expr(db, 132, 0);
    pRight = sqlite3Expr(db, 152, 0);
    if( pLeft && pRight ){
      pLeft->iTable = regData;
      pLeft->affinity = 'd';
      pRight->iTable = pSrc->a[0].iCursor;
      pRight->iColumn = -1;
    }
    pEq = sqlite3PExpr(pParse, 75, pLeft, pRight, 0);
    pWhere = sqlite3ExprAnd(db, pWhere, pEq);
  }


  memset(&sNameContext, 0, sizeof(NameContext));
  sNameContext.pSrcList = pSrc;
  sNameContext.pParse = pParse;
  sqlite3ResolveExprNames(&sNameContext, pWhere);





  pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, 0, 0);
  if( nIncr>0 && pFKey->isDeferred==0 ){
    ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse))->mayAbort = 1;
  }
  sqlite3VdbeAddOp2(v, 110, pFKey->isDeferred, nIncr);
  if( pWInfo ){
    sqlite3WhereEnd(pWInfo);
  }


  sqlite3ExprDelete(db, pWhere);
  if( iFkIfZero ){
    sqlite3VdbeJumpHere(v, iFkIfZero);
  }
}
# 83752 "ext/sqlite3/libsqlite/sqlite3.c"
static FKey *sqlite3FkReferences(Table *pTab){
  int nName = sqlite3Strlen30(pTab->zName);
  return (FKey *)sqlite3HashFind(&pTab->pSchema->fkeyHash, pTab->zName, nName);
}
# 83765 "ext/sqlite3/libsqlite/sqlite3.c"
static void fkTriggerDelete(sqlite3 *dbMem, Trigger *p){
  if( p ){
    TriggerStep *pStep = p->step_list;
    sqlite3ExprDelete(dbMem, pStep->pWhere);
    sqlite3ExprListDelete(dbMem, pStep->pExprList);
    sqlite3SelectDelete(dbMem, pStep->pSelect);
    sqlite3ExprDelete(dbMem, p->pWhen);
    sqlite3DbFree(dbMem, p);
  }
}
# 83793 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3FkDropTable(Parse *pParse, SrcList *pName, Table *pTab){
  sqlite3 *db = pParse->db;
  if( (db->flags&0x04000000) && !(((pTab)->tabFlags & 0x10)!=0) && !pTab->pSelect ){
    int iSkip = 0;
    Vdbe *v = sqlite3GetVdbe(pParse);

    ((void) (0));
    if( sqlite3FkReferences(pTab)==0 ){





      FKey *p;
      for(p=pTab->pFKey; p; p=p->pNextFrom){
        if( p->isDeferred ) break;
      }
      if( !p ) return;
      iSkip = sqlite3VdbeMakeLabel(v);
      sqlite3VdbeAddOp2(v, 111, 1, iSkip);
    }

    pParse->disableTriggers = 1;
    sqlite3DeleteFrom(pParse, sqlite3SrcListDup(db, pName, 0), 0);
    pParse->disableTriggers = 0;





    sqlite3VdbeAddOp2(v, 111, 0, sqlite3VdbeCurrentAddr(v)+2);
    sqlite3HaltConstraint(
        pParse, 2, "foreign key constraint failed", (-2)
    );

    if( iSkip ){
      sqlite3VdbeResolveLabel(v, iSkip);
    }
  }
}
# 83854 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3FkCheck(
  Parse *pParse,
  Table *pTab,
  int regOld,
  int regNew
){
  sqlite3 *db = pParse->db;
  FKey *pFKey;
  int iDb;
  const char *zDb;
  int isIgnoreErrors = pParse->disableTriggers;


  ((void) (0));


  if( (db->flags&0x04000000)==0 ) return;

  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  zDb = db->aDb[iDb].zName;



  for(pFKey=pTab->pFKey; pFKey; pFKey=pFKey->pNextFrom){
    Table *pTo;
    Index *pIdx = 0;
    int *aiFree = 0;
    int *aiCol;
    int iCol;
    int i;
    int isIgnore = 0;





    if( pParse->disableTriggers ){
      pTo = sqlite3FindTable(db, pFKey->zTo, zDb);
    }else{
      pTo = sqlite3LocateTable(pParse, 0, pFKey->zTo, zDb);
    }
    if( !pTo || locateFkeyIndex(pParse, pTo, pFKey, &pIdx, &aiFree) ){
      if( !isIgnoreErrors || db->mallocFailed ) return;
      continue;
    }
    ((void) (0));

    if( aiFree ){
      aiCol = aiFree;
    }else{
      iCol = pFKey->aCol[0].iFrom;
      aiCol = &iCol;
    }
    for(i=0; i<pFKey->nCol; i++){
      if( aiCol[i]==pTab->iPKey ){
        aiCol[i] = -1;
      }




      if( db->xAuth ){
        int rcauth;
        char *zCol = pTo->aCol[pIdx ? pIdx->aiColumn[i] : pTo->iPKey].zName;
        rcauth = sqlite3AuthReadCol(pParse, pTo->zName, zCol, iDb);
        isIgnore = (rcauth==2);
      }

    }




    sqlite3TableLock(pParse, iDb, pTo->tnum, 0, pTo->zName);
    pParse->nTab++;

    if( regOld!=0 ){



      fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regOld, -1,isIgnore);
    }
    if( regNew!=0 ){


      fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regNew, +1,isIgnore);
    }

    sqlite3DbFree(db, aiFree);
  }


  for(pFKey = sqlite3FkReferences(pTab); pFKey; pFKey=pFKey->pNextTo){
    Index *pIdx = 0;
    SrcList *pSrc;
    int *aiCol = 0;

    if( !pFKey->isDeferred && !pParse->pToplevel && !pParse->isMultiWrite ){
      ((void) (0));


      continue;
    }

    if( locateFkeyIndex(pParse, pTab, pFKey, &pIdx, &aiCol) ){
      if( !isIgnoreErrors || db->mallocFailed ) return;
      continue;
    }
    ((void) (0));




    pSrc = sqlite3SrcListAppend(db, 0, 0, 0);
    if( pSrc ){
      struct SrcList_item *pItem = pSrc->a;
      pItem->pTab = pFKey->pFrom;
      pItem->zName = pFKey->pFrom->zName;
      pItem->pTab->nRef++;
      pItem->iCursor = pParse->nTab++;

      if( regNew!=0 ){
        fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regNew, -1);
      }
      if( regOld!=0 ){






        fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regOld, 1);
      }
      pItem->zName = 0;
      sqlite3SrcListDelete(db, pSrc);
    }
    sqlite3DbFree(db, aiCol);
  }
}







static u32 sqlite3FkOldmask(
  Parse *pParse,
  Table *pTab
){
  u32 mask = 0;
  if( pParse->db->flags&0x04000000 ){
    FKey *p;
    int i;
    for(p=pTab->pFKey; p; p=p->pNextFrom){
      for(i=0; i<p->nCol; i++) mask |= (((p->aCol[i].iFrom)>31) ? 0xffffffff : ((u32)1<<(p->aCol[i].iFrom)));
    }
    for(p=sqlite3FkReferences(pTab); p; p=p->pNextTo){
      Index *pIdx = 0;
      locateFkeyIndex(pParse, pTab, p, &pIdx, 0);
      if( pIdx ){
        for(i=0; i<pIdx->nColumn; i++) mask |= (((pIdx->aiColumn[i])>31) ? 0xffffffff : ((u32)1<<(pIdx->aiColumn[i])));
      }
    }
  }
  return mask;
}
# 84036 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3FkRequired(
  Parse *pParse,
  Table *pTab,
  int *aChange,
  int chngRowid
){
  if( pParse->db->flags&0x04000000 ){
    if( !aChange ){



      return (sqlite3FkReferences(pTab) || pTab->pFKey);
    }else{


      int i;
      FKey *p;


      for(p=pTab->pFKey; p; p=p->pNextFrom){
        for(i=0; i<p->nCol; i++){
          int iChildKey = p->aCol[i].iFrom;
          if( aChange[iChildKey]>=0 ) return 1;
          if( iChildKey==pTab->iPKey && chngRowid ) return 1;
        }
      }


      for(p=sqlite3FkReferences(pTab); p; p=p->pNextTo){
        for(i=0; i<p->nCol; i++){
          char *zKey = p->aCol[i].zCol;
          int iKey;
          for(iKey=0; iKey<pTab->nCol; iKey++){
            Column *pCol = &pTab->aCol[iKey];
            if( (zKey ? !sqlite3StrICmp(pCol->zName, zKey) : pCol->isPrimKey) ){
              if( aChange[iKey]>=0 ) return 1;
              if( iKey==pTab->iPKey && chngRowid ) return 1;
            }
          }
        }
      }
    }
  }
  return 0;
}
# 84111 "ext/sqlite3/libsqlite/sqlite3.c"
static Trigger *fkActionTrigger(
  Parse *pParse,
  Table *pTab,
  FKey *pFKey,
  ExprList *pChanges
){
  sqlite3 *db = pParse->db;
  int action;
  Trigger *pTrigger;
  int iAction = (pChanges!=0);

  action = pFKey->aAction[iAction];
  pTrigger = pFKey->apTrigger[iAction];

  if( action!=0 && !pTrigger ){
    u8 enableLookaside;
    char const *zFrom;
    int nFrom;
    Index *pIdx = 0;
    int *aiCol = 0;
    TriggerStep *pStep = 0;
    Expr *pWhere = 0;
    ExprList *pList = 0;
    Select *pSelect = 0;
    int i;
    Expr *pWhen = 0;

    if( locateFkeyIndex(pParse, pTab, pFKey, &pIdx, &aiCol) ) return 0;
    ((void) (0));

    for(i=0; i<pFKey->nCol; i++){
      Token tOld = { "old", 3 };
      Token tNew = { "new", 3 };
      Token tFromCol;
      Token tToCol;
      int iFromCol;
      Expr *pEq;

      iFromCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;
      ((void) (0));
      tToCol.z = pIdx ? pTab->aCol[pIdx->aiColumn[i]].zName : "oid";
      tFromCol.z = pFKey->pFrom->aCol[iFromCol].zName;

      tToCol.n = sqlite3Strlen30(tToCol.z);
      tFromCol.n = sqlite3Strlen30(tFromCol.z);





      pEq = sqlite3PExpr(pParse, 76,
          sqlite3PExpr(pParse, 118,
            sqlite3PExpr(pParse, 26, 0, 0, &tOld),
            sqlite3PExpr(pParse, 26, 0, 0, &tToCol)
          , 0),
          sqlite3PExpr(pParse, 26, 0, 0, &tFromCol)
      , 0);
      pWhere = sqlite3ExprAnd(db, pWhere, pEq);






      if( pChanges ){
        pEq = sqlite3PExpr(pParse, 70,
            sqlite3PExpr(pParse, 118,
              sqlite3PExpr(pParse, 26, 0, 0, &tOld),
              sqlite3PExpr(pParse, 26, 0, 0, &tToCol),
              0),
            sqlite3PExpr(pParse, 118,
              sqlite3PExpr(pParse, 26, 0, 0, &tNew),
              sqlite3PExpr(pParse, 26, 0, 0, &tToCol),
              0),
            0);
        pWhen = sqlite3ExprAnd(db, pWhen, pEq);
      }

      if( action!=6 && (action!=9 || pChanges) ){
        Expr *pNew;
        if( action==9 ){
          pNew = sqlite3PExpr(pParse, 118,
            sqlite3PExpr(pParse, 26, 0, 0, &tNew),
            sqlite3PExpr(pParse, 26, 0, 0, &tToCol)
          , 0);
        }else if( action==8 ){
          Expr *pDflt = pFKey->pFrom->aCol[iFromCol].pDflt;
          if( pDflt ){
            pNew = sqlite3ExprDup(db, pDflt, 0);
          }else{
            pNew = sqlite3PExpr(pParse, 98, 0, 0, 0);
          }
        }else{
          pNew = sqlite3PExpr(pParse, 98, 0, 0, 0);
        }
        pList = sqlite3ExprListAppend(pParse, pList, pNew);
        sqlite3ExprListSetName(pParse, pList, &tFromCol, 0);
      }
    }
    sqlite3DbFree(db, aiCol);

    zFrom = pFKey->pFrom->zName;
    nFrom = sqlite3Strlen30(zFrom);

    if( action==6 ){
      Token tFrom;
      Expr *pRaise;

      tFrom.z = zFrom;
      tFrom.n = nFrom;
      pRaise = sqlite3Expr(db, 56, "foreign key constraint failed");
      if( pRaise ){
        pRaise->affinity = 2;
      }
      pSelect = sqlite3SelectNew(pParse,
          sqlite3ExprListAppend(pParse, 0, pRaise),
          sqlite3SrcListAppend(db, 0, &tFrom, 0),
          pWhere,
          0, 0, 0, 0, 0, 0
      );
      pWhere = 0;
    }


    enableLookaside = db->lookaside.bEnabled;
    db->lookaside.bEnabled = 0;

    pTrigger = (Trigger *)sqlite3DbMallocZero(db,
        sizeof(Trigger) +
        sizeof(TriggerStep) +
        nFrom + 1
    );
    if( pTrigger ){
      pStep = pTrigger->step_list = (TriggerStep *)&pTrigger[1];
      pStep->target.z = (char *)&pStep[1];
      pStep->target.n = nFrom;
      memcpy((char *)pStep->target.z, zFrom, nFrom);

      pStep->pWhere = sqlite3ExprDup(db, pWhere, 0x0001);
      pStep->pExprList = sqlite3ExprListDup(db, pList, 0x0001);
      pStep->pSelect = sqlite3SelectDup(db, pSelect, 0x0001);
      if( pWhen ){
        pWhen = sqlite3PExpr(pParse, 19, pWhen, 0, 0);
        pTrigger->pWhen = sqlite3ExprDup(db, pWhen, 0x0001);
      }
    }


    db->lookaside.bEnabled = enableLookaside;

    sqlite3ExprDelete(db, pWhere);
    sqlite3ExprDelete(db, pWhen);
    sqlite3ExprListDelete(db, pList);
    sqlite3SelectDelete(db, pSelect);
    if( db->mallocFailed==1 ){
      fkTriggerDelete(db, pTrigger);
      return 0;
    }

    switch( action ){
      case 6:
        pStep->op = 116;
        break;
      case 9:
        if( !pChanges ){
          pStep->op = 106;
          break;
        }
      default:
        pStep->op = 107;
    }
    pStep->pTrig = pTrigger;
    pTrigger->pSchema = pTab->pSchema;
    pTrigger->pTabSchema = pTab->pSchema;
    pFKey->apTrigger[iAction] = pTrigger;
    pTrigger->op = (pChanges ? 107 : 106);
  }

  return pTrigger;
}





static void sqlite3FkActions(
  Parse *pParse,
  Table *pTab,
  ExprList *pChanges,
  int regOld
){




  if( pParse->db->flags&0x04000000 ){
    FKey *pFKey;
    for(pFKey = sqlite3FkReferences(pTab); pFKey; pFKey=pFKey->pNextTo){
      Trigger *pAction = fkActionTrigger(pParse, pTab, pFKey, pChanges);
      if( pAction ){
        sqlite3CodeRowTriggerDirect(pParse, pAction, pTab, regOld, 2, 0);
      }
    }
  }
}
# 84324 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3FkDelete(sqlite3 *db, Table *pTab){
  FKey *pFKey;
  FKey *pNext;

  ((void) (0));
  for(pFKey=pTab->pFKey; pFKey; pFKey=pNext){


    if( !db || db->pnBytesFreed==0 ){
      if( pFKey->pPrevTo ){
        pFKey->pPrevTo->pNextTo = pFKey->pNextTo;
      }else{
        void *p = (void *)pFKey->pNextTo;
        const char *z = (p ? pFKey->pNextTo->zTo : pFKey->zTo);
        sqlite3HashInsert(&pTab->pSchema->fkeyHash, z, sqlite3Strlen30(z), p);
      }
      if( pFKey->pNextTo ){
        pFKey->pNextTo->pPrevTo = pFKey->pPrevTo;
      }
    }




    ((void) (0));



    fkTriggerDelete(db, pFKey->apTrigger[0]);
    fkTriggerDelete(db, pFKey->apTrigger[1]);


    pNext = pFKey->pNextFrom;
    sqlite3DbFree(db, pFKey);
  }
}
# 84382 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3OpenTable(
  Parse *p,
  int iCur,
  int iDb,
  Table *pTab,
  int opcode
){
  Vdbe *v;
  if( (((pTab)->tabFlags & 0x10)!=0) ) return;
  v = sqlite3GetVdbe(p);
  ((void) (0));
  sqlite3TableLock(p, iDb, pTab->tnum, (opcode==39)?1:0, pTab->zName);
  sqlite3VdbeAddOp3(v, opcode, iCur, pTab->tnum, iDb);
  sqlite3VdbeChangeP4(v, -1, ((void*)(long int)(pTab->nCol)), (-14));
                                     ;
}
# 84419 "ext/sqlite3/libsqlite/sqlite3.c"
static const char *sqlite3IndexAffinityStr(Vdbe *v, Index *pIdx){
  if( !pIdx->zColAff ){
# 84429 "ext/sqlite3/libsqlite/sqlite3.c"
    int n;
    Table *pTab = pIdx->pTable;
    sqlite3 *db = sqlite3VdbeDb(v);
    pIdx->zColAff = (char *)sqlite3DbMallocRaw(0, pIdx->nColumn+2);
    if( !pIdx->zColAff ){
      db->mallocFailed = 1;
      return 0;
    }
    for(n=0; n<pIdx->nColumn; n++){
      pIdx->zColAff[n] = pTab->aCol[pIdx->aiColumn[n]].affinity;
    }
    pIdx->zColAff[n++] = 'b';
    pIdx->zColAff[n] = 0;
  }

  return pIdx->zColAff;
}
# 84461 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3TableAffinityStr(Vdbe *v, Table *pTab){







  if( !pTab->zColAff ){
    char *zColAff;
    int i;
    sqlite3 *db = sqlite3VdbeDb(v);

    zColAff = (char *)sqlite3DbMallocRaw(0, pTab->nCol+1);
    if( !zColAff ){
      db->mallocFailed = 1;
      return;
    }

    for(i=0; i<pTab->nCol; i++){
      zColAff[i] = pTab->aCol[i].affinity;
    }
    zColAff[pTab->nCol] = '\0';

    pTab->zColAff = zColAff;
  }

  sqlite3VdbeChangeP4(v, -1, pTab->zColAff, 0);
}
# 84498 "ext/sqlite3/libsqlite/sqlite3.c"
static int readsTable(Parse *p, int iStartAddr, int iDb, Table *pTab){
  Vdbe *v = sqlite3GetVdbe(p);
  int i;
  int iEnd = sqlite3VdbeCurrentAddr(v);

  VTable *pVTab = (((pTab)->tabFlags & 0x10)!=0) ? sqlite3GetVTable(p->db, pTab) : 0;


  for(i=iStartAddr; i<iEnd; i++){
    VdbeOp *pOp = sqlite3VdbeGetOp(v, i);
    ((void) (0));
    if( pOp->opcode==38 && pOp->p3==iDb ){
      Index *pIndex;
      int tnum = pOp->p2;
      if( tnum==pTab->tnum ){
        return 1;
      }
      for(pIndex=pTab->pIndex; pIndex; pIndex=pIndex->pNext){
        if( tnum==pIndex->tnum ){
          return 1;
        }
      }
    }

    if( pOp->opcode==127 && pOp->p4.pVtab==pVTab ){
      ((void) (0));
      ((void) (0));
      return 1;
    }

  }
  return 0;
}
# 84553 "ext/sqlite3/libsqlite/sqlite3.c"
static int autoIncBegin(
  Parse *pParse,
  int iDb,
  Table *pTab
){
  int memId = 0;
  if( pTab->tabFlags & 0x08 ){
    Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
    AutoincInfo *pInfo;

    pInfo = pToplevel->pAinc;
    while( pInfo && pInfo->pTab!=pTab ){ pInfo = pInfo->pNext; }
    if( pInfo==0 ){
      pInfo = sqlite3DbMallocRaw(pParse->db, sizeof(*pInfo));
      if( pInfo==0 ) return 0;
      pInfo->pNext = pToplevel->pAinc;
      pToplevel->pAinc = pInfo;
      pInfo->pTab = pTab;
      pInfo->iDb = iDb;
      pToplevel->nMem++;
      pInfo->regCtr = ++pToplevel->nMem;
      pToplevel->nMem++;
    }
    memId = pInfo->regCtr;
  }
  return memId;
}





static void sqlite3AutoincrementBegin(Parse *pParse){
  AutoincInfo *p;
  sqlite3 *db = pParse->db;
  Db *pDb;
  int memId;
  int addr;
  Vdbe *v = pParse->pVdbe;



  ((void) (0));
  ((void) (0));

  ((void) (0));
  for(p = pParse->pAinc; p; p = p->pNext){
    pDb = &db->aDb[p->iDb];
    memId = p->regCtr;
    ((void) (0));
    sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, 38);
    addr = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeAddOp4(v, 94, 0, memId-1, 0, p->pTab->zName, 0);
    sqlite3VdbeAddOp2(v, 65, 0, addr+9);
    sqlite3VdbeAddOp3(v, 28, 0, 0, memId);
    sqlite3VdbeAddOp3(v, 75, memId-1, addr+7, memId);
    sqlite3VdbeChangeP5(v, 0x08);
    sqlite3VdbeAddOp2(v, 61, 0, memId+1);
    sqlite3VdbeAddOp3(v, 28, 0, 1, memId);
    sqlite3VdbeAddOp2(v, 1, 0, addr+9);
    sqlite3VdbeAddOp2(v, 67, 0, addr+2);
    sqlite3VdbeAddOp2(v, 7, 0, memId);
    sqlite3VdbeAddOp0(v, 43);
  }
}
# 84627 "ext/sqlite3/libsqlite/sqlite3.c"
static void autoIncStep(Parse *pParse, int memId, int regRowid){
  if( memId>0 ){
    sqlite3VdbeAddOp2(pParse->pVdbe, 112, memId, regRowid);
  }
}
# 84640 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3AutoincrementEnd(Parse *pParse){
  AutoincInfo *p;
  Vdbe *v = pParse->pVdbe;
  sqlite3 *db = pParse->db;

  ((void) (0));
  for(p = pParse->pAinc; p; p = p->pNext){
    Db *pDb = &db->aDb[p->iDb];
    int j1, j2, j3, j4, j5;
    int iRec;
    int memId = p->regCtr;

    iRec = sqlite3GetTempReg(pParse);
    ((void) (0));
    sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, 39);
    j1 = sqlite3VdbeAddOp1(v, 74, memId+1);
    j2 = sqlite3VdbeAddOp0(v, 65);
    j3 = sqlite3VdbeAddOp3(v, 28, 0, 0, iRec);
    j4 = sqlite3VdbeAddOp3(v, 76, memId-1, 0, iRec);
    sqlite3VdbeAddOp2(v, 67, 0, j3);
    sqlite3VdbeJumpHere(v, j2);
    sqlite3VdbeAddOp2(v, 54, 0, memId+1);
    j5 = sqlite3VdbeAddOp0(v, 1);
    sqlite3VdbeJumpHere(v, j4);
    sqlite3VdbeAddOp2(v, 61, 0, memId+1);
    sqlite3VdbeJumpHere(v, j1);
    sqlite3VdbeJumpHere(v, j5);
    sqlite3VdbeAddOp3(v, 30, memId-1, 2, iRec);
    sqlite3VdbeAddOp3(v, 55, 0, iRec, memId+1);
    sqlite3VdbeChangeP5(v, 0x08);
    sqlite3VdbeAddOp0(v, 43);
    sqlite3ReleaseTempReg(pParse, iRec);
  }
}
# 84685 "ext/sqlite3/libsqlite/sqlite3.c"
static int xferOptimization(
  Parse *pParse,
  Table *pDest,
  Select *pSelect,
  int onError,
  int iDbDest
);
# 84795 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3Insert(
  Parse *pParse,
  SrcList *pTabList,
  ExprList *pList,
  Select *pSelect,
  IdList *pColumn,
  int onError
){
  sqlite3 *db;
  Table *pTab;
  char *zTab;
  const char *zDb;
  int i, j, idx;
  Vdbe *v;
  Index *pIdx;
  int nColumn;
  int nHidden = 0;
  int baseCur = 0;
  int keyColumn = -1;
  int endOfLoop;
  int useTempTable = 0;
  int srcTab = 0;
  int addrInsTop = 0;
  int addrCont = 0;
  int addrSelect = 0;
  SelectDest dest;
  int iDb;
  Db *pDb;
  int appendFlag = 0;


  int regFromSelect = 0;
  int regAutoinc = 0;
  int regRowCount = 0;
  int regIns;
  int regRowid;
  int regData;
  int regEof = 0;
  int *aRegIdx = 0;


  int isView;
  Trigger *pTrigger;
  int tmask;


  db = pParse->db;
  memset(&dest, 0, sizeof(dest));
  if( pParse->nErr || db->mallocFailed ){
    goto insert_cleanup;
  }



  ((void) (0));
  zTab = pTabList->a[0].zName;
  if( (zTab==0) ) goto insert_cleanup;
  pTab = sqlite3SrcListLookup(pParse, pTabList);
  if( pTab==0 ){
    goto insert_cleanup;
  }
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  ((void) (0));
  pDb = &db->aDb[iDb];
  zDb = pDb->zName;
  if( sqlite3AuthCheck(pParse, 18, pTab->zName, 0, zDb) ){
    goto insert_cleanup;
  }





  pTrigger = sqlite3TriggersExist(pParse, pTab, 105, 0, &tmask);
  isView = pTab->pSelect!=0;
# 84879 "ext/sqlite3/libsqlite/sqlite3.c"
  ((void) (0));





  if( sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto insert_cleanup;
  }





  if( sqlite3IsReadOnly(pParse, pTab, tmask) ){
    goto insert_cleanup;
  }



  v = sqlite3GetVdbe(pParse);
  if( v==0 ) goto insert_cleanup;
  if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);
  sqlite3BeginWriteOperation(pParse, pSelect || pTrigger, iDb);
# 84914 "ext/sqlite3/libsqlite/sqlite3.c"
  if( pColumn==0 && xferOptimization(pParse, pTab, pSelect, onError, iDb) ){
    ((void) (0));
    ((void) (0));
    goto insert_end;
  }





  regAutoinc = autoIncBegin(pParse, iDb, pTab);






  if( pSelect ){
# 84954 "ext/sqlite3/libsqlite/sqlite3.c"
    int rc, j1;

    regEof = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 7, 0, regEof);
                                       ;
    sqlite3SelectDestInit(&dest, 10, ++pParse->nMem);
    addrSelect = sqlite3VdbeCurrentAddr(v)+2;
    sqlite3VdbeAddOp2(v, 7, addrSelect-1, dest.iParm);
    j1 = sqlite3VdbeAddOp2(v, 1, 0, 0);
                                                  ;


    rc = sqlite3Select(pParse, pSelect, &dest);
    ((void) (0));
    if( rc || (pParse->nErr) || db->mallocFailed ){
      goto insert_cleanup;
    }
    sqlite3VdbeAddOp2(v, 7, 1, regEof);
    sqlite3VdbeAddOp1(v, 4, dest.iParm);
    sqlite3VdbeAddOp2(v, 6, 2, 2);
                                               ;
    sqlite3VdbeJumpHere(v, j1);

    regFromSelect = dest.iMem;
    ((void) (0));
    nColumn = pSelect->pEList->nExpr;
    ((void) (0));
# 84991 "ext/sqlite3/libsqlite/sqlite3.c"
    if( pTrigger || readsTable(pParse, addrSelect, iDb, pTab) ){
      useTempTable = 1;
    }

    if( useTempTable ){
# 85007 "ext/sqlite3/libsqlite/sqlite3.c"
      int regRec;
      int regTempRowid;
      int addrTop;
      int addrIf;

      srcTab = pParse->nTab++;
      regRec = sqlite3GetTempReg(pParse);
      regTempRowid = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp2(v, 41, srcTab, nColumn);
      addrTop = sqlite3VdbeAddOp1(v, 4, dest.iParm);
      addrIf = sqlite3VdbeAddOp1(v, 26, regEof);
      sqlite3VdbeAddOp3(v, 30, regFromSelect, nColumn, regRec);
      sqlite3VdbeAddOp2(v, 54, srcTab, regTempRowid);
      sqlite3VdbeAddOp3(v, 55, srcTab, regRec, regTempRowid);
      sqlite3VdbeAddOp2(v, 1, 0, addrTop);
      sqlite3VdbeJumpHere(v, addrIf);
      sqlite3ReleaseTempReg(pParse, regRec);
      sqlite3ReleaseTempReg(pParse, regTempRowid);
    }
  }else{



    NameContext sNC;
    memset(&sNC, 0, sizeof(sNC));
    sNC.pParse = pParse;
    srcTab = -1;
    ((void) (0));
    nColumn = pList ? pList->nExpr : 0;
    for(i=0; i<nColumn; i++){
      if( sqlite3ResolveExprNames(&sNC, pList->a[i].pExpr) ){
        goto insert_cleanup;
      }
    }
  }




  if( (((pTab)->tabFlags & 0x10)!=0) ){
    for(i=0; i<pTab->nCol; i++){
      nHidden += (((&pTab->aCol[i])->isHidden) ? 1 : 0);
    }
  }
  if( pColumn==0 && nColumn && nColumn!=(pTab->nCol-nHidden) ){
    sqlite3ErrorMsg(pParse,
       "table %S has %d columns but %d values were supplied",
       pTabList, 0, pTab->nCol-nHidden, nColumn);
    goto insert_cleanup;
  }
  if( pColumn!=0 && nColumn!=pColumn->nId ){
    sqlite3ErrorMsg(pParse, "%d values for %d columns", nColumn, pColumn->nId);
    goto insert_cleanup;
  }
# 85073 "ext/sqlite3/libsqlite/sqlite3.c"
  if( pColumn ){
    for(i=0; i<pColumn->nId; i++){
      pColumn->a[i].idx = -1;
    }
    for(i=0; i<pColumn->nId; i++){
      for(j=0; j<pTab->nCol; j++){
        if( sqlite3StrICmp(pColumn->a[i].zName, pTab->aCol[j].zName)==0 ){
          pColumn->a[i].idx = j;
          if( j==pTab->iPKey ){
            keyColumn = i;
          }
          break;
        }
      }
      if( j>=pTab->nCol ){
        if( sqlite3IsRowid(pColumn->a[i].zName) ){
          keyColumn = i;
        }else{
          sqlite3ErrorMsg(pParse, "table %S has no column named %s",
              pTabList, 0, pColumn->a[i].zName);
          pParse->checkSchema = 1;
          goto insert_cleanup;
        }
      }
    }
  }





  if( pColumn==0 && nColumn>0 ){
    keyColumn = pTab->iPKey;
  }



  if( db->flags & 0x00001000 ){
    regRowCount = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 7, 0, regRowCount);
  }


  if( !isView ){
    int nIdx;

    baseCur = pParse->nTab;
    nIdx = sqlite3OpenTableAndIndices(pParse, pTab, baseCur, 39);
    aRegIdx = sqlite3DbMallocRaw(db, sizeof(int)*(nIdx+1));
    if( aRegIdx==0 ){
      goto insert_cleanup;
    }
    for(i=0; i<nIdx; i++){
      aRegIdx[i] = ++pParse->nMem;
    }
  }


  if( useTempTable ){
# 85141 "ext/sqlite3/libsqlite/sqlite3.c"
    addrInsTop = sqlite3VdbeAddOp1(v, 65, srcTab);
    addrCont = sqlite3VdbeCurrentAddr(v);
  }else if( pSelect ){
# 85153 "ext/sqlite3/libsqlite/sqlite3.c"
    addrCont = sqlite3VdbeAddOp1(v, 4, dest.iParm);
    addrInsTop = sqlite3VdbeAddOp1(v, 26, regEof);
  }




  regRowid = regIns = pParse->nMem+1;
  pParse->nMem += pTab->nCol + 1;
  if( (((pTab)->tabFlags & 0x10)!=0) ){
    regRowid++;
    pParse->nMem++;
  }
  regData = regRowid+1;



  endOfLoop = sqlite3VdbeMakeLabel(v);
  if( tmask & 1 ){
    int regCols = sqlite3GetTempRange(pParse, pTab->nCol+1);







    if( keyColumn<0 ){
      sqlite3VdbeAddOp2(v, 7, -1, regCols);
    }else{
      int j1;
      if( useTempTable ){
        sqlite3VdbeAddOp3(v, 28, srcTab, keyColumn, regCols);
      }else{
        ((void) (0));
        sqlite3ExprCode(pParse, pList->a[keyColumn].pExpr, regCols);
      }
      j1 = sqlite3VdbeAddOp1(v, 74, regCols);
      sqlite3VdbeAddOp2(v, 7, -1, regCols);
      sqlite3VdbeJumpHere(v, j1);
      sqlite3VdbeAddOp1(v, 21, regCols);
    }




    ((void) (0));



    for(i=0; i<pTab->nCol; i++){
      if( pColumn==0 ){
        j = i;
      }else{
        for(j=0; j<pColumn->nId; j++){
          if( pColumn->a[j].idx==i ) break;
        }
      }
      if( (!useTempTable && !pList) || (pColumn && j>=pColumn->nId) ){
        sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, regCols+i+1);
      }else if( useTempTable ){
        sqlite3VdbeAddOp3(v, 28, srcTab, j, regCols+i+1);
      }else{
        ((void) (0));
        sqlite3ExprCodeAndCache(pParse, pList->a[j].pExpr, regCols+i+1);
      }
    }






    if( !isView ){
      sqlite3VdbeAddOp2(v, 29, regCols+1, pTab->nCol);
      sqlite3TableAffinityStr(v, pTab);
    }


    sqlite3CodeRowTrigger(pParse, pTrigger, 105, 0, 1,
        pTab, regCols-pTab->nCol-1, onError, endOfLoop);

    sqlite3ReleaseTempRange(pParse, regCols, pTab->nCol+1);
  }






  if( !isView ){
    if( (((pTab)->tabFlags & 0x10)!=0) ){

      sqlite3VdbeAddOp2(v, 10, 0, regIns);
    }
    if( keyColumn>=0 ){
      if( useTempTable ){
        sqlite3VdbeAddOp3(v, 28, srcTab, keyColumn, regRowid);
      }else if( pSelect ){
        sqlite3VdbeAddOp2(v, 15, regFromSelect+keyColumn, regRowid);
      }else{
        VdbeOp *pOp;
        sqlite3ExprCode(pParse, pList->a[keyColumn].pExpr, regRowid);
        pOp = sqlite3VdbeGetOp(v, -1);
        if( (pOp) && pOp->opcode==10 && !(((pTab)->tabFlags & 0x10)!=0) ){
          appendFlag = 1;
          pOp->opcode = 54;
          pOp->p1 = baseCur;
          pOp->p2 = regRowid;
          pOp->p3 = regAutoinc;
        }
      }



      if( !appendFlag ){
        int j1;
        if( !(((pTab)->tabFlags & 0x10)!=0) ){
          j1 = sqlite3VdbeAddOp1(v, 74, regRowid);
          sqlite3VdbeAddOp3(v, 54, baseCur, regRowid, regAutoinc);
          sqlite3VdbeJumpHere(v, j1);
        }else{
          j1 = sqlite3VdbeCurrentAddr(v);
          sqlite3VdbeAddOp2(v, 73, regRowid, j1+2);
        }
        sqlite3VdbeAddOp1(v, 21, regRowid);
      }
    }else if( (((pTab)->tabFlags & 0x10)!=0) ){
      sqlite3VdbeAddOp2(v, 10, 0, regRowid);
    }else{
      sqlite3VdbeAddOp3(v, 54, baseCur, regRowid, regAutoinc);
      appendFlag = 1;
    }
    autoIncStep(pParse, regAutoinc, regRowid);




    nHidden = 0;
    for(i=0; i<pTab->nCol; i++){
      int iRegStore = regRowid+1+i;
      if( i==pTab->iPKey ){




        sqlite3VdbeAddOp2(v, 10, 0, iRegStore);
        continue;
      }
      if( pColumn==0 ){
        if( ((&pTab->aCol[i])->isHidden) ){
          ((void) (0));
          j = -1;
          nHidden++;
        }else{
          j = i - nHidden;
        }
      }else{
        for(j=0; j<pColumn->nId; j++){
          if( pColumn->a[j].idx==i ) break;
        }
      }
      if( j<0 || nColumn==0 || (pColumn && j>=pColumn->nId) ){
        sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, iRegStore);
      }else if( useTempTable ){
        sqlite3VdbeAddOp3(v, 28, srcTab, j, iRegStore);
      }else if( pSelect ){
        sqlite3VdbeAddOp2(v, 15, regFromSelect+j, iRegStore);
      }else{
        sqlite3ExprCode(pParse, pList->a[j].pExpr, iRegStore);
      }
    }





    if( (((pTab)->tabFlags & 0x10)!=0) ){
      const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);
      sqlite3VtabMakeWritable(pParse, pTab);
      sqlite3VdbeAddOp4(v, 133, 1, pTab->nCol+2, regIns, pVTab, (-10));
      sqlite3MayAbort(pParse);
    }else

    {
      int isReplace;
      sqlite3GenerateConstraintChecks(pParse, pTab, baseCur, regIns, aRegIdx,
          keyColumn>=0, 0, onError, endOfLoop, &isReplace
      );
      sqlite3FkCheck(pParse, pTab, 0, regIns);
      sqlite3CompleteInsertion(
          pParse, pTab, baseCur, regIns, aRegIdx, 0, appendFlag, isReplace==0
      );
    }
  }



  if( (db->flags & 0x00001000)!=0 ){
    sqlite3VdbeAddOp2(v, 20, regRowCount, 1);
  }

  if( pTrigger ){

    sqlite3CodeRowTrigger(pParse, pTrigger, 105, 0, 2,
        pTab, regData-2-pTab->nCol, onError, endOfLoop);
  }




  sqlite3VdbeResolveLabel(v, endOfLoop);
  if( useTempTable ){
    sqlite3VdbeAddOp2(v, 67, srcTab, addrCont);
    sqlite3VdbeJumpHere(v, addrInsTop);
    sqlite3VdbeAddOp1(v, 43, srcTab);
  }else if( pSelect ){
    sqlite3VdbeAddOp2(v, 1, 0, addrCont);
    sqlite3VdbeJumpHere(v, addrInsTop);
  }

  if( !(((pTab)->tabFlags & 0x10)!=0) && !isView ){

    sqlite3VdbeAddOp1(v, 43, baseCur);
    for(idx=1, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, idx++){
      sqlite3VdbeAddOp1(v, 43, idx+baseCur);
    }
  }

insert_end:




  if( pParse->nested==0 && pParse->pTriggerTab==0 ){
    sqlite3AutoincrementEnd(pParse);
  }






  if( (db->flags&0x00001000) && !pParse->nested && !pParse->pTriggerTab ){
    sqlite3VdbeAddOp2(v, 16, regRowCount, 1);
    sqlite3VdbeSetNumCols(v, 1);
    sqlite3VdbeSetColName(v, 0, 0, "rows inserted", ((sqlite3_destructor_type)0));
  }

insert_cleanup:
  sqlite3SrcListDelete(db, pTabList);
  sqlite3ExprListDelete(db, pList);
  sqlite3SelectDelete(db, pSelect);
  sqlite3IdListDelete(db, pColumn);
  sqlite3DbFree(db, aRegIdx);
}
# 85499 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3GenerateConstraintChecks(
  Parse *pParse,
  Table *pTab,
  int baseCur,
  int regRowid,
  int *aRegIdx,
  int rowidChng,
  int isUpdate,
  int overrideError,
  int ignoreDest,
  int *pbMayReplace
){
  int i;
  Vdbe *v;
  int nCol;
  int onError;
  int j1;
  int j2 = 0, j3;
  int regData;
  int iCur;
  Index *pIdx;
  int seenReplace = 0;
  int regOldRowid = (rowidChng && isUpdate) ? rowidChng : regRowid;

  v = sqlite3GetVdbe(pParse);
  ((void) (0));
  ((void) (0));
  nCol = pTab->nCol;
  regData = regRowid + 1;



  for(i=0; i<nCol; i++){
    if( i==pTab->iPKey ){
      continue;
    }
    onError = pTab->aCol[i].notNull;
    if( onError==0 ) continue;
    if( overrideError!=99 ){
      onError = overrideError;
    }else if( onError==99 ){
      onError = 2;
    }
    if( onError==5 && pTab->aCol[i].pDflt==0 ){
      onError = 2;
    }
    ((void) (0));

    switch( onError ){
      case 2:
        sqlite3MayAbort(pParse);
      case 1:
      case 3: {
        char *zMsg;
        sqlite3VdbeAddOp3(v, 5,
                                  19, onError, regData+i);
        zMsg = sqlite3MPrintf(pParse->db, "%s.%s may not be NULL",
                              pTab->zName, pTab->aCol[i].zName);
        sqlite3VdbeChangeP4(v, -1, zMsg, (-1));
        break;
      }
      case 4: {
        sqlite3VdbeAddOp2(v, 73, regData+i, ignoreDest);
        break;
      }
      default: {
        ((void) (0));
        j1 = sqlite3VdbeAddOp1(v, 74, regData+i);
        sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, regData+i);
        sqlite3VdbeJumpHere(v, j1);
        break;
      }
    }
  }




  if( pTab->pCheck && (pParse->db->flags & 0x00040000)==0 ){
    int allOk = sqlite3VdbeMakeLabel(v);
    pParse->ckBase = regData;
    sqlite3ExprIfTrue(pParse, pTab->pCheck, allOk, 0x08);
    onError = overrideError!=99 ? overrideError : 2;
    if( onError==4 ){
      sqlite3VdbeAddOp2(v, 1, 0, ignoreDest);
    }else{
      if( onError==5 ) onError = 2;
      sqlite3HaltConstraint(pParse, onError, 0, 0);
    }
    sqlite3VdbeResolveLabel(v, allOk);
  }






  if( rowidChng ){
    onError = pTab->keyConf;
    if( overrideError!=99 ){
      onError = overrideError;
    }else if( onError==99 ){
      onError = 2;
    }

    if( isUpdate ){
      j2 = sqlite3VdbeAddOp3(v, 76, regRowid, 0, rowidChng);
    }
    j3 = sqlite3VdbeAddOp3(v, 52, baseCur, 0, regRowid);
    switch( onError ){
      default: {
        onError = 2;

      }
      case 1:
      case 2:
      case 3: {
        sqlite3HaltConstraint(
          pParse, onError, "PRIMARY KEY must be unique", (-2));
        break;
      }
      case 5: {
# 85643 "ext/sqlite3/libsqlite/sqlite3.c"
        Trigger *pTrigger = 0;
        if( pParse->db->flags&0x02000000 ){
          pTrigger = sqlite3TriggersExist(pParse, pTab, 106, 0, 0);
        }
        if( pTrigger || sqlite3FkRequired(pParse, pTab, 0, 0) ){
          sqlite3MultiWrite(pParse);
          sqlite3GenerateRowDelete(
              pParse, pTab, baseCur, regRowid, 0, pTrigger, 5
          );
        }else if( pTab->pIndex ){
          sqlite3MultiWrite(pParse);
          sqlite3GenerateRowIndexDelete(pParse, pTab, baseCur, 0);
        }
        seenReplace = 1;
        break;
      }
      case 4: {
        ((void) (0));
        sqlite3VdbeAddOp2(v, 1, 0, ignoreDest);
        break;
      }
    }
    sqlite3VdbeJumpHere(v, j3);
    if( isUpdate ){
      sqlite3VdbeJumpHere(v, j2);
    }
  }





  for(iCur=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, iCur++){
    int regIdx;
    int regR;

    if( aRegIdx[iCur]==0 ) continue;


    regIdx = sqlite3GetTempRange(pParse, pIdx->nColumn+1);
    for(i=0; i<pIdx->nColumn; i++){
      int idx = pIdx->aiColumn[i];
      if( idx==pTab->iPKey ){
        sqlite3VdbeAddOp2(v, 15, regRowid, regIdx+i);
      }else{
        sqlite3VdbeAddOp2(v, 15, regData+idx, regIdx+i);
      }
    }
    sqlite3VdbeAddOp2(v, 15, regRowid, regIdx+i);
    sqlite3VdbeAddOp3(v, 30, regIdx, pIdx->nColumn+1, aRegIdx[iCur]);
    sqlite3VdbeChangeP4(v, -1, sqlite3IndexAffinityStr(v, pIdx), 0);
    sqlite3ExprCacheAffinityChange(pParse, regIdx, pIdx->nColumn+1);


    onError = pIdx->onError;
    if( onError==0 ){
      sqlite3ReleaseTempRange(pParse, regIdx, pIdx->nColumn+1);
      continue;
    }
    if( overrideError!=99 ){
      onError = overrideError;
    }else if( onError==99 ){
      onError = 2;
    }
    if( seenReplace ){
      if( onError==4 ) onError = 5;
      else if( onError==3 ) onError = 2;
    }


    regR = sqlite3GetTempReg(pParse);
    sqlite3VdbeAddOp2(v, 15, regOldRowid, regR);
    j3 = sqlite3VdbeAddOp4(v, 51, baseCur+iCur+1, 0,
                           regR, ((void*)(long int)(regIdx)),
                           (-14));
    sqlite3ReleaseTempRange(pParse, regIdx, pIdx->nColumn+1);


    ((void) (0));

    switch( onError ){
      case 1:
      case 2:
      case 3: {
        int j;
        StrAccum errMsg;
        const char *zSep;
        char *zErr;

        sqlite3StrAccumInit(&errMsg, 0, 0, 200);
        errMsg.db = pParse->db;
        zSep = pIdx->nColumn>1 ? "columns " : "column ";
        for(j=0; j<pIdx->nColumn; j++){
          char *zCol = pTab->aCol[pIdx->aiColumn[j]].zName;
          sqlite3StrAccumAppend(&errMsg, zSep, -1);
          zSep = ", ";
          sqlite3StrAccumAppend(&errMsg, zCol, -1);
        }
        sqlite3StrAccumAppend(&errMsg,
            pIdx->nColumn>1 ? " are not unique" : " is not unique", -1);
        zErr = sqlite3StrAccumFinish(&errMsg);
        sqlite3HaltConstraint(pParse, onError, zErr, 0);
        sqlite3DbFree(errMsg.db, zErr);
        break;
      }
      case 4: {
        ((void) (0));
        sqlite3VdbeAddOp2(v, 1, 0, ignoreDest);
        break;
      }
      default: {
        Trigger *pTrigger = 0;
        ((void) (0));
        sqlite3MultiWrite(pParse);
        if( pParse->db->flags&0x02000000 ){
          pTrigger = sqlite3TriggersExist(pParse, pTab, 106, 0, 0);
        }
        sqlite3GenerateRowDelete(
            pParse, pTab, baseCur, regR, 0, pTrigger, 5
        );
        seenReplace = 1;
        break;
      }
    }
    sqlite3VdbeJumpHere(v, j3);
    sqlite3ReleaseTempReg(pParse, regR);
  }

  if( pbMayReplace ){
    *pbMayReplace = seenReplace;
  }
}
# 85785 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3CompleteInsertion(
  Parse *pParse,
  Table *pTab,
  int baseCur,
  int regRowid,
  int *aRegIdx,
  int isUpdate,
  int appendBias,
  int useSeekResult
){
  int i;
  Vdbe *v;
  int nIdx;
  Index *pIdx;
  u8 pik_flags;
  int regData;
  int regRec;

  v = sqlite3GetVdbe(pParse);
  ((void) (0));
  ((void) (0));
  for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){}
  for(i=nIdx-1; i>=0; i--){
    if( aRegIdx[i]==0 ) continue;
    sqlite3VdbeAddOp2(v, 70, baseCur+i+1, aRegIdx[i]);
    if( useSeekResult ){
      sqlite3VdbeChangeP5(v, 0x10);
    }
  }
  regData = regRowid + 1;
  regRec = sqlite3GetTempReg(pParse);
  sqlite3VdbeAddOp3(v, 30, regData, pTab->nCol, regRec);
  sqlite3TableAffinityStr(v, pTab);
  sqlite3ExprCacheAffinityChange(pParse, regData, pTab->nCol);
  if( pParse->nested ){
    pik_flags = 0;
  }else{
    pik_flags = 0x01;
    pik_flags |= (isUpdate?0x04:0x02);
  }
  if( appendBias ){
    pik_flags |= 0x08;
  }
  if( useSeekResult ){
    pik_flags |= 0x10;
  }
  sqlite3VdbeAddOp3(v, 55, baseCur, regRec, regRowid);
  if( !pParse->nested ){
    sqlite3VdbeChangeP4(v, -1, pTab->zName, 0);
  }
  sqlite3VdbeChangeP5(v, pik_flags);
}
# 85845 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3OpenTableAndIndices(
  Parse *pParse,
  Table *pTab,
  int baseCur,
  int op
){
  int i;
  int iDb;
  Index *pIdx;
  Vdbe *v;

  if( (((pTab)->tabFlags & 0x10)!=0) ) return 0;
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
  v = sqlite3GetVdbe(pParse);
  ((void) (0));
  sqlite3OpenTable(pParse, baseCur, iDb, pTab, op);
  for(i=1, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, i++){
    KeyInfo *pKey = sqlite3IndexKeyinfo(pParse, pIdx);
    ((void) (0));
    sqlite3VdbeAddOp4(v, op, i+baseCur, pIdx->tnum, iDb,
                      (char*)pKey, (-16));
                                       ;
  }
  if( pParse->nTab<baseCur+i ){
    pParse->nTab = baseCur+i;
  }
  return i-1;
}
# 85890 "ext/sqlite3/libsqlite/sqlite3.c"
static int xferCompatibleCollation(const char *z1, const char *z2){
  if( z1==0 ){
    return z2==0;
  }
  if( z2==0 ){
    return 0;
  }
  return sqlite3StrICmp(z1, z2)==0;
}
# 85911 "ext/sqlite3/libsqlite/sqlite3.c"
static int xferCompatibleIndex(Index *pDest, Index *pSrc){
  int i;
  ((void) (0));
  ((void) (0));
  if( pDest->nColumn!=pSrc->nColumn ){
    return 0;
  }
  if( pDest->onError!=pSrc->onError ){
    return 0;
  }
  for(i=0; i<pSrc->nColumn; i++){
    if( pSrc->aiColumn[i]!=pDest->aiColumn[i] ){
      return 0;
    }
    if( pSrc->aSortOrder[i]!=pDest->aSortOrder[i] ){
      return 0;
    }
    if( !xferCompatibleCollation(pSrc->azColl[i],pDest->azColl[i]) ){
      return 0;
    }
  }


  return 1;
}
# 85968 "ext/sqlite3/libsqlite/sqlite3.c"
static int xferOptimization(
  Parse *pParse,
  Table *pDest,
  Select *pSelect,
  int onError,
  int iDbDest
){
  ExprList *pEList;
  Table *pSrc;
  Index *pSrcIdx, *pDestIdx;
  struct SrcList_item *pItem;
  int i;
  int iDbSrc;
  int iSrc, iDest;
  int addr1, addr2;
  int emptyDestTest;
  int emptySrcTest;
  Vdbe *v;
  KeyInfo *pKey;
  int regAutoinc;
  int destHasUniqueIdx = 0;
  int regData, regRowid;

  if( pSelect==0 ){
    return 0;
  }
  if( sqlite3TriggerList(pParse, pDest) ){
    return 0;
  }

  if( pDest->tabFlags & 0x10 ){
    return 0;
  }

  if( onError==99 ){
    onError = 2;
  }
  if( onError!=2 && onError!=1 ){
    return 0;
  }
  ((void) (0));
  if( pSelect->pSrc->nSrc!=1 ){
    return 0;
  }
  if( pSelect->pSrc->a[0].pSelect ){
    return 0;
  }
  if( pSelect->pWhere ){
    return 0;
  }
  if( pSelect->pOrderBy ){
    return 0;
  }


  if( pSelect->pGroupBy ){
    return 0;
  }
  if( pSelect->pLimit ){
    return 0;
  }
  ((void) (0));
  if( pSelect->pPrior ){
    return 0;
  }
  if( pSelect->selFlags & 0x0001 ){
    return 0;
  }
  pEList = pSelect->pEList;
  ((void) (0));
  if( pEList->nExpr!=1 ){
    return 0;
  }
  ((void) (0));
  if( pEList->a[0].pExpr->op!=113 ){
    return 0;
  }





  pItem = pSelect->pSrc->a;
  pSrc = sqlite3LocateTable(pParse, 0, pItem->zName, pItem->zDatabase);
  if( pSrc==0 ){
    return 0;
  }
  if( pSrc==pDest ){
    return 0;
  }

  if( pSrc->tabFlags & 0x10 ){
    return 0;
  }

  if( pSrc->pSelect ){
    return 0;
  }
  if( pDest->nCol!=pSrc->nCol ){
    return 0;
  }
  if( pDest->iPKey!=pSrc->iPKey ){
    return 0;
  }
  for(i=0; i<pDest->nCol; i++){
    if( pDest->aCol[i].affinity!=pSrc->aCol[i].affinity ){
      return 0;
    }
    if( !xferCompatibleCollation(pDest->aCol[i].zColl, pSrc->aCol[i].zColl) ){
      return 0;
    }
    if( pDest->aCol[i].notNull && !pSrc->aCol[i].notNull ){
      return 0;
    }
  }
  for(pDestIdx=pDest->pIndex; pDestIdx; pDestIdx=pDestIdx->pNext){
    if( pDestIdx->onError!=0 ){
      destHasUniqueIdx = 1;
    }
    for(pSrcIdx=pSrc->pIndex; pSrcIdx; pSrcIdx=pSrcIdx->pNext){
      if( xferCompatibleIndex(pDestIdx, pSrcIdx) ) break;
    }
    if( pSrcIdx==0 ){
      return 0;
    }
  }

  if( pDest->pCheck && sqlite3ExprCompare(pSrc->pCheck, pDest->pCheck) ){
    return 0;
  }
# 86111 "ext/sqlite3/libsqlite/sqlite3.c"
  iDbSrc = sqlite3SchemaToIndex(pParse->db, pSrc->pSchema);
  v = sqlite3GetVdbe(pParse);
  sqlite3CodeVerifySchema(pParse, iDbSrc);
  iSrc = pParse->nTab++;
  iDest = pParse->nTab++;
  regAutoinc = autoIncBegin(pParse, iDbDest, pDest);
  sqlite3OpenTable(pParse, iDest, iDbDest, pDest, 39);
  if( (pDest->iPKey<0 && pDest->pIndex!=0) || destHasUniqueIdx ){
# 86129 "ext/sqlite3/libsqlite/sqlite3.c"
    addr1 = sqlite3VdbeAddOp2(v, 65, iDest, 0);
    emptyDestTest = sqlite3VdbeAddOp2(v, 1, 0, 0);
    sqlite3VdbeJumpHere(v, addr1);
  }else{
    emptyDestTest = 0;
  }
  sqlite3OpenTable(pParse, iSrc, iDbSrc, pSrc, 38);
  emptySrcTest = sqlite3VdbeAddOp2(v, 65, iSrc, 0);
  regData = sqlite3GetTempReg(pParse);
  regRowid = sqlite3GetTempReg(pParse);
  if( pDest->iPKey>=0 ){
    addr1 = sqlite3VdbeAddOp2(v, 61, iSrc, regRowid);
    addr2 = sqlite3VdbeAddOp3(v, 52, iDest, 0, regRowid);
    sqlite3HaltConstraint(
        pParse, onError, "PRIMARY KEY must be unique", (-2));
    sqlite3VdbeJumpHere(v, addr2);
    autoIncStep(pParse, regAutoinc, regRowid);
  }else if( pDest->pIndex==0 ){
    addr1 = sqlite3VdbeAddOp2(v, 54, iDest, regRowid);
  }else{
    addr1 = sqlite3VdbeAddOp2(v, 61, iSrc, regRowid);
    ((void) (0));
  }
  sqlite3VdbeAddOp2(v, 60, iSrc, regData);
  sqlite3VdbeAddOp3(v, 55, iDest, regData, regRowid);
  sqlite3VdbeChangeP5(v, 0x01|0x02|0x08);
  sqlite3VdbeChangeP4(v, -1, pDest->zName, 0);
  sqlite3VdbeAddOp2(v, 67, iSrc, addr1);
  for(pDestIdx=pDest->pIndex; pDestIdx; pDestIdx=pDestIdx->pNext){
    for(pSrcIdx=pSrc->pIndex; (pSrcIdx); pSrcIdx=pSrcIdx->pNext){
      if( xferCompatibleIndex(pDestIdx, pSrcIdx) ) break;
    }
    ((void) (0));
    sqlite3VdbeAddOp2(v, 43, iSrc, 0);
    sqlite3VdbeAddOp2(v, 43, iDest, 0);
    pKey = sqlite3IndexKeyinfo(pParse, pSrcIdx);
    sqlite3VdbeAddOp4(v, 38, iSrc, pSrcIdx->tnum, iDbSrc,
                      (char*)pKey, (-16));
                                          ;
    pKey = sqlite3IndexKeyinfo(pParse, pDestIdx);
    sqlite3VdbeAddOp4(v, 39, iDest, pDestIdx->tnum, iDbDest,
                      (char*)pKey, (-16));
                                           ;
    addr1 = sqlite3VdbeAddOp2(v, 65, iSrc, 0);
    sqlite3VdbeAddOp2(v, 59, iSrc, regData);
    sqlite3VdbeAddOp3(v, 70, iDest, regData, 1);
    sqlite3VdbeAddOp2(v, 67, iSrc, addr1+1);
    sqlite3VdbeJumpHere(v, addr1);
  }
  sqlite3VdbeJumpHere(v, emptySrcTest);
  sqlite3ReleaseTempReg(pParse, regRowid);
  sqlite3ReleaseTempReg(pParse, regData);
  sqlite3VdbeAddOp2(v, 43, iSrc, 0);
  sqlite3VdbeAddOp2(v, 43, iDest, 0);
  if( emptyDestTest ){
    sqlite3VdbeAddOp2(v, 6, 0, 0);
    sqlite3VdbeJumpHere(v, emptyDestTest);
    sqlite3VdbeAddOp2(v, 43, iDest, 0);
    return 0;
  }else{
    return 1;
  }
}
# 86224 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_exec(
  sqlite3 *db,
  const char *zSql,
  sqlite3_callback xCallback,
  void *pArg,
  char **pzErrMsg
){
  int rc = 0;
  const char *zLeftover;
  sqlite3_stmt *pStmt = 0;
  char **azCols = 0;
  int nRetry = 0;
  int callbackIsInit;

  if( !sqlite3SafetyCheckOk(db) ) return sqlite3MisuseError(86238);
  if( zSql==0 ) zSql = "";

                                ;
  sqlite3Error(db, 0, 0);
  while( (rc==0 || (rc==17 && (++nRetry)<2)) && zSql[0] ){
    int nCol;
    char **azVals = 0;

    pStmt = 0;
    rc = sqlite3_prepare(db, zSql, -1, &pStmt, &zLeftover);
    ((void) (0));
    if( rc!=0 ){
      continue;
    }
    if( !pStmt ){

      zSql = zLeftover;
      continue;
    }

    callbackIsInit = 0;
    nCol = sqlite3_column_count(pStmt);

    while( 1 ){
      int i;
      rc = sqlite3_step(pStmt);


      if( xCallback && (100==rc ||
          (101==rc && !callbackIsInit
                           && db->flags&0x00002000)) ){
        if( !callbackIsInit ){
          azCols = sqlite3DbMallocZero(db, 2*nCol*sizeof(const char*) + 1);
          if( azCols==0 ){
            goto exec_out;
          }
          for(i=0; i<nCol; i++){
            azCols[i] = (char *)sqlite3_column_name(pStmt, i);


            ((void) (0));
          }
          callbackIsInit = 1;
        }
        if( rc==100 ){
          azVals = &azCols[nCol];
          for(i=0; i<nCol; i++){
            azVals[i] = (char *)sqlite3_column_text(pStmt, i);
            if( !azVals[i] && sqlite3_column_type(pStmt, i)!=5 ){
              db->mallocFailed = 1;
              goto exec_out;
            }
          }
        }
        if( xCallback(pArg, nCol, azVals, azCols) ){
          rc = 4;
          sqlite3VdbeFinalize((Vdbe *)pStmt);
          pStmt = 0;
          sqlite3Error(db, 4, 0);
          goto exec_out;
        }
      }

      if( rc!=100 ){
        rc = sqlite3VdbeFinalize((Vdbe *)pStmt);
        pStmt = 0;
        if( rc!=17 ){
          nRetry = 0;
          zSql = zLeftover;
          while( (sqlite3CtypeMap[(unsigned char)(zSql[0])]&0x01) ) zSql++;
        }
        break;
      }
    }

    sqlite3DbFree(db, azCols);
    azCols = 0;
  }

exec_out:
  if( pStmt ) sqlite3VdbeFinalize((Vdbe *)pStmt);
  sqlite3DbFree(db, azCols);

  rc = sqlite3ApiExit(db, rc);
  if( rc!=0 && (rc==sqlite3_errcode(db)) && pzErrMsg ){
    int nErrMsg = 1 + sqlite3Strlen30(sqlite3_errmsg(db));
    *pzErrMsg = sqlite3Malloc(nErrMsg);
    if( *pzErrMsg ){
      memcpy(*pzErrMsg, sqlite3_errmsg(db), nErrMsg);
    }else{
      rc = 7;
      sqlite3Error(db, 7, 0);
    }
  }else if( pzErrMsg ){
    *pzErrMsg = 0;
  }

  ((void) (0));
                                ;
  return rc;
}
# 86383 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct sqlite3_api_routines sqlite3_api_routines;
# 86395 "ext/sqlite3/libsqlite/sqlite3.c"
struct sqlite3_api_routines {
  void * (*aggregate_context)(sqlite3_context*,int nBytes);
  int (*aggregate_count)(sqlite3_context*);
  int (*bind_blob)(sqlite3_stmt*,int,const void*,int n,void(*)(void*));
  int (*bind_double)(sqlite3_stmt*,int,double);
  int (*bind_int)(sqlite3_stmt*,int,int);
  int (*bind_int64)(sqlite3_stmt*,int,sqlite_int64);
  int (*bind_null)(sqlite3_stmt*,int);
  int (*bind_parameter_count)(sqlite3_stmt*);
  int (*bind_parameter_index)(sqlite3_stmt*,const char*zName);
  const char * (*bind_parameter_name)(sqlite3_stmt*,int);
  int (*bind_text)(sqlite3_stmt*,int,const char*,int n,void(*)(void*));
  int (*bind_text16)(sqlite3_stmt*,int,const void*,int,void(*)(void*));
  int (*bind_value)(sqlite3_stmt*,int,const sqlite3_value*);
  int (*busy_handler)(sqlite3*,int(*)(void*,int),void*);
  int (*busy_timeout)(sqlite3*,int ms);
  int (*changes)(sqlite3*);
  int (*close)(sqlite3*);
  int (*collation_needed)(sqlite3*,void*,void(*)(void*,sqlite3*,int eTextRep,const char*));
  int (*collation_needed16)(sqlite3*,void*,void(*)(void*,sqlite3*,int eTextRep,const void*));
  const void * (*column_blob)(sqlite3_stmt*,int iCol);
  int (*column_bytes)(sqlite3_stmt*,int iCol);
  int (*column_bytes16)(sqlite3_stmt*,int iCol);
  int (*column_count)(sqlite3_stmt*pStmt);
  const char * (*column_database_name)(sqlite3_stmt*,int);
  const void * (*column_database_name16)(sqlite3_stmt*,int);
  const char * (*column_decltype)(sqlite3_stmt*,int i);
  const void * (*column_decltype16)(sqlite3_stmt*,int);
  double (*column_double)(sqlite3_stmt*,int iCol);
  int (*column_int)(sqlite3_stmt*,int iCol);
  sqlite_int64 (*column_int64)(sqlite3_stmt*,int iCol);
  const char * (*column_name)(sqlite3_stmt*,int);
  const void * (*column_name16)(sqlite3_stmt*,int);
  const char * (*column_origin_name)(sqlite3_stmt*,int);
  const void * (*column_origin_name16)(sqlite3_stmt*,int);
  const char * (*column_table_name)(sqlite3_stmt*,int);
  const void * (*column_table_name16)(sqlite3_stmt*,int);
  const unsigned char * (*column_text)(sqlite3_stmt*,int iCol);
  const void * (*column_text16)(sqlite3_stmt*,int iCol);
  int (*column_type)(sqlite3_stmt*,int iCol);
  sqlite3_value* (*column_value)(sqlite3_stmt*,int iCol);
  void * (*commit_hook)(sqlite3*,int(*)(void*),void*);
  int (*complete)(const char*sql);
  int (*complete16)(const void*sql);
  int (*create_collation)(sqlite3*,const char*,int,void*,int(*)(void*,int,const void*,int,const void*));
  int (*create_collation16)(sqlite3*,const void*,int,void*,int(*)(void*,int,const void*,int,const void*));
  int (*create_function)(sqlite3*,const char*,int,int,void*,void (*xFunc)(sqlite3_context*,int,sqlite3_value**),void (*xStep)(sqlite3_context*,int,sqlite3_value**),void (*xFinal)(sqlite3_context*));
  int (*create_function16)(sqlite3*,const void*,int,int,void*,void (*xFunc)(sqlite3_context*,int,sqlite3_value**),void (*xStep)(sqlite3_context*,int,sqlite3_value**),void (*xFinal)(sqlite3_context*));
  int (*create_module)(sqlite3*,const char*,const sqlite3_module*,void*);
  int (*data_count)(sqlite3_stmt*pStmt);
  sqlite3 * (*db_handle)(sqlite3_stmt*);
  int (*declare_vtab)(sqlite3*,const char*);
  int (*enable_shared_cache)(int);
  int (*errcode)(sqlite3*db);
  const char * (*errmsg)(sqlite3*);
  const void * (*errmsg16)(sqlite3*);
  int (*exec)(sqlite3*,const char*,sqlite3_callback,void*,char**);
  int (*expired)(sqlite3_stmt*);
  int (*finalize)(sqlite3_stmt*pStmt);
  void (*free)(void*);
  void (*free_table)(char**result);
  int (*get_autocommit)(sqlite3*);
  void * (*get_auxdata)(sqlite3_context*,int);
  int (*get_table)(sqlite3*,const char*,char***,int*,int*,char**);
  int (*global_recover)(void);
  void (*interruptx)(sqlite3*);
  sqlite_int64 (*last_insert_rowid)(sqlite3*);
  const char * (*libversion)(void);
  int (*libversion_number)(void);
  void *(*malloc)(int);
  char * (*mprintf)(const char*,...);
  int (*open)(const char*,sqlite3**);
  int (*open16)(const void*,sqlite3**);
  int (*prepare)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);
  int (*prepare16)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);
  void * (*profile)(sqlite3*,void(*)(void*,const char*,sqlite_uint64),void*);
  void (*progress_handler)(sqlite3*,int,int(*)(void*),void*);
  void *(*realloc)(void*,int);
  int (*reset)(sqlite3_stmt*pStmt);
  void (*result_blob)(sqlite3_context*,const void*,int,void(*)(void*));
  void (*result_double)(sqlite3_context*,double);
  void (*result_error)(sqlite3_context*,const char*,int);
  void (*result_error16)(sqlite3_context*,const void*,int);
  void (*result_int)(sqlite3_context*,int);
  void (*result_int64)(sqlite3_context*,sqlite_int64);
  void (*result_null)(sqlite3_context*);
  void (*result_text)(sqlite3_context*,const char*,int,void(*)(void*));
  void (*result_text16)(sqlite3_context*,const void*,int,void(*)(void*));
  void (*result_text16be)(sqlite3_context*,const void*,int,void(*)(void*));
  void (*result_text16le)(sqlite3_context*,const void*,int,void(*)(void*));
  void (*result_value)(sqlite3_context*,sqlite3_value*);
  void * (*rollback_hook)(sqlite3*,void(*)(void*),void*);
  int (*set_authorizer)(sqlite3*,int(*)(void*,int,const char*,const char*,const char*,const char*),void*);
  void (*set_auxdata)(sqlite3_context*,int,void*,void (*)(void*));
  char * (*snprintf)(int,char*,const char*,...);
  int (*step)(sqlite3_stmt*);
  int (*table_column_metadata)(sqlite3*,const char*,const char*,const char*,char const**,char const**,int*,int*,int*);
  void (*thread_cleanup)(void);
  int (*total_changes)(sqlite3*);
  void * (*trace)(sqlite3*,void(*xTrace)(void*,const char*),void*);
  int (*transfer_bindings)(sqlite3_stmt*,sqlite3_stmt*);
  void * (*update_hook)(sqlite3*,void(*)(void*,int ,char const*,char const*,sqlite_int64),void*);
  void * (*user_data)(sqlite3_context*);
  const void * (*value_blob)(sqlite3_value*);
  int (*value_bytes)(sqlite3_value*);
  int (*value_bytes16)(sqlite3_value*);
  double (*value_double)(sqlite3_value*);
  int (*value_int)(sqlite3_value*);
  sqlite_int64 (*value_int64)(sqlite3_value*);
  int (*value_numeric_type)(sqlite3_value*);
  const unsigned char * (*value_text)(sqlite3_value*);
  const void * (*value_text16)(sqlite3_value*);
  const void * (*value_text16be)(sqlite3_value*);
  const void * (*value_text16le)(sqlite3_value*);
  int (*value_type)(sqlite3_value*);
  char *(*vmprintf)(const char*,va_list);

  int (*overload_function)(sqlite3*, const char *zFuncName, int nArg);

  int (*prepare_v2)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);
  int (*prepare16_v2)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);
  int (*clear_bindings)(sqlite3_stmt*);

  int (*create_module_v2)(sqlite3*,const char*,const sqlite3_module*,void*,void (*xDestroy)(void *));

  int (*bind_zeroblob)(sqlite3_stmt*,int,int);
  int (*blob_bytes)(sqlite3_blob*);
  int (*blob_close)(sqlite3_blob*);
  int (*blob_open)(sqlite3*,const char*,const char*,const char*,sqlite3_int64,int,sqlite3_blob**);
  int (*blob_read)(sqlite3_blob*,void*,int,int);
  int (*blob_write)(sqlite3_blob*,const void*,int,int);
  int (*create_collation_v2)(sqlite3*,const char*,int,void*,int(*)(void*,int,const void*,int,const void*),void(*)(void*));
  int (*file_control)(sqlite3*,const char*,int,void*);
  sqlite3_int64 (*memory_highwater)(int);
  sqlite3_int64 (*memory_used)(void);
  sqlite3_mutex *(*mutex_alloc)(int);
  void (*mutex_enter)(sqlite3_mutex*);
  void (*mutex_free)(sqlite3_mutex*);
  void (*mutex_leave)(sqlite3_mutex*);
  int (*mutex_try)(sqlite3_mutex*);
  int (*open_v2)(const char*,sqlite3**,int,const char*);
  int (*release_memory)(int);
  void (*result_error_nomem)(sqlite3_context*);
  void (*result_error_toobig)(sqlite3_context*);
  int (*sleep)(int);
  void (*soft_heap_limit)(int);
  sqlite3_vfs *(*vfs_find)(const char*);
  int (*vfs_register)(sqlite3_vfs*,int);
  int (*vfs_unregister)(sqlite3_vfs*);
  int (*xthreadsafe)(void);
  void (*result_zeroblob)(sqlite3_context*,int);
  void (*result_error_code)(sqlite3_context*,int);
  int (*test_control)(int, ...);
  void (*randomness)(int,void*);
  sqlite3 *(*context_db_handle)(sqlite3_context*);
  int (*extended_result_codes)(sqlite3*,int);
  int (*limit)(sqlite3*,int,int);
  sqlite3_stmt *(*next_stmt)(sqlite3*,sqlite3_stmt*);
  const char *(*sql)(sqlite3_stmt*);
  int (*status)(int,int*,int*,int);
  int (*backup_finish)(sqlite3_backup*);
  sqlite3_backup *(*backup_init)(sqlite3*,const char*,sqlite3*,const char*);
  int (*backup_pagecount)(sqlite3_backup*);
  int (*backup_remaining)(sqlite3_backup*);
  int (*backup_step)(sqlite3_backup*,int);
  const char *(*compileoption_get)(int);
  int (*compileoption_used)(const char*);
  int (*create_function_v2)(sqlite3*,const char*,int,int,void*,void (*xFunc)(sqlite3_context*,int,sqlite3_value**),void (*xStep)(sqlite3_context*,int,sqlite3_value**),void (*xFinal)(sqlite3_context*),void(*xDestroy)(void*));
  int (*db_config)(sqlite3*,int,...);
  sqlite3_mutex *(*db_mutex)(sqlite3*);
  int (*db_status)(sqlite3*,int,int*,int*,int);
  int (*extended_errcode)(sqlite3*);
  void (*log)(int,const char*,...);
  sqlite3_int64 (*soft_heap_limit64)(sqlite3_int64);
  const char *(*sourceid)(void);
  int (*stmt_status)(sqlite3_stmt*,int,int);
  int (*strnicmp)(const char*,const char*,int);
  int (*unlock_notify)(sqlite3*,void(*)(void**,int),void*);
  int (*wal_autocheckpoint)(sqlite3*,int);
  int (*wal_checkpoint)(sqlite3*,const char*);
  void *(*wal_hook)(sqlite3*,int(*)(void*,sqlite3*,const char*,int),void*);
};
# 86890 "ext/sqlite3/libsqlite/sqlite3.c"
static const sqlite3_api_routines sqlite3Apis = {
  sqlite3_aggregate_context,

  sqlite3_aggregate_count,



  sqlite3_bind_blob,
  sqlite3_bind_double,
  sqlite3_bind_int,
  sqlite3_bind_int64,
  sqlite3_bind_null,
  sqlite3_bind_parameter_count,
  sqlite3_bind_parameter_index,
  sqlite3_bind_parameter_name,
  sqlite3_bind_text,
  sqlite3_bind_text16,
  sqlite3_bind_value,
  sqlite3_busy_handler,
  sqlite3_busy_timeout,
  sqlite3_changes,
  sqlite3_close,
  sqlite3_collation_needed,
  sqlite3_collation_needed16,
  sqlite3_column_blob,
  sqlite3_column_bytes,
  sqlite3_column_bytes16,
  sqlite3_column_count,
  sqlite3_column_database_name,
  sqlite3_column_database_name16,
  sqlite3_column_decltype,
  sqlite3_column_decltype16,
  sqlite3_column_double,
  sqlite3_column_int,
  sqlite3_column_int64,
  sqlite3_column_name,
  sqlite3_column_name16,
  sqlite3_column_origin_name,
  sqlite3_column_origin_name16,
  sqlite3_column_table_name,
  sqlite3_column_table_name16,
  sqlite3_column_text,
  sqlite3_column_text16,
  sqlite3_column_type,
  sqlite3_column_value,
  sqlite3_commit_hook,
  sqlite3_complete,
  sqlite3_complete16,
  sqlite3_create_collation,
  sqlite3_create_collation16,
  sqlite3_create_function,
  sqlite3_create_function16,
  sqlite3_create_module,
  sqlite3_data_count,
  sqlite3_db_handle,
  sqlite3_declare_vtab,
  sqlite3_enable_shared_cache,
  sqlite3_errcode,
  sqlite3_errmsg,
  sqlite3_errmsg16,
  sqlite3_exec,

  sqlite3_expired,



  sqlite3_finalize,
  sqlite3_free,
  sqlite3_free_table,
  sqlite3_get_autocommit,
  sqlite3_get_auxdata,
  sqlite3_get_table,
  0,
  sqlite3_interrupt,
  sqlite3_last_insert_rowid,
  sqlite3_libversion,
  sqlite3_libversion_number,
  sqlite3_malloc,
  sqlite3_mprintf,
  sqlite3_open,
  sqlite3_open16,
  sqlite3_prepare,
  sqlite3_prepare16,
  sqlite3_profile,
  sqlite3_progress_handler,
  sqlite3_realloc,
  sqlite3_reset,
  sqlite3_result_blob,
  sqlite3_result_double,
  sqlite3_result_error,
  sqlite3_result_error16,
  sqlite3_result_int,
  sqlite3_result_int64,
  sqlite3_result_null,
  sqlite3_result_text,
  sqlite3_result_text16,
  sqlite3_result_text16be,
  sqlite3_result_text16le,
  sqlite3_result_value,
  sqlite3_rollback_hook,
  sqlite3_set_authorizer,
  sqlite3_set_auxdata,
  sqlite3_snprintf,
  sqlite3_step,
  sqlite3_table_column_metadata,

  sqlite3_thread_cleanup,



  sqlite3_total_changes,
  sqlite3_trace,

  sqlite3_transfer_bindings,



  sqlite3_update_hook,
  sqlite3_user_data,
  sqlite3_value_blob,
  sqlite3_value_bytes,
  sqlite3_value_bytes16,
  sqlite3_value_double,
  sqlite3_value_int,
  sqlite3_value_int64,
  sqlite3_value_numeric_type,
  sqlite3_value_text,
  sqlite3_value_text16,
  sqlite3_value_text16be,
  sqlite3_value_text16le,
  sqlite3_value_type,
  sqlite3_vmprintf,
# 87030 "ext/sqlite3/libsqlite/sqlite3.c"
  sqlite3_overload_function,




  sqlite3_prepare_v2,
  sqlite3_prepare16_v2,
  sqlite3_clear_bindings,




  sqlite3_create_module_v2,




  sqlite3_bind_zeroblob,
  sqlite3_blob_bytes,
  sqlite3_blob_close,
  sqlite3_blob_open,
  sqlite3_blob_read,
  sqlite3_blob_write,
  sqlite3_create_collation_v2,
  sqlite3_file_control,
  sqlite3_memory_highwater,
  sqlite3_memory_used,

  0,
  0,
  0,
  0,
  0,







  sqlite3_open_v2,
  sqlite3_release_memory,
  sqlite3_result_error_nomem,
  sqlite3_result_error_toobig,
  sqlite3_sleep,
  sqlite3_soft_heap_limit,
  sqlite3_vfs_find,
  sqlite3_vfs_register,
  sqlite3_vfs_unregister,




  sqlite3_threadsafe,
  sqlite3_result_zeroblob,
  sqlite3_result_error_code,
  sqlite3_test_control,
  sqlite3_randomness,
  sqlite3_context_db_handle,




  sqlite3_extended_result_codes,
  sqlite3_limit,
  sqlite3_next_stmt,
  sqlite3_sql,
  sqlite3_status,




  sqlite3_backup_finish,
  sqlite3_backup_init,
  sqlite3_backup_pagecount,
  sqlite3_backup_remaining,
  sqlite3_backup_step,

  sqlite3_compileoption_get,
  sqlite3_compileoption_used,




  sqlite3_create_function_v2,
  sqlite3_db_config,
  sqlite3_db_mutex,
  sqlite3_db_status,
  sqlite3_extended_errcode,
  sqlite3_log,
  sqlite3_soft_heap_limit64,
  sqlite3_sourceid,
  sqlite3_stmt_status,
  sqlite3_strnicmp,



  0,


  sqlite3_wal_autocheckpoint,
  sqlite3_wal_checkpoint,
  sqlite3_wal_hook,





};
# 87152 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3LoadExtension(
  sqlite3 *db,
  const char *zFile,
  const char *zProc,
  char **pzErrMsg
){
  sqlite3_vfs *pVfs = db->pVfs;
  void *handle;
  int (*xInit)(sqlite3*,char**,const sqlite3_api_routines*);
  char *zErrmsg = 0;
  void **aHandle;
  const int nMsg = 300;

  if( pzErrMsg ) *pzErrMsg = 0;







  if( (db->flags & 0x20000000)==0 ){
    if( pzErrMsg ){
      *pzErrMsg = sqlite3_mprintf("not authorized");
    }
    return 1;
  }

  if( zProc==0 ){
    zProc = "sqlite3_extension_init";
  }

  handle = sqlite3OsDlOpen(pVfs, zFile);
  if( handle==0 ){
    if( pzErrMsg ){
      *pzErrMsg = zErrmsg = sqlite3_malloc(nMsg);
      if( zErrmsg ){
        sqlite3_snprintf(nMsg, zErrmsg,
            "unable to open shared library [%s]", zFile);
        sqlite3OsDlError(pVfs, nMsg-1, zErrmsg);
      }
    }
    return 1;
  }
  xInit = (int(*)(sqlite3*,char**,const sqlite3_api_routines*))
                   sqlite3OsDlSym(pVfs, handle, zProc);
  if( xInit==0 ){
    if( pzErrMsg ){
      *pzErrMsg = zErrmsg = sqlite3_malloc(nMsg);
      if( zErrmsg ){
        sqlite3_snprintf(nMsg, zErrmsg,
            "no entry point [%s] in shared library [%s]", zProc,zFile);
        sqlite3OsDlError(pVfs, nMsg-1, zErrmsg);
      }
      sqlite3OsDlClose(pVfs, handle);
    }
    return 1;
  }else if( xInit(db, &zErrmsg, &sqlite3Apis) ){
    if( pzErrMsg ){
      *pzErrMsg = sqlite3_mprintf("error during initialization: %s", zErrmsg);
    }
    sqlite3_free(zErrmsg);
    sqlite3OsDlClose(pVfs, handle);
    return 1;
  }


  aHandle = sqlite3DbMallocZero(db, sizeof(handle)*(db->nExtension+1));
  if( aHandle==0 ){
    return 7;
  }
  if( db->nExtension>0 ){
    memcpy(aHandle, db->aExtension, sizeof(handle)*db->nExtension);
  }
  sqlite3DbFree(db, db->aExtension);
  db->aExtension = aHandle;

  db->aExtension[db->nExtension++] = handle;
  return 0;
}
           int sqlite3_load_extension(
  sqlite3 *db,
  const char *zFile,
  const char *zProc,
  char **pzErrMsg
){
  int rc;
                                ;
  rc = sqlite3LoadExtension(db, zFile, zProc, pzErrMsg);
  rc = sqlite3ApiExit(db, rc);
                                ;
  return rc;
}





static void sqlite3CloseExtensions(sqlite3 *db){
  int i;
  ((void) (0));
  for(i=0; i<db->nExtension; i++){
    sqlite3OsDlClose(db->pVfs, db->aExtension[i]);
  }
  sqlite3DbFree(db, db->aExtension);
}





           int sqlite3_enable_load_extension(sqlite3 *db, int onoff){
                                ;
  if( onoff ){
    db->flags |= 0x20000000;
  }else{
    db->flags &= ~0x20000000;
  }
                                ;
  return 0;
}
# 87294 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct sqlite3AutoExtList sqlite3AutoExtList;
static struct sqlite3AutoExtList {
  int nExt;
  void (**aExt)(void);
} sqlite3Autoext = { 0, 0 };
# 87320 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_auto_extension(void (*xInit)(void)){
  int rc = 0;

  rc = sqlite3_initialize();
  if( rc ){
    return rc;
  }else

  {
    int i;



                  ;
                              ;
    for(i=0; i<sqlite3Autoext.nExt; i++){
      if( sqlite3Autoext.aExt[i]==xInit ) break;
    }
    if( i==sqlite3Autoext.nExt ){
      int nByte = (sqlite3Autoext.nExt+1)*sizeof(sqlite3Autoext.aExt[0]);
      void (**aNew)(void);
      aNew = sqlite3_realloc(sqlite3Autoext.aExt, nByte);
      if( aNew==0 ){
        rc = 7;
      }else{
        sqlite3Autoext.aExt = aNew;
        sqlite3Autoext.aExt[sqlite3Autoext.nExt] = xInit;
        sqlite3Autoext.nExt++;
      }
    }
                              ;
    ((void) (0));
    return rc;
  }
}




           void sqlite3_reset_auto_extension(void){

  if( sqlite3_initialize()==0 )

  {



                  ;
                              ;
    sqlite3_free(sqlite3Autoext.aExt);
    sqlite3Autoext.aExt = 0;
    sqlite3Autoext.nExt = 0;
                              ;
  }
}






static void sqlite3AutoLoadExtensions(sqlite3 *db){
  int i;
  int go = 1;
  int (*xInit)(sqlite3*,char**,const sqlite3_api_routines*);

                ;
  if( sqlite3Autoext.nExt==0 ){

    return;
  }
  for(i=0; go; i++){
    char *zErrmsg;



                              ;
    if( i>=sqlite3Autoext.nExt ){
      xInit = 0;
      go = 0;
    }else{
      xInit = (int(*)(sqlite3*,char**,const sqlite3_api_routines*))
              sqlite3Autoext.aExt[i];
    }
                              ;
    zErrmsg = 0;
    if( xInit && xInit(db, &zErrmsg, &sqlite3Apis) ){
      sqlite3Error(db, 1,
            "automatic extension loading failed: %s", zErrmsg);
      go = 0;
    }
    sqlite3_free(zErrmsg);
  }
}
# 87445 "ext/sqlite3/libsqlite/sqlite3.c"
static u8 getSafetyLevel(const char *z){

  static const char zText[] = "onoffalseyestruefull";
  static const u8 iOffset[] = {0, 1, 2, 4, 9, 12, 16};
  static const u8 iLength[] = {2, 2, 3, 5, 3, 4, 4};
  static const u8 iValue[] = {1, 0, 0, 0, 1, 1, 2};
  int i, n;
  if( (sqlite3CtypeMap[(unsigned char)(*z)]&0x04) ){
    return (u8)sqlite3Atoi(z);
  }
  n = sqlite3Strlen30(z);
  for(i=0; i<((int)(sizeof(iLength)/sizeof(iLength[0]))); i++){
    if( iLength[i]==n && sqlite3_strnicmp(&zText[iOffset[i]],z,n)==0 ){
      return iValue[i];
    }
  }
  return 1;
}




static u8 getBoolean(const char *z){
  return getSafetyLevel(z)&1;
}




static int getLockingMode(const char *z){
  if( z ){
    if( 0==sqlite3StrICmp(z, "exclusive") ) return 1;
    if( 0==sqlite3StrICmp(z, "normal") ) return 0;
  }
  return -1;
}
# 87489 "ext/sqlite3/libsqlite/sqlite3.c"
static int getAutoVacuum(const char *z){
  int i;
  if( 0==sqlite3StrICmp(z, "none") ) return 0;
  if( 0==sqlite3StrICmp(z, "full") ) return 1;
  if( 0==sqlite3StrICmp(z, "incremental") ) return 2;
  i = sqlite3Atoi(z);
  return (u8)((i>=0&&i<=2)?i:0);
}
# 87505 "ext/sqlite3/libsqlite/sqlite3.c"
static int getTempStore(const char *z){
  if( z[0]>='0' && z[0]<='2' ){
    return z[0] - '0';
  }else if( sqlite3StrICmp(z, "file")==0 ){
    return 1;
  }else if( sqlite3StrICmp(z, "memory")==0 ){
    return 2;
  }else{
    return 0;
  }
}







static int invalidateTempStorage(Parse *pParse){
  sqlite3 *db = pParse->db;
  if( db->aDb[1].pBt!=0 ){
    if( !db->autoCommit || sqlite3BtreeIsInReadTrans(db->aDb[1].pBt) ){
      sqlite3ErrorMsg(pParse, "temporary storage cannot be changed "
        "from within a transaction");
      return 1;
    }
    sqlite3BtreeClose(db->aDb[1].pBt);
    db->aDb[1].pBt = 0;
    sqlite3ResetInternalSchema(db, -1);
  }
  return 0;
}
# 87545 "ext/sqlite3/libsqlite/sqlite3.c"
static int changeTempStorage(Parse *pParse, const char *zStorageType){
  int ts = getTempStore(zStorageType);
  sqlite3 *db = pParse->db;
  if( db->temp_store==ts ) return 0;
  if( invalidateTempStorage( pParse ) != 0 ){
    return 1;
  }
  db->temp_store = (u8)ts;
  return 0;
}





static void returnSingleInt(Parse *pParse, const char *zLabel, i64 value){
  Vdbe *v = sqlite3GetVdbe(pParse);
  int mem = ++pParse->nMem;
  i64 *pI64 = sqlite3DbMallocRaw(pParse->db, sizeof(value));
  if( pI64 ){
    memcpy(pI64, &value, sizeof(value));
  }
  sqlite3VdbeAddOp4(v, 8, 0, mem, 0, (char*)pI64, (-13));
  sqlite3VdbeSetNumCols(v, 1);
  sqlite3VdbeSetColName(v, 0, 0, zLabel, ((sqlite3_destructor_type)0));
  sqlite3VdbeAddOp2(v, 16, mem, 1);
}







static int flagPragma(Parse *pParse, const char *zLeft, const char *zRight){
  static const struct sPragmaType {
    const char *zName;
    int mask;
  } aPragma[] = {
    { "full_column_names", 0x00000400 },
    { "short_column_names", 0x00000800 },
    { "count_changes", 0x00001000 },
    { "empty_result_callbacks", 0x00002000 },
    { "legacy_file_format", 0x00100000 },
    { "fullfsync", 0x00200000 },
    { "checkpoint_fullfsync", 0x00400000 },
    { "reverse_unordered_selects", 0x01000000 },

    { "automatic_index", 0x08000000 },







    { "ignore_check_constraints", 0x00040000 },


    { "writable_schema", 0x00010000|0x00800000 },
    { "omit_readlock", 0x00020000 },



    { "read_uncommitted", 0x0080000 },
    { "recursive_triggers", 0x02000000 },




    { "foreign_keys", 0x04000000 },

  };
  int i;
  const struct sPragmaType *p;
  for(i=0, p=aPragma; i<((int)(sizeof(aPragma)/sizeof(aPragma[0]))); i++, p++){
    if( sqlite3StrICmp(zLeft, p->zName)==0 ){
      sqlite3 *db = pParse->db;
      Vdbe *v;
      v = sqlite3GetVdbe(pParse);
      ((void) (0));
      if( (v) ){
        if( zRight==0 ){
          returnSingleInt(pParse, p->zName, (db->flags & p->mask)!=0 );
        }else{
          int mask = p->mask;
          if( db->autoCommit==0 ){


            mask &= ~(0x04000000);
          }

          if( getBoolean(zRight) ){
            db->flags |= mask;
          }else{
            db->flags &= ~mask;
          }





          sqlite3VdbeAddOp2(v, 122, 0, 0);
        }
      }

      return 1;
    }
  }
  return 0;
}






static const char *actionName(u8 action){
  const char *zName;
  switch( action ){
    case 7: zName = "SET NULL"; break;
    case 8: zName = "SET DEFAULT"; break;
    case 9: zName = "CASCADE"; break;
    case 6: zName = "RESTRICT"; break;
    default: zName = "NO ACTION";
                      ((void) (0)); break;
  }
  return zName;
}
# 87682 "ext/sqlite3/libsqlite/sqlite3.c"
static const char *sqlite3JournalModename(int eMode){
  static char * const azModeName[] = {
    "delete", "persist", "off", "truncate", "memory"

     , "wal"

  };
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( eMode==((int)(sizeof(azModeName)/sizeof(azModeName[0]))) ) return 0;
  return azModeName[eMode];
}
# 87716 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3Pragma(
  Parse *pParse,
  Token *pId1,
  Token *pId2,
  Token *pValue,
  int minusFlag
){
  char *zLeft = 0;
  char *zRight = 0;
  const char *zDb = 0;
  Token *pId;
  int iDb;
  sqlite3 *db = pParse->db;
  Db *pDb;
  Vdbe *v = pParse->pVdbe = sqlite3VdbeCreate(db);
  if( v==0 ) return;
  sqlite3VdbeRunOnlyOnce(v);
  pParse->nMem = 2;



  iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);
  if( iDb<0 ) return;
  pDb = &db->aDb[iDb];




  if( iDb==1 && sqlite3OpenTempDatabase(pParse) ){
    return;
  }

  zLeft = sqlite3NameFromToken(db, pId);
  if( !zLeft ) return;
  if( minusFlag ){
    zRight = sqlite3MPrintf(db, "-%T", pValue);
  }else{
    zRight = sqlite3NameFromToken(db, pValue);
  }

  ((void) (0));
  zDb = pId2->n>0 ? pDb->zName : 0;
  if( sqlite3AuthCheck(pParse, 19, zLeft, zRight, zDb) ){
    goto pragma_out;
  }
# 87779 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3StrICmp(zLeft,"default_cache_size")==0 ){
    static const VdbeOpList getCacheSize[] = {
      { 34, 0, 0, 0},
      { 35, 0, 1, 3},
      { 113, 1, 7, 0},
      { 7, 0, 2, 0},
      { 87, 1, 2, 1},
      { 113, 1, 7, 0},
      { 7, 0, 1, 0},
      { 16, 1, 1, 0},
    };
    int addr;
    if( sqlite3ReadSchema(pParse) ) goto pragma_out;
    sqlite3VdbeUsesBtree(v, iDb);
    if( !zRight ){
      sqlite3VdbeSetNumCols(v, 1);
      sqlite3VdbeSetColName(v, 0, 0, "cache_size", ((sqlite3_destructor_type)0));
      pParse->nMem += 2;
      addr = sqlite3VdbeAddOpList(v, ((int)(sizeof(getCacheSize)/sizeof(getCacheSize[0]))), getCacheSize);
      sqlite3VdbeChangeP1(v, addr, iDb);
      sqlite3VdbeChangeP1(v, addr+1, iDb);
      sqlite3VdbeChangeP1(v, addr+6, 2000);
    }else{
      int size = sqlite3AbsInt32(sqlite3Atoi(zRight));
      sqlite3BeginWriteOperation(pParse, 0, iDb);
      sqlite3VdbeAddOp2(v, 7, size, 1);
      sqlite3VdbeAddOp3(v, 36, iDb, 3, 1);
      ((void) (0));
      pDb->pSchema->cache_size = size;
      sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);
    }
  }else
# 87821 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3StrICmp(zLeft,"page_size")==0 ){
    Btree *pBt = pDb->pBt;
    ((void) (0));
    if( !zRight ){
      int size = (pBt) ? sqlite3BtreeGetPageSize(pBt) : 0;
      returnSingleInt(pParse, "page_size", size);
    }else{



      db->nextPagesize = sqlite3Atoi(zRight);
      if( 7==sqlite3BtreeSetPageSize(pBt, db->nextPagesize, -1, 0) ){
        db->mallocFailed = 1;
      }
    }
  }else
# 87846 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3StrICmp(zLeft,"secure_delete")==0 ){
    Btree *pBt = pDb->pBt;
    int b = -1;
    ((void) (0));
    if( zRight ){
      b = getBoolean(zRight);
    }
    if( pId2->n==0 && b>=0 ){
      int ii;
      for(ii=0; ii<db->nDb; ii++){
        sqlite3BtreeSecureDelete(db->aDb[ii].pBt, b);
      }
    }
    b = sqlite3BtreeSecureDelete(pBt, b);
    returnSingleInt(pParse, "secure_delete", b);
  }else
# 87876 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3StrICmp(zLeft,"page_count")==0
   || sqlite3StrICmp(zLeft,"max_page_count")==0
  ){
    int iReg;
    if( sqlite3ReadSchema(pParse) ) goto pragma_out;
    sqlite3CodeVerifySchema(pParse, iDb);
    iReg = ++pParse->nMem;
    if( zLeft[0]=='p' ){
      sqlite3VdbeAddOp2(v, 134, iDb, iReg);
    }else{
      sqlite3VdbeAddOp3(v, 135, iDb, iReg, sqlite3Atoi(zRight));
    }
    sqlite3VdbeAddOp2(v, 16, iReg, 1);
    sqlite3VdbeSetNumCols(v, 1);
    sqlite3VdbeSetColName(v, 0, 0, zLeft, ((sqlite3_destructor_type)-1));
  }else





  if( sqlite3StrICmp(zLeft,"locking_mode")==0 ){
    const char *zRet = "normal";
    int eMode = getLockingMode(zRight);

    if( pId2->n==0 && eMode==-1 ){




      eMode = db->dfltLockMode;
    }else{
      Pager *pPager;
      if( pId2->n==0 ){
# 87918 "ext/sqlite3/libsqlite/sqlite3.c"
        int ii;
        ((void) (0));
        for(ii=2; ii<db->nDb; ii++){
          pPager = sqlite3BtreePager(db->aDb[ii].pBt);
          sqlite3PagerLockingMode(pPager, eMode);
        }
        db->dfltLockMode = (u8)eMode;
      }
      pPager = sqlite3BtreePager(pDb->pBt);
      eMode = sqlite3PagerLockingMode(pPager, eMode);
    }

    ((void) (0));
    if( eMode==1 ){
      zRet = "exclusive";
    }
    sqlite3VdbeSetNumCols(v, 1);
    sqlite3VdbeSetColName(v, 0, 0, "locking_mode", ((sqlite3_destructor_type)0));
    sqlite3VdbeAddOp4(v, 94, 0, 1, 0, zRet, 0);
    sqlite3VdbeAddOp2(v, 16, 1, 1);
  }else






  if( sqlite3StrICmp(zLeft,"journal_mode")==0 ){
    int eMode;
    int ii;



    if( sqlite3ReadSchema(pParse) ){
      goto pragma_out;
    }

    sqlite3VdbeSetNumCols(v, 1);
    sqlite3VdbeSetColName(v, 0, 0, "journal_mode", ((sqlite3_destructor_type)0));

    if( zRight==0 ){


      eMode = (-1);
    }else{
      const char *zMode;
      int n = sqlite3Strlen30(zRight);
      for(eMode=0; (zMode = sqlite3JournalModename(eMode))!=0; eMode++){
        if( sqlite3_strnicmp(zRight, zMode, n)==0 ) break;
      }
      if( !zMode ){


        eMode = (-1);
      }
    }
    if( eMode==(-1) && pId2->n==0 ){

      iDb = 0;
      pId2->n = 1;
    }
    for(ii=db->nDb-1; ii>=0; ii--){
      if( db->aDb[ii].pBt && (ii==iDb || pId2->n==0) ){
        sqlite3VdbeUsesBtree(v, ii);
        sqlite3VdbeAddOp3(v, 119, ii, 1, eMode);
      }
    }
    sqlite3VdbeAddOp2(v, 16, 1, 1);
  }else







  if( sqlite3StrICmp(zLeft,"journal_size_limit")==0 ){
    Pager *pPager = sqlite3BtreePager(pDb->pBt);
    i64 iLimit = -2;
    if( zRight ){
      sqlite3Atoi64(zRight, &iLimit, 1000000, 1);
      if( iLimit<-1 ) iLimit = -1;
    }
    iLimit = sqlite3PagerJournalSizeLimit(pPager, iLimit);
    returnSingleInt(pParse, "journal_size_limit", iLimit);
  }else
# 88015 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3StrICmp(zLeft,"auto_vacuum")==0 ){
    Btree *pBt = pDb->pBt;
    ((void) (0));
    if( sqlite3ReadSchema(pParse) ){
      goto pragma_out;
    }
    if( !zRight ){
      int auto_vacuum;
      if( (pBt) ){
         auto_vacuum = sqlite3BtreeGetAutoVacuum(pBt);
      }else{
         auto_vacuum = 0;
      }
      returnSingleInt(pParse, "auto_vacuum", auto_vacuum);
    }else{
      int eAuto = getAutoVacuum(zRight);
      ((void) (0));
      db->nextAutovac = (u8)eAuto;
      if( (eAuto>=0) ){





        int rc = sqlite3BtreeSetAutoVacuum(pBt, eAuto);
        if( rc==0 && (eAuto==1 || eAuto==2) ){





          static const VdbeOpList setMeta6[] = {
            { 34, 0, 1, 0},
            { 35, 0, 1, 4},
            { 26, 1, 0, 0},
            { 6, 0, 2, 0},
            { 7, 0, 1, 0},
            { 36, 0, 7, 1},
          };
          int iAddr;
          iAddr = sqlite3VdbeAddOpList(v, ((int)(sizeof(setMeta6)/sizeof(setMeta6[0]))), setMeta6);
          sqlite3VdbeChangeP1(v, iAddr, iDb);
          sqlite3VdbeChangeP1(v, iAddr+1, iDb);
          sqlite3VdbeChangeP2(v, iAddr+2, iAddr+4);
          sqlite3VdbeChangeP1(v, iAddr+4, eAuto-1);
          sqlite3VdbeChangeP1(v, iAddr+5, iDb);
          sqlite3VdbeUsesBtree(v, iDb);
        }
      }
    }
  }else
# 88074 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3StrICmp(zLeft,"incremental_vacuum")==0 ){
    int iLimit, addr;
    if( sqlite3ReadSchema(pParse) ){
      goto pragma_out;
    }
    if( zRight==0 || !sqlite3GetInt32(zRight, &iLimit) || iLimit<=0 ){
      iLimit = 0x7fffffff;
    }
    sqlite3BeginWriteOperation(pParse, 0, iDb);
    sqlite3VdbeAddOp2(v, 7, iLimit, 1);
    addr = sqlite3VdbeAddOp1(v, 121, iDb);
    sqlite3VdbeAddOp1(v, 16, 1);
    sqlite3VdbeAddOp2(v, 20, 1, -1);
    sqlite3VdbeAddOp2(v, 113, 1, addr);
    sqlite3VdbeJumpHere(v, addr);
  }else
# 88107 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3StrICmp(zLeft,"cache_size")==0 ){
    if( sqlite3ReadSchema(pParse) ) goto pragma_out;
    ((void) (0));
    if( !zRight ){
      returnSingleInt(pParse, "cache_size", pDb->pSchema->cache_size);
    }else{
      int size = sqlite3AbsInt32(sqlite3Atoi(zRight));
      pDb->pSchema->cache_size = size;
      sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);
    }
  }else
# 88130 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3StrICmp(zLeft, "temp_store")==0 ){
    if( !zRight ){
      returnSingleInt(pParse, "temp_store", db->temp_store);
    }else{
      changeTempStorage(pParse, zRight);
    }
  }else
# 88148 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3StrICmp(zLeft, "temp_store_directory")==0 ){
    if( !zRight ){
      if( sqlite3_temp_directory ){
        sqlite3VdbeSetNumCols(v, 1);
        sqlite3VdbeSetColName(v, 0, 0,
            "temp_store_directory", ((sqlite3_destructor_type)0));
        sqlite3VdbeAddOp4(v, 94, 0, 1, 0, sqlite3_temp_directory, 0);
        sqlite3VdbeAddOp2(v, 16, 1, 1);
      }
    }else{

      if( zRight[0] ){
        int rc;
        int res;
        rc = sqlite3OsAccess(db->pVfs, zRight, 1, &res);
        if( rc!=0 || res==0 ){
          sqlite3ErrorMsg(pParse, "not a writable directory");
          goto pragma_out;
        }
      }
      if( 1==0
       || (1==1 && db->temp_store<=1)
       || (1==2 && db->temp_store==1)
      ){
        invalidateTempStorage(pParse);
      }
      sqlite3_free(sqlite3_temp_directory);
      if( zRight[0] ){
        sqlite3_temp_directory = sqlite3_mprintf("%s", zRight);
      }else{
        sqlite3_temp_directory = 0;
      }

    }
  }else
# 88243 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3StrICmp(zLeft,"synchronous")==0 ){
    if( sqlite3ReadSchema(pParse) ) goto pragma_out;
    if( !zRight ){
      returnSingleInt(pParse, "synchronous", pDb->safety_level-1);
    }else{
      if( !db->autoCommit ){
        sqlite3ErrorMsg(pParse,
            "Safety level may not be changed inside a transaction");
      }else{
        pDb->safety_level = getSafetyLevel(zRight)+1;
      }
    }
  }else



  if( flagPragma(pParse, zLeft, zRight) ){


  }else
# 88278 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3StrICmp(zLeft, "table_info")==0 && zRight ){
    Table *pTab;
    if( sqlite3ReadSchema(pParse) ) goto pragma_out;
    pTab = sqlite3FindTable(db, zRight, zDb);
    if( pTab ){
      int i;
      int nHidden = 0;
      Column *pCol;
      sqlite3VdbeSetNumCols(v, 6);
      pParse->nMem = 6;
      sqlite3VdbeSetColName(v, 0, 0, "cid", ((sqlite3_destructor_type)0));
      sqlite3VdbeSetColName(v, 1, 0, "name", ((sqlite3_destructor_type)0));
      sqlite3VdbeSetColName(v, 2, 0, "type", ((sqlite3_destructor_type)0));
      sqlite3VdbeSetColName(v, 3, 0, "notnull", ((sqlite3_destructor_type)0));
      sqlite3VdbeSetColName(v, 4, 0, "dflt_value", ((sqlite3_destructor_type)0));
      sqlite3VdbeSetColName(v, 5, 0, "pk", ((sqlite3_destructor_type)0));
      sqlite3ViewGetColumnNames(pParse, pTab);
      for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){
        if( ((pCol)->isHidden) ){
          nHidden++;
          continue;
        }
        sqlite3VdbeAddOp2(v, 7, i-nHidden, 1);
        sqlite3VdbeAddOp4(v, 94, 0, 2, 0, pCol->zName, 0);
        sqlite3VdbeAddOp4(v, 94, 0, 3, 0,
           pCol->zType ? pCol->zType : "", 0);
        sqlite3VdbeAddOp2(v, 7, (pCol->notNull ? 1 : 0), 4);
        if( pCol->zDflt ){
          sqlite3VdbeAddOp4(v, 94, 0, 5, 0, (char*)pCol->zDflt, 0);
        }else{
          sqlite3VdbeAddOp2(v, 10, 0, 5);
        }
        sqlite3VdbeAddOp2(v, 7, pCol->isPrimKey, 6);
        sqlite3VdbeAddOp2(v, 16, 1, 6);
      }
    }
  }else

  if( sqlite3StrICmp(zLeft, "index_info")==0 && zRight ){
    Index *pIdx;
    Table *pTab;
    if( sqlite3ReadSchema(pParse) ) goto pragma_out;
    pIdx = sqlite3FindIndex(db, zRight, zDb);
    if( pIdx ){
      int i;
      pTab = pIdx->pTable;
      sqlite3VdbeSetNumCols(v, 3);
      pParse->nMem = 3;
      sqlite3VdbeSetColName(v, 0, 0, "seqno", ((sqlite3_destructor_type)0));
      sqlite3VdbeSetColName(v, 1, 0, "cid", ((sqlite3_destructor_type)0));
      sqlite3VdbeSetColName(v, 2, 0, "name", ((sqlite3_destructor_type)0));
      for(i=0; i<pIdx->nColumn; i++){
        int cnum = pIdx->aiColumn[i];
        sqlite3VdbeAddOp2(v, 7, i, 1);
        sqlite3VdbeAddOp2(v, 7, cnum, 2);
        ((void) (0));
        sqlite3VdbeAddOp4(v, 94, 0, 3, 0, pTab->aCol[cnum].zName, 0);
        sqlite3VdbeAddOp2(v, 16, 1, 3);
      }
    }
  }else

  if( sqlite3StrICmp(zLeft, "index_list")==0 && zRight ){
    Index *pIdx;
    Table *pTab;
    if( sqlite3ReadSchema(pParse) ) goto pragma_out;
    pTab = sqlite3FindTable(db, zRight, zDb);
    if( pTab ){
      v = sqlite3GetVdbe(pParse);
      pIdx = pTab->pIndex;
      if( pIdx ){
        int i = 0;
        sqlite3VdbeSetNumCols(v, 3);
        pParse->nMem = 3;
        sqlite3VdbeSetColName(v, 0, 0, "seq", ((sqlite3_destructor_type)0));
        sqlite3VdbeSetColName(v, 1, 0, "name", ((sqlite3_destructor_type)0));
        sqlite3VdbeSetColName(v, 2, 0, "unique", ((sqlite3_destructor_type)0));
        while(pIdx){
          sqlite3VdbeAddOp2(v, 7, i, 1);
          sqlite3VdbeAddOp4(v, 94, 0, 2, 0, pIdx->zName, 0);
          sqlite3VdbeAddOp2(v, 7, pIdx->onError!=0, 3);
          sqlite3VdbeAddOp2(v, 16, 1, 3);
          ++i;
          pIdx = pIdx->pNext;
        }
      }
    }
  }else

  if( sqlite3StrICmp(zLeft, "database_list")==0 ){
    int i;
    if( sqlite3ReadSchema(pParse) ) goto pragma_out;
    sqlite3VdbeSetNumCols(v, 3);
    pParse->nMem = 3;
    sqlite3VdbeSetColName(v, 0, 0, "seq", ((sqlite3_destructor_type)0));
    sqlite3VdbeSetColName(v, 1, 0, "name", ((sqlite3_destructor_type)0));
    sqlite3VdbeSetColName(v, 2, 0, "file", ((sqlite3_destructor_type)0));
    for(i=0; i<db->nDb; i++){
      if( db->aDb[i].pBt==0 ) continue;
      ((void) (0));
      sqlite3VdbeAddOp2(v, 7, i, 1);
      sqlite3VdbeAddOp4(v, 94, 0, 2, 0, db->aDb[i].zName, 0);
      sqlite3VdbeAddOp4(v, 94, 0, 3, 0,
           sqlite3BtreeGetFilename(db->aDb[i].pBt), 0);
      sqlite3VdbeAddOp2(v, 16, 1, 3);
    }
  }else

  if( sqlite3StrICmp(zLeft, "collation_list")==0 ){
    int i = 0;
    HashElem *p;
    sqlite3VdbeSetNumCols(v, 2);
    pParse->nMem = 2;
    sqlite3VdbeSetColName(v, 0, 0, "seq", ((sqlite3_destructor_type)0));
    sqlite3VdbeSetColName(v, 1, 0, "name", ((sqlite3_destructor_type)0));
    for(p=((&db->aCollSeq)->first); p; p=((p)->next)){
      CollSeq *pColl = (CollSeq *)((p)->data);
      sqlite3VdbeAddOp2(v, 7, i++, 1);
      sqlite3VdbeAddOp4(v, 94, 0, 2, 0, pColl->zName, 0);
      sqlite3VdbeAddOp2(v, 16, 1, 2);
    }
  }else



  if( sqlite3StrICmp(zLeft, "foreign_key_list")==0 && zRight ){
    FKey *pFK;
    Table *pTab;
    if( sqlite3ReadSchema(pParse) ) goto pragma_out;
    pTab = sqlite3FindTable(db, zRight, zDb);
    if( pTab ){
      v = sqlite3GetVdbe(pParse);
      pFK = pTab->pFKey;
      if( pFK ){
        int i = 0;
        sqlite3VdbeSetNumCols(v, 8);
        pParse->nMem = 8;
        sqlite3VdbeSetColName(v, 0, 0, "id", ((sqlite3_destructor_type)0));
        sqlite3VdbeSetColName(v, 1, 0, "seq", ((sqlite3_destructor_type)0));
        sqlite3VdbeSetColName(v, 2, 0, "table", ((sqlite3_destructor_type)0));
        sqlite3VdbeSetColName(v, 3, 0, "from", ((sqlite3_destructor_type)0));
        sqlite3VdbeSetColName(v, 4, 0, "to", ((sqlite3_destructor_type)0));
        sqlite3VdbeSetColName(v, 5, 0, "on_update", ((sqlite3_destructor_type)0));
        sqlite3VdbeSetColName(v, 6, 0, "on_delete", ((sqlite3_destructor_type)0));
        sqlite3VdbeSetColName(v, 7, 0, "match", ((sqlite3_destructor_type)0));
        while(pFK){
          int j;
          for(j=0; j<pFK->nCol; j++){
            char *zCol = pFK->aCol[j].zCol;
            char *zOnDelete = (char *)actionName(pFK->aAction[0]);
            char *zOnUpdate = (char *)actionName(pFK->aAction[1]);
            sqlite3VdbeAddOp2(v, 7, i, 1);
            sqlite3VdbeAddOp2(v, 7, j, 2);
            sqlite3VdbeAddOp4(v, 94, 0, 3, 0, pFK->zTo, 0);
            sqlite3VdbeAddOp4(v, 94, 0, 4, 0,
                              pTab->aCol[pFK->aCol[j].iFrom].zName, 0);
            sqlite3VdbeAddOp4(v, zCol ? 94 : 10, 0, 5, 0, zCol, 0);
            sqlite3VdbeAddOp4(v, 94, 0, 6, 0, zOnUpdate, 0);
            sqlite3VdbeAddOp4(v, 94, 0, 7, 0, zOnDelete, 0);
            sqlite3VdbeAddOp4(v, 94, 0, 8, 0, "NONE", 0);
            sqlite3VdbeAddOp2(v, 16, 1, 8);
          }
          ++i;
          pFK = pFK->pNextFrom;
        }
      }
    }
  }else
# 88463 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3StrICmp(zLeft, "case_sensitive_like")==0 ){
    if( zRight ){
      sqlite3RegisterLikeFunctions(db, getBoolean(zRight));
    }
  }else
# 88478 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3StrICmp(zLeft, "integrity_check")==0
   || sqlite3StrICmp(zLeft, "quick_check")==0
  ){
    int i, j, addr, mxErr;





    static const VdbeOpList endCode[] = {
      { 20, 1, 0, 0},
      { 114, 1, 0, 0},
      { 94, 0, 3, 0},
      { 16, 3, 1, 0},
    };

    int isQuick = (zLeft[0]=='q');


    if( sqlite3ReadSchema(pParse) ) goto pragma_out;
    pParse->nMem = 6;
    sqlite3VdbeSetNumCols(v, 1);
    sqlite3VdbeSetColName(v, 0, 0, "integrity_check", ((sqlite3_destructor_type)0));


    mxErr = 100;
    if( zRight ){
      sqlite3GetInt32(zRight, &mxErr);
      if( mxErr<=0 ){
        mxErr = 100;
      }
    }
    sqlite3VdbeAddOp2(v, 7, mxErr, 1);


    for(i=0; i<db->nDb; i++){
      HashElem *x;
      Hash *pTbls;
      int cnt = 0;

      if( 0 && i==1 ) continue;

      sqlite3CodeVerifySchema(pParse, i);
      addr = sqlite3VdbeAddOp1(v, 113, 1);
      sqlite3VdbeAddOp2(v, 6, 0, 0);
      sqlite3VdbeJumpHere(v, addr);






      ((void) (0));
      pTbls = &db->aDb[i].pSchema->tblHash;
      for(x=((pTbls)->first); x; x=((x)->next)){
        Table *pTab = ((x)->data);
        Index *pIdx;
        sqlite3VdbeAddOp2(v, 7, pTab->tnum, 2+cnt);
        cnt++;
        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
          sqlite3VdbeAddOp2(v, 7, pIdx->tnum, 2+cnt);
          cnt++;
        }
      }


      if( pParse->nMem < cnt+4 ){
        pParse->nMem = cnt+4;
      }


      sqlite3VdbeAddOp3(v, 104, 2, cnt, 1);
      sqlite3VdbeChangeP5(v, (u8)i);
      addr = sqlite3VdbeAddOp1(v, 73, 2);
      sqlite3VdbeAddOp4(v, 94, 0, 3, 0,
         sqlite3MPrintf(db, "*** in database %s ***\n", db->aDb[i].zName),
         (-1));
      sqlite3VdbeAddOp3(v, 13, 2, 4, 1);
      sqlite3VdbeAddOp3(v, 91, 4, 3, 2);
      sqlite3VdbeAddOp2(v, 16, 2, 1);
      sqlite3VdbeJumpHere(v, addr);



      for(x=((pTbls)->first); x && !isQuick; x=((x)->next)){
        Table *pTab = ((x)->data);
        Index *pIdx;
        int loopTop;

        if( pTab->pIndex==0 ) continue;
        addr = sqlite3VdbeAddOp1(v, 113, 1);
        sqlite3VdbeAddOp2(v, 6, 0, 0);
        sqlite3VdbeJumpHere(v, addr);
        sqlite3OpenTableAndIndices(pParse, pTab, 1, 38);
        sqlite3VdbeAddOp2(v, 7, 0, 2);
        loopTop = sqlite3VdbeAddOp2(v, 65, 1, 0);
        sqlite3VdbeAddOp2(v, 20, 2, 1);
        for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){
          int jmp2;
          int r1;
          static const VdbeOpList idxErr[] = {
            { 20, 1, -1, 0},
            { 94, 0, 3, 0},
            { 61, 1, 4, 0},
            { 94, 0, 5, 0},
            { 94, 0, 6, 0},
            { 91, 4, 3, 3},
            { 91, 5, 3, 3},
            { 91, 6, 3, 3},
            { 16, 3, 1, 0},
            { 113, 1, 0, 0},
            { 6, 0, 0, 0},
          };
          r1 = sqlite3GenerateIndexKey(pParse, pIdx, 1, 3, 0);
          jmp2 = sqlite3VdbeAddOp4Int(v, 50, j+2, 0, r1, pIdx->nColumn+1);
          addr = sqlite3VdbeAddOpList(v, ((int)(sizeof(idxErr)/sizeof(idxErr[0]))), idxErr);
          sqlite3VdbeChangeP4(v, addr+1, "rowid ", (-2));
          sqlite3VdbeChangeP4(v, addr+3, " missing from index ", (-2));
          sqlite3VdbeChangeP4(v, addr+4, pIdx->zName, 0);
          sqlite3VdbeJumpHere(v, addr+9);
          sqlite3VdbeJumpHere(v, jmp2);
        }
        sqlite3VdbeAddOp2(v, 67, 1, loopTop+1);
        sqlite3VdbeJumpHere(v, loopTop);
        for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){
          static const VdbeOpList cntIdx[] = {
             { 7, 0, 3, 0},
             { 65, 0, 0, 0},
             { 20, 3, 1, 0},
             { 67, 0, 0, 0},
             { 76, 2, 0, 3},
             { 20, 1, -1, 0},
             { 94, 0, 2, 0},
             { 94, 0, 3, 0},
             { 91, 3, 2, 2},
             { 16, 2, 1, 0},
          };
          addr = sqlite3VdbeAddOp1(v, 113, 1);
          sqlite3VdbeAddOp2(v, 6, 0, 0);
          sqlite3VdbeJumpHere(v, addr);
          addr = sqlite3VdbeAddOpList(v, ((int)(sizeof(cntIdx)/sizeof(cntIdx[0]))), cntIdx);
          sqlite3VdbeChangeP1(v, addr+1, j+2);
          sqlite3VdbeChangeP2(v, addr+1, addr+4);
          sqlite3VdbeChangeP1(v, addr+3, j+2);
          sqlite3VdbeChangeP2(v, addr+3, addr+2);
          sqlite3VdbeJumpHere(v, addr+4);
          sqlite3VdbeChangeP4(v, addr+6,
                     "wrong # of entries in index ", (-2));
          sqlite3VdbeChangeP4(v, addr+7, pIdx->zName, 0);
        }
      }
    }
    addr = sqlite3VdbeAddOpList(v, ((int)(sizeof(endCode)/sizeof(endCode[0]))), endCode);
    sqlite3VdbeChangeP2(v, addr, -mxErr);
    sqlite3VdbeJumpHere(v, addr+1);
    sqlite3VdbeChangeP4(v, addr+2, "ok", (-2));
  }else
# 88660 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3StrICmp(zLeft, "encoding")==0 ){
    static const struct EncName {
      char *zName;
      u8 enc;
    } encnames[] = {
      { "UTF8", 1 },
      { "UTF-8", 1 },
      { "UTF-16le", 2 },
      { "UTF-16be", 3 },
      { "UTF16le", 2 },
      { "UTF16be", 3 },
      { "UTF-16", 0 },
      { "UTF16", 0 },
      { 0, 0 }
    };
    const struct EncName *pEnc;
    if( !zRight ){
      if( sqlite3ReadSchema(pParse) ) goto pragma_out;
      sqlite3VdbeSetNumCols(v, 1);
      sqlite3VdbeSetColName(v, 0, 0, "encoding", ((sqlite3_destructor_type)0));
      sqlite3VdbeAddOp2(v, 94, 0, 1);
      ((void) (0));
      ((void) (0));
      ((void) (0));
      sqlite3VdbeChangeP4(v, -1, encnames[((pParse->db)->aDb[0].pSchema->enc)].zName, (-2));
      sqlite3VdbeAddOp2(v, 16, 1, 1);
    }else{





      if(
        !((((db)->aDb[0].pSchema->flags&(0x0001))==(0x0001))) ||
        (((db)->aDb[0].pSchema->flags&(0x0004))==(0x0004))
      ){
        for(pEnc=&encnames[0]; pEnc->zName; pEnc++){
          if( 0==sqlite3StrICmp(zRight, pEnc->zName) ){
            ((pParse->db)->aDb[0].pSchema->enc) = pEnc->enc ? pEnc->enc : 2;
            break;
          }
        }
        if( !pEnc->zName ){
          sqlite3ErrorMsg(pParse, "unsupported encoding: %s", zRight);
        }
      }
    }
  }else
# 88736 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3StrICmp(zLeft, "schema_version")==0
   || sqlite3StrICmp(zLeft, "user_version")==0
   || sqlite3StrICmp(zLeft, "freelist_count")==0
  ){
    int iCookie;
    sqlite3VdbeUsesBtree(v, iDb);
    switch( zLeft[0] ){
      case 'f': case 'F':
        iCookie = 0;
        break;
      case 's': case 'S':
        iCookie = 1;
        break;
      default:
        iCookie = 6;
        break;
    }

    if( zRight && iCookie!=0 ){

      static const VdbeOpList setCookie[] = {
        { 34, 0, 1, 0},
        { 7, 0, 1, 0},
        { 36, 0, 0, 1},
      };
      int addr = sqlite3VdbeAddOpList(v, ((int)(sizeof(setCookie)/sizeof(setCookie[0]))), setCookie);
      sqlite3VdbeChangeP1(v, addr, iDb);
      sqlite3VdbeChangeP1(v, addr+1, sqlite3Atoi(zRight));
      sqlite3VdbeChangeP1(v, addr+2, iDb);
      sqlite3VdbeChangeP2(v, addr+2, iCookie);
    }else{

      static const VdbeOpList readCookie[] = {
        { 34, 0, 0, 0},
        { 35, 0, 1, 0},
        { 16, 1, 1, 0}
      };
      int addr = sqlite3VdbeAddOpList(v, ((int)(sizeof(readCookie)/sizeof(readCookie[0]))), readCookie);
      sqlite3VdbeChangeP1(v, addr, iDb);
      sqlite3VdbeChangeP1(v, addr+1, iDb);
      sqlite3VdbeChangeP3(v, addr+1, iCookie);
      sqlite3VdbeSetNumCols(v, 1);
      sqlite3VdbeSetColName(v, 0, 0, zLeft, ((sqlite3_destructor_type)-1));
    }
  }else
# 88790 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3StrICmp(zLeft, "compile_options")==0 ){
    int i = 0;
    const char *zOpt;
    sqlite3VdbeSetNumCols(v, 1);
    pParse->nMem = 1;
    sqlite3VdbeSetColName(v, 0, 0, "compile_option", ((sqlite3_destructor_type)0));
    while( (zOpt = sqlite3_compileoption_get(i++))!=0 ){
      sqlite3VdbeAddOp4(v, 94, 0, 1, 0, zOpt, 0);
      sqlite3VdbeAddOp2(v, 16, 1, 1);
    }
  }else
# 88809 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3StrICmp(zLeft, "wal_checkpoint")==0 ){
    int iBt = (pId2->z?iDb:10);
    int eMode = 0;
    if( zRight ){
      if( sqlite3StrICmp(zRight, "full")==0 ){
        eMode = 1;
      }else if( sqlite3StrICmp(zRight, "restart")==0 ){
        eMode = 2;
      }
    }
    if( sqlite3ReadSchema(pParse) ) goto pragma_out;
    sqlite3VdbeSetNumCols(v, 3);
    pParse->nMem = 3;
    sqlite3VdbeSetColName(v, 0, 0, "busy", ((sqlite3_destructor_type)0));
    sqlite3VdbeSetColName(v, 1, 0, "log", ((sqlite3_destructor_type)0));
    sqlite3VdbeSetColName(v, 2, 0, "checkpointed", ((sqlite3_destructor_type)0));

    sqlite3VdbeAddOp3(v, 118, iBt, eMode, 1);
    sqlite3VdbeAddOp2(v, 16, 1, 3);
  }else
# 88838 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3StrICmp(zLeft, "wal_autocheckpoint")==0 ){
    if( zRight ){
      sqlite3_wal_autocheckpoint(db, sqlite3Atoi(zRight));
    }
    returnSingleInt(pParse, "wal_autocheckpoint",
       db->xWalCallback==sqlite3WalDefaultHook ?
           ((int)(long int)(db->pWalArg)) : 0);
  }else
# 88921 "ext/sqlite3/libsqlite/sqlite3.c"
  { }






  if( db->autoCommit ){
    sqlite3BtreeSetSafetyLevel(pDb->pBt, pDb->safety_level,
               (db->flags&0x00200000)!=0,
               (db->flags&0x00400000)!=0);
  }

pragma_out:
  sqlite3DbFree(db, zLeft);
  sqlite3DbFree(db, zRight);
}
# 88963 "ext/sqlite3/libsqlite/sqlite3.c"
static void corruptSchema(
  InitData *pData,
  const char *zObj,
  const char *zExtra
){
  sqlite3 *db = pData->db;
  if( !db->mallocFailed && (db->flags & 0x00800000)==0 ){
    if( zObj==0 ) zObj = "?";
    sqlite3SetString(pData->pzErrMsg, db,
      "malformed database schema (%s)", zObj);
    if( zExtra ){
      *pData->pzErrMsg = sqlite3MAppendf(db, *pData->pzErrMsg,
                                 "%s - %s", *pData->pzErrMsg, zExtra);
    }
  }
  pData->rc = db->mallocFailed ? 7 : sqlite3CorruptError(88978);
}
# 88993 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3InitCallback(void *pInit, int argc, char **argv, char **NotUsed){
  InitData *pData = (InitData*)pInit;
  sqlite3 *db = pData->db;
  int iDb = pData->iDb;

  ((void) (0));
  (void)(NotUsed),(void)(argc);
  ((void) (0));
  (db)->aDb[iDb].pSchema->flags&=~(0x0004);
  if( db->mallocFailed ){
    corruptSchema(pData, argv[0], 0);
    return 1;
  }

  ((void) (0));
  if( argv==0 ) return 0;
  if( argv[1]==0 ){
    corruptSchema(pData, argv[0], 0);
  }else if( argv[2] && argv[2][0] ){





    int rc;
    sqlite3_stmt *pStmt;
                     ;

    ((void) (0));
    db->init.iDb = iDb;
    db->init.newTnum = sqlite3Atoi(argv[1]);
    db->init.orphanTrigger = 0;
                     sqlite3_prepare(db, argv[2], -1, &pStmt, 0);
    rc = db->errCode;
    ((void) (0));
    db->init.iDb = 0;
    if( 0!=rc ){
      if( db->init.orphanTrigger ){
        ((void) (0));
      }else{
        pData->rc = rc;
        if( rc==7 ){
          db->mallocFailed = 1;
        }else if( rc!=9 && (rc&0xFF)!=6 ){
          corruptSchema(pData, argv[0], sqlite3_errmsg(db));
        }
      }
    }
    sqlite3_finalize(pStmt);
  }else if( argv[0]==0 ){
    corruptSchema(pData, 0, 0);
  }else{






    Index *pIndex;
    pIndex = sqlite3FindIndex(db, argv[0], db->aDb[iDb].zName);
    if( pIndex==0 ){





                      ;
    }else if( sqlite3GetInt32(argv[1], &pIndex->tnum)==0 ){
      corruptSchema(pData, argv[0], "invalid rootpage");
    }
  }
  return 0;
}
# 89075 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3InitOne(sqlite3 *db, int iDb, char **pzErrMsg){
  int rc;
  int i;
  int size;
  Table *pTab;
  Db *pDb;
  char const *azArg[4];
  int meta[5];
  InitData initData;
  char const *zMasterSchema;
  char const *zMasterName;
  int openedTransaction = 0;




  static const char master_schema[] =
     "CREATE TABLE sqlite_master(\n"
     "  type text,\n"
     "  name text,\n"
     "  tbl_name text,\n"
     "  rootpage integer,\n"
     "  sql text\n"
     ")"
  ;

  static const char temp_master_schema[] =
     "CREATE TEMP TABLE sqlite_temp_master(\n"
     "  type text,\n"
     "  name text,\n"
     "  tbl_name text,\n"
     "  rootpage integer,\n"
     "  sql text\n"
     ")"
  ;




  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));





  if( !0 && iDb==1 ){
    zMasterSchema = temp_master_schema;
  }else{
    zMasterSchema = master_schema;
  }
  zMasterName = ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master");


  azArg[0] = zMasterName;
  azArg[1] = "1";
  azArg[2] = zMasterSchema;
  azArg[3] = 0;
  initData.db = db;
  initData.iDb = iDb;
  initData.rc = 0;
  initData.pzErrMsg = pzErrMsg;
  sqlite3InitCallback(&initData, 3, (char **)azArg, 0);
  if( initData.rc ){
    rc = initData.rc;
    goto error_out;
  }
  pTab = sqlite3FindTable(db, zMasterName, db->aDb[iDb].zName);
  if( (pTab) ){
    pTab->tabFlags |= 0x01;
  }



  pDb = &db->aDb[iDb];
  if( pDb->pBt==0 ){
    if( !0 && (iDb==1) ){
      (db)->aDb[1].pSchema->flags|=(0x0001);
    }
    return 0;
  }




  sqlite3BtreeEnter(pDb->pBt);
  if( !sqlite3BtreeIsInReadTrans(pDb->pBt) ){
    rc = sqlite3BtreeBeginTrans(pDb->pBt, 0);
    if( rc!=0 ){
      sqlite3SetString(pzErrMsg, db, "%s", sqlite3ErrStr(rc));
      goto initone_error_out;
    }
    openedTransaction = 1;
  }
# 89189 "ext/sqlite3/libsqlite/sqlite3.c"
  for(i=0; i<((int)(sizeof(meta)/sizeof(meta[0]))); i++){
    sqlite3BtreeGetMeta(pDb->pBt, i+1, (u32 *)&meta[i]);
  }
  pDb->pSchema->schema_cookie = meta[1 -1];






  if( meta[5 -1] ){
    if( iDb==0 ){
      u8 encoding;

      encoding = (u8)meta[5 -1] & 3;
      if( encoding==0 ) encoding = 1;
      ((db)->aDb[0].pSchema->enc) = encoding;
      db->pDfltColl = sqlite3FindCollSeq(db, 1, "BINARY", 0);
    }else{

      if( meta[5 -1]!=((db)->aDb[0].pSchema->enc) ){
        sqlite3SetString(pzErrMsg, db, "attached databases must use the same"
            " text encoding as main database");
        rc = 1;
        goto initone_error_out;
      }
    }
  }else{
    (db)->aDb[iDb].pSchema->flags|=(0x0004);
  }
  pDb->pSchema->enc = ((db)->aDb[0].pSchema->enc);

  if( pDb->pSchema->cache_size==0 ){
    size = sqlite3AbsInt32(meta[3 -1]);
    if( size==0 ){ size = 2000; }
    pDb->pSchema->cache_size = size;
    sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);
  }







  pDb->pSchema->file_format = (u8)meta[2 -1];
  if( pDb->pSchema->file_format==0 ){
    pDb->pSchema->file_format = 1;
  }
  if( pDb->pSchema->file_format>4 ){
    sqlite3SetString(pzErrMsg, db, "unsupported file format");
    rc = 1;
    goto initone_error_out;
  }






  if( iDb==0 && meta[2 -1]>=4 ){
    db->flags &= ~0x00100000;
  }



  ((void) (0));
  {
    char *zSql;
    zSql = sqlite3MPrintf(db,
        "SELECT name, rootpage, sql FROM '%q'.%s ORDER BY rowid",
        db->aDb[iDb].zName, zMasterName);

    {
      int (*xAuth)(void*,int,const char*,const char*,const char*,const char*);
      xAuth = db->xAuth;
      db->xAuth = 0;

      rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);

      db->xAuth = xAuth;
    }

    if( rc==0 ) rc = initData.rc;
    sqlite3DbFree(db, zSql);

    if( rc==0 ){
      sqlite3AnalysisLoad(db, iDb);
    }

  }
  if( db->mallocFailed ){
    rc = 7;
    sqlite3ResetInternalSchema(db, -1);
  }
  if( rc==0 || (db->flags&0x00800000)){
# 89293 "ext/sqlite3/libsqlite/sqlite3.c"
    (db)->aDb[iDb].pSchema->flags|=(0x0001);
    rc = 0;
  }





initone_error_out:
  if( openedTransaction ){
    sqlite3BtreeCommit(pDb->pBt);
  }
                             ;

error_out:
  if( rc==7 || rc==(10 | (12<<8)) ){
    db->mallocFailed = 1;
  }
  return rc;
}
# 89324 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Init(sqlite3 *db, char **pzErrMsg){
  int i, rc;
  int commit_internal = !(db->flags&0x00000200);

  ((void) (0));
  rc = 0;
  db->init.busy = 1;
  for(i=0; rc==0 && i<db->nDb; i++){
    if( (((db)->aDb[i].pSchema->flags&(0x0001))==(0x0001)) || i==1 ) continue;
    rc = sqlite3InitOne(db, i, pzErrMsg);
    if( rc ){
      sqlite3ResetInternalSchema(db, i);
    }
  }






  if( rc==0 && (db->nDb>1)
                    && !(((db)->aDb[1].pSchema->flags&(0x0001))==(0x0001)) ){
    rc = sqlite3InitOne(db, 1, pzErrMsg);
    if( rc ){
      sqlite3ResetInternalSchema(db, 1);
    }
  }


  db->init.busy = 0;
  if( rc==0 && commit_internal ){
    sqlite3CommitInternalChanges(db);
  }

  return rc;
}





static int sqlite3ReadSchema(Parse *pParse){
  int rc = 0;
  sqlite3 *db = pParse->db;
  ((void) (0));
  if( !db->init.busy ){
    rc = sqlite3Init(db, &pParse->zErrMsg);
  }
  if( rc!=0 ){
    pParse->rc = rc;
    pParse->nErr++;
  }
  return rc;
}







static void schemaIsValid(Parse *pParse){
  sqlite3 *db = pParse->db;
  int iDb;
  int rc;
  int cookie;

  ((void) (0));
  ((void) (0));
  for(iDb=0; iDb<db->nDb; iDb++){
    int openedTransaction = 0;
    Btree *pBt = db->aDb[iDb].pBt;
    if( pBt==0 ) continue;




    if( !sqlite3BtreeIsInReadTrans(pBt) ){
      rc = sqlite3BtreeBeginTrans(pBt, 0);
      if( rc==7 || rc==(10 | (12<<8)) ){
        db->mallocFailed = 1;
      }
      if( rc!=0 ) return;
      openedTransaction = 1;
    }




    sqlite3BtreeGetMeta(pBt, 1, (u32 *)&cookie);
    ((void) (0));
    if( cookie!=db->aDb[iDb].pSchema->schema_cookie ){
      sqlite3ResetInternalSchema(db, iDb);
      pParse->rc = 17;
    }


    if( openedTransaction ){
      sqlite3BtreeCommit(pBt);
    }
  }
}
# 89434 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3SchemaToIndex(sqlite3 *db, Schema *pSchema){
  int i = -1000000;
# 89447 "ext/sqlite3/libsqlite/sqlite3.c"
  ((void) (0));
  if( pSchema ){
    for(i=0; (i<db->nDb); i++){
      if( db->aDb[i].pSchema==pSchema ){
        break;
      }
    }
    ((void) (0));
  }
  return i;
}




static int sqlite3Prepare(
  sqlite3 *db,
  const char *zSql,
  int nBytes,
  int saveSqlFlag,
  Vdbe *pReprepare,
  sqlite3_stmt **ppStmt,
  const char **pzTail
){
  Parse *pParse;
  char *zErrMsg = 0;
  int rc = 0;
  int i;


  pParse = sqlite3DbMallocZero(db,sizeof(*pParse));
  if( pParse==0 ){
    rc = 7;
    goto end_prepare;
  }
  pParse->pReprepare = pReprepare;
  ((void) (0));
  ((void) (0));
  ((void) (0));
# 89510 "ext/sqlite3/libsqlite/sqlite3.c"
  for(i=0; i<db->nDb; i++) {
    Btree *pBt = db->aDb[i].pBt;
    if( pBt ){
      ((void) (0));
      rc = sqlite3BtreeSchemaLocked(pBt);
      if( rc ){
        const char *zDb = db->aDb[i].zName;
        sqlite3Error(db, rc, "database schema is locked: %s", zDb);
                                                      ;
        goto end_prepare;
      }
    }
  }

  sqlite3VtabUnlockList(db);

  pParse->db = db;
  pParse->nQueryLoop = (double)1;
  if( nBytes>=0 && (nBytes==0 || zSql[nBytes-1]!=0) ){
    char *zSqlCopy;
    int mxLen = db->aLimit[1];
                             ;
                               ;
    if( nBytes>mxLen ){
      sqlite3Error(db, 18, "statement too long");
      rc = sqlite3ApiExit(db, 18);
      goto end_prepare;
    }
    zSqlCopy = sqlite3DbStrNDup(db, zSql, nBytes);
    if( zSqlCopy ){
      sqlite3RunParser(pParse, zSqlCopy, &zErrMsg);
      sqlite3DbFree(db, zSqlCopy);
      pParse->zTail = &zSql[pParse->zTail-zSqlCopy];
    }else{
      pParse->zTail = &zSql[nBytes];
    }
  }else{
    sqlite3RunParser(pParse, zSql, &zErrMsg);
  }
  ((void) (0));

  if( db->mallocFailed ){
    pParse->rc = 7;
  }
  if( pParse->rc==101 ) pParse->rc = 0;
  if( pParse->checkSchema ){
    schemaIsValid(pParse);
  }
  if( db->mallocFailed ){
    pParse->rc = 7;
  }
  if( pzTail ){
    *pzTail = pParse->zTail;
  }
  rc = pParse->rc;


  if( rc==0 && pParse->pVdbe && pParse->explain ){
    static const char * const azColName[] = {
       "addr", "opcode", "p1", "p2", "p3", "p4", "p5", "comment",
       "selectid", "order", "from", "detail"
    };
    int iFirst, mx;
    if( pParse->explain==2 ){
      sqlite3VdbeSetNumCols(pParse->pVdbe, 4);
      iFirst = 8;
      mx = 12;
    }else{
      sqlite3VdbeSetNumCols(pParse->pVdbe, 8);
      iFirst = 0;
      mx = 8;
    }
    for(i=iFirst; i<mx; i++){
      sqlite3VdbeSetColName(pParse->pVdbe, i-iFirst, 0,
                            azColName[i], ((sqlite3_destructor_type)0));
    }
  }


  ((void) (0));
  if( db->init.busy==0 ){
    Vdbe *pVdbe = pParse->pVdbe;
    sqlite3VdbeSetSql(pVdbe, zSql, (int)(pParse->zTail-zSql), saveSqlFlag);
  }
  if( pParse->pVdbe && (rc!=0 || db->mallocFailed) ){
    sqlite3VdbeFinalize(pParse->pVdbe);
    ((void) (0));
  }else{
    *ppStmt = (sqlite3_stmt*)pParse->pVdbe;
  }

  if( zErrMsg ){
    sqlite3Error(db, rc, "%s", zErrMsg);
    sqlite3DbFree(db, zErrMsg);
  }else{
    sqlite3Error(db, rc, 0);
  }


  while( pParse->pTriggerPrg ){
    TriggerPrg *pT = pParse->pTriggerPrg;
    pParse->pTriggerPrg = pT->pNext;
    sqlite3DbFree(db, pT);
  }

end_prepare:

  sqlite3DbFree(db,pParse);
  rc = sqlite3ApiExit(db, rc);
  ((void) (0));
  return rc;
}
static int sqlite3LockAndPrepare(
  sqlite3 *db,
  const char *zSql,
  int nBytes,
  int saveSqlFlag,
  Vdbe *pOld,
  sqlite3_stmt **ppStmt,
  const char **pzTail
){
  int rc;
  ((void) (0));
  *ppStmt = 0;
  if( !sqlite3SafetyCheckOk(db) ){
    return sqlite3MisuseError(89635);
  }
                                ;
  sqlite3BtreeEnterAll(db);
  rc = sqlite3Prepare(db, zSql, nBytes, saveSqlFlag, pOld, ppStmt, pzTail);
  if( rc==17 ){
    sqlite3_finalize(*ppStmt);
    rc = sqlite3Prepare(db, zSql, nBytes, saveSqlFlag, pOld, ppStmt, pzTail);
  }
                          ;
                                ;
  return rc;
}
# 89657 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Reprepare(Vdbe *p){
  int rc;
  sqlite3_stmt *pNew;
  const char *zSql;
  sqlite3 *db;

  ((void) (0));
  zSql = sqlite3_sql((sqlite3_stmt *)p);
  ((void) (0));
  db = sqlite3VdbeDb(p);
  ((void) (0));
  rc = sqlite3LockAndPrepare(db, zSql, -1, 0, p, &pNew, 0);
  if( rc ){
    if( rc==7 ){
      db->mallocFailed = 1;
    }
    ((void) (0));
    return rc;
  }else{
    ((void) (0));
  }
  sqlite3VdbeSwap((Vdbe*)pNew, p);
  sqlite3TransferBindings(pNew, (sqlite3_stmt*)p);
  sqlite3VdbeResetStepResult((Vdbe*)pNew);
  sqlite3VdbeFinalize((Vdbe*)pNew);
  return 0;
}
# 89694 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_prepare(
  sqlite3 *db,
  const char *zSql,
  int nBytes,
  sqlite3_stmt **ppStmt,
  const char **pzTail
){
  int rc;
  rc = sqlite3LockAndPrepare(db,zSql,nBytes,0,0,ppStmt,pzTail);
  ((void) (0));
  return rc;
}
           int sqlite3_prepare_v2(
  sqlite3 *db,
  const char *zSql,
  int nBytes,
  sqlite3_stmt **ppStmt,
  const char **pzTail
){
  int rc;
  rc = sqlite3LockAndPrepare(db,zSql,nBytes,1,0,ppStmt,pzTail);
  ((void) (0));
  return rc;
}






static int sqlite3Prepare16(
  sqlite3 *db,
  const void *zSql,
  int nBytes,
  int saveSqlFlag,
  sqlite3_stmt **ppStmt,
  const void **pzTail
){




  char *zSql8;
  const char *zTail8 = 0;
  int rc = 0;

  ((void) (0));
  *ppStmt = 0;
  if( !sqlite3SafetyCheckOk(db) ){
    return sqlite3MisuseError(89743);
  }
                                ;
  zSql8 = sqlite3Utf16to8(db, zSql, nBytes, 2);
  if( zSql8 ){
    rc = sqlite3LockAndPrepare(db, zSql8, -1, saveSqlFlag, 0, ppStmt, &zTail8);
  }

  if( zTail8 && pzTail ){





    int chars_parsed = sqlite3Utf8CharLen(zSql8, (int)(zTail8-zSql8));
    *pzTail = (u8 *)zSql + sqlite3Utf16ByteLen(zSql, chars_parsed);
  }
  sqlite3DbFree(db, zSql8);
  rc = sqlite3ApiExit(db, rc);
                                ;
  return rc;
}
# 89774 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_prepare16(
  sqlite3 *db,
  const void *zSql,
  int nBytes,
  sqlite3_stmt **ppStmt,
  const void **pzTail
){
  int rc;
  rc = sqlite3Prepare16(db,zSql,nBytes,0,ppStmt,pzTail);
  ((void) (0));
  return rc;
}
           int sqlite3_prepare16_v2(
  sqlite3 *db,
  const void *zSql,
  int nBytes,
  sqlite3_stmt **ppStmt,
  const void **pzTail
){
  int rc;
  rc = sqlite3Prepare16(db,zSql,nBytes,1,ppStmt,pzTail);
  ((void) (0));
  return rc;
}
# 89823 "ext/sqlite3/libsqlite/sqlite3.c"
static void clearSelect(sqlite3 *db, Select *p){
  sqlite3ExprListDelete(db, p->pEList);
  sqlite3SrcListDelete(db, p->pSrc);
  sqlite3ExprDelete(db, p->pWhere);
  sqlite3ExprListDelete(db, p->pGroupBy);
  sqlite3ExprDelete(db, p->pHaving);
  sqlite3ExprListDelete(db, p->pOrderBy);
  sqlite3SelectDelete(db, p->pPrior);
  sqlite3ExprDelete(db, p->pLimit);
  sqlite3ExprDelete(db, p->pOffset);
}




static void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm){
  pDest->eDest = (u8)eDest;
  pDest->iParm = iParm;
  pDest->affinity = 0;
  pDest->iMem = 0;
  pDest->nMem = 0;
}






static Select *sqlite3SelectNew(
  Parse *pParse,
  ExprList *pEList,
  SrcList *pSrc,
  Expr *pWhere,
  ExprList *pGroupBy,
  Expr *pHaving,
  ExprList *pOrderBy,
  int isDistinct,
  Expr *pLimit,
  Expr *pOffset
){
  Select *pNew;
  Select standin;
  sqlite3 *db = pParse->db;
  pNew = sqlite3DbMallocZero(db, sizeof(*pNew) );
  ((void) (0));
  if( pNew==0 ){
    pNew = &standin;
    memset(pNew, 0, sizeof(*pNew));
  }
  if( pEList==0 ){
    pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db,113,0));
  }
  pNew->pEList = pEList;
  pNew->pSrc = pSrc;
  pNew->pWhere = pWhere;
  pNew->pGroupBy = pGroupBy;
  pNew->pHaving = pHaving;
  pNew->pOrderBy = pOrderBy;
  pNew->selFlags = isDistinct ? 0x0001 : 0;
  pNew->op = 116;
  pNew->pLimit = pLimit;
  pNew->pOffset = pOffset;
  ((void) (0));
  pNew->addrOpenEphm[0] = -1;
  pNew->addrOpenEphm[1] = -1;
  pNew->addrOpenEphm[2] = -1;
  if( db->mallocFailed ) {
    clearSelect(db, pNew);
    if( pNew!=&standin ) sqlite3DbFree(db, pNew);
    pNew = 0;
  }
  return pNew;
}




static void sqlite3SelectDelete(sqlite3 *db, Select *p){
  if( p ){
    clearSelect(db, p);
    sqlite3DbFree(db, p);
  }
}
# 89924 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3JoinType(Parse *pParse, Token *pA, Token *pB, Token *pC){
  int jointype = 0;
  Token *apAll[3];
  Token *p;

  static const char zKeyText[] = "naturaleftouterightfullinnercross";
  static const struct {
    u8 i;
    u8 nChar;
    u8 code;
  } aKeyword[] = {
                  { 0, 7, 0x0004 },
                  { 6, 4, 0x0008|0x0020 },
                  { 10, 5, 0x0020 },
                  { 14, 5, 0x0010|0x0020 },
                  { 19, 4, 0x0008|0x0010|0x0020 },
                  { 23, 5, 0x0001 },
                  { 28, 5, 0x0001|0x0002 },
  };
  int i, j;
  apAll[0] = pA;
  apAll[1] = pB;
  apAll[2] = pC;
  for(i=0; i<3 && apAll[i]; i++){
    p = apAll[i];
    for(j=0; j<((int)(sizeof(aKeyword)/sizeof(aKeyword[0]))); j++){
      if( p->n==aKeyword[j].nChar
          && sqlite3_strnicmp((char*)p->z, &zKeyText[aKeyword[j].i], p->n)==0 ){
        jointype |= aKeyword[j].code;
        break;
      }
    }
                                                                    ;
    if( j>=((int)(sizeof(aKeyword)/sizeof(aKeyword[0]))) ){
      jointype |= 0x0040;
      break;
    }
  }
  if(
     (jointype & (0x0001|0x0020))==(0x0001|0x0020) ||
     (jointype & 0x0040)!=0
  ){
    const char *zSp = " ";
    ((void) (0));
    if( pC==0 ){ zSp++; }
    sqlite3ErrorMsg(pParse, "unknown or unsupported join type: "
       "%T %T%s%T", pA, pB, zSp, pC);
    jointype = 0x0001;
  }else if( (jointype & 0x0020)!=0
         && (jointype & (0x0008|0x0010))!=0x0008 ){
    sqlite3ErrorMsg(pParse,
      "RIGHT and FULL OUTER JOINs are not currently supported");
    jointype = 0x0001;
  }
  return jointype;
}





static int columnIndex(Table *pTab, const char *zCol){
  int i;
  for(i=0; i<pTab->nCol; i++){
    if( sqlite3StrICmp(pTab->aCol[i].zName, zCol)==0 ) return i;
  }
  return -1;
}
# 90002 "ext/sqlite3/libsqlite/sqlite3.c"
static int tableAndColumnIndex(
  SrcList *pSrc,
  int N,
  const char *zCol,
  int *piTab,
  int *piCol
){
  int i;
  int iCol;

  ((void) (0));
  for(i=0; i<N; i++){
    iCol = columnIndex(pSrc->a[i].pTab, zCol);
    if( iCol>=0 ){
      if( piTab ){
        *piTab = i;
        *piCol = iCol;
      }
      return 1;
    }
  }
  return 0;
}
# 90037 "ext/sqlite3/libsqlite/sqlite3.c"
static void addWhereTerm(
  Parse *pParse,
  SrcList *pSrc,
  int iLeft,
  int iColLeft,
  int iRight,
  int iColRight,
  int isOuterJoin,
  Expr **ppWhere
){
  sqlite3 *db = pParse->db;
  Expr *pE1;
  Expr *pE2;
  Expr *pEq;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  pE1 = sqlite3CreateColumnExpr(db, pSrc, iLeft, iColLeft);
  pE2 = sqlite3CreateColumnExpr(db, pSrc, iRight, iColRight);

  pEq = sqlite3PExpr(pParse, 76, pE1, pE2, 0);
  if( pEq && isOuterJoin ){
    (pEq)->flags|=(0x0001);
    ((void) (0));
                           ;
    pEq->iRightJoinTable = (i16)pE2->iTable;
  }
  *ppWhere = sqlite3ExprAnd(db, *ppWhere, pEq);
}
# 90096 "ext/sqlite3/libsqlite/sqlite3.c"
static void setJoinExpr(Expr *p, int iTable){
  while( p ){
    (p)->flags|=(0x0001);
    ((void) (0));
                         ;
    p->iRightJoinTable = (i16)iTable;
    setJoinExpr(p->pLeft, iTable);
    p = p->pRight;
  }
}
# 90121 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqliteProcessJoin(Parse *pParse, Select *p){
  SrcList *pSrc;
  int i, j;
  struct SrcList_item *pLeft;
  struct SrcList_item *pRight;

  pSrc = p->pSrc;
  pLeft = &pSrc->a[0];
  pRight = &pLeft[1];
  for(i=0; i<pSrc->nSrc-1; i++, pRight++, pLeft++){
    Table *pLeftTab = pLeft->pTab;
    Table *pRightTab = pRight->pTab;
    int isOuter;

    if( (pLeftTab==0 || pRightTab==0) ) continue;
    isOuter = (pRight->jointype & 0x0020)!=0;




    if( pRight->jointype & 0x0004 ){
      if( pRight->pOn || pRight->pUsing ){
        sqlite3ErrorMsg(pParse, "a NATURAL join may not have "
           "an ON or USING clause", 0);
        return 1;
      }
      for(j=0; j<pRightTab->nCol; j++){
        char *zName;
        int iLeft;
        int iLeftCol;

        zName = pRightTab->aCol[j].zName;
        if( tableAndColumnIndex(pSrc, i+1, zName, &iLeft, &iLeftCol) ){
          addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i+1, j,
                       isOuter, &p->pWhere);
        }
      }
    }



    if( pRight->pOn && pRight->pUsing ){
      sqlite3ErrorMsg(pParse, "cannot have both ON and USING "
        "clauses in the same join");
      return 1;
    }




    if( pRight->pOn ){
      if( isOuter ) setJoinExpr(pRight->pOn, pRight->iCursor);
      p->pWhere = sqlite3ExprAnd(pParse->db, p->pWhere, pRight->pOn);
      pRight->pOn = 0;
    }
# 90184 "ext/sqlite3/libsqlite/sqlite3.c"
    if( pRight->pUsing ){
      IdList *pList = pRight->pUsing;
      for(j=0; j<pList->nId; j++){
        char *zName;
        int iLeft;
        int iLeftCol;
        int iRightCol;

        zName = pList->a[j].zName;
        iRightCol = columnIndex(pRightTab, zName);
        if( iRightCol<0
         || !tableAndColumnIndex(pSrc, i+1, zName, &iLeft, &iLeftCol)
        ){
          sqlite3ErrorMsg(pParse, "cannot join using column %s - column "
            "not present in both tables", zName);
          return 1;
        }
        addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i+1, iRightCol,
                     isOuter, &p->pWhere);
      }
    }
  }
  return 0;
}





static void pushOntoSorter(
  Parse *pParse,
  ExprList *pOrderBy,
  Select *pSelect,
  int regData
){
  Vdbe *v = pParse->pVdbe;
  int nExpr = pOrderBy->nExpr;
  int regBase = sqlite3GetTempRange(pParse, nExpr+2);
  int regRecord = sqlite3GetTempReg(pParse);
  sqlite3ExprCacheClear(pParse);
  sqlite3ExprCodeExprList(pParse, pOrderBy, regBase, 0);
  sqlite3VdbeAddOp2(v, 53, pOrderBy->iECursor, regBase+nExpr);
  sqlite3ExprCodeMove(pParse, regData, regBase+nExpr+1, 1);
  sqlite3VdbeAddOp3(v, 30, regBase, nExpr + 2, regRecord);
  sqlite3VdbeAddOp2(v, 70, pOrderBy->iECursor, regRecord);
  sqlite3ReleaseTempReg(pParse, regRecord);
  sqlite3ReleaseTempRange(pParse, regBase, nExpr+2);
  if( pSelect->iLimit ){
    int addr1, addr2;
    int iLimit;
    if( pSelect->iOffset ){
      iLimit = pSelect->iOffset+1;
    }else{
      iLimit = pSelect->iLimit;
    }
    addr1 = sqlite3VdbeAddOp1(v, 115, iLimit);
    sqlite3VdbeAddOp2(v, 20, iLimit, -1);
    addr2 = sqlite3VdbeAddOp0(v, 1);
    sqlite3VdbeJumpHere(v, addr1);
    sqlite3VdbeAddOp1(v, 63, pOrderBy->iECursor);
    sqlite3VdbeAddOp1(v, 57, pOrderBy->iECursor);
    sqlite3VdbeJumpHere(v, addr2);
  }
}




static void codeOffset(
  Vdbe *v,
  Select *p,
  int iContinue
){
  if( p->iOffset && iContinue!=0 ){
    int addr;
    sqlite3VdbeAddOp2(v, 20, p->iOffset, -1);
    addr = sqlite3VdbeAddOp1(v, 114, p->iOffset);
    sqlite3VdbeAddOp2(v, 1, 0, iContinue);
                                           ;
    sqlite3VdbeJumpHere(v, addr);
  }
}
# 90276 "ext/sqlite3/libsqlite/sqlite3.c"
static void codeDistinct(
  Parse *pParse,
  int iTab,
  int addrRepeat,
  int N,
  int iMem
){
  Vdbe *v;
  int r1;

  v = pParse->pVdbe;
  r1 = sqlite3GetTempReg(pParse);
  sqlite3VdbeAddOp4Int(v, 50, iTab, addrRepeat, iMem, N);
  sqlite3VdbeAddOp3(v, 30, iMem, N, r1);
  sqlite3VdbeAddOp2(v, 70, iTab, r1);
  sqlite3ReleaseTempReg(pParse, r1);
}
# 90302 "ext/sqlite3/libsqlite/sqlite3.c"
static int checkForMultiColumnSelectError(
  Parse *pParse,
  SelectDest *pDest,
  int nExpr
){
  int eDest = pDest->eDest;
  if( nExpr>1 && (eDest==6 || eDest==7) ){
    sqlite3ErrorMsg(pParse, "only a single result allowed for "
       "a SELECT that is part of an expression");
    return 1;
  }else{
    return 0;
  }
}
# 90327 "ext/sqlite3/libsqlite/sqlite3.c"
static void selectInnerLoop(
  Parse *pParse,
  Select *p,
  ExprList *pEList,
  int srcTab,
  int nColumn,
  ExprList *pOrderBy,
  int distinct,
  SelectDest *pDest,
  int iContinue,
  int iBreak
){
  Vdbe *v = pParse->pVdbe;
  int i;
  int hasDistinct;
  int regResult;
  int eDest = pDest->eDest;
  int iParm = pDest->iParm;
  int nResultCol;

  ((void) (0));
  if( (v==0) ) return;
  ((void) (0));
  hasDistinct = distinct>=0;
  if( pOrderBy==0 && !hasDistinct ){
    codeOffset(v, p, iContinue);
  }



  if( nColumn>0 ){
    nResultCol = nColumn;
  }else{
    nResultCol = pEList->nExpr;
  }
  if( pDest->iMem==0 ){
    pDest->iMem = pParse->nMem+1;
    pDest->nMem = nResultCol;
    pParse->nMem += nResultCol;
  }else{
    ((void) (0));
  }
  regResult = pDest->iMem;
  if( nColumn>0 ){
    for(i=0; i<nColumn; i++){
      sqlite3VdbeAddOp3(v, 28, srcTab, i, regResult+i);
    }
  }else if( eDest!=3 ){



    sqlite3ExprCacheClear(pParse);
    sqlite3ExprCodeExprList(pParse, pEList, regResult, eDest==5);
  }
  nColumn = nResultCol;





  if( hasDistinct ){
    ((void) (0));
    ((void) (0));
    codeDistinct(pParse, distinct, iContinue, nColumn, regResult);
    if( pOrderBy==0 ){
      codeOffset(v, p, iContinue);
    }
  }

  switch( eDest ){




    case 1: {
      int r1;
      r1 = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp3(v, 30, regResult, nColumn, r1);
      sqlite3VdbeAddOp2(v, 70, iParm, r1);
      sqlite3ReleaseTempReg(pParse, r1);
      break;
    }





    case 2: {
      sqlite3VdbeAddOp3(v, 71, iParm, regResult, nColumn);
      break;
    }




    case 8:
    case 9: {
      int r1 = sqlite3GetTempReg(pParse);
                                  ;
                                     ;
      sqlite3VdbeAddOp3(v, 30, regResult, nColumn, r1);
      if( pOrderBy ){
        pushOntoSorter(pParse, pOrderBy, p, r1);
      }else{
        int r2 = sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp2(v, 54, iParm, r2);
        sqlite3VdbeAddOp3(v, 55, iParm, r1, r2);
        sqlite3VdbeChangeP5(v, 0x08);
        sqlite3ReleaseTempReg(pParse, r2);
      }
      sqlite3ReleaseTempReg(pParse, r1);
      break;
    }






    case 7: {
      ((void) (0));
      p->affinity = sqlite3CompareAffinity(pEList->a[0].pExpr, pDest->affinity);
      if( pOrderBy ){




        pushOntoSorter(pParse, pOrderBy, p, regResult);
      }else{
        int r1 = sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp4(v, 30, regResult, 1, r1, &p->affinity, 1);
        sqlite3ExprCacheAffinityChange(pParse, regResult, 1);
        sqlite3VdbeAddOp2(v, 70, iParm, r1);
        sqlite3ReleaseTempReg(pParse, r1);
      }
      break;
    }



    case 3: {
      sqlite3VdbeAddOp2(v, 7, 1, iParm);

      break;
    }





    case 6: {
      ((void) (0));
      if( pOrderBy ){
        pushOntoSorter(pParse, pOrderBy, p, regResult);
      }else{
        sqlite3ExprCodeMove(pParse, regResult, iParm, 1);

      }
      break;
    }






    case 10:
    case 5: {
                                      ;
                                   ;
      if( pOrderBy ){
        int r1 = sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp3(v, 30, regResult, nColumn, r1);
        pushOntoSorter(pParse, pOrderBy, p, r1);
        sqlite3ReleaseTempReg(pParse, r1);
      }else if( eDest==10 ){
        sqlite3VdbeAddOp1(v, 4, pDest->iParm);
      }else{
        sqlite3VdbeAddOp2(v, 16, regResult, nColumn);
        sqlite3ExprCacheAffinityChange(pParse, regResult, nColumn);
      }
      break;
    }







    default: {
      ((void) (0));
      break;
    }

  }





  if( pOrderBy==0 && p->iLimit ){
    sqlite3VdbeAddOp3(v, 115, p->iLimit, iBreak, -1);
  }
}
# 90548 "ext/sqlite3/libsqlite/sqlite3.c"
static KeyInfo *keyInfoFromExprList(Parse *pParse, ExprList *pList){
  sqlite3 *db = pParse->db;
  int nExpr;
  KeyInfo *pInfo;
  struct ExprList_item *pItem;
  int i;

  nExpr = pList->nExpr;
  pInfo = sqlite3DbMallocZero(db, sizeof(*pInfo) + nExpr*(sizeof(CollSeq*)+1) );
  if( pInfo ){
    pInfo->aSortOrder = (u8*)&pInfo->aColl[nExpr];
    pInfo->nField = (u16)nExpr;
    pInfo->enc = ((db)->aDb[0].pSchema->enc);
    pInfo->db = db;
    for(i=0, pItem=pList->a; i<nExpr; i++, pItem++){
      CollSeq *pColl;
      pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);
      if( !pColl ){
        pColl = db->pDfltColl;
      }
      pInfo->aColl[i] = pColl;
      pInfo->aSortOrder[i] = pItem->sortOrder;
    }
  }
  return pInfo;
}





static const char *selectOpName(int id){
  char *z;
  switch( id ){
    case 113: z = "UNION ALL"; break;
    case 115: z = "INTERSECT"; break;
    case 114: z = "EXCEPT"; break;
    default: z = "UNION"; break;
  }
  return z;
}
# 90602 "ext/sqlite3/libsqlite/sqlite3.c"
static void explainTempTable(Parse *pParse, const char *zUsage){
  if( pParse->explain==2 ){
    Vdbe *v = pParse->pVdbe;
    char *zMsg = sqlite3MPrintf(pParse->db, "USE TEMP B-TREE FOR %s", zUsage);
    sqlite3VdbeAddOp4(v, 138, pParse->iSelectId, 0, 0, zMsg, (-1));
  }
}
# 90640 "ext/sqlite3/libsqlite/sqlite3.c"
static void explainComposite(
  Parse *pParse,
  int op,
  int iSub1,
  int iSub2,
  int bUseTmp
){
  ((void) (0));
  if( pParse->explain==2 ){
    Vdbe *v = pParse->pVdbe;
    char *zMsg = sqlite3MPrintf(
        pParse->db, "COMPOUND SUBQUERIES %d AND %d %s(%s)", iSub1, iSub2,
        bUseTmp?"USING TEMP B-TREE ":"", selectOpName(op)
    );
    sqlite3VdbeAddOp4(v, 138, pParse->iSelectId, 0, 0, zMsg, (-1));
  }
}
# 90668 "ext/sqlite3/libsqlite/sqlite3.c"
static void generateSortTail(
  Parse *pParse,
  Select *p,
  Vdbe *v,
  int nColumn,
  SelectDest *pDest
){
  int addrBreak = sqlite3VdbeMakeLabel(v);
  int addrContinue = sqlite3VdbeMakeLabel(v);
  int addr;
  int iTab;
  int pseudoTab = 0;
  ExprList *pOrderBy = p->pOrderBy;

  int eDest = pDest->eDest;
  int iParm = pDest->iParm;

  int regRow;
  int regRowid;

  iTab = pOrderBy->iECursor;
  regRow = sqlite3GetTempReg(pParse);
  if( eDest==5 || eDest==10 ){
    pseudoTab = pParse->nTab++;
    sqlite3VdbeAddOp3(v, 42, pseudoTab, regRow, nColumn);
    regRowid = 0;
  }else{
    regRowid = sqlite3GetTempReg(pParse);
  }
  addr = 1 + sqlite3VdbeAddOp2(v, 64, iTab, addrBreak);
  codeOffset(v, p, addrContinue);
  sqlite3VdbeAddOp3(v, 28, iTab, pOrderBy->nExpr + 1, regRow);
  switch( eDest ){
    case 8:
    case 9: {
                                  ;
                                     ;
      sqlite3VdbeAddOp2(v, 54, iParm, regRowid);
      sqlite3VdbeAddOp3(v, 55, iParm, regRow, regRowid);
      sqlite3VdbeChangeP5(v, 0x08);
      break;
    }

    case 7: {
      ((void) (0));
      sqlite3VdbeAddOp4(v, 30, regRow, 1, regRowid, &p->affinity, 1);
      sqlite3ExprCacheAffinityChange(pParse, regRow, 1);
      sqlite3VdbeAddOp2(v, 70, iParm, regRowid);
      break;
    }
    case 6: {
      ((void) (0));
      sqlite3ExprCodeMove(pParse, regRow, iParm, 1);

      break;
    }

    default: {
      int i;
      ((void) (0));
                                   ;
                                      ;
      for(i=0; i<nColumn; i++){
        ((void) (0));
        sqlite3VdbeAddOp3(v, 28, pseudoTab, i, pDest->iMem+i);
        if( i==0 ){
          sqlite3VdbeChangeP5(v, 0x20);
        }
      }
      if( eDest==5 ){
        sqlite3VdbeAddOp2(v, 16, pDest->iMem, nColumn);
        sqlite3ExprCacheAffinityChange(pParse, pDest->iMem, nColumn);
      }else{
        sqlite3VdbeAddOp1(v, 4, pDest->iParm);
      }
      break;
    }
  }
  sqlite3ReleaseTempReg(pParse, regRow);
  sqlite3ReleaseTempReg(pParse, regRowid);



  sqlite3VdbeResolveLabel(v, addrContinue);
  sqlite3VdbeAddOp2(v, 67, iTab, addr);
  sqlite3VdbeResolveLabel(v, addrBreak);
  if( eDest==5 || eDest==10 ){
    sqlite3VdbeAddOp2(v, 43, pseudoTab, 0);
  }
}
# 90777 "ext/sqlite3/libsqlite/sqlite3.c"
static const char *columnType(
  NameContext *pNC,
  Expr *pExpr,
  const char **pzOriginDb,
  const char **pzOriginTab,
  const char **pzOriginCol
){
  char const *zType = 0;
  char const *zOriginDb = 0;
  char const *zOriginTab = 0;
  char const *zOriginCol = 0;
  int j;
  if( (pExpr==0) || pNC->pSrcList==0 ) return 0;

  switch( pExpr->op ){
    case 154:
    case 152: {




      Table *pTab = 0;
      Select *pS = 0;
      int iCol = pExpr->iColumn;
                                          ;
                                      ;
      while( pNC && !pTab ){
        SrcList *pTabList = pNC->pSrcList;
        for(j=0;j<pTabList->nSrc && pTabList->a[j].iCursor!=pExpr->iTable;j++);
        if( j<pTabList->nSrc ){
          pTab = pTabList->a[j].pTab;
          pS = pTabList->a[j].pSelect;
        }else{
          pNC = pNC->pNext;
        }
      }

      if( pTab==0 ){
# 90832 "ext/sqlite3/libsqlite/sqlite3.c"
        break;
      }

      ((void) (0));
      if( pS ){




        if( iCol>=0 && (iCol<pS->pEList->nExpr) ){




          NameContext sNC;
          Expr *p = pS->pEList->a[iCol].pExpr;
          sNC.pSrcList = pS->pSrc;
          sNC.pNext = pNC;
          sNC.pParse = pNC->pParse;
          zType = columnType(&sNC, p, &zOriginDb, &zOriginTab, &zOriginCol);
        }
      }else if( (pTab->pSchema) ){

        ((void) (0));
        if( iCol<0 ) iCol = pTab->iPKey;
        ((void) (0));
        if( iCol<0 ){
          zType = "INTEGER";
          zOriginCol = "rowid";
        }else{
          zType = pTab->aCol[iCol].zType;
          zOriginCol = pTab->aCol[iCol].zName;
        }
        zOriginTab = pTab->zName;
        if( pNC->pParse ){
          int iDb = sqlite3SchemaToIndex(pNC->pParse->db, pTab->pSchema);
          zOriginDb = pNC->pParse->db->aDb[iDb].zName;
        }
      }
      break;
    }

    case 116: {




      NameContext sNC;
      Select *pS = pExpr->x.pSelect;
      Expr *p = pS->pEList->a[0].pExpr;
      ((void) (0));
      sNC.pSrcList = pS->pSrc;
      sNC.pNext = pNC;
      sNC.pParse = pNC->pParse;
      zType = columnType(&sNC, p, &zOriginDb, &zOriginTab, &zOriginCol);
      break;
    }

  }

  if( pzOriginDb ){
    ((void) (0));
    *pzOriginDb = zOriginDb;
    *pzOriginTab = zOriginTab;
    *pzOriginCol = zOriginCol;
  }
  return zType;
}





static void generateColumnTypes(
  Parse *pParse,
  SrcList *pTabList,
  ExprList *pEList
){

  Vdbe *v = pParse->pVdbe;
  int i;
  NameContext sNC;
  sNC.pSrcList = pTabList;
  sNC.pParse = pParse;
  for(i=0; i<pEList->nExpr; i++){
    Expr *p = pEList->a[i].pExpr;
    const char *zType;

    const char *zOrigDb = 0;
    const char *zOrigTab = 0;
    const char *zOrigCol = 0;
    zType = columnType(&sNC, p, &zOrigDb, &zOrigTab, &zOrigCol);





    sqlite3VdbeSetColName(v, i, 2, zOrigDb, ((sqlite3_destructor_type)-1));
    sqlite3VdbeSetColName(v, i, 3, zOrigTab, ((sqlite3_destructor_type)-1));
    sqlite3VdbeSetColName(v, i, 4, zOrigCol, ((sqlite3_destructor_type)-1));



    sqlite3VdbeSetColName(v, i, 1, zType, ((sqlite3_destructor_type)-1));
  }

}






static void generateColumnNames(
  Parse *pParse,
  SrcList *pTabList,
  ExprList *pEList
){
  Vdbe *v = pParse->pVdbe;
  int i, j;
  sqlite3 *db = pParse->db;
  int fullNames, shortNames;



  if( pParse->explain ){
    return;
  }


  if( pParse->colNamesSet || (v==0) || db->mallocFailed ) return;
  pParse->colNamesSet = 1;
  fullNames = (db->flags & 0x00000400)!=0;
  shortNames = (db->flags & 0x00000800)!=0;
  sqlite3VdbeSetNumCols(v, pEList->nExpr);
  for(i=0; i<pEList->nExpr; i++){
    Expr *p;
    p = pEList->a[i].pExpr;
    if( (p==0) ) continue;
    if( pEList->a[i].zName ){
      char *zName = pEList->a[i].zName;
      sqlite3VdbeSetColName(v, i, 0, zName, ((sqlite3_destructor_type)-1));
    }else if( (p->op==152 || p->op==154) && pTabList ){
      Table *pTab;
      char *zCol;
      int iCol = p->iColumn;
      for(j=0; (j<pTabList->nSrc); j++){
        if( pTabList->a[j].iCursor==p->iTable ) break;
      }
      ((void) (0));
      pTab = pTabList->a[j].pTab;
      if( iCol<0 ) iCol = pTab->iPKey;
      ((void) (0));
      if( iCol<0 ){
        zCol = "rowid";
      }else{
        zCol = pTab->aCol[iCol].zName;
      }
      if( !shortNames && !fullNames ){
        sqlite3VdbeSetColName(v, i, 0,
            sqlite3DbStrDup(db, pEList->a[i].zSpan), ((sqlite3_destructor_type)sqlite3DbFree));
      }else if( fullNames ){
        char *zName = 0;
        zName = sqlite3MPrintf(db, "%s.%s", pTab->zName, zCol);
        sqlite3VdbeSetColName(v, i, 0, zName, ((sqlite3_destructor_type)sqlite3DbFree));
      }else{
        sqlite3VdbeSetColName(v, i, 0, zCol, ((sqlite3_destructor_type)-1));
      }
    }else{
      sqlite3VdbeSetColName(v, i, 0,
          sqlite3DbStrDup(db, pEList->a[i].zSpan), ((sqlite3_destructor_type)sqlite3DbFree));
    }
  }
  generateColumnTypes(pParse, pTabList, pEList);
}
# 91021 "ext/sqlite3/libsqlite/sqlite3.c"
static int selectColumnsFromExprList(
  Parse *pParse,
  ExprList *pEList,
  int *pnCol,
  Column **paCol
){
  sqlite3 *db = pParse->db;
  int i, j;
  int cnt;
  Column *aCol, *pCol;
  int nCol;
  Expr *p;
  char *zName;
  int nName;

  *pnCol = nCol = pEList->nExpr;
  aCol = *paCol = sqlite3DbMallocZero(db, sizeof(aCol[0])*nCol);
  if( aCol==0 ) return 7;
  for(i=0, pCol=aCol; i<nCol; i++, pCol++){


    p = pEList->a[i].pExpr;
    ((void) (0));

    if( (zName = pEList->a[i].zName)!=0 ){

      zName = sqlite3DbStrDup(db, zName);
    }else{
      Expr *pColExpr = p;
      Table *pTab;
      while( pColExpr->op==118 ) pColExpr = pColExpr->pRight;
      if( pColExpr->op==152 && (pColExpr->pTab!=0) ){

        int iCol = pColExpr->iColumn;
        pTab = pColExpr->pTab;
        if( iCol<0 ) iCol = pTab->iPKey;
        zName = sqlite3MPrintf(db, "%s",
                 iCol>=0 ? pTab->aCol[iCol].zName : "rowid");
      }else if( pColExpr->op==26 ){
        ((void) (0));
        zName = sqlite3MPrintf(db, "%s", pColExpr->u.zToken);
      }else{

        zName = sqlite3MPrintf(db, "%s", pEList->a[i].zSpan);
      }
    }
    if( db->mallocFailed ){
      sqlite3DbFree(db, zName);
      break;
    }




    nName = sqlite3Strlen30(zName);
    for(j=cnt=0; j<i; j++){
      if( sqlite3StrICmp(aCol[j].zName, zName)==0 ){
        char *zNewName;
        zName[nName] = 0;
        zNewName = sqlite3MPrintf(db, "%s:%d", zName, ++cnt);
        sqlite3DbFree(db, zName);
        zName = zNewName;
        j = -1;
        if( zName==0 ) break;
      }
    }
    pCol->zName = zName;
  }
  if( db->mallocFailed ){
    for(j=0; j<i; j++){
      sqlite3DbFree(db, aCol[j].zName);
    }
    sqlite3DbFree(db, aCol);
    *paCol = 0;
    *pnCol = 0;
    return 7;
  }
  return 0;
}
# 91112 "ext/sqlite3/libsqlite/sqlite3.c"
static void selectAddColumnTypeAndCollation(
  Parse *pParse,
  int nCol,
  Column *aCol,
  Select *pSelect
){
  sqlite3 *db = pParse->db;
  NameContext sNC;
  Column *pCol;
  CollSeq *pColl;
  int i;
  Expr *p;
  struct ExprList_item *a;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( db->mallocFailed ) return;
  memset(&sNC, 0, sizeof(sNC));
  sNC.pSrcList = pSelect->pSrc;
  a = pSelect->pEList->a;
  for(i=0, pCol=aCol; i<nCol; i++, pCol++){
    p = a[i].pExpr;
    pCol->zType = sqlite3DbStrDup(db, columnType(&sNC, p, 0, 0, 0));
    pCol->affinity = sqlite3ExprAffinity(p);
    if( pCol->affinity==0 ) pCol->affinity = 'b';
    pColl = sqlite3ExprCollSeq(pParse, p);
    if( pColl ){
      pCol->zColl = sqlite3DbStrDup(db, pColl->zName);
    }
  }
}





static Table *sqlite3ResultSetOfSelect(Parse *pParse, Select *pSelect){
  Table *pTab;
  sqlite3 *db = pParse->db;
  int savedFlags;

  savedFlags = db->flags;
  db->flags &= ~0x00000400;
  db->flags |= 0x00000800;
  sqlite3SelectPrep(pParse, pSelect, 0);
  if( pParse->nErr ) return 0;
  while( pSelect->pPrior ) pSelect = pSelect->pPrior;
  db->flags = savedFlags;
  pTab = sqlite3DbMallocZero(db, sizeof(Table) );
  if( pTab==0 ){
    return 0;
  }


  ((void) (0));
  pTab->nRef = 1;
  pTab->zName = 0;
  pTab->nRowEst = 1000000;
  selectColumnsFromExprList(pParse, pSelect->pEList, &pTab->nCol, &pTab->aCol);
  selectAddColumnTypeAndCollation(pParse, pTab->nCol, pTab->aCol, pSelect);
  pTab->iPKey = -1;
  if( db->mallocFailed ){
    sqlite3DeleteTable(db, pTab);
    return 0;
  }
  return pTab;
}





static Vdbe *sqlite3GetVdbe(Parse *pParse){
  Vdbe *v = pParse->pVdbe;
  if( v==0 ){
    v = pParse->pVdbe = sqlite3VdbeCreate(pParse->db);

    if( v ){
      sqlite3VdbeAddOp0(v, 136);
    }

  }
  return v;
}
# 91217 "ext/sqlite3/libsqlite/sqlite3.c"
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak){
  Vdbe *v = 0;
  int iLimit = 0;
  int iOffset;
  int addr1, n;
  if( p->iLimit ) return;







  sqlite3ExprCacheClear(pParse);
  ((void) (0));
  if( p->pLimit ){
    p->iLimit = iLimit = ++pParse->nMem;
    v = sqlite3GetVdbe(pParse);
    if( (v==0) ) return;
    if( sqlite3ExprIsInteger(p->pLimit, &n) ){
      sqlite3VdbeAddOp2(v, 7, n, iLimit);
                                       ;
      if( n==0 ){
        sqlite3VdbeAddOp2(v, 1, 0, iBreak);
      }else{
        if( p->nSelectRow > (double)n ) p->nSelectRow = (double)n;
      }
    }else{
      sqlite3ExprCode(pParse, p->pLimit, iLimit);
      sqlite3VdbeAddOp1(v, 21, iLimit);
                                       ;
      sqlite3VdbeAddOp2(v, 115, iLimit, iBreak);
    }
    if( p->pOffset ){
      p->iOffset = iOffset = ++pParse->nMem;
      pParse->nMem++;
      sqlite3ExprCode(pParse, p->pOffset, iOffset);
      sqlite3VdbeAddOp1(v, 21, iOffset);
                                        ;
      addr1 = sqlite3VdbeAddOp1(v, 113, iOffset);
      sqlite3VdbeAddOp2(v, 7, 0, iOffset);
      sqlite3VdbeJumpHere(v, addr1);
      sqlite3VdbeAddOp3(v, 86, iLimit, iOffset, iOffset+1);
                                      ;
      addr1 = sqlite3VdbeAddOp1(v, 113, iLimit);
      sqlite3VdbeAddOp2(v, 7, -1, iOffset+1);
      sqlite3VdbeJumpHere(v, addr1);
    }
  }
}
# 91277 "ext/sqlite3/libsqlite/sqlite3.c"
static CollSeq *multiSelectCollSeq(Parse *pParse, Select *p, int iCol){
  CollSeq *pRet;
  if( p->pPrior ){
    pRet = multiSelectCollSeq(pParse, p->pPrior, iCol);
  }else{
    pRet = 0;
  }
  ((void) (0));
  if( pRet==0 && iCol<p->pEList->nExpr ){
    pRet = sqlite3ExprCollSeq(pParse, p->pEList->a[iCol].pExpr);
  }
  return pRet;
}



static int multiSelectOrderBy(
  Parse *pParse,
  Select *p,
  SelectDest *pDest
);
# 91332 "ext/sqlite3/libsqlite/sqlite3.c"
static int multiSelect(
  Parse *pParse,
  Select *p,
  SelectDest *pDest
){
  int rc = 0;
  Select *pPrior;
  Vdbe *v;
  SelectDest dest;
  Select *pDelete = 0;
  sqlite3 *db;

  int iSub1;
  int iSub2;





  ((void) (0));
  db = pParse->db;
  pPrior = p->pPrior;
  ((void) (0));
  ((void) (0));
  dest = *pDest;
  if( pPrior->pOrderBy ){
    sqlite3ErrorMsg(pParse,"ORDER BY clause should come after %s not before",
      selectOpName(p->op));
    rc = 1;
    goto multi_select_end;
  }
  if( pPrior->pLimit ){
    sqlite3ErrorMsg(pParse,"LIMIT clause should come after %s not before",
      selectOpName(p->op));
    rc = 1;
    goto multi_select_end;
  }

  v = sqlite3GetVdbe(pParse);
  ((void) (0));



  if( dest.eDest==9 ){
    ((void) (0));
    sqlite3VdbeAddOp2(v, 41, dest.iParm, p->pEList->nExpr);
    sqlite3VdbeChangeP5(v, 16);
    dest.eDest = 8;
  }




  ((void) (0));
  if( p->pEList->nExpr!=pPrior->pEList->nExpr ){
    sqlite3ErrorMsg(pParse, "SELECTs to the left and right of %s"
      " do not have the same number of result columns", selectOpName(p->op));
    rc = 1;
    goto multi_select_end;
  }



  if( p->pOrderBy ){
    return multiSelectOrderBy(pParse, p, pDest);
  }



  switch( p->op ){
    case 113: {
      int addr = 0;
      int nLimit;
      ((void) (0));
      pPrior->pLimit = p->pLimit;
      pPrior->pOffset = p->pOffset;
      iSub1 = pParse->iNextSelectId;
      rc = sqlite3Select(pParse, pPrior, &dest);
      p->pLimit = 0;
      p->pOffset = 0;
      if( rc ){
        goto multi_select_end;
      }
      p->pPrior = 0;
      p->iLimit = pPrior->iLimit;
      p->iOffset = pPrior->iOffset;
      if( p->iLimit ){
        addr = sqlite3VdbeAddOp1(v, 115, p->iLimit);
                                                       ;
      }
      iSub2 = pParse->iNextSelectId;
      rc = sqlite3Select(pParse, p, &dest);
                               ;
      pDelete = p->pPrior;
      p->pPrior = pPrior;
      p->nSelectRow += pPrior->nSelectRow;
      if( pPrior->pLimit
       && sqlite3ExprIsInteger(pPrior->pLimit, &nLimit)
       && p->nSelectRow > (double)nLimit
      ){
        p->nSelectRow = (double)nLimit;
      }
      if( addr ){
        sqlite3VdbeJumpHere(v, addr);
      }
      break;
    }
    case 114:
    case 112: {
      int unionTab;
      u8 op = 0;
      int priorOp;
      Expr *pLimit, *pOffset;
      int addr;
      SelectDest uniondest;

                                  ;
                                 ;
      priorOp = 1;
      if( dest.eDest==priorOp && (!p->pLimit &&!p->pOffset) ){



        ((void) (0));

        ((void) (0));
        ((void) (0));
        unionTab = dest.iParm;
      }else{



        unionTab = pParse->nTab++;
        ((void) (0));
        addr = sqlite3VdbeAddOp2(v, 41, unionTab, 0);
        ((void) (0));
        p->addrOpenEphm[0] = addr;
        p->pRightmost->selFlags |= 0x0008;
        ((void) (0));
      }



      ((void) (0));
      sqlite3SelectDestInit(&uniondest, priorOp, unionTab);
      iSub1 = pParse->iNextSelectId;
      rc = sqlite3Select(pParse, pPrior, &uniondest);
      if( rc ){
        goto multi_select_end;
      }



      if( p->op==114 ){
        op = 2;
      }else{
        ((void) (0));
        op = 1;
      }
      p->pPrior = 0;
      pLimit = p->pLimit;
      p->pLimit = 0;
      pOffset = p->pOffset;
      p->pOffset = 0;
      uniondest.eDest = op;
      iSub2 = pParse->iNextSelectId;
      rc = sqlite3Select(pParse, p, &uniondest);
                               ;


      sqlite3ExprListDelete(db, p->pOrderBy);
      pDelete = p->pPrior;
      p->pPrior = pPrior;
      p->pOrderBy = 0;
      if( p->op==112 ) p->nSelectRow += pPrior->nSelectRow;
      sqlite3ExprDelete(db, p->pLimit);
      p->pLimit = pLimit;
      p->pOffset = pOffset;
      p->iLimit = 0;
      p->iOffset = 0;




      ((void) (0));
      if( dest.eDest!=priorOp ){
        int iCont, iBreak, iStart;
        ((void) (0));
        if( dest.eDest==5 ){
          Select *pFirst = p;
          while( pFirst->pPrior ) pFirst = pFirst->pPrior;
          generateColumnNames(pParse, 0, pFirst->pEList);
        }
        iBreak = sqlite3VdbeMakeLabel(v);
        iCont = sqlite3VdbeMakeLabel(v);
        computeLimitRegisters(pParse, p, iBreak);
        sqlite3VdbeAddOp2(v, 65, unionTab, iBreak);
        iStart = sqlite3VdbeCurrentAddr(v);
        selectInnerLoop(pParse, p, p->pEList, unionTab, p->pEList->nExpr,
                        0, -1, &dest, iCont, iBreak);
        sqlite3VdbeResolveLabel(v, iCont);
        sqlite3VdbeAddOp2(v, 67, unionTab, iStart);
        sqlite3VdbeResolveLabel(v, iBreak);
        sqlite3VdbeAddOp2(v, 43, unionTab, 0);
      }
      break;
    }
    default: ((void) (0)); {
      int tab1, tab2;
      int iCont, iBreak, iStart;
      Expr *pLimit, *pOffset;
      int addr;
      SelectDest intersectdest;
      int r1;





      tab1 = pParse->nTab++;
      tab2 = pParse->nTab++;
      ((void) (0));

      addr = sqlite3VdbeAddOp2(v, 41, tab1, 0);
      ((void) (0));
      p->addrOpenEphm[0] = addr;
      p->pRightmost->selFlags |= 0x0008;
      ((void) (0));



      sqlite3SelectDestInit(&intersectdest, 1, tab1);
      iSub1 = pParse->iNextSelectId;
      rc = sqlite3Select(pParse, pPrior, &intersectdest);
      if( rc ){
        goto multi_select_end;
      }



      addr = sqlite3VdbeAddOp2(v, 41, tab2, 0);
      ((void) (0));
      p->addrOpenEphm[1] = addr;
      p->pPrior = 0;
      pLimit = p->pLimit;
      p->pLimit = 0;
      pOffset = p->pOffset;
      p->pOffset = 0;
      intersectdest.iParm = tab2;
      iSub2 = pParse->iNextSelectId;
      rc = sqlite3Select(pParse, p, &intersectdest);
                               ;
      pDelete = p->pPrior;
      p->pPrior = pPrior;
      if( p->nSelectRow>pPrior->nSelectRow ) p->nSelectRow = pPrior->nSelectRow;
      sqlite3ExprDelete(db, p->pLimit);
      p->pLimit = pLimit;
      p->pOffset = pOffset;




      ((void) (0));
      if( dest.eDest==5 ){
        Select *pFirst = p;
        while( pFirst->pPrior ) pFirst = pFirst->pPrior;
        generateColumnNames(pParse, 0, pFirst->pEList);
      }
      iBreak = sqlite3VdbeMakeLabel(v);
      iCont = sqlite3VdbeMakeLabel(v);
      computeLimitRegisters(pParse, p, iBreak);
      sqlite3VdbeAddOp2(v, 65, tab1, iBreak);
      r1 = sqlite3GetTempReg(pParse);
      iStart = sqlite3VdbeAddOp2(v, 59, tab1, r1);
      sqlite3VdbeAddOp4Int(v, 49, tab2, iCont, r1, 0);
      sqlite3ReleaseTempReg(pParse, r1);
      selectInnerLoop(pParse, p, p->pEList, tab1, p->pEList->nExpr,
                      0, -1, &dest, iCont, iBreak);
      sqlite3VdbeResolveLabel(v, iCont);
      sqlite3VdbeAddOp2(v, 67, tab1, iStart);
      sqlite3VdbeResolveLabel(v, iBreak);
      sqlite3VdbeAddOp2(v, 43, tab2, 0);
      sqlite3VdbeAddOp2(v, 43, tab1, 0);
      break;
    }
  }

  explainComposite(pParse, p->op, iSub1, iSub2, p->op!=113);
# 91630 "ext/sqlite3/libsqlite/sqlite3.c"
  if( p->selFlags & 0x0008 ){
    int i;
    KeyInfo *pKeyInfo;
    Select *pLoop;
    CollSeq **apColl;
    int nCol;

    ((void) (0));
    nCol = p->pEList->nExpr;
    pKeyInfo = sqlite3DbMallocZero(db,
                       sizeof(*pKeyInfo)+nCol*(sizeof(CollSeq*) + 1));
    if( !pKeyInfo ){
      rc = 7;
      goto multi_select_end;
    }

    pKeyInfo->enc = ((db)->aDb[0].pSchema->enc);
    pKeyInfo->nField = (u16)nCol;

    for(i=0, apColl=pKeyInfo->aColl; i<nCol; i++, apColl++){
      *apColl = multiSelectCollSeq(pParse, p, i);
      if( 0==*apColl ){
        *apColl = db->pDfltColl;
      }
    }

    for(pLoop=p; pLoop; pLoop=pLoop->pPrior){
      for(i=0; i<2; i++){
        int addr = pLoop->addrOpenEphm[i];
        if( addr<0 ){


          ((void) (0));
          break;
        }
        sqlite3VdbeChangeP2(v, addr, nCol);
        sqlite3VdbeChangeP4(v, addr, (char*)pKeyInfo, (-6));
        pLoop->addrOpenEphm[i] = -1;
      }
    }
    sqlite3DbFree(db, pKeyInfo);
  }

multi_select_end:
  pDest->iMem = dest.iMem;
  pDest->nMem = dest.nMem;
  sqlite3SelectDelete(db, pDelete);
  return rc;
}
# 91701 "ext/sqlite3/libsqlite/sqlite3.c"
static int generateOutputSubroutine(
  Parse *pParse,
  Select *p,
  SelectDest *pIn,
  SelectDest *pDest,
  int regReturn,
  int regPrev,
  KeyInfo *pKeyInfo,
  int p4type,
  int iBreak
){
  Vdbe *v = pParse->pVdbe;
  int iContinue;
  int addr;

  addr = sqlite3VdbeCurrentAddr(v);
  iContinue = sqlite3VdbeMakeLabel(v);



  if( regPrev ){
    int j1, j2;
    j1 = sqlite3VdbeAddOp1(v, 27, regPrev);
    j2 = sqlite3VdbeAddOp4(v, 24, pIn->iMem, regPrev+1, pIn->nMem,
                              (char*)pKeyInfo, p4type);
    sqlite3VdbeAddOp3(v, 25, j2+2, iContinue, j2+2);
    sqlite3VdbeJumpHere(v, j1);
    sqlite3ExprCodeCopy(pParse, pIn->iMem, regPrev+1, pIn->nMem);
    sqlite3VdbeAddOp2(v, 7, 1, regPrev);
  }
  if( pParse->db->mallocFailed ) return 0;



  codeOffset(v, p, iContinue);

  switch( pDest->eDest ){


    case 8:
    case 9: {
      int r1 = sqlite3GetTempReg(pParse);
      int r2 = sqlite3GetTempReg(pParse);
                                         ;
                                            ;
      sqlite3VdbeAddOp3(v, 30, pIn->iMem, pIn->nMem, r1);
      sqlite3VdbeAddOp2(v, 54, pDest->iParm, r2);
      sqlite3VdbeAddOp3(v, 55, pDest->iParm, r1, r2);
      sqlite3VdbeChangeP5(v, 0x08);
      sqlite3ReleaseTempReg(pParse, r2);
      sqlite3ReleaseTempReg(pParse, r1);
      break;
    }






    case 7: {
      int r1;
      ((void) (0));
      p->affinity =
         sqlite3CompareAffinity(p->pEList->a[0].pExpr, pDest->affinity);
      r1 = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp4(v, 30, pIn->iMem, 1, r1, &p->affinity, 1);
      sqlite3ExprCacheAffinityChange(pParse, pIn->iMem, 1);
      sqlite3VdbeAddOp2(v, 70, pDest->iParm, r1);
      sqlite3ReleaseTempReg(pParse, r1);
      break;
    }
# 91787 "ext/sqlite3/libsqlite/sqlite3.c"
    case 6: {
      ((void) (0));
      sqlite3ExprCodeMove(pParse, pIn->iMem, pDest->iParm, 1);

      break;
    }





    case 10: {
      if( pDest->iMem==0 ){
        pDest->iMem = sqlite3GetTempRange(pParse, pIn->nMem);
        pDest->nMem = pIn->nMem;
      }
      sqlite3ExprCodeMove(pParse, pIn->iMem, pDest->iMem, pDest->nMem);
      sqlite3VdbeAddOp1(v, 4, pDest->iParm);
      break;
    }
# 91816 "ext/sqlite3/libsqlite/sqlite3.c"
    default: {
      ((void) (0));
      sqlite3VdbeAddOp2(v, 16, pIn->iMem, pIn->nMem);
      sqlite3ExprCacheAffinityChange(pParse, pIn->iMem, pIn->nMem);
      break;
    }
  }



  if( p->iLimit ){
    sqlite3VdbeAddOp3(v, 115, p->iLimit, iBreak, -1);
  }



  sqlite3VdbeResolveLabel(v, iContinue);
  sqlite3VdbeAddOp1(v, 3, regReturn);

  return addr;
}
# 91924 "ext/sqlite3/libsqlite/sqlite3.c"
static int multiSelectOrderBy(
  Parse *pParse,
  Select *p,
  SelectDest *pDest
){
  int i, j;
  Select *pPrior;
  Vdbe *v;
  SelectDest destA;
  SelectDest destB;
  int regAddrA;
  int regEofA;
  int regAddrB;
  int regEofB;
  int addrSelectA;
  int addrSelectB;
  int regOutA;
  int regOutB;
  int addrOutA;
  int addrOutB = 0;
  int addrEofA;
  int addrEofB;
  int addrAltB;
  int addrAeqB;
  int addrAgtB;
  int regLimitA;
  int regLimitB;
  int regPrev;
  int savedLimit;
  int savedOffset;
  int labelCmpr;
  int labelEnd;
  int j1;
  int op;
  KeyInfo *pKeyDup = 0;
  KeyInfo *pKeyMerge;
  sqlite3 *db;
  ExprList *pOrderBy;
  int nOrderBy;
  int *aPermute;

  int iSub1;
  int iSub2;


  ((void) (0));
  ((void) (0));
  db = pParse->db;
  v = pParse->pVdbe;
  ((void) (0));
  labelEnd = sqlite3VdbeMakeLabel(v);
  labelCmpr = sqlite3VdbeMakeLabel(v);




  op = p->op;
  pPrior = p->pPrior;
  ((void) (0));
  pOrderBy = p->pOrderBy;
  ((void) (0));
  nOrderBy = pOrderBy->nExpr;





  if( op!=113 ){
    for(i=1; db->mallocFailed==0 && i<=p->pEList->nExpr; i++){
      struct ExprList_item *pItem;
      for(j=0, pItem=pOrderBy->a; j<nOrderBy; j++, pItem++){
        ((void) (0));
        if( pItem->iCol==i ) break;
      }
      if( j==nOrderBy ){
        Expr *pNew = sqlite3Expr(db, 129, 0);
        if( pNew==0 ) return 7;
        pNew->flags |= 0x0400;
        pNew->u.iValue = i;
        pOrderBy = sqlite3ExprListAppend(pParse, pOrderBy, pNew);
        pOrderBy->a[nOrderBy++].iCol = (u16)i;
      }
    }
  }
# 92016 "ext/sqlite3/libsqlite/sqlite3.c"
  aPermute = sqlite3DbMallocRaw(db, sizeof(int)*nOrderBy);
  if( aPermute ){
    struct ExprList_item *pItem;
    for(i=0, pItem=pOrderBy->a; i<nOrderBy; i++, pItem++){
      ((void) (0));
      aPermute[i] = pItem->iCol - 1;
    }
    pKeyMerge =
      sqlite3DbMallocRaw(db, sizeof(*pKeyMerge)+nOrderBy*(sizeof(CollSeq*)+1));
    if( pKeyMerge ){
      pKeyMerge->aSortOrder = (u8*)&pKeyMerge->aColl[nOrderBy];
      pKeyMerge->nField = (u16)nOrderBy;
      pKeyMerge->enc = ((db)->aDb[0].pSchema->enc);
      for(i=0; i<nOrderBy; i++){
        CollSeq *pColl;
        Expr *pTerm = pOrderBy->a[i].pExpr;
        if( pTerm->flags & 0x0100 ){
          pColl = pTerm->pColl;
        }else{
          pColl = multiSelectCollSeq(pParse, p, aPermute[i]);
          pTerm->flags |= 0x0100;
          pTerm->pColl = pColl;
        }
        pKeyMerge->aColl[i] = pColl;
        pKeyMerge->aSortOrder[i] = pOrderBy->a[i].sortOrder;
      }
    }
  }else{
    pKeyMerge = 0;
  }



  p->pOrderBy = pOrderBy;
  pPrior->pOrderBy = sqlite3ExprListDup(pParse->db, pOrderBy, 0);





  if( op==113 ){
    regPrev = 0;
  }else{
    int nExpr = p->pEList->nExpr;
    ((void) (0));
    regPrev = sqlite3GetTempRange(pParse, nExpr+1);
    sqlite3VdbeAddOp2(v, 7, 0, regPrev);
    pKeyDup = sqlite3DbMallocZero(db,
                  sizeof(*pKeyDup) + nExpr*(sizeof(CollSeq*)+1) );
    if( pKeyDup ){
      pKeyDup->aSortOrder = (u8*)&pKeyDup->aColl[nExpr];
      pKeyDup->nField = (u16)nExpr;
      pKeyDup->enc = ((db)->aDb[0].pSchema->enc);
      for(i=0; i<nExpr; i++){
        pKeyDup->aColl[i] = multiSelectCollSeq(pParse, p, i);
        pKeyDup->aSortOrder[i] = 0;
      }
    }
  }



  p->pPrior = 0;
  sqlite3ResolveOrderGroupBy(pParse, p, p->pOrderBy, "ORDER");
  if( pPrior->pPrior==0 ){
    sqlite3ResolveOrderGroupBy(pParse, pPrior, pPrior->pOrderBy, "ORDER");
  }


  computeLimitRegisters(pParse, p, labelEnd);
  if( p->iLimit && op==113 ){
    regLimitA = ++pParse->nMem;
    regLimitB = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 14, p->iOffset ? p->iOffset+1 : p->iLimit,
                                  regLimitA);
    sqlite3VdbeAddOp2(v, 14, regLimitA, regLimitB);
  }else{
    regLimitA = regLimitB = 0;
  }
  sqlite3ExprDelete(db, p->pLimit);
  p->pLimit = 0;
  sqlite3ExprDelete(db, p->pOffset);
  p->pOffset = 0;

  regAddrA = ++pParse->nMem;
  regEofA = ++pParse->nMem;
  regAddrB = ++pParse->nMem;
  regEofB = ++pParse->nMem;
  regOutA = ++pParse->nMem;
  regOutB = ++pParse->nMem;
  sqlite3SelectDestInit(&destA, 10, regAddrA);
  sqlite3SelectDestInit(&destB, 10, regAddrB);




  j1 = sqlite3VdbeAddOp0(v, 1);
  addrSelectA = sqlite3VdbeCurrentAddr(v);





                                                         ;
  pPrior->iLimit = regLimitA;
  iSub1 = pParse->iNextSelectId;
  sqlite3Select(pParse, pPrior, &destA);
  sqlite3VdbeAddOp2(v, 7, 1, regEofA);
  sqlite3VdbeAddOp1(v, 4, regAddrA);
                                                       ;




  addrSelectB = sqlite3VdbeCurrentAddr(v);
                                                          ;
  savedLimit = p->iLimit;
  savedOffset = p->iOffset;
  p->iLimit = regLimitB;
  p->iOffset = 0;
  iSub2 = pParse->iNextSelectId;
  sqlite3Select(pParse, p, &destB);
  p->iLimit = savedLimit;
  p->iOffset = savedOffset;
  sqlite3VdbeAddOp2(v, 7, 1, regEofB);
  sqlite3VdbeAddOp1(v, 4, regAddrB);
                                                        ;




                                              ;
  addrOutA = generateOutputSubroutine(pParse,
                 p, &destA, pDest, regOutA,
                 regPrev, pKeyDup, (-16), labelEnd);




  if( op==113 || op==112 ){
                                                ;
    addrOutB = generateOutputSubroutine(pParse,
                 p, &destB, pDest, regOutB,
                 regPrev, pKeyDup, (-17), labelEnd);
  }




                                          ;
  if( op==114 || op==115 ){
    addrEofA = sqlite3VdbeAddOp2(v, 1, 0, labelEnd);
  }else{
    addrEofA = sqlite3VdbeAddOp2(v, 26, regEofB, labelEnd);
    sqlite3VdbeAddOp2(v, 2, regOutB, addrOutB);
    sqlite3VdbeAddOp1(v, 4, regAddrB);
    sqlite3VdbeAddOp2(v, 1, 0, addrEofA);
    p->nSelectRow += pPrior->nSelectRow;
  }




  if( op==115 ){
    addrEofB = addrEofA;
    if( p->nSelectRow > pPrior->nSelectRow ) p->nSelectRow = pPrior->nSelectRow;
  }else{
                                            ;
    addrEofB = sqlite3VdbeAddOp2(v, 26, regEofA, labelEnd);
    sqlite3VdbeAddOp2(v, 2, regOutA, addrOutA);
    sqlite3VdbeAddOp1(v, 4, regAddrA);
    sqlite3VdbeAddOp2(v, 1, 0, addrEofB);
  }



                                           ;
  addrAltB = sqlite3VdbeAddOp2(v, 2, regOutA, addrOutA);
  sqlite3VdbeAddOp1(v, 4, regAddrA);
  sqlite3VdbeAddOp2(v, 26, regEofA, addrEofA);
  sqlite3VdbeAddOp2(v, 1, 0, labelCmpr);



  if( op==113 ){
    addrAeqB = addrAltB;
  }else if( op==115 ){
    addrAeqB = addrAltB;
    addrAltB++;
  }else{
                                             ;
    addrAeqB =
    sqlite3VdbeAddOp1(v, 4, regAddrA);
    sqlite3VdbeAddOp2(v, 26, regEofA, addrEofA);
    sqlite3VdbeAddOp2(v, 1, 0, labelCmpr);
  }



                                           ;
  addrAgtB = sqlite3VdbeCurrentAddr(v);
  if( op==113 || op==112 ){
    sqlite3VdbeAddOp2(v, 2, regOutB, addrOutB);
  }
  sqlite3VdbeAddOp1(v, 4, regAddrB);
  sqlite3VdbeAddOp2(v, 26, regEofB, addrEofB);
  sqlite3VdbeAddOp2(v, 1, 0, labelCmpr);



  sqlite3VdbeJumpHere(v, j1);
  sqlite3VdbeAddOp2(v, 7, 0, regEofA);
  sqlite3VdbeAddOp2(v, 7, 0, regEofB);
  sqlite3VdbeAddOp2(v, 2, regAddrA, addrSelectA);
  sqlite3VdbeAddOp2(v, 2, regAddrB, addrSelectB);
  sqlite3VdbeAddOp2(v, 26, regEofA, addrEofA);
  sqlite3VdbeAddOp2(v, 26, regEofB, addrEofB);



  sqlite3VdbeResolveLabel(v, labelCmpr);
  sqlite3VdbeAddOp4(v, 23, 0, 0, 0, (char*)aPermute, (-15));
  sqlite3VdbeAddOp4(v, 24, destA.iMem, destB.iMem, nOrderBy,
                         (char*)pKeyMerge, (-16));
  sqlite3VdbeAddOp3(v, 25, addrAltB, addrAeqB, addrAgtB);



  if( regPrev ){
    sqlite3ReleaseTempRange(pParse, regPrev, nOrderBy+1);
  }



  sqlite3VdbeResolveLabel(v, labelEnd);



  if( pDest->eDest==5 ){
    Select *pFirst = pPrior;
    while( pFirst->pPrior ) pFirst = pFirst->pPrior;
    generateColumnNames(pParse, 0, pFirst->pEList);
  }



  if( p->pPrior ){
    sqlite3SelectDelete(db, p->pPrior);
  }
  p->pPrior = pPrior;



  explainComposite(pParse, p->op, iSub1, iSub2, 0);
  return 0;
}




static void substExprList(sqlite3*, ExprList*, int, ExprList*);
static void substSelect(sqlite3*, Select *, int, ExprList *);
# 92292 "ext/sqlite3/libsqlite/sqlite3.c"
static Expr *substExpr(
  sqlite3 *db,
  Expr *pExpr,
  int iTable,
  ExprList *pEList
){
  if( pExpr==0 ) return 0;
  if( pExpr->op==152 && pExpr->iTable==iTable ){
    if( pExpr->iColumn<0 ){
      pExpr->op = 98;
    }else{
      Expr *pNew;
      ((void) (0));
      ((void) (0));
      pNew = sqlite3ExprDup(db, pEList->a[pExpr->iColumn].pExpr, 0);
      if( pNew && pExpr->pColl ){
        pNew->pColl = pExpr->pColl;
      }
      sqlite3ExprDelete(db, pExpr);
      pExpr = pNew;
    }
  }else{
    pExpr->pLeft = substExpr(db, pExpr->pLeft, iTable, pEList);
    pExpr->pRight = substExpr(db, pExpr->pRight, iTable, pEList);
    if( (((pExpr)->flags&(0x0800))==(0x0800)) ){
      substSelect(db, pExpr->x.pSelect, iTable, pEList);
    }else{
      substExprList(db, pExpr->x.pList, iTable, pEList);
    }
  }
  return pExpr;
}
static void substExprList(
  sqlite3 *db,
  ExprList *pList,
  int iTable,
  ExprList *pEList
){
  int i;
  if( pList==0 ) return;
  for(i=0; i<pList->nExpr; i++){
    pList->a[i].pExpr = substExpr(db, pList->a[i].pExpr, iTable, pEList);
  }
}
static void substSelect(
  sqlite3 *db,
  Select *p,
  int iTable,
  ExprList *pEList
){
  SrcList *pSrc;
  struct SrcList_item *pItem;
  int i;
  if( !p ) return;
  substExprList(db, p->pEList, iTable, pEList);
  substExprList(db, p->pGroupBy, iTable, pEList);
  substExprList(db, p->pOrderBy, iTable, pEList);
  p->pHaving = substExpr(db, p->pHaving, iTable, pEList);
  p->pWhere = substExpr(db, p->pWhere, iTable, pEList);
  substSelect(db, p->pPrior, iTable, pEList);
  pSrc = p->pSrc;
  ((void) (0));
  if( (pSrc) ){
    for(i=pSrc->nSrc, pItem=pSrc->a; i>0; i--, pItem++){
      substSelect(db, pItem->pSelect, iTable, pEList);
    }
  }
}
# 92473 "ext/sqlite3/libsqlite/sqlite3.c"
static int flattenSubquery(
  Parse *pParse,
  Select *p,
  int iFrom,
  int isAgg,
  int subqueryIsAgg
){
  const char *zSavedAuthContext = pParse->zAuthContext;
  Select *pParent;
  Select *pSub;
  Select *pSub1;
  SrcList *pSrc;
  SrcList *pSubSrc;
  ExprList *pList;
  int iParent;
  int i;
  Expr *pWhere;
  struct SrcList_item *pSubitem;
  sqlite3 *db = pParse->db;



  ((void) (0));
  ((void) (0));
  if( db->flags & 0x01 ) return 0;
  pSrc = p->pSrc;
  ((void) (0));
  pSubitem = &pSrc->a[iFrom];
  iParent = pSubitem->iCursor;
  pSub = pSubitem->pSelect;
  ((void) (0));
  if( isAgg && subqueryIsAgg ) return 0;
  if( subqueryIsAgg && pSrc->nSrc>1 ) return 0;
  pSubSrc = pSub->pSrc;
  ((void) (0));





  if( pSub->pLimit && p->pLimit ) return 0;
  if( pSub->pOffset ) return 0;
  if( p->pRightmost && pSub->pLimit ){
    return 0;
  }
  if( pSubSrc->nSrc==0 ) return 0;
  if( pSub->selFlags & 0x0001 ) return 0;
  if( pSub->pLimit && (pSrc->nSrc>1 || isAgg) ){
     return 0;
  }
  if( (p->selFlags & 0x0001)!=0 && subqueryIsAgg ){
     return 0;
  }
  if( p->pOrderBy && pSub->pOrderBy ){
     return 0;
  }
  if( isAgg && pSub->pOrderBy ) return 0;
  if( pSub->pLimit && p->pWhere ) return 0;
  if( pSub->pLimit && (p->selFlags & 0x0001)!=0 ){
     return 0;
  }
# 92567 "ext/sqlite3/libsqlite/sqlite3.c"
  if( (pSubitem->jointype & 0x0020)!=0 ){
    return 0;
  }






  if( pSub->pPrior ){
    if( pSub->pOrderBy ){
      return 0;
    }
    if( isAgg || (p->selFlags & 0x0001)!=0 || pSrc->nSrc!=1 ){
      return 0;
    }
    for(pSub1=pSub; pSub1; pSub1=pSub1->pPrior){
                                                                             ;
                                                                              ;
      if( (pSub1->selFlags & (0x0001|0x0004))!=0
       || (pSub1->pPrior && pSub1->op!=113)
       || (pSub1->pSrc==0) || pSub1->pSrc->nSrc!=1
      ){
        return 0;
      }
    }


    if( p->pOrderBy ){
      int ii;
      for(ii=0; ii<p->pOrderBy->nExpr; ii++){
        if( p->pOrderBy->a[ii].iCol==0 ) return 0;
      }
    }
  }




  pParse->zAuthContext = pSubitem->zName;
  sqlite3AuthCheck(pParse, 21, 0, 0, 0);
  pParse->zAuthContext = zSavedAuthContext;
# 92643 "ext/sqlite3/libsqlite/sqlite3.c"
  for(pSub=pSub->pPrior; pSub; pSub=pSub->pPrior){
    Select *pNew;
    ExprList *pOrderBy = p->pOrderBy;
    Expr *pLimit = p->pLimit;
    Select *pPrior = p->pPrior;
    p->pOrderBy = 0;
    p->pSrc = 0;
    p->pPrior = 0;
    p->pLimit = 0;
    pNew = sqlite3SelectDup(db, p, 0);
    p->pLimit = pLimit;
    p->pOrderBy = pOrderBy;
    p->pSrc = pSrc;
    p->op = 113;
    p->pRightmost = 0;
    if( pNew==0 ){
      pNew = pPrior;
    }else{
      pNew->pPrior = pPrior;
      pNew->pRightmost = 0;
    }
    p->pPrior = pNew;
    if( db->mallocFailed ) return 1;
  }




  pSub = pSub1 = pSubitem->pSelect;




  sqlite3DbFree(db, pSubitem->zDatabase);
  sqlite3DbFree(db, pSubitem->zName);
  sqlite3DbFree(db, pSubitem->zAlias);
  pSubitem->zDatabase = 0;
  pSubitem->zName = 0;
  pSubitem->zAlias = 0;
  pSubitem->pSelect = 0;
# 92691 "ext/sqlite3/libsqlite/sqlite3.c"
  if( (pSubitem->pTab!=0) ){
    Table *pTabToDel = pSubitem->pTab;
    if( pTabToDel->nRef==1 ){
      Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
      pTabToDel->pNextZombie = pToplevel->pZombieTab;
      pToplevel->pZombieTab = pTabToDel;
    }else{
      pTabToDel->nRef--;
    }
    pSubitem->pTab = 0;
  }
# 92716 "ext/sqlite3/libsqlite/sqlite3.c"
  for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){
    int nSubSrc;
    u8 jointype = 0;
    pSubSrc = pSub->pSrc;
    nSubSrc = pSubSrc->nSrc;
    pSrc = pParent->pSrc;

    if( pSrc ){
      ((void) (0));
      jointype = pSubitem->jointype;
    }else{
      ((void) (0));
      pSrc = pParent->pSrc = sqlite3SrcListAppend(db, 0, 0, 0);
      if( pSrc==0 ){
        ((void) (0));
        break;
      }
    }
# 92750 "ext/sqlite3/libsqlite/sqlite3.c"
    if( nSubSrc>1 ){
      pParent->pSrc = pSrc = sqlite3SrcListEnlarge(db, pSrc, nSubSrc-1,iFrom+1);
      if( db->mallocFailed ){
        break;
      }
    }




    for(i=0; i<nSubSrc; i++){
      sqlite3IdListDelete(db, pSrc->a[i+iFrom].pUsing);
      pSrc->a[i+iFrom] = pSubSrc->a[i];
      memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));
    }
    pSrc->a[iFrom].jointype = jointype;
# 92779 "ext/sqlite3/libsqlite/sqlite3.c"
    pList = pParent->pEList;
    for(i=0; i<pList->nExpr; i++){
      if( pList->a[i].zName==0 ){
        const char *zSpan = pList->a[i].zSpan;
        if( (zSpan) ){
          pList->a[i].zName = sqlite3DbStrDup(db, zSpan);
        }
      }
    }
    substExprList(db, pParent->pEList, iParent, pSub->pEList);
    if( isAgg ){
      substExprList(db, pParent->pGroupBy, iParent, pSub->pEList);
      pParent->pHaving = substExpr(db, pParent->pHaving, iParent, pSub->pEList);
    }
    if( pSub->pOrderBy ){
      ((void) (0));
      pParent->pOrderBy = pSub->pOrderBy;
      pSub->pOrderBy = 0;
    }else if( pParent->pOrderBy ){
      substExprList(db, pParent->pOrderBy, iParent, pSub->pEList);
    }
    if( pSub->pWhere ){
      pWhere = sqlite3ExprDup(db, pSub->pWhere, 0);
    }else{
      pWhere = 0;
    }
    if( subqueryIsAgg ){
      ((void) (0));
      pParent->pHaving = pParent->pWhere;
      pParent->pWhere = pWhere;
      pParent->pHaving = substExpr(db, pParent->pHaving, iParent, pSub->pEList);
      pParent->pHaving = sqlite3ExprAnd(db, pParent->pHaving,
                                  sqlite3ExprDup(db, pSub->pHaving, 0));
      ((void) (0));
      pParent->pGroupBy = sqlite3ExprListDup(db, pSub->pGroupBy, 0);
    }else{
      pParent->pWhere = substExpr(db, pParent->pWhere, iParent, pSub->pEList);
      pParent->pWhere = sqlite3ExprAnd(db, pParent->pWhere, pWhere);
    }




    pParent->selFlags |= pSub->selFlags & 0x0001;







    if( pSub->pLimit ){
      pParent->pLimit = pSub->pLimit;
      pSub->pLimit = 0;
    }
  }




  sqlite3SelectDelete(db, pSub1);

  return 1;
}
# 92856 "ext/sqlite3/libsqlite/sqlite3.c"
static u8 minMaxQuery(Select *p){
  Expr *pExpr;
  ExprList *pEList = p->pEList;

  if( pEList->nExpr!=1 ) return 0x0000;
  pExpr = pEList->a[0].pExpr;
  if( pExpr->op!=153 ) return 0;
  if( ((((pExpr)->flags&(0x0800))==(0x0800))) ) return 0;
  pEList = pExpr->x.pList;
  if( pEList==0 || pEList->nExpr!=1 ) return 0;
  if( pEList->a[0].pExpr->op!=154 ) return 0x0000;
  ((void) (0));
  if( sqlite3StrICmp(pExpr->u.zToken,"min")==0 ){
    return 0x0001;
  }else if( sqlite3StrICmp(pExpr->u.zToken,"max")==0 ){
    return 0x0002;
  }
  return 0x0000;
}
# 92887 "ext/sqlite3/libsqlite/sqlite3.c"
static Table *isSimpleCount(Select *p, AggInfo *pAggInfo){
  Table *pTab;
  Expr *pExpr;

  ((void) (0));

  if( p->pWhere || p->pEList->nExpr!=1
   || p->pSrc->nSrc!=1 || p->pSrc->a[0].pSelect
  ){
    return 0;
  }
  pTab = p->pSrc->a[0].pTab;
  pExpr = p->pEList->a[0].pExpr;
  ((void) (0));

  if( (((pTab)->tabFlags & 0x10)!=0) ) return 0;
  if( pExpr->op!=153 ) return 0;
  if( (pAggInfo->aFunc[0].pFunc->flags&0x20)==0 ) return 0;
  if( pExpr->flags&0x0010 ) return 0;

  return pTab;
}
# 92917 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3IndexedByLookup(Parse *pParse, struct SrcList_item *pFrom){
  if( pFrom->pTab && pFrom->zIndex ){
    Table *pTab = pFrom->pTab;
    char *zIndex = pFrom->zIndex;
    Index *pIdx;
    for(pIdx=pTab->pIndex;
        pIdx && sqlite3StrICmp(pIdx->zName, zIndex);
        pIdx=pIdx->pNext
    );
    if( !pIdx ){
      sqlite3ErrorMsg(pParse, "no such index: %s", zIndex, 0);
      pParse->checkSchema = 1;
      return 1;
    }
    pFrom->pIndex = pIdx;
  }
  return 0;
}
# 92960 "ext/sqlite3/libsqlite/sqlite3.c"
static int selectExpander(Walker *pWalker, Select *p){
  Parse *pParse = pWalker->pParse;
  int i, j, k;
  SrcList *pTabList;
  ExprList *pEList;
  struct SrcList_item *pFrom;
  sqlite3 *db = pParse->db;

  if( db->mallocFailed ){
    return 2;
  }
  if( (p->pSrc==0) || (p->selFlags & 0x0010)!=0 ){
    return 1;
  }
  p->selFlags |= 0x0010;
  pTabList = p->pSrc;
  pEList = p->pEList;




  sqlite3SrcListAssignCursors(pParse, pTabList);





  for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){
    Table *pTab;
    if( pFrom->pTab!=0 ){


      ((void) (0));
      return 1;
    }
    if( pFrom->zName==0 ){

      Select *pSel = pFrom->pSelect;

      ((void) (0));
      ((void) (0));
      sqlite3WalkSelect(pWalker, pSel);
      pFrom->pTab = pTab = sqlite3DbMallocZero(db, sizeof(Table));
      if( pTab==0 ) return 2;
      pTab->nRef = 1;
      pTab->zName = sqlite3MPrintf(db, "sqlite_subquery_%p_", (void*)pTab);
      while( pSel->pPrior ){ pSel = pSel->pPrior; }
      selectColumnsFromExprList(pParse, pSel->pEList, &pTab->nCol, &pTab->aCol);
      pTab->iPKey = -1;
      pTab->nRowEst = 1000000;
      pTab->tabFlags |= 0x02;

    }else{

      ((void) (0));
      pFrom->pTab = pTab =
        sqlite3LocateTable(pParse,0,pFrom->zName,pFrom->zDatabase);
      if( pTab==0 ) return 2;
      pTab->nRef++;

      if( pTab->pSelect || (((pTab)->tabFlags & 0x10)!=0) ){

        if( sqlite3ViewGetColumnNames(pParse, pTab) ) return 2;
        ((void) (0));
        pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0);
        sqlite3WalkSelect(pWalker, pFrom->pSelect);
      }

    }


    if( sqlite3IndexedByLookup(pParse, pFrom) ){
      return 2;
    }
  }



  if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){
    return 2;
  }
# 93052 "ext/sqlite3/libsqlite/sqlite3.c"
  for(k=0; k<pEList->nExpr; k++){
    Expr *pE = pEList->a[k].pExpr;
    if( pE->op==113 ) break;
    ((void) (0));
    ((void) (0));
    if( pE->op==118 && pE->pRight->op==113 ) break;
  }
  if( k<pEList->nExpr ){





    struct ExprList_item *a = pEList->a;
    ExprList *pNew = 0;
    int flags = pParse->db->flags;
    int longNames = (flags & 0x00000400)!=0
                      && (flags & 0x00000800)==0;

    for(k=0; k<pEList->nExpr; k++){
      Expr *pE = a[k].pExpr;
      ((void) (0));
      if( pE->op!=113 && (pE->op!=118 || pE->pRight->op!=113) ){


        pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);
        if( pNew ){
          pNew->a[pNew->nExpr-1].zName = a[k].zName;
          pNew->a[pNew->nExpr-1].zSpan = a[k].zSpan;
          a[k].zName = 0;
          a[k].zSpan = 0;
        }
        a[k].pExpr = 0;
      }else{


        int tableSeen = 0;
        char *zTName;
        if( pE->op==118 ){
          ((void) (0));
          ((void) (0));
          zTName = pE->pLeft->u.zToken;
        }else{
          zTName = 0;
        }
        for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){
          Table *pTab = pFrom->pTab;
          char *zTabName = pFrom->zAlias;
          if( zTabName==0 ){
            zTabName = pTab->zName;
          }
          if( db->mallocFailed ) break;
          if( zTName && sqlite3StrICmp(zTName, zTabName)!=0 ){
            continue;
          }
          tableSeen = 1;
          for(j=0; j<pTab->nCol; j++){
            Expr *pExpr, *pRight;
            char *zName = pTab->aCol[j].zName;
            char *zColname;
            char *zToFree;
            Token sColname;





            if( ((&pTab->aCol[j])->isHidden) ){
              ((void) (0));
              continue;
            }

            if( i>0 && zTName==0 ){
              if( (pFrom->jointype & 0x0004)!=0
                && tableAndColumnIndex(pTabList, i, zName, 0, 0)
              ){


                continue;
              }
              if( sqlite3IdListIndex(pFrom->pUsing, zName)>=0 ){


                continue;
              }
            }
            pRight = sqlite3Expr(db, 26, zName);
            zColname = zName;
            zToFree = 0;
            if( longNames || pTabList->nSrc>1 ){
              Expr *pLeft;
              pLeft = sqlite3Expr(db, 26, zTabName);
              pExpr = sqlite3PExpr(pParse, 118, pLeft, pRight, 0);
              if( longNames ){
                zColname = sqlite3MPrintf(db, "%s.%s", zTabName, zName);
                zToFree = zColname;
              }
            }else{
              pExpr = pRight;
            }
            pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);
            sColname.z = zColname;
            sColname.n = sqlite3Strlen30(zColname);
            sqlite3ExprListSetName(pParse, pNew, &sColname, 0);
            sqlite3DbFree(db, zToFree);
          }
        }
        if( !tableSeen ){
          if( zTName ){
            sqlite3ErrorMsg(pParse, "no such table: %s", zTName);
          }else{
            sqlite3ErrorMsg(pParse, "no tables specified");
          }
        }
      }
    }
    sqlite3ExprListDelete(db, pEList);
    p->pEList = pNew;
  }

  if( p->pEList && p->pEList->nExpr>db->aLimit[2] ){
    sqlite3ErrorMsg(pParse, "too many columns in result set");
  }

  return 0;
}
# 93188 "ext/sqlite3/libsqlite/sqlite3.c"
static int exprWalkNoop(Walker *NotUsed, Expr *NotUsed2){
  (void)(NotUsed),(void)(NotUsed2);
  return 0;
}
# 93206 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3SelectExpand(Parse *pParse, Select *pSelect){
  Walker w;
  w.xSelectCallback = selectExpander;
  w.xExprCallback = exprWalkNoop;
  w.pParse = pParse;
  sqlite3WalkSelect(&w, pSelect);
}
# 93229 "ext/sqlite3/libsqlite/sqlite3.c"
static int selectAddSubqueryTypeInfo(Walker *pWalker, Select *p){
  Parse *pParse;
  int i;
  SrcList *pTabList;
  struct SrcList_item *pFrom;

  ((void) (0));
  if( (p->selFlags & 0x0020)==0 ){
    p->selFlags |= 0x0020;
    pParse = pWalker->pParse;
    pTabList = p->pSrc;
    for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){
      Table *pTab = pFrom->pTab;
      if( (pTab!=0) && (pTab->tabFlags & 0x02)!=0 ){

        Select *pSel = pFrom->pSelect;
        ((void) (0));
        while( pSel->pPrior ) pSel = pSel->pPrior;
        selectAddColumnTypeAndCollation(pParse, pTab->nCol, pTab->aCol, pSel);
      }
    }
  }
  return 0;
}
# 93263 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3SelectAddTypeInfo(Parse *pParse, Select *pSelect){

  Walker w;
  w.xSelectCallback = selectAddSubqueryTypeInfo;
  w.xExprCallback = exprWalkNoop;
  w.pParse = pParse;
  sqlite3WalkSelect(&w, pSelect);

}
# 93286 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3SelectPrep(
  Parse *pParse,
  Select *p,
  NameContext *pOuterNC
){
  sqlite3 *db;
  if( (p==0) ) return;
  db = pParse->db;
  if( p->selFlags & 0x0020 ) return;
  sqlite3SelectExpand(pParse, p);
  if( pParse->nErr || db->mallocFailed ) return;
  sqlite3ResolveSelectNames(pParse, p, pOuterNC);
  if( pParse->nErr || db->mallocFailed ) return;
  sqlite3SelectAddTypeInfo(pParse, p);
}
# 93309 "ext/sqlite3/libsqlite/sqlite3.c"
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo){
  Vdbe *v = pParse->pVdbe;
  int i;
  struct AggInfo_func *pFunc;
  if( pAggInfo->nFunc+pAggInfo->nColumn==0 ){
    return;
  }
  for(i=0; i<pAggInfo->nColumn; i++){
    sqlite3VdbeAddOp2(v, 10, 0, pAggInfo->aCol[i].iMem);
  }
  for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++){
    sqlite3VdbeAddOp2(v, 10, 0, pFunc->iMem);
    if( pFunc->iDistinct>=0 ){
      Expr *pE = pFunc->pExpr;
      ((void) (0));
      if( pE->x.pList==0 || pE->x.pList->nExpr!=1 ){
        sqlite3ErrorMsg(pParse, "DISTINCT aggregates must have exactly one "
           "argument");
        pFunc->iDistinct = -1;
      }else{
        KeyInfo *pKeyInfo = keyInfoFromExprList(pParse, pE->x.pList);
        sqlite3VdbeAddOp4(v, 41, pFunc->iDistinct, 0, 0,
                          (char*)pKeyInfo, (-16));
      }
    }
  }
}





static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo){
  Vdbe *v = pParse->pVdbe;
  int i;
  struct AggInfo_func *pF;
  for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){
    ExprList *pList = pF->pExpr->x.pList;
    ((void) (0));
    sqlite3VdbeAddOp4(v, 117, pF->iMem, pList ? pList->nExpr : 0, 0,
                      (void*)pF->pFunc, (-5));
  }
}





static void updateAccumulator(Parse *pParse, AggInfo *pAggInfo){
  Vdbe *v = pParse->pVdbe;
  int i;
  struct AggInfo_func *pF;
  struct AggInfo_col *pC;

  pAggInfo->directMode = 1;
  sqlite3ExprCacheClear(pParse);
  for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){
    int nArg;
    int addrNext = 0;
    int regAgg;
    ExprList *pList = pF->pExpr->x.pList;
    ((void) (0));
    if( pList ){
      nArg = pList->nExpr;
      regAgg = sqlite3GetTempRange(pParse, nArg);
      sqlite3ExprCodeExprList(pParse, pList, regAgg, 1);
    }else{
      nArg = 0;
      regAgg = 0;
    }
    if( pF->iDistinct>=0 ){
      addrNext = sqlite3VdbeMakeLabel(v);
      ((void) (0));
      codeDistinct(pParse, pF->iDistinct, addrNext, 1, regAgg);
    }
    if( pF->pFunc->flags & 0x08 ){
      CollSeq *pColl = 0;
      struct ExprList_item *pItem;
      int j;
      ((void) (0));
      for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++){
        pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);
      }
      if( !pColl ){
        pColl = pParse->db->pDfltColl;
      }
      sqlite3VdbeAddOp4(v, 17, 0, 0, 0, (char *)pColl, (-4));
    }
    sqlite3VdbeAddOp4(v, 116, 0, regAgg, pF->iMem,
                      (void*)pF->pFunc, (-5));
    sqlite3VdbeChangeP5(v, (u8)nArg);
    sqlite3ExprCacheAffinityChange(pParse, regAgg, nArg);
    sqlite3ReleaseTempRange(pParse, regAgg, nArg);
    if( addrNext ){
      sqlite3VdbeResolveLabel(v, addrNext);
      sqlite3ExprCacheClear(pParse);
    }
  }
# 93418 "ext/sqlite3/libsqlite/sqlite3.c"
  sqlite3ExprCacheClear(pParse);
  for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++){
    sqlite3ExprCode(pParse, pC->pExpr, pC->iMem);
  }
  pAggInfo->directMode = 0;
  sqlite3ExprCacheClear(pParse);
}






static void explainSimpleCount(
  Parse *pParse,
  Table *pTab,
  Index *pIdx
){
  if( pParse->explain==2 ){
    char *zEqp = sqlite3MPrintf(pParse->db, "SCAN TABLE %s %s%s(~%d rows)",
        pTab->zName,
        pIdx ? "USING COVERING INDEX " : "",
        pIdx ? pIdx->zName : "",
        pTab->nRowEst
    );
    sqlite3VdbeAddOp4(
        pParse->pVdbe, 138, pParse->iSelectId, 0, 0, zEqp, (-1)
    );
  }
}
# 93506 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Select(
  Parse *pParse,
  Select *p,
  SelectDest *pDest
){
  int i, j;
  WhereInfo *pWInfo;
  Vdbe *v;
  int isAgg;
  ExprList *pEList;
  SrcList *pTabList;
  Expr *pWhere;
  ExprList *pOrderBy;
  ExprList *pGroupBy;
  Expr *pHaving;
  int isDistinct;
  int distinct;
  int rc = 1;
  int addrSortIndex;
  AggInfo sAggInfo;
  int iEnd;
  sqlite3 *db;


  int iRestoreSelectId = pParse->iSelectId;
  pParse->iSelectId = pParse->iNextSelectId++;


  db = pParse->db;
  if( p==0 || db->mallocFailed || pParse->nErr ){
    return 1;
  }
  if( sqlite3AuthCheck(pParse, 21, 0, 0, 0) ) return 1;
  memset(&sAggInfo, 0, sizeof(sAggInfo));

  if( ((pDest->eDest)<=4) ){
    ((void) (0));



    sqlite3ExprListDelete(db, p->pOrderBy);
    p->pOrderBy = 0;
    p->selFlags &= ~0x0001;
  }
  sqlite3SelectPrep(pParse, p, 0);
  pOrderBy = p->pOrderBy;
  pTabList = p->pSrc;
  pEList = p->pEList;
  if( pParse->nErr || db->mallocFailed ){
    goto select_end;
  }
  isAgg = (p->selFlags & 0x0004)!=0;
  ((void) (0));



  v = sqlite3GetVdbe(pParse);
  if( v==0 ) goto select_end;





  if( checkForMultiColumnSelectError(pParse, pDest, pEList->nExpr) ){
    goto select_end;
  }





  for(i=0; !p->pPrior && i<pTabList->nSrc; i++){
    struct SrcList_item *pItem = &pTabList->a[i];
    SelectDest dest;
    Select *pSub = pItem->pSelect;
    int isAggSub;

    if( pSub==0 || pItem->isPopulated ) continue;
# 93592 "ext/sqlite3/libsqlite/sqlite3.c"
    pParse->nHeight += sqlite3SelectExprHeight(p);


    isAggSub = (pSub->selFlags & 0x0004)!=0;
    if( flattenSubquery(pParse, p, i, isAgg, isAggSub) ){
      if( isAggSub ){
        isAgg = 1;
        p->selFlags |= 0x0004;
      }
      i = -1;
    }else{
      sqlite3SelectDestInit(&dest, 9, pItem->iCursor);
      ((void) (0));
      pItem->iSelectId = (u8)pParse->iNextSelectId;
      sqlite3Select(pParse, pSub, &dest);
      pItem->isPopulated = 1;
      pItem->pTab->nRowEst = (unsigned)pSub->nSelectRow;
    }
    if( db->mallocFailed ){
      goto select_end;
    }
    pParse->nHeight -= sqlite3SelectExprHeight(p);
    pTabList = p->pSrc;
    if( !((pDest->eDest)<=4) ){
      pOrderBy = p->pOrderBy;
    }
  }
  pEList = p->pEList;

  pWhere = p->pWhere;
  pGroupBy = p->pGroupBy;
  pHaving = p->pHaving;
  isDistinct = (p->selFlags & 0x0001)!=0;




  if( p->pPrior ){
    if( p->pRightmost==0 ){
      Select *pLoop, *pRight = 0;
      int cnt = 0;
      int mxSelect;
      for(pLoop=p; pLoop; pLoop=pLoop->pPrior, cnt++){
        pLoop->pRightmost = p;
        pLoop->pNext = pRight;
        pRight = pLoop;
      }
      mxSelect = db->aLimit[4];
      if( mxSelect && cnt>mxSelect ){
        sqlite3ErrorMsg(pParse, "too many terms in compound SELECT");
        goto select_end;
      }
    }
    rc = multiSelect(pParse, p, pDest);
    pParse->iSelectId = iRestoreSelectId;
    return rc;
  }





  ((void) (0));
  if( (p->selFlags & (0x0001|0x0004))==0x0001 ){
    p->pGroupBy = sqlite3ExprListDup(db, p->pEList, 0);
    pGroupBy = p->pGroupBy;
    p->selFlags &= ~0x0001;
  }
# 93668 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3ExprListCompare(p->pGroupBy, pOrderBy)==0
         && (db->flags & 0x20)==0 ){
    pOrderBy = 0;
  }
# 93680 "ext/sqlite3/libsqlite/sqlite3.c"
  if( pOrderBy ){
    KeyInfo *pKeyInfo;
    pKeyInfo = keyInfoFromExprList(pParse, pOrderBy);
    pOrderBy->iECursor = pParse->nTab++;
    p->addrOpenEphm[2] = addrSortIndex =
      sqlite3VdbeAddOp4(v, 41,
                           pOrderBy->iECursor, pOrderBy->nExpr+2, 0,
                           (char*)pKeyInfo, (-16));
  }else{
    addrSortIndex = -1;
  }



  if( pDest->eDest==9 ){
    sqlite3VdbeAddOp2(v, 41, pDest->iParm, pEList->nExpr);
  }



  iEnd = sqlite3VdbeMakeLabel(v);
  p->nSelectRow = (double)(0xffffffff|(((i64)0x7fffffff)<<32));
  computeLimitRegisters(pParse, p, iEnd);



  if( p->selFlags & 0x0001 ){
    KeyInfo *pKeyInfo;
    ((void) (0));
    distinct = pParse->nTab++;
    pKeyInfo = keyInfoFromExprList(pParse, p->pEList);
    sqlite3VdbeAddOp4(v, 41, distinct, 0, 0,
                        (char*)pKeyInfo, (-16));
    sqlite3VdbeChangeP5(v, 16);
  }else{
    distinct = -1;
  }


  if( !isAgg && pGroupBy==0 ){



    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, &pOrderBy, 0);
    if( pWInfo==0 ) goto select_end;
    if( pWInfo->nRowOut < p->nSelectRow ) p->nSelectRow = pWInfo->nRowOut;





    if( addrSortIndex>=0 && pOrderBy==0 ){
      sqlite3VdbeChangeToNoop(v, addrSortIndex, 1);
      p->addrOpenEphm[2] = -1;
    }



    ((void) (0));
    selectInnerLoop(pParse, p, pEList, 0, 0, pOrderBy, -1, pDest,
                    pWInfo->iContinue, pWInfo->iBreak);



    sqlite3WhereEnd(pWInfo);
  }else{

    NameContext sNC;
    int iAMem;
    int iBMem;
    int iUseFlag;


    int iAbortFlag;
    int groupBySort;
    int addrEnd;




    if( pGroupBy ){
      int k;
      struct ExprList_item *pItem;

      for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++){
        pItem->iAlias = 0;
      }
      for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++){
        pItem->iAlias = 0;
      }
      if( p->nSelectRow>(double)100 ) p->nSelectRow = (double)100;
    }else{
      p->nSelectRow = (double)1;
    }



    addrEnd = sqlite3VdbeMakeLabel(v);





    memset(&sNC, 0, sizeof(sNC));
    sNC.pParse = pParse;
    sNC.pSrcList = pTabList;
    sNC.pAggInfo = &sAggInfo;
    sAggInfo.nSortingColumn = pGroupBy ? pGroupBy->nExpr+1 : 0;
    sAggInfo.pGroupBy = pGroupBy;
    sqlite3ExprAnalyzeAggList(&sNC, pEList);
    sqlite3ExprAnalyzeAggList(&sNC, pOrderBy);
    if( pHaving ){
      sqlite3ExprAnalyzeAggregates(&sNC, pHaving);
    }
    sAggInfo.nAccumulator = sAggInfo.nColumn;
    for(i=0; i<sAggInfo.nFunc; i++){
      ((void) (0));
      sqlite3ExprAnalyzeAggList(&sNC, sAggInfo.aFunc[i].pExpr->x.pList);
    }
    if( db->mallocFailed ) goto select_end;




    if( pGroupBy ){
      KeyInfo *pKeyInfo;
      int j1;
      int addrOutputRow;
      int regOutputRow;
      int addrSetAbort;
      int addrTopOfLoop;
      int addrSortingIdx;
      int addrReset;
      int regReset;






      sAggInfo.sortingIdx = pParse->nTab++;
      pKeyInfo = keyInfoFromExprList(pParse, pGroupBy);
      addrSortingIdx = sqlite3VdbeAddOp4(v, 41,
          sAggInfo.sortingIdx, sAggInfo.nSortingColumn,
          0, (char*)pKeyInfo, (-16));



      iUseFlag = ++pParse->nMem;
      iAbortFlag = ++pParse->nMem;
      regOutputRow = ++pParse->nMem;
      addrOutputRow = sqlite3VdbeMakeLabel(v);
      regReset = ++pParse->nMem;
      addrReset = sqlite3VdbeMakeLabel(v);
      iAMem = pParse->nMem + 1;
      pParse->nMem += pGroupBy->nExpr;
      iBMem = pParse->nMem + 1;
      pParse->nMem += pGroupBy->nExpr;
      sqlite3VdbeAddOp2(v, 7, 0, iAbortFlag);
                                          ;
      sqlite3VdbeAddOp2(v, 7, 0, iUseFlag);
                                                    ;






      sqlite3VdbeAddOp2(v, 2, regReset, addrReset);
      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, &pGroupBy, 0);
      if( pWInfo==0 ) goto select_end;
      if( pGroupBy==0 ){




        pGroupBy = p->pGroupBy;
        groupBySort = 0;
      }else{





        int regBase;
        int regRecord;
        int nCol;
        int nGroupBy;

        explainTempTable(pParse,
            isDistinct && !(p->selFlags&0x0001)?"DISTINCT":"GROUP BY");

        groupBySort = 1;
        nGroupBy = pGroupBy->nExpr;
        nCol = nGroupBy + 1;
        j = nGroupBy+1;
        for(i=0; i<sAggInfo.nColumn; i++){
          if( sAggInfo.aCol[i].iSorterColumn>=j ){
            nCol++;
            j++;
          }
        }
        regBase = sqlite3GetTempRange(pParse, nCol);
        sqlite3ExprCacheClear(pParse);
        sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0);
        sqlite3VdbeAddOp2(v, 53, sAggInfo.sortingIdx,regBase+nGroupBy);
        j = nGroupBy+1;
        for(i=0; i<sAggInfo.nColumn; i++){
          struct AggInfo_col *pCol = &sAggInfo.aCol[i];
          if( pCol->iSorterColumn>=j ){
            int r1 = j + regBase;
            int r2;

            r2 = sqlite3ExprCodeGetColumn(pParse,
                               pCol->pTab, pCol->iColumn, pCol->iTable, r1);
            if( r1!=r2 ){
              sqlite3VdbeAddOp2(v, 15, r2, r1);
            }
            j++;
          }
        }
        regRecord = sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp3(v, 30, regBase, nCol, regRecord);
        sqlite3VdbeAddOp2(v, 70, sAggInfo.sortingIdx, regRecord);
        sqlite3ReleaseTempReg(pParse, regRecord);
        sqlite3ReleaseTempRange(pParse, regBase, nCol);
        sqlite3WhereEnd(pWInfo);
        sqlite3VdbeAddOp2(v, 64, sAggInfo.sortingIdx, addrEnd);
                                         ;
        sAggInfo.useSortingIdx = 1;
        sqlite3ExprCacheClear(pParse);
      }






      addrTopOfLoop = sqlite3VdbeCurrentAddr(v);
      sqlite3ExprCacheClear(pParse);
      for(j=0; j<pGroupBy->nExpr; j++){
        if( groupBySort ){
          sqlite3VdbeAddOp3(v, 28, sAggInfo.sortingIdx, j, iBMem+j);
        }else{
          sAggInfo.directMode = 1;
          sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem+j);
        }
      }
      sqlite3VdbeAddOp4(v, 24, iAMem, iBMem, pGroupBy->nExpr,
                          (char*)pKeyInfo, (-6));
      j1 = sqlite3VdbeCurrentAddr(v);
      sqlite3VdbeAddOp3(v, 25, j1+1, 0, j1+1);
# 93942 "ext/sqlite3/libsqlite/sqlite3.c"
      sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);
      sqlite3VdbeAddOp2(v, 2, regOutputRow, addrOutputRow);
                                        ;
      sqlite3VdbeAddOp2(v, 113, iAbortFlag, addrEnd);
                                          ;
      sqlite3VdbeAddOp2(v, 2, regReset, addrReset);
                                           ;




      sqlite3VdbeJumpHere(v, j1);
      updateAccumulator(pParse, &sAggInfo);
      sqlite3VdbeAddOp2(v, 7, 1, iUseFlag);
                                                      ;



      if( groupBySort ){
        sqlite3VdbeAddOp2(v, 67, sAggInfo.sortingIdx, addrTopOfLoop);
      }else{
        sqlite3WhereEnd(pWInfo);
        sqlite3VdbeChangeToNoop(v, addrSortingIdx, 1);
      }



      sqlite3VdbeAddOp2(v, 2, regOutputRow, addrOutputRow);
                                          ;



      sqlite3VdbeAddOp2(v, 1, 0, addrEnd);
# 93983 "ext/sqlite3/libsqlite/sqlite3.c"
      addrSetAbort = sqlite3VdbeCurrentAddr(v);
      sqlite3VdbeAddOp2(v, 7, 1, iAbortFlag);
                                        ;
      sqlite3VdbeAddOp1(v, 3, regOutputRow);
      sqlite3VdbeResolveLabel(v, addrOutputRow);
      addrOutputRow = sqlite3VdbeCurrentAddr(v);
      sqlite3VdbeAddOp2(v, 113, iUseFlag, addrOutputRow+2);
                                                              ;
      sqlite3VdbeAddOp1(v, 3, regOutputRow);
      finalizeAggFunctions(pParse, &sAggInfo);
      sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow+1, 0x08);
      selectInnerLoop(pParse, p, p->pEList, 0, 0, pOrderBy,
                      distinct, pDest,
                      addrOutputRow+1, addrSetAbort);
      sqlite3VdbeAddOp1(v, 3, regOutputRow);
                                                      ;



      sqlite3VdbeResolveLabel(v, addrReset);
      resetAccumulator(pParse, &sAggInfo);
      sqlite3VdbeAddOp1(v, 3, regReset);

    }
    else {
      ExprList *pDel = 0;

      Table *pTab;
      if( (pTab = isSimpleCount(p, &sAggInfo))!=0 ){
# 94025 "ext/sqlite3/libsqlite/sqlite3.c"
        const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
        const int iCsr = pParse->nTab++;
        Index *pIdx;
        KeyInfo *pKeyInfo = 0;
        Index *pBest = 0;
        int iRoot = pTab->tnum;

        sqlite3CodeVerifySchema(pParse, iDb);
        sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
# 94046 "ext/sqlite3/libsqlite/sqlite3.c"
        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
          if( !pBest || pIdx->nColumn<pBest->nColumn ){
            pBest = pIdx;
          }
        }
        if( pBest && pBest->nColumn<pTab->nCol ){
          iRoot = pBest->tnum;
          pKeyInfo = sqlite3IndexKeyinfo(pParse, pBest);
        }


        sqlite3VdbeAddOp3(v, 38, iCsr, iRoot, iDb);
        if( pKeyInfo ){
          sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, (-16));
        }
        sqlite3VdbeAddOp2(v, 31, iCsr, sAggInfo.aFunc[0].iMem);
        sqlite3VdbeAddOp1(v, 43, iCsr);
        explainSimpleCount(pParse, pTab, pBest);
      }else

      {
# 94092 "ext/sqlite3/libsqlite/sqlite3.c"
        ExprList *pMinMax = 0;
        u8 flag = minMaxQuery(p);
        if( flag ){
          ((void) (0));
          pMinMax = sqlite3ExprListDup(db, p->pEList->a[0].pExpr->x.pList,0);
          pDel = pMinMax;
          if( pMinMax && !db->mallocFailed ){
            pMinMax->a[0].sortOrder = flag!=0x0001 ?1:0;
            pMinMax->a[0].pExpr->op = 152;
          }
        }





        resetAccumulator(pParse, &sAggInfo);
        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, &pMinMax, flag);
        if( pWInfo==0 ){
          sqlite3ExprListDelete(db, pDel);
          goto select_end;
        }
        updateAccumulator(pParse, &sAggInfo);
        if( !pMinMax && flag ){
          sqlite3VdbeAddOp2(v, 1, 0, pWInfo->iBreak);

                                                       ;
        }
        sqlite3WhereEnd(pWInfo);
        finalizeAggFunctions(pParse, &sAggInfo);
      }

      pOrderBy = 0;
      sqlite3ExprIfFalse(pParse, pHaving, addrEnd, 0x08);
      selectInnerLoop(pParse, p, p->pEList, 0, 0, 0, -1,
                      pDest, addrEnd, addrEnd);
      sqlite3ExprListDelete(db, pDel);
    }
    sqlite3VdbeResolveLabel(v, addrEnd);

  }

  if( distinct>=0 ){
    explainTempTable(pParse, "DISTINCT");
  }




  if( pOrderBy ){
    explainTempTable(pParse, "ORDER BY");
    generateSortTail(pParse, p, v, pEList->nExpr, pDest);
  }



  sqlite3VdbeResolveLabel(v, iEnd);




  rc = 0;




select_end:
  pParse->iSelectId = iRestoreSelectId;



  if( rc==0 && pDest->eDest==5 ){
    generateColumnNames(pParse, pTabList, pEList);
  }

  sqlite3DbFree(db, sAggInfo.aCol);
  sqlite3DbFree(db, sAggInfo.aFunc);
  return rc;
}
# 94295 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct TabResult {
  char **azResult;
  char *zErrMsg;
  int nAlloc;
  int nRow;
  int nColumn;
  int nData;
  int rc;
} TabResult;






static int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv){
  TabResult *p = (TabResult*)pArg;
  int need;
  int i;
  char *z;




  if( p->nRow==0 && argv!=0 ){
    need = nCol*2;
  }else{
    need = nCol;
  }
  if( p->nData + need > p->nAlloc ){
    char **azNew;
    p->nAlloc = p->nAlloc*2 + need;
    azNew = sqlite3_realloc( p->azResult, sizeof(char*)*p->nAlloc );
    if( azNew==0 ) goto malloc_failed;
    p->azResult = azNew;
  }




  if( p->nRow==0 ){
    p->nColumn = nCol;
    for(i=0; i<nCol; i++){
      z = sqlite3_mprintf("%s", colv[i]);
      if( z==0 ) goto malloc_failed;
      p->azResult[p->nData++] = z;
    }
  }else if( p->nColumn!=nCol ){
    sqlite3_free(p->zErrMsg);
    p->zErrMsg = sqlite3_mprintf(
       "sqlite3_get_table() called with two or more incompatible queries"
    );
    p->rc = 1;
    return 1;
  }



  if( argv!=0 ){
    for(i=0; i<nCol; i++){
      if( argv[i]==0 ){
        z = 0;
      }else{
        int n = sqlite3Strlen30(argv[i])+1;
        z = sqlite3_malloc( n );
        if( z==0 ) goto malloc_failed;
        memcpy(z, argv[i], n);
      }
      p->azResult[p->nData++] = z;
    }
    p->nRow++;
  }
  return 0;

malloc_failed:
  p->rc = 7;
  return 1;
}
# 94384 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_get_table(
  sqlite3 *db,
  const char *zSql,
  char ***pazResult,
  int *pnRow,
  int *pnColumn,
  char **pzErrMsg
){
  int rc;
  TabResult res;

  *pazResult = 0;
  if( pnColumn ) *pnColumn = 0;
  if( pnRow ) *pnRow = 0;
  if( pzErrMsg ) *pzErrMsg = 0;
  res.zErrMsg = 0;
  res.nRow = 0;
  res.nColumn = 0;
  res.nData = 1;
  res.nAlloc = 20;
  res.rc = 0;
  res.azResult = sqlite3_malloc(sizeof(char*)*res.nAlloc );
  if( res.azResult==0 ){
     db->errCode = 7;
     return 7;
  }
  res.azResult[0] = 0;
  rc = sqlite3_exec(db, zSql, sqlite3_get_table_cb, &res, pzErrMsg);
  ((void) (0));
  res.azResult[0] = ((void*)(long int)(res.nData));
  if( (rc&0xff)==4 ){
    sqlite3_free_table(&res.azResult[1]);
    if( res.zErrMsg ){
      if( pzErrMsg ){
        sqlite3_free(*pzErrMsg);
        *pzErrMsg = sqlite3_mprintf("%s",res.zErrMsg);
      }
      sqlite3_free(res.zErrMsg);
    }
    db->errCode = res.rc;
    return res.rc;
  }
  sqlite3_free(res.zErrMsg);
  if( rc!=0 ){
    sqlite3_free_table(&res.azResult[1]);
    return rc;
  }
  if( res.nAlloc>res.nData ){
    char **azNew;
    azNew = sqlite3_realloc( res.azResult, sizeof(char*)*res.nData );
    if( azNew==0 ){
      sqlite3_free_table(&res.azResult[1]);
      db->errCode = 7;
      return 7;
    }
    res.azResult = azNew;
  }
  *pazResult = &res.azResult[1];
  if( pnColumn ) *pnColumn = res.nColumn;
  if( pnRow ) *pnRow = res.nRow;
  return rc;
}




           void sqlite3_free_table(
  char **azResult
){
  if( azResult ){
    int i, n;
    azResult--;
    ((void) (0));
    n = ((int)(long int)(azResult[0]));
    for(i=1; i<n; i++){ if( azResult[i] ) sqlite3_free(azResult[i]); }
    sqlite3_free(azResult);
  }
}
# 94484 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3DeleteTriggerStep(sqlite3 *db, TriggerStep *pTriggerStep){
  while( pTriggerStep ){
    TriggerStep * pTmp = pTriggerStep;
    pTriggerStep = pTriggerStep->pNext;

    sqlite3ExprDelete(db, pTmp->pWhere);
    sqlite3ExprListDelete(db, pTmp->pExprList);
    sqlite3SelectDelete(db, pTmp->pSelect);
    sqlite3IdListDelete(db, pTmp->pIdList);

    sqlite3DbFree(db, pTmp);
  }
}
# 94512 "ext/sqlite3/libsqlite/sqlite3.c"
static Trigger *sqlite3TriggerList(Parse *pParse, Table *pTab){
  Schema * const pTmpSchema = pParse->db->aDb[1].pSchema;
  Trigger *pList = 0;

  if( pParse->disableTriggers ){
    return 0;
  }

  if( pTmpSchema!=pTab->pSchema ){
    HashElem *p;
    ((void) (0));
    for(p=((&pTmpSchema->trigHash)->first); p; p=((p)->next)){
      Trigger *pTrig = (Trigger *)((p)->data);
      if( pTrig->pTabSchema==pTab->pSchema
       && 0==sqlite3StrICmp(pTrig->table, pTab->zName)
      ){
        pTrig->pNext = (pList ? pList : pTab->pTrigger);
        pList = pTrig;
      }
    }
  }

  return (pList ? pList : pTab->pTrigger);
}
# 94545 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3BeginTrigger(
  Parse *pParse,
  Token *pName1,
  Token *pName2,
  int tr_tm,
  int op,
  IdList *pColumns,
  SrcList *pTableName,
  Expr *pWhen,
  int isTemp,
  int noErr
){
  Trigger *pTrigger = 0;
  Table *pTab;
  char *zName = 0;
  sqlite3 *db = pParse->db;
  int iDb;
  Token *pName;
  DbFixer sFix;
  int iTabDb;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( isTemp ){

    if( pName2->n>0 ){
      sqlite3ErrorMsg(pParse, "temporary trigger may not have qualified name");
      goto trigger_cleanup;
    }
    iDb = 1;
    pName = pName1;
  }else{

    iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);
    if( iDb<0 ){
      goto trigger_cleanup;
    }
  }






  if( !pTableName || db->mallocFailed ){
    goto trigger_cleanup;
  }
  pTab = sqlite3SrcListLookup(pParse, pTableName);
  if( db->init.busy==0 && pName2->n==0 && pTab
        && pTab->pSchema==db->aDb[1].pSchema ){
    iDb = 1;
  }


  if( db->mallocFailed ) goto trigger_cleanup;
  ((void) (0));
  if( sqlite3FixInit(&sFix, pParse, iDb, "trigger", pName) &&
      sqlite3FixSrcList(&sFix, pTableName) ){
    goto trigger_cleanup;
  }
  pTab = sqlite3SrcListLookup(pParse, pTableName);
  if( !pTab ){

    if( db->init.iDb==1 ){
# 94619 "ext/sqlite3/libsqlite/sqlite3.c"
      db->init.orphanTrigger = 1;
    }
    goto trigger_cleanup;
  }
  if( (((pTab)->tabFlags & 0x10)!=0) ){
    sqlite3ErrorMsg(pParse, "cannot create triggers on virtual tables");
    goto trigger_cleanup;
  }



  zName = sqlite3NameFromToken(db, pName);
  if( !zName || 0!=sqlite3CheckObjectName(pParse, zName) ){
    goto trigger_cleanup;
  }
  ((void) (0));
  if( sqlite3HashFind(&(db->aDb[iDb].pSchema->trigHash),
                      zName, sqlite3Strlen30(zName)) ){
    if( !noErr ){
      sqlite3ErrorMsg(pParse, "trigger %T already exists", pName);
    }else{
      ((void) (0));
      sqlite3CodeVerifySchema(pParse, iDb);
    }
    goto trigger_cleanup;
  }


  if( sqlite3_strnicmp(pTab->zName, "sqlite_", 7)==0 ){
    sqlite3ErrorMsg(pParse, "cannot create trigger on system table");
    pParse->nErr++;
    goto trigger_cleanup;
  }




  if( pTab->pSelect && tr_tm!=48 ){
    sqlite3ErrorMsg(pParse, "cannot create %s trigger on view: %S",
        (tr_tm == 34)?"BEFORE":"AFTER", pTableName, 0);
    goto trigger_cleanup;
  }
  if( !pTab->pSelect && tr_tm==48 ){
    sqlite3ErrorMsg(pParse, "cannot create INSTEAD OF"
        " trigger on table: %S", pTableName, 0);
    goto trigger_cleanup;
  }
  iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);


  {
    int code = 7;
    const char *zDb = db->aDb[iTabDb].zName;
    const char *zDbTrig = isTemp ? db->aDb[1].zName : zDb;
    if( iTabDb==1 || isTemp ) code = 5;
    if( sqlite3AuthCheck(pParse, code, zName, pTab->zName, zDbTrig) ){
      goto trigger_cleanup;
    }
    if( sqlite3AuthCheck(pParse, 18, ((!0)&&(iTabDb==1)?"sqlite_temp_master":"sqlite_master"),0,zDb)){
      goto trigger_cleanup;
    }
  }







  if (tr_tm == 48){
    tr_tm = 34;
  }


  pTrigger = (Trigger*)sqlite3DbMallocZero(db, sizeof(Trigger));
  if( pTrigger==0 ) goto trigger_cleanup;
  pTrigger->zName = zName;
  zName = 0;
  pTrigger->table = sqlite3DbStrDup(db, pTableName->a[0].zName);
  pTrigger->pSchema = db->aDb[iDb].pSchema;
  pTrigger->pTabSchema = pTab->pSchema;
  pTrigger->op = (u8)op;
  pTrigger->tr_tm = tr_tm==34 ? 1 : 2;
  pTrigger->pWhen = sqlite3ExprDup(db, pWhen, 0x0001);
  pTrigger->pColumns = sqlite3IdListDup(db, pColumns);
  ((void) (0));
  pParse->pNewTrigger = pTrigger;

trigger_cleanup:
  sqlite3DbFree(db, zName);
  sqlite3SrcListDelete(db, pTableName);
  sqlite3IdListDelete(db, pColumns);
  sqlite3ExprDelete(db, pWhen);
  if( !pParse->pNewTrigger ){
    sqlite3DeleteTrigger(db, pTrigger);
  }else{
    ((void) (0));
  }
}





static void sqlite3FinishTrigger(
  Parse *pParse,
  TriggerStep *pStepList,
  Token *pAll
){
  Trigger *pTrig = pParse->pNewTrigger;
  char *zName;
  sqlite3 *db = pParse->db;
  DbFixer sFix;
  int iDb;
  Token nameToken;

  pParse->pNewTrigger = 0;
  if( (pParse->nErr) || !pTrig ) goto triggerfinish_cleanup;
  zName = pTrig->zName;
  iDb = sqlite3SchemaToIndex(pParse->db, pTrig->pSchema);
  pTrig->step_list = pStepList;
  while( pStepList ){
    pStepList->pTrig = pTrig;
    pStepList = pStepList->pNext;
  }
  nameToken.z = pTrig->zName;
  nameToken.n = sqlite3Strlen30(nameToken.z);
  if( sqlite3FixInit(&sFix, pParse, iDb, "trigger", &nameToken)
          && sqlite3FixTriggerStep(&sFix, pTrig->step_list) ){
    goto triggerfinish_cleanup;
  }




  if( !db->init.busy ){
    Vdbe *v;
    char *z;


    v = sqlite3GetVdbe(pParse);
    if( v==0 ) goto triggerfinish_cleanup;
    sqlite3BeginWriteOperation(pParse, 0, iDb);
    z = sqlite3DbStrNDup(db, (char*)pAll->z, pAll->n);
    sqlite3NestedParse(pParse,
       "INSERT INTO %Q.%s VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')",
       db->aDb[iDb].zName, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"), zName,
       pTrig->table, z);
    sqlite3DbFree(db, z);
    sqlite3ChangeCookie(pParse, iDb);
    sqlite3VdbeAddOp4(v, 99, iDb, 0, 0, sqlite3MPrintf(
        db, "type='trigger' AND name='%q'", zName), (-1)
    );
  }

  if( db->init.busy ){
    Trigger *pLink = pTrig;
    Hash *pHash = &db->aDb[iDb].pSchema->trigHash;
    ((void) (0));
    pTrig = sqlite3HashInsert(pHash, zName, sqlite3Strlen30(zName), pTrig);
    if( pTrig ){
      db->mallocFailed = 1;
    }else if( pLink->pSchema==pLink->pTabSchema ){
      Table *pTab;
      int n = sqlite3Strlen30(pLink->table);
      pTab = sqlite3HashFind(&pLink->pTabSchema->tblHash, pLink->table, n);
      ((void) (0));
      pLink->pNext = pTab->pTrigger;
      pTab->pTrigger = pLink;
    }
  }

triggerfinish_cleanup:
  sqlite3DeleteTrigger(db, pTrig);
  ((void) (0));
  sqlite3DeleteTriggerStep(db, pStepList);
}
# 94804 "ext/sqlite3/libsqlite/sqlite3.c"
static TriggerStep *sqlite3TriggerSelectStep(sqlite3 *db, Select *pSelect){
  TriggerStep *pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep));
  if( pTriggerStep==0 ) {
    sqlite3SelectDelete(db, pSelect);
    return 0;
  }
  pTriggerStep->op = 116;
  pTriggerStep->pSelect = pSelect;
  pTriggerStep->orconf = 99;
  return pTriggerStep;
}







static TriggerStep *triggerStepAllocate(
  sqlite3 *db,
  u8 op,
  Token *pName
){
  TriggerStep *pTriggerStep;

  pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep) + pName->n);
  if( pTriggerStep ){
    char *z = (char*)&pTriggerStep[1];
    memcpy(z, pName->z, pName->n);
    pTriggerStep->target.z = z;
    pTriggerStep->target.n = pName->n;
    pTriggerStep->op = op;
  }
  return pTriggerStep;
}
# 94847 "ext/sqlite3/libsqlite/sqlite3.c"
static TriggerStep *sqlite3TriggerInsertStep(
  sqlite3 *db,
  Token *pTableName,
  IdList *pColumn,
  ExprList *pEList,
  Select *pSelect,
  u8 orconf
){
  TriggerStep *pTriggerStep;

  ((void) (0));
  ((void) (0));

  pTriggerStep = triggerStepAllocate(db, 105, pTableName);
  if( pTriggerStep ){
    pTriggerStep->pSelect = sqlite3SelectDup(db, pSelect, 0x0001);
    pTriggerStep->pIdList = pColumn;
    pTriggerStep->pExprList = sqlite3ExprListDup(db, pEList, 0x0001);
    pTriggerStep->orconf = orconf;
  }else{
    sqlite3IdListDelete(db, pColumn);
  }
  sqlite3ExprListDelete(db, pEList);
  sqlite3SelectDelete(db, pSelect);

  return pTriggerStep;
}






static TriggerStep *sqlite3TriggerUpdateStep(
  sqlite3 *db,
  Token *pTableName,
  ExprList *pEList,
  Expr *pWhere,
  u8 orconf
){
  TriggerStep *pTriggerStep;

  pTriggerStep = triggerStepAllocate(db, 107, pTableName);
  if( pTriggerStep ){
    pTriggerStep->pExprList = sqlite3ExprListDup(db, pEList, 0x0001);
    pTriggerStep->pWhere = sqlite3ExprDup(db, pWhere, 0x0001);
    pTriggerStep->orconf = orconf;
  }
  sqlite3ExprListDelete(db, pEList);
  sqlite3ExprDelete(db, pWhere);
  return pTriggerStep;
}






static TriggerStep *sqlite3TriggerDeleteStep(
  sqlite3 *db,
  Token *pTableName,
  Expr *pWhere
){
  TriggerStep *pTriggerStep;

  pTriggerStep = triggerStepAllocate(db, 106, pTableName);
  if( pTriggerStep ){
    pTriggerStep->pWhere = sqlite3ExprDup(db, pWhere, 0x0001);
    pTriggerStep->orconf = 99;
  }
  sqlite3ExprDelete(db, pWhere);
  return pTriggerStep;
}




static void sqlite3DeleteTrigger(sqlite3 *db, Trigger *pTrigger){
  if( pTrigger==0 ) return;
  sqlite3DeleteTriggerStep(db, pTrigger->step_list);
  sqlite3DbFree(db, pTrigger->zName);
  sqlite3DbFree(db, pTrigger->table);
  sqlite3ExprDelete(db, pTrigger->pWhen);
  sqlite3IdListDelete(db, pTrigger->pColumns);
  sqlite3DbFree(db, pTrigger);
}
# 94942 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3DropTrigger(Parse *pParse, SrcList *pName, int noErr){
  Trigger *pTrigger = 0;
  int i;
  const char *zDb;
  const char *zName;
  int nName;
  sqlite3 *db = pParse->db;

  if( db->mallocFailed ) goto drop_trigger_cleanup;
  if( 0!=sqlite3ReadSchema(pParse) ){
    goto drop_trigger_cleanup;
  }

  ((void) (0));
  zDb = pName->a[0].zDatabase;
  zName = pName->a[0].zName;
  nName = sqlite3Strlen30(zName);
  ((void) (0));
  for(i=0; i<db->nDb; i++){
    int j = (i<2) ? i^1 : i;
    if( zDb && sqlite3StrICmp(db->aDb[j].zName, zDb) ) continue;
    ((void) (0));
    pTrigger = sqlite3HashFind(&(db->aDb[j].pSchema->trigHash), zName, nName);
    if( pTrigger ) break;
  }
  if( !pTrigger ){
    if( !noErr ){
      sqlite3ErrorMsg(pParse, "no such trigger: %S", pName, 0);
    }else{
      sqlite3CodeVerifyNamedSchema(pParse, zDb);
    }
    pParse->checkSchema = 1;
    goto drop_trigger_cleanup;
  }
  sqlite3DropTriggerPtr(pParse, pTrigger);

drop_trigger_cleanup:
  sqlite3SrcListDelete(db, pName);
}





static Table *tableOfTrigger(Trigger *pTrigger){
  int n = sqlite3Strlen30(pTrigger->table);
  return sqlite3HashFind(&pTrigger->pTabSchema->tblHash, pTrigger->table, n);
}





static void sqlite3DropTriggerPtr(Parse *pParse, Trigger *pTrigger){
  Table *pTable;
  Vdbe *v;
  sqlite3 *db = pParse->db;
  int iDb;

  iDb = sqlite3SchemaToIndex(pParse->db, pTrigger->pSchema);
  ((void) (0));
  pTable = tableOfTrigger(pTrigger);
  ((void) (0));
  ((void) (0));

  {
    int code = 16;
    const char *zDb = db->aDb[iDb].zName;
    const char *zTab = ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master");
    if( iDb==1 ) code = 14;
    if( sqlite3AuthCheck(pParse, code, pTrigger->zName, pTable->zName, zDb) ||
      sqlite3AuthCheck(pParse, 9, zTab, 0, zDb) ){
      return;
    }
  }




  ((void) (0));
  if( (v = sqlite3GetVdbe(pParse))!=0 ){
    int base;
    static const VdbeOpList dropTrigger[] = {
      { 65, 0, (-1-(9)), 0},
      { 94, 0, 1, 0},
      { 28, 0, 1, 2},
      { 75, 2, (-1-(8)), 1},
      { 94, 0, 1, 0},
      { 28, 0, 0, 2},
      { 75, 2, (-1-(8)), 1},
      { 57, 0, 0, 0},
      { 67, 0, (-1-(1)), 0},
    };

    sqlite3BeginWriteOperation(pParse, 0, iDb);
    sqlite3OpenMasterTable(pParse, iDb);
    base = sqlite3VdbeAddOpList(v, ((int)(sizeof(dropTrigger)/sizeof(dropTrigger[0]))), dropTrigger);
    sqlite3VdbeChangeP4(v, base+1, pTrigger->zName, 0);
    sqlite3VdbeChangeP4(v, base+4, "trigger", (-2));
    sqlite3ChangeCookie(pParse, iDb);
    sqlite3VdbeAddOp2(v, 43, 0, 0);
    sqlite3VdbeAddOp4(v, 103, iDb, 0, 0, pTrigger->zName, 0);
    if( pParse->nMem<3 ){
      pParse->nMem = 3;
    }
  }
}




static void sqlite3UnlinkAndDeleteTrigger(sqlite3 *db, int iDb, const char *zName){
  Trigger *pTrigger;
  Hash *pHash;

  ((void) (0));
  pHash = &(db->aDb[iDb].pSchema->trigHash);
  pTrigger = sqlite3HashInsert(pHash, zName, sqlite3Strlen30(zName), 0);
  if( (pTrigger) ){
    if( pTrigger->pSchema==pTrigger->pTabSchema ){
      Table *pTab = tableOfTrigger(pTrigger);
      Trigger **pp;
      for(pp=&pTab->pTrigger; *pp!=pTrigger; pp=&((*pp)->pNext));
      *pp = (*pp)->pNext;
    }
    sqlite3DeleteTrigger(db, pTrigger);
    db->flags |= 0x00000200;
  }
}
# 95081 "ext/sqlite3/libsqlite/sqlite3.c"
static int checkColumnOverlap(IdList *pIdList, ExprList *pEList){
  int e;
  if( pIdList==0 || (pEList==0) ) return 1;
  for(e=0; e<pEList->nExpr; e++){
    if( sqlite3IdListIndex(pIdList, pEList->a[e].zName)>=0 ) return 1;
  }
  return 0;
}







static Trigger *sqlite3TriggersExist(
  Parse *pParse,
  Table *pTab,
  int op,
  ExprList *pChanges,
  int *pMask
){
  int mask = 0;
  Trigger *pList = 0;
  Trigger *p;

  if( (pParse->db->flags & 0x40000000)!=0 ){
    pList = sqlite3TriggerList(pParse, pTab);
  }
  ((void) (0));
  for(p=pList; p; p=p->pNext){
    if( p->op==op && checkColumnOverlap(p->pColumns, pChanges) ){
      mask |= p->tr_tm;
    }
  }
  if( pMask ){
    *pMask = mask;
  }
  return (mask ? pList : 0);
}
# 95132 "ext/sqlite3/libsqlite/sqlite3.c"
static SrcList *targetSrcList(
  Parse *pParse,
  TriggerStep *pStep
){
  int iDb;
  SrcList *pSrc;

  pSrc = sqlite3SrcListAppend(pParse->db, 0, &pStep->target, 0);
  if( pSrc ){
    ((void) (0));
    ((void) (0));
    iDb = sqlite3SchemaToIndex(pParse->db, pStep->pTrig->pSchema);
    if( iDb==0 || iDb>=2 ){
      sqlite3 *db = pParse->db;
      ((void) (0));
      pSrc->a[pSrc->nSrc-1].zDatabase = sqlite3DbStrDup(db, db->aDb[iDb].zName);
    }
  }
  return pSrc;
}





static int codeTriggerProgram(
  Parse *pParse,
  TriggerStep *pStepList,
  int orconf
){
  TriggerStep *pStep;
  Vdbe *v = pParse->pVdbe;
  sqlite3 *db = pParse->db;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  for(pStep=pStepList; pStep; pStep=pStep->pNext){
# 95183 "ext/sqlite3/libsqlite/sqlite3.c"
    pParse->eOrconf = (orconf==99)?pStep->orconf:(u8)orconf;

    switch( pStep->op ){
      case 107: {
        sqlite3Update(pParse,
          targetSrcList(pParse, pStep),
          sqlite3ExprListDup(db, pStep->pExprList, 0),
          sqlite3ExprDup(db, pStep->pWhere, 0),
          pParse->eOrconf
        );
        break;
      }
      case 105: {
        sqlite3Insert(pParse,
          targetSrcList(pParse, pStep),
          sqlite3ExprListDup(db, pStep->pExprList, 0),
          sqlite3SelectDup(db, pStep->pSelect, 0),
          sqlite3IdListDup(db, pStep->pIdList),
          pParse->eOrconf
        );
        break;
      }
      case 106: {
        sqlite3DeleteFrom(pParse,
          targetSrcList(pParse, pStep),
          sqlite3ExprDup(db, pStep->pWhere, 0)
        );
        break;
      }
      default: ((void) (0)); {
        SelectDest sDest;
        Select *pSelect = sqlite3SelectDup(db, pStep->pSelect, 0);
        sqlite3SelectDestInit(&sDest, 4, 0);
        sqlite3Select(pParse, pSelect, &sDest);
        sqlite3SelectDelete(db, pSelect);
        break;
      }
    }
    if( pStep->op!=116 ){
      sqlite3VdbeAddOp0(v, 58);
    }
  }

  return 0;
}
# 95252 "ext/sqlite3/libsqlite/sqlite3.c"
static void transferParseError(Parse *pTo, Parse *pFrom){
  ((void) (0));
  ((void) (0));
  if( pTo->nErr==0 ){
    pTo->zErrMsg = pFrom->zErrMsg;
    pTo->nErr = pFrom->nErr;
  }else{
    sqlite3DbFree(pFrom->db, pFrom->zErrMsg);
  }
}





static TriggerPrg *codeRowTrigger(
  Parse *pParse,
  Trigger *pTrigger,
  Table *pTab,
  int orconf
){
  Parse *pTop = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  sqlite3 *db = pParse->db;
  TriggerPrg *pPrg;
  Expr *pWhen = 0;
  Vdbe *v;
  NameContext sNC;
  SubProgram *pProgram = 0;
  Parse *pSubParse;
  int iEndTrigger = 0;

  ((void) (0));
  ((void) (0));




  pPrg = sqlite3DbMallocZero(db, sizeof(TriggerPrg));
  if( !pPrg ) return 0;
  pPrg->pNext = pTop->pTriggerPrg;
  pTop->pTriggerPrg = pPrg;
  pPrg->pProgram = pProgram = sqlite3DbMallocZero(db, sizeof(SubProgram));
  if( !pProgram ) return 0;
  sqlite3VdbeLinkSubProgram(pTop->pVdbe, pProgram);
  pPrg->pTrigger = pTrigger;
  pPrg->orconf = orconf;
  pPrg->aColmask[0] = 0xffffffff;
  pPrg->aColmask[1] = 0xffffffff;



  pSubParse = sqlite3DbMallocZero(db,sizeof(Parse));
  if( !pSubParse ) return 0;
  memset(&sNC, 0, sizeof(sNC));
  sNC.pParse = pSubParse;
  pSubParse->db = db;
  pSubParse->pTriggerTab = pTab;
  pSubParse->pToplevel = pTop;
  pSubParse->zAuthContext = pTrigger->zName;
  pSubParse->eTriggerOp = pTrigger->op;
  pSubParse->nQueryLoop = pParse->nQueryLoop;

  v = sqlite3GetVdbe(pSubParse);
  if( v ){







      ;

    sqlite3VdbeChangeP4(v, -1,
      sqlite3MPrintf(db, "-- TRIGGER %s", pTrigger->zName), (-1)
    );





    if( pTrigger->pWhen ){
      pWhen = sqlite3ExprDup(db, pTrigger->pWhen, 0);
      if( 0==sqlite3ResolveExprNames(&sNC, pWhen)
       && db->mallocFailed==0
      ){
        iEndTrigger = sqlite3VdbeMakeLabel(v);
        sqlite3ExprIfFalse(pSubParse, pWhen, iEndTrigger, 0x08);
      }
      sqlite3ExprDelete(db, pWhen);
    }


    codeTriggerProgram(pSubParse, pTrigger->step_list, orconf);


    if( iEndTrigger ){
      sqlite3VdbeResolveLabel(v, iEndTrigger);
    }
    sqlite3VdbeAddOp0(v, 6);
                                                                        ;

    transferParseError(pParse, pSubParse);
    if( db->mallocFailed==0 ){
      pProgram->aOp = sqlite3VdbeTakeOpArray(v, &pProgram->nOp, &pTop->nMaxArg);
    }
    pProgram->nMem = pSubParse->nMem;
    pProgram->nCsr = pSubParse->nTab;
    pProgram->token = (void *)pTrigger;
    pPrg->aColmask[0] = pSubParse->oldmask;
    pPrg->aColmask[1] = pSubParse->newmask;
    sqlite3VdbeDelete(v);
  }

  ((void) (0));
  ((void) (0));
  sqlite3DbFree(db,pSubParse);

  return pPrg;
}







static TriggerPrg *getRowTrigger(
  Parse *pParse,
  Trigger *pTrigger,
  Table *pTab,
  int orconf
){
  Parse *pRoot = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  TriggerPrg *pPrg;

  ((void) (0));





  for(pPrg=pRoot->pTriggerPrg;
      pPrg && (pPrg->pTrigger!=pTrigger || pPrg->orconf!=orconf);
      pPrg=pPrg->pNext
  );


  if( !pPrg ){
    pPrg = codeRowTrigger(pParse, pTrigger, pTab, orconf);
  }

  return pPrg;
}







static void sqlite3CodeRowTriggerDirect(
  Parse *pParse,
  Trigger *p,
  Table *pTab,
  int reg,
  int orconf,
  int ignoreJump
){
  Vdbe *v = sqlite3GetVdbe(pParse);
  TriggerPrg *pPrg;
  pPrg = getRowTrigger(pParse, p, pTab, orconf);
  ((void) (0));



  if( pPrg ){
    int bRecursive = (p->zName && 0==(pParse->db->flags&0x02000000));

    sqlite3VdbeAddOp3(v, 108, reg, ignoreJump, ++pParse->nMem);
    sqlite3VdbeChangeP4(v, -1, (const char *)pPrg->pProgram, (-18));

                                                                            ;






    sqlite3VdbeChangeP5(v, (u8)bRecursive);
  }
}
# 95485 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3CodeRowTrigger(
  Parse *pParse,
  Trigger *pTrigger,
  int op,
  ExprList *pChanges,
  int tr_tm,
  Table *pTab,
  int reg,
  int orconf,
  int ignoreJump
){
  Trigger *p;

  ((void) (0));
  ((void) (0));
  ((void) (0));

  for(p=pTrigger; p; p=p->pNext){




    ((void) (0));
    ((void) (0));
    ((void) (0));



    if( p->op==op
     && p->tr_tm==tr_tm
     && checkColumnOverlap(p->pColumns, pChanges)
    ){
      sqlite3CodeRowTriggerDirect(pParse, p, pTab, reg, orconf, ignoreJump);
    }
  }
}
# 95547 "ext/sqlite3/libsqlite/sqlite3.c"
static u32 sqlite3TriggerColmask(
  Parse *pParse,
  Trigger *pTrigger,
  ExprList *pChanges,
  int isNew,
  int tr_tm,
  Table *pTab,
  int orconf
){
  const int op = pChanges ? 107 : 106;
  u32 mask = 0;
  Trigger *p;

  ((void) (0));
  for(p=pTrigger; p; p=p->pNext){
    if( p->op==op && (tr_tm&p->tr_tm)
     && checkColumnOverlap(p->pColumns,pChanges)
    ){
      TriggerPrg *pPrg;
      pPrg = getRowTrigger(pParse, p, pTab, orconf);
      if( pPrg ){
        mask |= pPrg->aColmask[isNew];
      }
    }
  }

  return mask;
}
# 95597 "ext/sqlite3/libsqlite/sqlite3.c"
static void updateVirtualTable(
  Parse *pParse,
  SrcList *pSrc,
  Table *pTab,
  ExprList *pChanges,
  Expr *pRowidExpr,
  int *aXRef,
  Expr *pWhere
);
# 95638 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3ColumnDefault(Vdbe *v, Table *pTab, int i, int iReg){
  ((void) (0));
  if( !pTab->pSelect ){
    sqlite3_value *pValue;
    u8 enc = ((sqlite3VdbeDb(v))->aDb[0].pSchema->enc);
    Column *pCol = &pTab->aCol[i];
                                                       ;
    ((void) (0));
    sqlite3ValueFromExpr(sqlite3VdbeDb(v), pCol->pDflt, enc,
                         pCol->affinity, &pValue);
    if( pValue ){
      sqlite3VdbeChangeP4(v, -1, (const char *)pValue, (-8));
    }

    if( iReg>=0 && pTab->aCol[i].affinity=='e' ){
      sqlite3VdbeAddOp1(v, 22, iReg);
    }

  }
}
# 95666 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3Update(
  Parse *pParse,
  SrcList *pTabList,
  ExprList *pChanges,
  Expr *pWhere,
  int onError
){
  int i, j;
  Table *pTab;
  int addr = 0;
  WhereInfo *pWInfo;
  Vdbe *v;
  Index *pIdx;
  int nIdx;
  int iCur;
  sqlite3 *db;
  int *aRegIdx = 0;
  int *aXRef = 0;


  int chngRowid;
  Expr *pRowidExpr = 0;
  int openAll = 0;
  AuthContext sContext;
  NameContext sNC;
  int iDb;
  int okOnePass;
  int hasFK;


  int isView;
  Trigger *pTrigger;
  int tmask;

  int newmask;


  int regRowCount = 0;
  int regOldRowid;
  int regNewRowid;
  int regNew;
  int regOld = 0;
  int regRowSet = 0;

  memset(&sContext, 0, sizeof(sContext));
  db = pParse->db;
  if( pParse->nErr || db->mallocFailed ){
    goto update_cleanup;
  }
  ((void) (0));



  pTab = sqlite3SrcListLookup(pParse, pTabList);
  if( pTab==0 ) goto update_cleanup;
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);





  pTrigger = sqlite3TriggersExist(pParse, pTab, 107, pChanges, &tmask);
  isView = pTab->pSelect!=0;
  ((void) (0));
# 95740 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto update_cleanup;
  }
  if( sqlite3IsReadOnly(pParse, pTab, tmask) ){
    goto update_cleanup;
  }
  aXRef = sqlite3DbMallocRaw(db, sizeof(int) * pTab->nCol );
  if( aXRef==0 ) goto update_cleanup;
  for(i=0; i<pTab->nCol; i++) aXRef[i] = -1;






  pTabList->a[0].iCursor = iCur = pParse->nTab++;
  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
    pParse->nTab++;
  }


  memset(&sNC, 0, sizeof(sNC));
  sNC.pParse = pParse;
  sNC.pSrcList = pTabList;







  chngRowid = 0;
  for(i=0; i<pChanges->nExpr; i++){
    if( sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr) ){
      goto update_cleanup;
    }
    for(j=0; j<pTab->nCol; j++){
      if( sqlite3StrICmp(pTab->aCol[j].zName, pChanges->a[i].zName)==0 ){
        if( j==pTab->iPKey ){
          chngRowid = 1;
          pRowidExpr = pChanges->a[i].pExpr;
        }
        aXRef[j] = i;
        break;
      }
    }
    if( j>=pTab->nCol ){
      if( sqlite3IsRowid(pChanges->a[i].zName) ){
        chngRowid = 1;
        pRowidExpr = pChanges->a[i].pExpr;
      }else{
        sqlite3ErrorMsg(pParse, "no such column: %s", pChanges->a[i].zName);
        pParse->checkSchema = 1;
        goto update_cleanup;
      }
    }

    {
      int rc;
      rc = sqlite3AuthCheck(pParse, 23, pTab->zName,
                           pTab->aCol[j].zName, db->aDb[iDb].zName);
      if( rc==1 ){
        goto update_cleanup;
      }else if( rc==2 ){
        aXRef[j] = -1;
      }
    }

  }

  hasFK = sqlite3FkRequired(pParse, pTab, aXRef, chngRowid);






  for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){}
  if( nIdx>0 ){
    aRegIdx = sqlite3DbMallocRaw(db, sizeof(Index*) * nIdx );
    if( aRegIdx==0 ) goto update_cleanup;
  }
  for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){
    int reg;
    if( chngRowid ){
      reg = ++pParse->nMem;
    }else{
      reg = 0;
      for(i=0; i<pIdx->nColumn; i++){
        if( aXRef[pIdx->aiColumn[i]]>=0 ){
          reg = ++pParse->nMem;
          break;
        }
      }
    }
    aRegIdx[j] = reg;
  }


  v = sqlite3GetVdbe(pParse);
  if( v==0 ) goto update_cleanup;
  if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);
  sqlite3BeginWriteOperation(pParse, 1, iDb);



  if( (((pTab)->tabFlags & 0x10)!=0) ){
    updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef,
                       pWhere);
    pWhere = 0;
    pTabList = 0;
    goto update_cleanup;
  }



  regOldRowid = regNewRowid = ++pParse->nMem;
  if( pTrigger || hasFK ){
    regOld = pParse->nMem + 1;
    pParse->nMem += pTab->nCol;
  }
  if( chngRowid || pTrigger || hasFK ){
    regNewRowid = ++pParse->nMem;
  }
  regNew = pParse->nMem + 1;
  pParse->nMem += pTab->nCol;


  if( isView ){
    sqlite3AuthContextPush(pParse, &sContext, pTab->zName);
  }





  if( isView ){
    sqlite3MaterializeView(pParse, pTab, pWhere, iCur);
  }





  if( sqlite3ResolveExprNames(&sNC, pWhere) ){
    goto update_cleanup;
  }



  sqlite3VdbeAddOp2(v, 10, 0, regOldRowid);
  pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere,0, 0x0004);
  if( pWInfo==0 ) goto update_cleanup;
  okOnePass = pWInfo->okOnePass;



  sqlite3VdbeAddOp2(v, 61, iCur, regOldRowid);
  if( !okOnePass ){
    regRowSet = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 105, regRowSet, regOldRowid);
  }



  sqlite3WhereEnd(pWInfo);



  if( (db->flags & 0x00001000) && !pParse->pTriggerTab ){
    regRowCount = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 7, 0, regRowCount);
  }

  if( !isView ){






    if( !okOnePass ) sqlite3OpenTable(pParse, iCur, iDb, pTab, 39);
    if( onError==5 ){
      openAll = 1;
    }else{
      openAll = 0;
      for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
        if( pIdx->onError==5 ){
          openAll = 1;
          break;
        }
      }
    }
    for(i=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, i++){
      if( openAll || aRegIdx[i]>0 ){
        KeyInfo *pKey = sqlite3IndexKeyinfo(pParse, pIdx);
        sqlite3VdbeAddOp4(v, 39, iCur+i+1, pIdx->tnum, iDb,
                       (char*)pKey, (-16));
        ((void) (0));
      }
    }
  }


  if( okOnePass ){
    int a1 = sqlite3VdbeAddOp1(v, 74, regOldRowid);
    addr = sqlite3VdbeAddOp0(v, 1);
    sqlite3VdbeJumpHere(v, a1);
  }else{
    addr = sqlite3VdbeAddOp3(v, 106, regRowSet, 0, regOldRowid);
  }




  sqlite3VdbeAddOp3(v, 52, iCur, addr, regOldRowid);





  ((void) (0));
  if( chngRowid ){
    sqlite3ExprCode(pParse, pRowidExpr, regNewRowid);
    sqlite3VdbeAddOp1(v, 21, regNewRowid);
  }



  if( hasFK || pTrigger ){
    u32 oldmask = (hasFK ? sqlite3FkOldmask(pParse, pTab) : 0);
    oldmask |= sqlite3TriggerColmask(pParse,
        pTrigger, pChanges, 0, 1|2, pTab, onError
    );
    for(i=0; i<pTab->nCol; i++){
      if( aXRef[i]<0 || oldmask==0xffffffff || (i<32 && (oldmask & (1<<i))) ){
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, i, regOld+i);
      }else{
        sqlite3VdbeAddOp2(v, 10, 0, regOld+i);
      }
    }
    if( chngRowid==0 ){
      sqlite3VdbeAddOp2(v, 14, regOldRowid, regNewRowid);
    }
  }
# 95999 "ext/sqlite3/libsqlite/sqlite3.c"
  newmask = sqlite3TriggerColmask(
      pParse, pTrigger, pChanges, 1, 1, pTab, onError
  );
  for(i=0; i<pTab->nCol; i++){
    if( i==pTab->iPKey ){
      sqlite3VdbeAddOp2(v, 10, 0, regNew+i);
    }else{
      j = aXRef[i];
      if( j>=0 ){
        sqlite3ExprCode(pParse, pChanges->a[j].pExpr, regNew+i);
      }else if( 0==(tmask&1) || i>31 || (newmask&(1<<i)) ){





                         ;
                         ;
        sqlite3VdbeAddOp3(v, 28, iCur, i, regNew+i);
        sqlite3ColumnDefault(v, pTab, i, regNew+i);
      }
    }
  }




  if( tmask&1 ){
    sqlite3VdbeAddOp2(v, 29, regNew, pTab->nCol);
    sqlite3TableAffinityStr(v, pTab);
    sqlite3CodeRowTrigger(pParse, pTrigger, 107, pChanges,
        1, pTab, regOldRowid, onError, addr);







    sqlite3VdbeAddOp3(v, 52, iCur, addr, regOldRowid);






    for(i=0; i<pTab->nCol; i++){
      if( aXRef[i]<0 && i!=pTab->iPKey ){
        sqlite3VdbeAddOp3(v, 28, iCur, i, regNew+i);
        sqlite3ColumnDefault(v, pTab, i, regNew+i);
      }
    }
  }

  if( !isView ){
    int j1;


    sqlite3GenerateConstraintChecks(pParse, pTab, iCur, regNewRowid,
        aRegIdx, (chngRowid?regOldRowid:0), 1, onError, addr, 0);


    if( hasFK ){
      sqlite3FkCheck(pParse, pTab, regOldRowid, 0);
    }


    j1 = sqlite3VdbeAddOp3(v, 52, iCur, 0, regOldRowid);
    sqlite3GenerateRowIndexDelete(pParse, pTab, iCur, aRegIdx);


    if( hasFK || chngRowid ){
      sqlite3VdbeAddOp2(v, 57, iCur, 0);
    }
    sqlite3VdbeJumpHere(v, j1);

    if( hasFK ){
      sqlite3FkCheck(pParse, pTab, 0, regNewRowid);
    }


    sqlite3CompleteInsertion(pParse, pTab, iCur, regNewRowid, aRegIdx, 1, 0, 0);




    if( hasFK ){
      sqlite3FkActions(pParse, pTab, pChanges, regOldRowid);
    }
  }



  if( (db->flags & 0x00001000) && !pParse->pTriggerTab){
    sqlite3VdbeAddOp2(v, 20, regRowCount, 1);
  }

  sqlite3CodeRowTrigger(pParse, pTrigger, 107, pChanges,
      2, pTab, regOldRowid, onError, addr);




  sqlite3VdbeAddOp2(v, 1, 0, addr);
  sqlite3VdbeJumpHere(v, addr);


  for(i=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, i++){
    if( openAll || aRegIdx[i]>0 ){
      sqlite3VdbeAddOp2(v, 43, iCur+i+1, 0);
    }
  }
  sqlite3VdbeAddOp2(v, 43, iCur, 0);





  if( pParse->nested==0 && pParse->pTriggerTab==0 ){
    sqlite3AutoincrementEnd(pParse);
  }






  if( (db->flags&0x00001000) && !pParse->pTriggerTab && !pParse->nested ){
    sqlite3VdbeAddOp2(v, 16, regRowCount, 1);
    sqlite3VdbeSetNumCols(v, 1);
    sqlite3VdbeSetColName(v, 0, 0, "rows updated", ((sqlite3_destructor_type)0));
  }

update_cleanup:
  sqlite3AuthContextPop(&sContext);
  sqlite3DbFree(db, aRegIdx);
  sqlite3DbFree(db, aXRef);
  sqlite3SrcListDelete(db, pTabList);
  sqlite3ExprListDelete(db, pChanges);
  sqlite3ExprDelete(db, pWhere);
  return;
}
# 96171 "ext/sqlite3/libsqlite/sqlite3.c"
static void updateVirtualTable(
  Parse *pParse,
  SrcList *pSrc,
  Table *pTab,
  ExprList *pChanges,
  Expr *pRowid,
  int *aXRef,
  Expr *pWhere
){
  Vdbe *v = pParse->pVdbe;
  ExprList *pEList = 0;
  Select *pSelect = 0;
  Expr *pExpr;
  int ephemTab;
  int i;
  int addr;
  int iReg;
  sqlite3 *db = pParse->db;
  const char *pVTab = (const char*)sqlite3GetVTable(db, pTab);
  SelectDest dest;




  pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, 26, "_rowid_"));
  if( pRowid ){
    pEList = sqlite3ExprListAppend(pParse, pEList,
                                   sqlite3ExprDup(db, pRowid, 0));
  }
  ((void) (0));
  for(i=0; i<pTab->nCol; i++){
    if( aXRef[i]>=0 ){
      pExpr = sqlite3ExprDup(db, pChanges->a[aXRef[i]].pExpr, 0);
    }else{
      pExpr = sqlite3Expr(db, 26, pTab->aCol[i].zName);
    }
    pEList = sqlite3ExprListAppend(pParse, pEList, pExpr);
  }
  pSelect = sqlite3SelectNew(pParse, pEList, pSrc, pWhere, 0, 0, 0, 0, 0, 0);




  ((void) (0));
  ephemTab = pParse->nTab++;
  sqlite3VdbeAddOp2(v, 41, ephemTab, pTab->nCol+1+(pRowid!=0));
  sqlite3VdbeChangeP5(v, 16);



  sqlite3SelectDestInit(&dest, 8, ephemTab);
  sqlite3Select(pParse, pSelect, &dest);


  iReg = ++pParse->nMem;
  pParse->nMem += pTab->nCol+1;
  addr = sqlite3VdbeAddOp2(v, 65, ephemTab, 0);
  sqlite3VdbeAddOp3(v, 28, ephemTab, 0, iReg);
  sqlite3VdbeAddOp3(v, 28, ephemTab, (pRowid?1:0), iReg+1);
  for(i=0; i<pTab->nCol; i++){
    sqlite3VdbeAddOp3(v, 28, ephemTab, i+1+(pRowid!=0), iReg+2+i);
  }
  sqlite3VtabMakeWritable(pParse, pTab);
  sqlite3VdbeAddOp4(v, 133, 0, pTab->nCol+2, iReg, pVTab, (-10));
  sqlite3MayAbort(pParse);
  sqlite3VdbeAddOp2(v, 67, ephemTab, addr+1);
  sqlite3VdbeJumpHere(v, addr);
  sqlite3VdbeAddOp2(v, 43, ephemTab, 0);


  sqlite3SelectDelete(db, pSelect);
}
# 96269 "ext/sqlite3/libsqlite/sqlite3.c"
static int vacuumFinalize(sqlite3 *db, sqlite3_stmt *pStmt, char **pzErrMsg){
  int rc;
  rc = sqlite3VdbeFinalize((Vdbe*)pStmt);
  if( rc ){
    sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));
  }
  return rc;
}




static int execSql(sqlite3 *db, char **pzErrMsg, const char *zSql){
  sqlite3_stmt *pStmt;

  if( !zSql ){
    return 7;
  }
  if( 0!=sqlite3_prepare(db, zSql, -1, &pStmt, 0) ){
    sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));
    return sqlite3_errcode(db);
  }
                   sqlite3_step(pStmt);
  ((void) (0));
  return vacuumFinalize(db, pStmt, pzErrMsg);
}





static int execExecSql(sqlite3 *db, char **pzErrMsg, const char *zSql){
  sqlite3_stmt *pStmt;
  int rc;

  rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0);
  if( rc!=0 ) return rc;

  while( 100==sqlite3_step(pStmt) ){
    rc = execSql(db, pzErrMsg, (char*)sqlite3_column_text(pStmt, 0));
    if( rc!=0 ){
      vacuumFinalize(db, pStmt, pzErrMsg);
      return rc;
    }
  }

  return vacuumFinalize(db, pStmt, pzErrMsg);
}
# 96328 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3Vacuum(Parse *pParse){
  Vdbe *v = sqlite3GetVdbe(pParse);
  if( v ){
    sqlite3VdbeAddOp2(v, 120, 0, 0);
  }
  return;
}




static int sqlite3RunVacuum(char **pzErrMsg, sqlite3 *db){
  int rc = 0;
  Btree *pMain;
  Btree *pTemp;
  char *zSql = 0;
  int saved_flags;
  int saved_nChange;
  int saved_nTotalChange;
  void (*saved_xTrace)(void*,const char*);
  Db *pDb = 0;
  int isMemDb;
  int nRes;
  int nDb;

  if( !db->autoCommit ){
    sqlite3SetString(pzErrMsg, db, "cannot VACUUM from within a transaction");
    return 1;
  }
  if( db->activeVdbeCnt>1 ){
    sqlite3SetString(pzErrMsg, db,"cannot VACUUM - SQL statements in progress");
    return 1;
  }




  saved_flags = db->flags;
  saved_nChange = db->nChange;
  saved_nTotalChange = db->nTotalChange;
  saved_xTrace = db->xTrace;
  db->flags |= 0x00010000 | 0x00040000 | 0x10000000;
  db->flags &= ~(0x04000000 | 0x01000000);
  db->xTrace = 0;

  pMain = db->aDb[0].pBt;
  isMemDb = sqlite3PagerIsMemdb(sqlite3BtreePager(pMain));
# 96390 "ext/sqlite3/libsqlite/sqlite3.c"
  nDb = db->nDb;
  if( sqlite3TempInMemory(db) ){
    zSql = "ATTACH ':memory:' AS vacuum_db;";
  }else{
    zSql = "ATTACH '' AS vacuum_db;";
  }
  rc = execSql(db, pzErrMsg, zSql);
  if( db->nDb>nDb ){
    pDb = &db->aDb[db->nDb-1];
    ((void) (0));
  }
  if( rc!=0 ) goto end_of_vacuum;
  pTemp = db->aDb[db->nDb-1].pBt;





  sqlite3BtreeCommit(pTemp);

  nRes = sqlite3BtreeGetReserve(pMain);
# 96424 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3PagerGetJournalMode(sqlite3BtreePager(pMain))
                                               ==5 ){
    db->nextPagesize = 0;
  }

  if( sqlite3BtreeSetPageSize(pTemp, sqlite3BtreeGetPageSize(pMain), nRes, 0)
   || (!isMemDb && sqlite3BtreeSetPageSize(pTemp, db->nextPagesize, nRes, 0))
   || (db->mallocFailed)
  ){
    rc = 7;
    goto end_of_vacuum;
  }
  rc = execSql(db, pzErrMsg, "PRAGMA vacuum_db.synchronous=OFF");
  if( rc!=0 ){
    goto end_of_vacuum;
  }


  sqlite3BtreeSetAutoVacuum(pTemp, db->nextAutovac>=0 ? db->nextAutovac :
                                           sqlite3BtreeGetAutoVacuum(pMain));



  rc = execSql(db, pzErrMsg, "BEGIN EXCLUSIVE;");
  if( rc!=0 ) goto end_of_vacuum;




  rc = execExecSql(db, pzErrMsg,
      "SELECT 'CREATE TABLE vacuum_db.' || substr(sql,14) "
      "  FROM sqlite_master WHERE type='table' AND name!='sqlite_sequence'"
      "   AND rootpage>0"
  );
  if( rc!=0 ) goto end_of_vacuum;
  rc = execExecSql(db, pzErrMsg,
      "SELECT 'CREATE INDEX vacuum_db.' || substr(sql,14)"
      "  FROM sqlite_master WHERE sql LIKE 'CREATE INDEX %' ");
  if( rc!=0 ) goto end_of_vacuum;
  rc = execExecSql(db, pzErrMsg,
      "SELECT 'CREATE UNIQUE INDEX vacuum_db.' || substr(sql,21) "
      "  FROM sqlite_master WHERE sql LIKE 'CREATE UNIQUE INDEX %'");
  if( rc!=0 ) goto end_of_vacuum;





  rc = execExecSql(db, pzErrMsg,
      "SELECT 'INSERT INTO vacuum_db.' || quote(name) "
      "|| ' SELECT * FROM main.' || quote(name) || ';'"
      "FROM main.sqlite_master "
      "WHERE type = 'table' AND name!='sqlite_sequence' "
      "  AND rootpage>0"
  );
  if( rc!=0 ) goto end_of_vacuum;



  rc = execExecSql(db, pzErrMsg,
      "SELECT 'DELETE FROM vacuum_db.' || quote(name) || ';' "
      "FROM vacuum_db.sqlite_master WHERE name='sqlite_sequence' "
  );
  if( rc!=0 ) goto end_of_vacuum;
  rc = execExecSql(db, pzErrMsg,
      "SELECT 'INSERT INTO vacuum_db.' || quote(name) "
      "|| ' SELECT * FROM main.' || quote(name) || ';' "
      "FROM vacuum_db.sqlite_master WHERE name=='sqlite_sequence';"
  );
  if( rc!=0 ) goto end_of_vacuum;







  rc = execSql(db, pzErrMsg,
      "INSERT INTO vacuum_db.sqlite_master "
      "  SELECT type, name, tbl_name, rootpage, sql"
      "    FROM main.sqlite_master"
      "   WHERE type='view' OR type='trigger'"
      "      OR (type='table' AND rootpage=0)"
  );
  if( rc ) goto end_of_vacuum;
# 96518 "ext/sqlite3/libsqlite/sqlite3.c"
  {
    u32 meta;
    int i;







    static const unsigned char aCopy[] = {
       1, 1,
       3, 0,
       5, 0,
       6, 0,
    };

    ((void) (0));
    ((void) (0));


    for(i=0; i<((int)(sizeof(aCopy)/sizeof(aCopy[0]))); i+=2){


      sqlite3BtreeGetMeta(pMain, aCopy[i], &meta);
      rc = sqlite3BtreeUpdateMeta(pTemp, aCopy[i], meta+aCopy[i+1]);
      if( (rc!=0) ) goto end_of_vacuum;
    }

    rc = sqlite3BtreeCopyFile(pMain, pTemp);
    if( rc!=0 ) goto end_of_vacuum;
    rc = sqlite3BtreeCommit(pTemp);
    if( rc!=0 ) goto end_of_vacuum;

    sqlite3BtreeSetAutoVacuum(pMain, sqlite3BtreeGetAutoVacuum(pTemp));

  }

  ((void) (0));
  rc = sqlite3BtreeSetPageSize(pMain, sqlite3BtreeGetPageSize(pTemp), nRes,1);

end_of_vacuum:

  db->flags = saved_flags;
  db->nChange = saved_nChange;
  db->nTotalChange = saved_nTotalChange;
  db->xTrace = saved_xTrace;
  sqlite3BtreeSetPageSize(pMain, -1, -1, 1);
# 96574 "ext/sqlite3/libsqlite/sqlite3.c"
  db->autoCommit = 1;

  if( pDb ){
    sqlite3BtreeClose(pDb->pBt);
    pDb->pBt = 0;
    pDb->pSchema = 0;
  }



  sqlite3ResetInternalSchema(db, -1);

  return rc;
}
# 96613 "ext/sqlite3/libsqlite/sqlite3.c"
static int createModule(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *pModule,
  void *pAux,
  void (*xDestroy)(void *)
){
  int rc, nName;
  Module *pMod;

                                ;
  nName = sqlite3Strlen30(zName);
  pMod = (Module *)sqlite3DbMallocRaw(db, sizeof(Module) + nName + 1);
  if( pMod ){
    Module *pDel;
    char *zCopy = (char *)(&pMod[1]);
    memcpy(zCopy, zName, nName+1);
    pMod->zName = zCopy;
    pMod->pModule = pModule;
    pMod->pAux = pAux;
    pMod->xDestroy = xDestroy;
    pDel = (Module *)sqlite3HashInsert(&db->aModule, zCopy, nName, (void*)pMod);
    if( pDel && pDel->xDestroy ){
      pDel->xDestroy(pDel->pAux);
    }
    sqlite3DbFree(db, pDel);
    if( pDel==pMod ){
      db->mallocFailed = 1;
    }
    sqlite3ResetInternalSchema(db, -1);
  }else if( xDestroy ){
    xDestroy(pAux);
  }
  rc = sqlite3ApiExit(db, 0);
                                ;
  return rc;
}





           int sqlite3_create_module(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *pModule,
  void *pAux
){
  return createModule(db, zName, pModule, pAux, 0);
}




           int sqlite3_create_module_v2(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *pModule,
  void *pAux,
  void (*xDestroy)(void *)
){
  return createModule(db, zName, pModule, pAux, xDestroy);
}
# 96685 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3VtabLock(VTable *pVTab){
  pVTab->nRef++;
}







static VTable *sqlite3GetVTable(sqlite3 *db, Table *pTab){
  VTable *pVtab;
  ((void) (0));
  for(pVtab=pTab->pVTable; pVtab && pVtab->db!=db; pVtab=pVtab->pNext);
  return pVtab;
}





static void sqlite3VtabUnlock(VTable *pVTab){
  sqlite3 *db = pVTab->db;

  ((void) (0));
  ((void) (0));
  ((void) (0));

  pVTab->nRef--;
  if( pVTab->nRef==0 ){
    sqlite3_vtab *p = pVTab->pVtab;
    if( p ){
      p->pModule->xDisconnect(p);
    }
    sqlite3DbFree(db, pVTab);
  }
}
# 96730 "ext/sqlite3/libsqlite/sqlite3.c"
static VTable *vtabDisconnectAll(sqlite3 *db, Table *p){
  VTable *pRet = 0;
  VTable *pVTable = p->pVTable;
  p->pVTable = 0;







  ((void) (0));

  while( pVTable ){
    sqlite3 *db2 = pVTable->db;
    VTable *pNext = pVTable->pNext;
    ((void) (0));
    if( db2==db ){
      pRet = pVTable;
      p->pVTable = pRet;
      pRet->pNext = 0;
    }else{
      pVTable->pNext = db2->pDisconnect;
      db2->pDisconnect = pVTable;
    }
    pVTable = pNext;
  }

  ((void) (0));
  return pRet;
}
# 96783 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3VtabUnlockList(sqlite3 *db){
  VTable *p = db->pDisconnect;
  db->pDisconnect = 0;

  ((void) (0));
  ((void) (0));

  if( p ){
    sqlite3ExpirePreparedStatements(db);
    do {
      VTable *pNext = p->pNext;
      sqlite3VtabUnlock(p);
      p = pNext;
    }while( p );
  }
}
# 96814 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3VtabClear(sqlite3 *db, Table *p){
  if( !db || db->pnBytesFreed==0 ) vtabDisconnectAll(0, p);
  if( p->azModuleArg ){
    int i;
    for(i=0; i<p->nModuleArg; i++){
      sqlite3DbFree(db, p->azModuleArg[i]);
    }
    sqlite3DbFree(db, p->azModuleArg);
  }
}







static void addModuleArgument(sqlite3 *db, Table *pTable, char *zArg){
  int i = pTable->nModuleArg++;
  int nBytes = sizeof(char *)*(1+pTable->nModuleArg);
  char **azModuleArg;
  azModuleArg = sqlite3DbRealloc(db, pTable->azModuleArg, nBytes);
  if( azModuleArg==0 ){
    int j;
    for(j=0; j<i; j++){
      sqlite3DbFree(db, pTable->azModuleArg[j]);
    }
    sqlite3DbFree(db, zArg);
    sqlite3DbFree(db, pTable->azModuleArg);
    pTable->nModuleArg = 0;
  }else{
    azModuleArg[i] = zArg;
    azModuleArg[i+1] = 0;
  }
  pTable->azModuleArg = azModuleArg;
}






static void sqlite3VtabBeginParse(
  Parse *pParse,
  Token *pName1,
  Token *pName2,
  Token *pModuleName
){
  int iDb;
  Table *pTable;
  sqlite3 *db;

  sqlite3StartTable(pParse, pName1, pName2, 0, 0, 1, 0);
  pTable = pParse->pNewTable;
  if( pTable==0 ) return;
  ((void) (0));

  db = pParse->db;
  iDb = sqlite3SchemaToIndex(db, pTable->pSchema);
  ((void) (0));

  pTable->tabFlags |= 0x10;
  pTable->nModuleArg = 0;
  addModuleArgument(db, pTable, sqlite3NameFromToken(db, pModuleName));
  addModuleArgument(db, pTable, sqlite3DbStrDup(db, db->aDb[iDb].zName));
  addModuleArgument(db, pTable, sqlite3DbStrDup(db, pTable->zName));
  pParse->sNameToken.n = (int)(&pModuleName->z[pModuleName->n] - pName1->z);







  if( pTable->azModuleArg ){
    sqlite3AuthCheck(pParse, 29, pTable->zName,
            pTable->azModuleArg[0], pParse->db->aDb[iDb].zName);
  }

}






static void addArgumentToVtab(Parse *pParse){
  if( pParse->sArg.z && (pParse->pNewTable) ){
    const char *z = (const char*)pParse->sArg.z;
    int n = pParse->sArg.n;
    sqlite3 *db = pParse->db;
    addModuleArgument(db, pParse->pNewTable, sqlite3DbStrNDup(db, z, n));
  }
}





static void sqlite3VtabFinishParse(Parse *pParse, Token *pEnd){
  Table *pTab = pParse->pNewTable;
  sqlite3 *db = pParse->db;

  if( pTab==0 ) return;
  addArgumentToVtab(pParse);
  pParse->sArg.z = 0;
  if( pTab->nModuleArg<1 ) return;







  if( !db->init.busy ){
    char *zStmt;
    char *zWhere;
    int iDb;
    Vdbe *v;


    if( pEnd ){
      pParse->sNameToken.n = (int)(pEnd->z - pParse->sNameToken.z) + pEnd->n;
    }
    zStmt = sqlite3MPrintf(db, "CREATE VIRTUAL TABLE %T", &pParse->sNameToken);
# 96948 "ext/sqlite3/libsqlite/sqlite3.c"
    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
    sqlite3NestedParse(pParse,
      "UPDATE %Q.%s "
         "SET type='table', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q "
       "WHERE rowid=#%d",
      db->aDb[iDb].zName, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"),
      pTab->zName,
      pTab->zName,
      zStmt,
      pParse->regRowid
    );
    sqlite3DbFree(db, zStmt);
    v = sqlite3GetVdbe(pParse);
    sqlite3ChangeCookie(pParse, iDb);

    sqlite3VdbeAddOp2(v, 122, 0, 0);
    zWhere = sqlite3MPrintf(db, "name='%q' AND type='table'", pTab->zName);
    sqlite3VdbeAddOp4(v, 99, iDb, 0, 0, zWhere, (-1));
    sqlite3VdbeAddOp4(v, 125, iDb, 0, 0,
                         pTab->zName, sqlite3Strlen30(pTab->zName) + 1);
  }






  else {
    Table *pOld;
    Schema *pSchema = pTab->pSchema;
    const char *zName = pTab->zName;
    int nName = sqlite3Strlen30(zName);
    ((void) (0));
    pOld = sqlite3HashInsert(&pSchema->tblHash, zName, nName, pTab);
    if( pOld ){
      db->mallocFailed = 1;
      ((void) (0));
      return;
    }
    pParse->pNewTable = 0;
  }
}





static void sqlite3VtabArgInit(Parse *pParse){
  addArgumentToVtab(pParse);
  pParse->sArg.z = 0;
  pParse->sArg.n = 0;
}





static void sqlite3VtabArgExtend(Parse *pParse, Token *p){
  Token *pArg = &pParse->sArg;
  if( pArg->z==0 ){
    pArg->z = p->z;
    pArg->n = p->n;
  }else{
    ((void) (0));
    pArg->n = (int)(&p->z[p->n] - pArg->z);
  }
}






static int vtabCallConstructor(
  sqlite3 *db,
  Table *pTab,
  Module *pMod,
  int (*xConstruct)(sqlite3*,void*,int,const char*const*,sqlite3_vtab**,char**),
  char **pzErr
){
  VTable *pVTable;
  int rc;
  const char *const*azArg = (const char *const*)pTab->azModuleArg;
  int nArg = pTab->nModuleArg;
  char *zErr = 0;
  char *zModuleName = sqlite3MPrintf(db, "%s", pTab->zName);

  if( !zModuleName ){
    return 7;
  }

  pVTable = sqlite3DbMallocZero(db, sizeof(VTable));
  if( !pVTable ){
    sqlite3DbFree(db, zModuleName);
    return 7;
  }
  pVTable->db = db;
  pVTable->pMod = pMod;

  ((void) (0));
  ((void) (0));
  db->pVTab = pTab;


  rc = xConstruct(db, pMod->pAux, nArg, azArg, &pVTable->pVtab, &zErr);
  if( rc==7 ) db->mallocFailed = 1;

  if( 0!=rc ){
    if( zErr==0 ){
      *pzErr = sqlite3MPrintf(db, "vtable constructor failed: %s", zModuleName);
    }else {
      *pzErr = sqlite3MPrintf(db, "%s", zErr);
      sqlite3_free(zErr);
    }
    sqlite3DbFree(db, pVTable);
  }else if( (pVTable->pVtab) ){


    pVTable->pVtab->pModule = pMod->pModule;
    pVTable->nRef = 1;
    if( db->pVTab ){
      const char *zFormat = "vtable constructor did not declare schema: %s";
      *pzErr = sqlite3MPrintf(db, zFormat, pTab->zName);
      sqlite3VtabUnlock(pVTable);
      rc = 1;
    }else{
      int iCol;





      pVTable->pNext = pTab->pVTable;
      pTab->pVTable = pVTable;

      for(iCol=0; iCol<pTab->nCol; iCol++){
        char *zType = pTab->aCol[iCol].zType;
        int nType;
        int i = 0;
        if( !zType ) continue;
        nType = sqlite3Strlen30(zType);
        if( sqlite3_strnicmp("hidden", zType, 6)||(zType[6] && zType[6]!=' ') ){
          for(i=0; i<nType; i++){
            if( (0==sqlite3_strnicmp(" hidden", &zType[i], 7))
             && (zType[i+7]=='\0' || zType[i+7]==' ')
            ){
              i++;
              break;
            }
          }
        }
        if( i<nType ){
          int j;
          int nDel = 6 + (zType[i+6] ? 1 : 0);
          for(j=i; (j+nDel)<=nType; j++){
            zType[j] = zType[j+nDel];
          }
          if( zType[i]=='\0' && i>0 ){
            ((void) (0));
            zType[i-1] = '\0';
          }
          pTab->aCol[iCol].isHidden = 1;
        }
      }
    }
  }

  sqlite3DbFree(db, zModuleName);
  db->pVTab = 0;
  return rc;
}
# 97127 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VtabCallConnect(Parse *pParse, Table *pTab){
  sqlite3 *db = pParse->db;
  const char *zMod;
  Module *pMod;
  int rc;

  ((void) (0));
  if( (pTab->tabFlags & 0x10)==0 || sqlite3GetVTable(db, pTab) ){
    return 0;
  }


  zMod = pTab->azModuleArg[0];
  pMod = (Module*)sqlite3HashFind(&db->aModule, zMod, sqlite3Strlen30(zMod));

  if( !pMod ){
    const char *zModule = pTab->azModuleArg[0];
    sqlite3ErrorMsg(pParse, "no such module: %s", zModule);
    rc = 1;
  }else{
    char *zErr = 0;
    rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xConnect, &zErr);
    if( rc!=0 ){
      sqlite3ErrorMsg(pParse, "%s", zErr);
    }
    sqlite3DbFree(db, zErr);
  }

  return rc;
}




static int addToVTrans(sqlite3 *db, VTable *pVTab){
  const int ARRAY_INCR = 5;


  if( (db->nVTrans%ARRAY_INCR)==0 ){
    VTable **aVTrans;
    int nBytes = sizeof(sqlite3_vtab *) * (db->nVTrans + ARRAY_INCR);
    aVTrans = sqlite3DbRealloc(db, (void *)db->aVTrans, nBytes);
    if( !aVTrans ){
      return 7;
    }
    memset(&aVTrans[db->nVTrans], 0, sizeof(sqlite3_vtab *)*ARRAY_INCR);
    db->aVTrans = aVTrans;
  }


  db->aVTrans[db->nVTrans++] = pVTab;
  sqlite3VtabLock(pVTab);
  return 0;
}
# 97190 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VtabCallCreate(sqlite3 *db, int iDb, const char *zTab, char **pzErr){
  int rc = 0;
  Table *pTab;
  Module *pMod;
  const char *zMod;

  pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zName);
  ((void) (0));


  zMod = pTab->azModuleArg[0];
  pMod = (Module*)sqlite3HashFind(&db->aModule, zMod, sqlite3Strlen30(zMod));





  if( !pMod ){
    *pzErr = sqlite3MPrintf(db, "no such module: %s", zMod);
    rc = 1;
  }else{
    rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xCreate, pzErr);
  }



  if( rc==0 && (sqlite3GetVTable(db, pTab)) ){
      rc = addToVTrans(db, sqlite3GetVTable(db, pTab));
  }

  return rc;
}






           int sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable){
  Parse *pParse;

  int rc = 0;
  Table *pTab;
  char *zErr = 0;

                                ;
  pTab = db->pVTab;
  if( !pTab ){
    sqlite3Error(db, 21, 0);
                                  ;
    return sqlite3MisuseError(97240);
  }
  ((void) (0));

  pParse = sqlite3DbMallocZero(db,sizeof(*pParse));
  if( pParse==0 ){
    rc = 7;
  }else{
    pParse->declareVtab = 1;
    pParse->db = db;
    pParse->nQueryLoop = 1;

    if( 0==sqlite3RunParser(pParse, zCreateTable, &zErr)
     && pParse->pNewTable
     && !db->mallocFailed
     && !pParse->pNewTable->pSelect
     && (pParse->pNewTable->tabFlags & 0x10)==0
    ){
      if( !pTab->aCol ){
        pTab->aCol = pParse->pNewTable->aCol;
        pTab->nCol = pParse->pNewTable->nCol;
        pParse->pNewTable->nCol = 0;
        pParse->pNewTable->aCol = 0;
      }
      db->pVTab = 0;
    }else{
      sqlite3Error(db, 1, (zErr ? "%s" : 0), zErr);
      sqlite3DbFree(db, zErr);
      rc = 1;
    }
    pParse->declareVtab = 0;

    if( pParse->pVdbe ){
      sqlite3VdbeFinalize(pParse->pVdbe);
    }
    sqlite3DeleteTable(db, pParse->pNewTable);
    sqlite3DbFree(db,pParse);
  }

  ((void) (0));
  rc = sqlite3ApiExit(db, rc);
                                ;
  return rc;
}
# 97292 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VtabCallDestroy(sqlite3 *db, int iDb, const char *zTab){
  int rc = 0;
  Table *pTab;

  pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zName);
  if( (pTab!=0 && pTab->pVTable!=0) ){
    VTable *p = vtabDisconnectAll(db, pTab);

    ((void) (0));
    rc = p->pMod->pModule->xDestroy(p->pVtab);


    if( rc==0 ){
      ((void) (0));
      p->pVtab = 0;
      pTab->pVTable = 0;
      sqlite3VtabUnlock(p);
    }
  }

  return rc;
}
# 97323 "ext/sqlite3/libsqlite/sqlite3.c"
static void callFinaliser(sqlite3 *db, int offset){
  int i;
  if( db->aVTrans ){
    for(i=0; i<db->nVTrans; i++){
      VTable *pVTab = db->aVTrans[i];
      sqlite3_vtab *p = pVTab->pVtab;
      if( p ){
        int (*x)(sqlite3_vtab *);
        x = *(int (**)(sqlite3_vtab *))((char *)p->pModule + offset);
        if( x ) x(p);
      }
      sqlite3VtabUnlock(pVTab);
    }
    sqlite3DbFree(db, db->aVTrans);
    db->nVTrans = 0;
    db->aVTrans = 0;
  }
}
# 97350 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VtabSync(sqlite3 *db, char **pzErrmsg){
  int i;
  int rc = 0;
  VTable **aVTrans = db->aVTrans;

  db->aVTrans = 0;
  for(i=0; rc==0 && i<db->nVTrans; i++){
    int (*x)(sqlite3_vtab *);
    sqlite3_vtab *pVtab = aVTrans[i]->pVtab;
    if( pVtab && (x = pVtab->pModule->xSync)!=0 ){
      rc = x(pVtab);
      sqlite3DbFree(db, *pzErrmsg);
      *pzErrmsg = sqlite3DbStrDup(db, pVtab->zErrMsg);
      sqlite3_free(pVtab->zErrMsg);
    }
  }
  db->aVTrans = aVTrans;
  return rc;
}





static int sqlite3VtabRollback(sqlite3 *db){
  callFinaliser(db, __builtin_offsetof(sqlite3_module, xRollback));
  return 0;
}





static int sqlite3VtabCommit(sqlite3 *db){
  callFinaliser(db, __builtin_offsetof(sqlite3_module, xCommit));
  return 0;
}
# 97396 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3VtabBegin(sqlite3 *db, VTable *pVTab){
  int rc = 0;
  const sqlite3_module *pModule;






  if( ((db)->nVTrans>0 && (db)->aVTrans==0) ){
    return 6;
  }
  if( !pVTab ){
    return 0;
  }
  pModule = pVTab->pVtab->pModule;

  if( pModule->xBegin ){
    int i;



    for(i=0; i<db->nVTrans; i++){
      if( db->aVTrans[i]==pVTab ){
        return 0;
      }
    }


    rc = pModule->xBegin(pVTab->pVtab);
    if( rc==0 ){
      rc = addToVTrans(db, pVTab);
    }
  }
  return rc;
}
# 97446 "ext/sqlite3/libsqlite/sqlite3.c"
static FuncDef *sqlite3VtabOverloadFunction(
  sqlite3 *db,
  FuncDef *pDef,
  int nArg,
  Expr *pExpr
){
  Table *pTab;
  sqlite3_vtab *pVtab;
  sqlite3_module *pMod;
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**) = 0;
  void *pArg = 0;
  FuncDef *pNew;
  int rc = 0;
  char *zLowerName;
  unsigned char *z;



  if( (pExpr==0) ) return pDef;
  if( pExpr->op!=152 ) return pDef;
  pTab = pExpr->pTab;
  if( (pTab==0) ) return pDef;
  if( (pTab->tabFlags & 0x10)==0 ) return pDef;
  pVtab = sqlite3GetVTable(db, pTab)->pVtab;
  ((void) (0));
  ((void) (0));
  pMod = (sqlite3_module *)pVtab->pModule;
  if( pMod->xFindFunction==0 ) return pDef;




  zLowerName = sqlite3DbStrDup(db, pDef->zName);
  if( zLowerName ){
    for(z=(unsigned char*)zLowerName; *z; z++){
      *z = sqlite3UpperToLower[*z];
    }
    rc = pMod->xFindFunction(pVtab, nArg, zLowerName, &xFunc, &pArg);
    sqlite3DbFree(db, zLowerName);
  }
  if( rc==0 ){
    return pDef;
  }



  pNew = sqlite3DbMallocZero(db, sizeof(*pNew)
                             + sqlite3Strlen30(pDef->zName) + 1);
  if( pNew==0 ){
    return pDef;
  }
  *pNew = *pDef;
  pNew->zName = (char *)&pNew[1];
  memcpy(pNew->zName, pDef->zName, sqlite3Strlen30(pDef->zName)+1);
  pNew->xFunc = xFunc;
  pNew->pUserData = pArg;
  pNew->flags |= 0x04;
  return pNew;
}







static void sqlite3VtabMakeWritable(Parse *pParse, Table *pTab){
  Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  int i, n;
  Table **apVtabLock;

  ((void) (0));
  for(i=0; i<pToplevel->nVtabLock; i++){
    if( pTab==pToplevel->apVtabLock[i] ) return;
  }
  n = (pToplevel->nVtabLock+1)*sizeof(pToplevel->apVtabLock[0]);
  apVtabLock = sqlite3_realloc(pToplevel->apVtabLock, n);
  if( apVtabLock ){
    pToplevel->apVtabLock = apVtabLock;
    pToplevel->apVtabLock[pToplevel->nVtabLock++] = pTab;
  }else{
    pToplevel->db->mallocFailed = 1;
  }
}
# 97569 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct WhereClause WhereClause;
typedef struct WhereMaskSet WhereMaskSet;
typedef struct WhereOrInfo WhereOrInfo;
typedef struct WhereAndInfo WhereAndInfo;
typedef struct WhereCost WhereCost;
# 97626 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct WhereTerm WhereTerm;
struct WhereTerm {
  Expr *pExpr;
  int iParent;
  int leftCursor;
  union {
    int leftColumn;
    WhereOrInfo *pOrInfo;
    WhereAndInfo *pAndInfo;
  } u;
  u16 eOperator;
  u8 wtFlags;
  u8 nChild;
  WhereClause *pWC;
  Bitmask prereqRight;
  Bitmask prereqAll;
};
# 97664 "ext/sqlite3/libsqlite/sqlite3.c"
struct WhereClause {
  Parse *pParse;
  WhereMaskSet *pMaskSet;
  Bitmask vmask;
  u8 op;
  int nTerm;
  int nSlot;
  WhereTerm *a;



  WhereTerm aStatic[8];

};





struct WhereOrInfo {
  WhereClause wc;
  Bitmask indexable;
};





struct WhereAndInfo {
  WhereClause wc;
};
# 97722 "ext/sqlite3/libsqlite/sqlite3.c"
struct WhereMaskSet {
  int n;
  int ix[((int)(sizeof(Bitmask)*8))];
};





struct WhereCost {
  WherePlan plan;
  double rCost;
  Bitmask used;
};
# 97793 "ext/sqlite3/libsqlite/sqlite3.c"
static void whereClauseInit(
  WhereClause *pWC,
  Parse *pParse,
  WhereMaskSet *pMaskSet
){
  pWC->pParse = pParse;
  pWC->pMaskSet = pMaskSet;
  pWC->nTerm = 0;
  pWC->nSlot = ((int)(sizeof(pWC->aStatic)/sizeof(pWC->aStatic[0])));
  pWC->a = pWC->aStatic;
  pWC->vmask = 0;
}


static void whereClauseClear(WhereClause*);




static void whereOrInfoDelete(sqlite3 *db, WhereOrInfo *p){
  whereClauseClear(&p->wc);
  sqlite3DbFree(db, p);
}




static void whereAndInfoDelete(sqlite3 *db, WhereAndInfo *p){
  whereClauseClear(&p->wc);
  sqlite3DbFree(db, p);
}





static void whereClauseClear(WhereClause *pWC){
  int i;
  WhereTerm *a;
  sqlite3 *db = pWC->pParse->db;
  for(i=pWC->nTerm-1, a=pWC->a; i>=0; i--, a++){
    if( a->wtFlags & 0x01 ){
      sqlite3ExprDelete(db, a->pExpr);
    }
    if( a->wtFlags & 0x10 ){
      whereOrInfoDelete(db, a->u.pOrInfo);
    }else if( a->wtFlags & 0x20 ){
      whereAndInfoDelete(db, a->u.pAndInfo);
    }
  }
  if( pWC->a!=pWC->aStatic ){
    sqlite3DbFree(db, pWC->a);
  }
}
# 97867 "ext/sqlite3/libsqlite/sqlite3.c"
static int whereClauseInsert(WhereClause *pWC, Expr *p, u8 wtFlags){
  WhereTerm *pTerm;
  int idx;
                                    ;
  if( pWC->nTerm>=pWC->nSlot ){
    WhereTerm *pOld = pWC->a;
    sqlite3 *db = pWC->pParse->db;
    pWC->a = sqlite3DbMallocRaw(db, sizeof(pWC->a[0])*pWC->nSlot*2 );
    if( pWC->a==0 ){
      if( wtFlags & 0x01 ){
        sqlite3ExprDelete(db, p);
      }
      pWC->a = pOld;
      return 0;
    }
    memcpy(pWC->a, pOld, sizeof(pWC->a[0])*pWC->nTerm);
    if( pOld!=pWC->aStatic ){
      sqlite3DbFree(db, pOld);
    }
    pWC->nSlot = sqlite3DbMallocSize(db, pWC->a)/sizeof(pWC->a[0]);
  }
  pTerm = &pWC->a[idx = pWC->nTerm++];
  pTerm->pExpr = p;
  pTerm->wtFlags = wtFlags;
  pTerm->pWC = pWC;
  pTerm->iParent = -1;
  return idx;
}
# 97913 "ext/sqlite3/libsqlite/sqlite3.c"
static void whereSplit(WhereClause *pWC, Expr *pExpr, int op){
  pWC->op = (u8)op;
  if( pExpr==0 ) return;
  if( pExpr->op!=op ){
    whereClauseInsert(pWC, pExpr, 0);
  }else{
    whereSplit(pWC, pExpr->pLeft, op);
    whereSplit(pWC, pExpr->pRight, op);
  }
}
# 97933 "ext/sqlite3/libsqlite/sqlite3.c"
static Bitmask getMask(WhereMaskSet *pMaskSet, int iCursor){
  int i;
  ((void) (0));
  for(i=0; i<pMaskSet->n; i++){
    if( pMaskSet->ix[i]==iCursor ){
      return ((Bitmask)1)<<i;
    }
  }
  return 0;
}
# 97952 "ext/sqlite3/libsqlite/sqlite3.c"
static void createMask(WhereMaskSet *pMaskSet, int iCursor){
  ((void) (0));
  pMaskSet->ix[pMaskSet->n++] = iCursor;
}
# 97971 "ext/sqlite3/libsqlite/sqlite3.c"
static Bitmask exprListTableUsage(WhereMaskSet*, ExprList*);
static Bitmask exprSelectTableUsage(WhereMaskSet*, Select*);
static Bitmask exprTableUsage(WhereMaskSet *pMaskSet, Expr *p){
  Bitmask mask = 0;
  if( p==0 ) return 0;
  if( p->op==152 ){
    mask = getMask(pMaskSet, p->iTable);
    return mask;
  }
  mask = exprTableUsage(pMaskSet, p->pRight);
  mask |= exprTableUsage(pMaskSet, p->pLeft);
  if( (((p)->flags&(0x0800))==(0x0800)) ){
    mask |= exprSelectTableUsage(pMaskSet, p->x.pSelect);
  }else{
    mask |= exprListTableUsage(pMaskSet, p->x.pList);
  }
  return mask;
}
static Bitmask exprListTableUsage(WhereMaskSet *pMaskSet, ExprList *pList){
  int i;
  Bitmask mask = 0;
  if( pList ){
    for(i=0; i<pList->nExpr; i++){
      mask |= exprTableUsage(pMaskSet, pList->a[i].pExpr);
    }
  }
  return mask;
}
static Bitmask exprSelectTableUsage(WhereMaskSet *pMaskSet, Select *pS){
  Bitmask mask = 0;
  while( pS ){
    mask |= exprListTableUsage(pMaskSet, pS->pEList);
    mask |= exprListTableUsage(pMaskSet, pS->pGroupBy);
    mask |= exprListTableUsage(pMaskSet, pS->pOrderBy);
    mask |= exprTableUsage(pMaskSet, pS->pWhere);
    mask |= exprTableUsage(pMaskSet, pS->pHaving);
    pS = pS->pPrior;
  }
  return mask;
}
# 98024 "ext/sqlite3/libsqlite/sqlite3.c"
static int allowedOp(int op){
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  return op==72 || (op>=76 && op<=80) || op==73;
}
# 98049 "ext/sqlite3/libsqlite/sqlite3.c"
static void exprCommute(Parse *pParse, Expr *pExpr){
  u16 expRight = (pExpr->pRight->flags & 0x0100);
  u16 expLeft = (pExpr->pLeft->flags & 0x0100);
  ((void) (0));
  pExpr->pRight->pColl = sqlite3ExprCollSeq(pParse, pExpr->pRight);
  pExpr->pLeft->pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft);
  {CollSeq* t=pExpr->pRight->pColl; pExpr->pRight->pColl=pExpr->pLeft->pColl; pExpr->pLeft->pColl=t;};
  pExpr->pRight->flags = (pExpr->pRight->flags & ~0x0100) | expLeft;
  pExpr->pLeft->flags = (pExpr->pLeft->flags & ~0x0100) | expRight;
  {Expr* t=pExpr->pRight; pExpr->pRight=pExpr->pLeft; pExpr->pLeft=t;};
  if( pExpr->op>=77 ){
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    pExpr->op = ((pExpr->op-77)^2)+77;
  }
}




static u16 operatorMask(int op){
  u16 c;
  ((void) (0));
  if( op==72 ){
    c = 0x001;
  }else if( op==73 ){
    c = 0x080;
  }else{
    ((void) (0));
    c = (u16)(0x002<<(op-76));
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  return c;
}







static WhereTerm *findTerm(
  WhereClause *pWC,
  int iCur,
  int iColumn,
  Bitmask notReady,
  u32 op,
  Index *pIdx
){
  WhereTerm *pTerm;
  int k;
  ((void) (0));
  op &= 0xfff;
  for(pTerm=pWC->a, k=pWC->nTerm; k; k--, pTerm++){
    if( pTerm->leftCursor==iCur
       && (pTerm->prereqRight & notReady)==0
       && pTerm->u.leftColumn==iColumn
       && (pTerm->eOperator & op)!=0
    ){
      if( pIdx && pTerm->eOperator!=0x080 ){
        Expr *pX = pTerm->pExpr;
        CollSeq *pColl;
        char idxaff;
        int j;
        Parse *pParse = pWC->pParse;

        idxaff = pIdx->pTable->aCol[iColumn].affinity;
        if( !sqlite3IndexAffinityOk(pX, idxaff) ) continue;





        ((void) (0));
        pColl = sqlite3BinaryCompareCollSeq(pParse, pX->pLeft, pX->pRight);
        ((void) (0));

        for(j=0; pIdx->aiColumn[j]!=iColumn; j++){
          if( (j>=pIdx->nColumn) ) return 0;
        }
        if( pColl && sqlite3StrICmp(pColl->zName, pIdx->azColl[j]) ) continue;
      }
      return pTerm;
    }
  }
  return 0;
}


static void exprAnalyze(SrcList*, WhereClause*, int);






static void exprAnalyzeAll(
  SrcList *pTabList,
  WhereClause *pWC
){
  int i;
  for(i=pWC->nTerm-1; i>=0; i--){
    exprAnalyze(pTabList, pWC, i);
  }
}
# 98173 "ext/sqlite3/libsqlite/sqlite3.c"
static int isLikeOrGlob(
  Parse *pParse,
  Expr *pExpr,
  Expr **ppPrefix,
  int *pisComplete,
  int *pnoCase
){
  const char *z = 0;
  Expr *pRight, *pLeft;
  ExprList *pList;
  int c;
  int cnt;
  char wc[3];
  sqlite3 *db = pParse->db;
  sqlite3_value *pVal = 0;
  int op;

  if( !sqlite3IsLikeFunction(db, pExpr, pnoCase, wc) ){
    return 0;
  }



  pList = pExpr->x.pList;
  pLeft = pList->a[1].pExpr;
  if( pLeft->op!=152 || sqlite3ExprAffinity(pLeft)!='a' ){


    return 0;
  }
  ((void) (0));

  pRight = pList->a[0].pExpr;
  op = pRight->op;
  if( op==132 ){
    op = pRight->op2;
  }
  if( op==133 ){
    Vdbe *pReprepare = pParse->pReprepare;
    int iCol = pRight->iColumn;
    pVal = sqlite3VdbeGetValue(pReprepare, iCol, 'b');
    if( pVal && sqlite3_value_type(pVal)==3 ){
      z = (char *)sqlite3_value_text(pVal);
    }
    sqlite3VdbeSetVarmask(pParse->pVdbe, iCol);
    ((void) (0));
  }else if( op==94 ){
    z = pRight->u.zToken;
  }
  if( z ){
    cnt = 0;
    while( (c=z[cnt])!=0 && c!=wc[0] && c!=wc[1] && c!=wc[2] ){
      cnt++;
    }
    if( cnt!=0 && 255!=(u8)z[cnt-1] ){
      Expr *pPrefix;
      *pisComplete = c==wc[0] && z[cnt+1]==0;
      pPrefix = sqlite3Expr(db, 94, z);
      if( pPrefix ) pPrefix->u.zToken[cnt] = 0;
      *ppPrefix = pPrefix;
      if( op==133 ){
        Vdbe *v = pParse->pVdbe;
        sqlite3VdbeSetVarmask(v, pRight->iColumn);
        if( *pisComplete && pRight->u.zToken[1] ){






          int r1 = sqlite3GetTempReg(pParse);
          sqlite3ExprCodeTarget(pParse, pRight, r1);
          sqlite3VdbeChangeP3(v, sqlite3VdbeCurrentAddr(v)-1, 0);
          sqlite3ReleaseTempReg(pParse, r1);
        }
      }
    }else{
      z = 0;
    }
  }

  sqlite3ValueFree(pVal);
  return (z!=0);
}
# 98268 "ext/sqlite3/libsqlite/sqlite3.c"
static int isMatchOfColumn(
  Expr *pExpr
){
  ExprList *pList;

  if( pExpr->op!=151 ){
    return 0;
  }
  if( sqlite3StrICmp(pExpr->u.zToken,"match")!=0 ){
    return 0;
  }
  pList = pExpr->x.pList;
  if( pList->nExpr!=2 ){
    return 0;
  }
  if( pList->a[1].pExpr->op != 152 ){
    return 0;
  }
  return 1;
}






static void transferJoinMarkings(Expr *pDerived, Expr *pBase){
  pDerived->flags |= pBase->flags & 0x0001;
  pDerived->iRightJoinTable = pBase->iRightJoinTable;
}
# 98376 "ext/sqlite3/libsqlite/sqlite3.c"
static void exprAnalyzeOrTerm(
  SrcList *pSrc,
  WhereClause *pWC,
  int idxTerm
){
  Parse *pParse = pWC->pParse;
  sqlite3 *db = pParse->db;
  WhereTerm *pTerm = &pWC->a[idxTerm];
  Expr *pExpr = pTerm->pExpr;
  WhereMaskSet *pMaskSet = pWC->pMaskSet;
  int i;
  WhereClause *pOrWc;
  WhereTerm *pOrTerm;
  WhereOrInfo *pOrInfo;
  Bitmask chngToIN;
  Bitmask indexable;






  ((void) (0));
  ((void) (0));
  pTerm->u.pOrInfo = pOrInfo = sqlite3DbMallocZero(db, sizeof(*pOrInfo));
  if( pOrInfo==0 ) return;
  pTerm->wtFlags |= 0x10;
  pOrWc = &pOrInfo->wc;
  whereClauseInit(pOrWc, pWC->pParse, pMaskSet);
  whereSplit(pOrWc, pExpr, 68);
  exprAnalyzeAll(pSrc, pOrWc);
  if( db->mallocFailed ) return;
  ((void) (0));




  indexable = ~(Bitmask)0;
  chngToIN = ~(pWC->vmask);
  for(i=pOrWc->nTerm-1, pOrTerm=pOrWc->a; i>=0 && indexable; i--, pOrTerm++){
    if( (pOrTerm->eOperator & 0x0ff)==0 ){
      WhereAndInfo *pAndInfo;
      ((void) (0));
      ((void) (0));
      chngToIN = 0;
      pAndInfo = sqlite3DbMallocRaw(db, sizeof(*pAndInfo));
      if( pAndInfo ){
        WhereClause *pAndWC;
        WhereTerm *pAndTerm;
        int j;
        Bitmask b = 0;
        pOrTerm->u.pAndInfo = pAndInfo;
        pOrTerm->wtFlags |= 0x20;
        pOrTerm->eOperator = 0x200;
        pAndWC = &pAndInfo->wc;
        whereClauseInit(pAndWC, pWC->pParse, pMaskSet);
        whereSplit(pAndWC, pOrTerm->pExpr, 69);
        exprAnalyzeAll(pSrc, pAndWC);
                                    ;
        if( !db->mallocFailed ){
          for(j=0, pAndTerm=pAndWC->a; j<pAndWC->nTerm; j++, pAndTerm++){
            ((void) (0));
            if( allowedOp(pAndTerm->pExpr->op) ){
              b |= getMask(pMaskSet, pAndTerm->leftCursor);
            }
          }
        }
        indexable &= b;
      }
    }else if( pOrTerm->wtFlags & 0x08 ){


    }else{
      Bitmask b;
      b = getMask(pMaskSet, pOrTerm->leftCursor);
      if( pOrTerm->wtFlags & 0x02 ){
        WhereTerm *pOther = &pOrWc->a[pOrTerm->iParent];
        b |= getMask(pMaskSet, pOther->leftCursor);
      }
      indexable &= b;
      if( pOrTerm->eOperator!=0x002 ){
        chngToIN = 0;
      }else{
        chngToIN &= b;
      }
    }
  }





  pOrInfo->indexable = indexable;
  pTerm->eOperator = indexable==0 ? 0 : 0x100;
# 98492 "ext/sqlite3/libsqlite/sqlite3.c"
  if( chngToIN ){
    int okToChngToIN = 0;
    int iColumn = -1;
    int iCursor = -1;
    int j = 0;







    for(j=0; j<2 && !okToChngToIN; j++){
      pOrTerm = pOrWc->a;
      for(i=pOrWc->nTerm-1; i>=0; i--, pOrTerm++){
        ((void) (0));
        pOrTerm->wtFlags &= ~0x40;
        if( pOrTerm->leftCursor==iCursor ){


          ((void) (0));
          continue;
        }
        if( (chngToIN & getMask(pMaskSet, pOrTerm->leftCursor))==0 ){




                                                    ;
                                                     ;
          ((void) (0));
          continue;
        }
        iColumn = pOrTerm->u.leftColumn;
        iCursor = pOrTerm->leftCursor;
        break;
      }
      if( i<0 ){


        ((void) (0));
        ((void) (0));
        ((void) (0));
        break;
      }
                      ;



      okToChngToIN = 1;
      for(; i>=0 && okToChngToIN; i--, pOrTerm++){
        ((void) (0));
        if( pOrTerm->leftCursor!=iCursor ){
          pOrTerm->wtFlags &= ~0x40;
        }else if( pOrTerm->u.leftColumn!=iColumn ){
          okToChngToIN = 0;
        }else{
          int affLeft, affRight;




          affRight = sqlite3ExprAffinity(pOrTerm->pExpr->pRight);
          affLeft = sqlite3ExprAffinity(pOrTerm->pExpr->pLeft);
          if( affRight!=0 && affRight!=affLeft ){
            okToChngToIN = 0;
          }else{
            pOrTerm->wtFlags |= 0x40;
          }
        }
      }
    }







    if( okToChngToIN ){
      Expr *pDup;
      ExprList *pList = 0;
      Expr *pLeft = 0;
      Expr *pNew;

      for(i=pOrWc->nTerm-1, pOrTerm=pOrWc->a; i>=0; i--, pOrTerm++){
        if( (pOrTerm->wtFlags & 0x40)==0 ) continue;
        ((void) (0));
        ((void) (0));
        ((void) (0));
        pDup = sqlite3ExprDup(db, pOrTerm->pExpr->pRight, 0);
        pList = sqlite3ExprListAppend(pWC->pParse, pList, pDup);
        pLeft = pOrTerm->pExpr->pLeft;
      }
      ((void) (0));
      pDup = sqlite3ExprDup(db, pLeft, 0);
      pNew = sqlite3PExpr(pParse, 72, pDup, 0, 0);
      if( pNew ){
        int idxNew;
        transferJoinMarkings(pNew, pExpr);
        ((void) (0));
        pNew->x.pList = pList;
        idxNew = whereClauseInsert(pWC, pNew, 0x02|0x01);
                             ;
        exprAnalyze(pSrc, pWC, idxNew);
        pTerm = &pWC->a[idxTerm];
        pWC->a[idxNew].iParent = idxTerm;
        pTerm->nChild = 1;
      }else{
        sqlite3ExprListDelete(db, pList);
      }
      pTerm->eOperator = 0x800;
    }
  }
}
# 98628 "ext/sqlite3/libsqlite/sqlite3.c"
static void exprAnalyze(
  SrcList *pSrc,
  WhereClause *pWC,
  int idxTerm
){
  WhereTerm *pTerm;
  WhereMaskSet *pMaskSet;
  Expr *pExpr;
  Bitmask prereqLeft;
  Bitmask prereqAll;
  Bitmask extraRight = 0;
  Expr *pStr1 = 0;
  int isComplete = 0;
  int noCase = 0;
  int op;
  Parse *pParse = pWC->pParse;
  sqlite3 *db = pParse->db;

  if( db->mallocFailed ){
    return;
  }
  pTerm = &pWC->a[idxTerm];
  pMaskSet = pWC->pMaskSet;
  pExpr = pTerm->pExpr;
  prereqLeft = exprTableUsage(pMaskSet, pExpr->pLeft);
  op = pExpr->op;
  if( op==72 ){
    ((void) (0));
    if( (((pExpr)->flags&(0x0800))==(0x0800)) ){
      pTerm->prereqRight = exprSelectTableUsage(pMaskSet, pExpr->x.pSelect);
    }else{
      pTerm->prereqRight = exprListTableUsage(pMaskSet, pExpr->x.pList);
    }
  }else if( op==73 ){
    pTerm->prereqRight = 0;
  }else{
    pTerm->prereqRight = exprTableUsage(pMaskSet, pExpr->pRight);
  }
  prereqAll = exprTableUsage(pMaskSet, pExpr);
  if( (((pExpr)->flags&(0x0001))==(0x0001)) ){
    Bitmask x = getMask(pMaskSet, pExpr->iRightJoinTable);
    prereqAll |= x;
    extraRight = x-1;

  }
  pTerm->prereqAll = prereqAll;
  pTerm->leftCursor = -1;
  pTerm->iParent = -1;
  pTerm->eOperator = 0;
  if( allowedOp(op) && (pTerm->prereqRight & prereqLeft)==0 ){
    Expr *pLeft = pExpr->pLeft;
    Expr *pRight = pExpr->pRight;
    if( pLeft->op==152 ){
      pTerm->leftCursor = pLeft->iTable;
      pTerm->u.leftColumn = pLeft->iColumn;
      pTerm->eOperator = operatorMask(op);
    }
    if( pRight && pRight->op==152 ){
      WhereTerm *pNew;
      Expr *pDup;
      if( pTerm->leftCursor>=0 ){
        int idxNew;
        pDup = sqlite3ExprDup(db, pExpr, 0);
        if( db->mallocFailed ){
          sqlite3ExprDelete(db, pDup);
          return;
        }
        idxNew = whereClauseInsert(pWC, pDup, 0x02|0x01);
        if( idxNew==0 ) return;
        pNew = &pWC->a[idxNew];
        pNew->iParent = idxTerm;
        pTerm = &pWC->a[idxTerm];
        pTerm->nChild = 1;
        pTerm->wtFlags |= 0x08;
      }else{
        pDup = pExpr;
        pNew = pTerm;
      }
      exprCommute(pParse, pDup);
      pLeft = pDup->pLeft;
      pNew->leftCursor = pLeft->iTable;
      pNew->u.leftColumn = pLeft->iColumn;
                                                         ;
      pNew->prereqRight = prereqLeft | extraRight;
      pNew->prereqAll = prereqAll;
      pNew->eOperator = operatorMask(pDup->op);
    }
  }
# 98733 "ext/sqlite3/libsqlite/sqlite3.c"
  else if( pExpr->op==71 && pWC->op==69 ){
    ExprList *pList = pExpr->x.pList;
    int i;
    static const u8 ops[] = {80, 78};
    ((void) (0));
    ((void) (0));
    for(i=0; i<2; i++){
      Expr *pNewExpr;
      int idxNew;
      pNewExpr = sqlite3PExpr(pParse, ops[i],
                             sqlite3ExprDup(db, pExpr->pLeft, 0),
                             sqlite3ExprDup(db, pList->a[i].pExpr, 0), 0);
      idxNew = whereClauseInsert(pWC, pNewExpr, 0x02|0x01);
                           ;
      exprAnalyze(pSrc, pWC, idxNew);
      pTerm = &pWC->a[idxTerm];
      pWC->a[idxNew].iParent = idxTerm;
    }
    pTerm->nChild = 2;
  }






  else if( pExpr->op==68 ){
    ((void) (0));
    exprAnalyzeOrTerm(pSrc, pWC, idxTerm);
    pTerm = &pWC->a[idxTerm];
  }
# 98777 "ext/sqlite3/libsqlite/sqlite3.c"
  if( pWC->op==69
   && isLikeOrGlob(pParse, pExpr, &pStr1, &isComplete, &noCase)
  ){
    Expr *pLeft;
    Expr *pStr2;
    Expr *pNewExpr1;
    Expr *pNewExpr2;
    int idxNew1;
    int idxNew2;
    CollSeq *pColl;

    pLeft = pExpr->x.pList->a[1].pExpr;
    pStr2 = sqlite3ExprDup(db, pStr1, 0);
    if( !db->mallocFailed ){
      u8 c, *pC;
      pC = (u8*)&pStr2->u.zToken[sqlite3Strlen30(pStr2->u.zToken)-1];
      c = *pC;
      if( noCase ){






        if( c=='A'-1 ) isComplete = 0;


        c = sqlite3UpperToLower[c];
      }
      *pC = c + 1;
    }
    pColl = sqlite3FindCollSeq(db, 1, noCase ? "NOCASE" : "BINARY",0);
    pNewExpr1 = sqlite3PExpr(pParse, 80,
                     sqlite3ExprSetColl(sqlite3ExprDup(db,pLeft,0), pColl),
                     pStr1, 0);
    idxNew1 = whereClauseInsert(pWC, pNewExpr1, 0x02|0x01);
                          ;
    exprAnalyze(pSrc, pWC, idxNew1);
    pNewExpr2 = sqlite3PExpr(pParse, 79,
                     sqlite3ExprSetColl(sqlite3ExprDup(db,pLeft,0), pColl),
                     pStr2, 0);
    idxNew2 = whereClauseInsert(pWC, pNewExpr2, 0x02|0x01);
                          ;
    exprAnalyze(pSrc, pWC, idxNew2);
    pTerm = &pWC->a[idxTerm];
    if( isComplete ){
      pWC->a[idxNew1].iParent = idxTerm;
      pWC->a[idxNew2].iParent = idxTerm;
      pTerm->nChild = 2;
    }
  }
# 98837 "ext/sqlite3/libsqlite/sqlite3.c"
  if( isMatchOfColumn(pExpr) ){
    int idxNew;
    Expr *pRight, *pLeft;
    WhereTerm *pNewTerm;
    Bitmask prereqColumn, prereqExpr;

    pRight = pExpr->x.pList->a[0].pExpr;
    pLeft = pExpr->x.pList->a[1].pExpr;
    prereqExpr = exprTableUsage(pMaskSet, pRight);
    prereqColumn = exprTableUsage(pMaskSet, pLeft);
    if( (prereqExpr & prereqColumn)==0 ){
      Expr *pNewExpr;
      pNewExpr = sqlite3PExpr(pParse, 50,
                              0, sqlite3ExprDup(db, pRight, 0), 0);
      idxNew = whereClauseInsert(pWC, pNewExpr, 0x02|0x01);
                           ;
      pNewTerm = &pWC->a[idxNew];
      pNewTerm->prereqRight = prereqExpr;
      pNewTerm->leftCursor = pLeft->iTable;
      pNewTerm->u.leftColumn = pLeft->iColumn;
      pNewTerm->eOperator = 0x040;
      pNewTerm->iParent = idxTerm;
      pTerm = &pWC->a[idxTerm];
      pTerm->nChild = 1;
      pTerm->wtFlags |= 0x08;
      pNewTerm->prereqAll = pTerm->prereqAll;
    }
  }
# 98911 "ext/sqlite3/libsqlite/sqlite3.c"
  pTerm->prereqRight |= extraRight;
}





static int referencesOtherTables(
  ExprList *pList,
  WhereMaskSet *pMaskSet,
  int iFirst,
  int iBase
){
  Bitmask allowed = ~getMask(pMaskSet, iBase);
  while( iFirst<pList->nExpr ){
    if( (exprTableUsage(pMaskSet, pList->a[iFirst++].pExpr)&allowed)!=0 ){
      return 1;
    }
  }
  return 0;
}
# 98953 "ext/sqlite3/libsqlite/sqlite3.c"
static int isSortingIndex(
  Parse *pParse,
  WhereMaskSet *pMaskSet,
  Index *pIdx,
  int base,
  ExprList *pOrderBy,
  int nEqCol,
  int wsFlags,
  int *pbRev
){
  int i, j;
  int sortOrder = 0;
  int nTerm;
  struct ExprList_item *pTerm;
  sqlite3 *db = pParse->db;

  ((void) (0));
  nTerm = pOrderBy->nExpr;
  ((void) (0));




  ((void) (0));
# 98986 "ext/sqlite3/libsqlite/sqlite3.c"
  for(i=j=0, pTerm=pOrderBy->a; j<nTerm && i<=pIdx->nColumn; i++){
    Expr *pExpr;
    CollSeq *pColl;
    int termSortOrder;
    int iColumn;
    int iSortOrder;
    const char *zColl;

    pExpr = pTerm->pExpr;
    if( pExpr->op!=152 || pExpr->iTable!=base ){


      break;
    }
    pColl = sqlite3ExprCollSeq(pParse, pExpr);
    if( !pColl ){
      pColl = db->pDfltColl;
    }
    if( pIdx->zName && i<pIdx->nColumn ){
      iColumn = pIdx->aiColumn[i];
      if( iColumn==pIdx->pTable->iPKey ){
        iColumn = -1;
      }
      iSortOrder = pIdx->aSortOrder[i];
      zColl = pIdx->azColl[i];
    }else{
      iColumn = -1;
      iSortOrder = 0;
      zColl = pColl->zName;
    }
    if( pExpr->iColumn!=iColumn || sqlite3StrICmp(pColl->zName, zColl) ){

      if( i<nEqCol ){



        continue;
      }else if( i==pIdx->nColumn ){

        break;
      }else{



        return 0;
      }
    }
    ((void) (0));
    ((void) (0));
    ((void) (0));
    termSortOrder = iSortOrder ^ pTerm->sortOrder;
    if( i>nEqCol ){
      if( termSortOrder!=sortOrder ){


        return 0;
      }
    }else{
      sortOrder = termSortOrder;
    }
    j++;
    pTerm++;
    if( iColumn<0 && !referencesOtherTables(pOrderBy, pMaskSet, j, base) ){






      j = nTerm;
    }
  }

  *pbRev = sortOrder!=0;
  if( j>=nTerm ){


    return 1;
  }
  if( pIdx->onError!=0 && i==pIdx->nColumn
      && (wsFlags & 0x00080000)==0
      && !referencesOtherTables(pOrderBy, pMaskSet, j, base) ){






    return 1;
  }
  return 0;
}
# 99086 "ext/sqlite3/libsqlite/sqlite3.c"
static double estLog(double N){
  double logN = 1;
  double x = 10;
  while( N>x ){
    logN += 1;
    x *= 10;
  }
  return logN;
}
# 99143 "ext/sqlite3/libsqlite/sqlite3.c"
static void bestIndex(
    Parse*, WhereClause*, struct SrcList_item*,
    Bitmask, Bitmask, ExprList*, WhereCost*);
# 99154 "ext/sqlite3/libsqlite/sqlite3.c"
static void bestOrClauseIndex(
  Parse *pParse,
  WhereClause *pWC,
  struct SrcList_item *pSrc,
  Bitmask notReady,
  Bitmask notValid,
  ExprList *pOrderBy,
  WhereCost *pCost
){

  const int iCur = pSrc->iCursor;
  const Bitmask maskSrc = getMask(pWC->pMaskSet, iCur);
  WhereTerm * const pWCEnd = &pWC->a[pWC->nTerm];
  WhereTerm *pTerm;



  if( pSrc->notIndexed || pSrc->pIndex!=0 ){
    return;
  }


  for(pTerm=pWC->a; pTerm<pWCEnd; pTerm++){
    if( pTerm->eOperator==0x100
     && ((pTerm->prereqAll & ~maskSrc) & notReady)==0
     && (pTerm->u.pOrInfo->indexable & maskSrc)!=0
    ){
      WhereClause * const pOrWC = &pTerm->u.pOrInfo->wc;
      WhereTerm * const pOrWCEnd = &pOrWC->a[pOrWC->nTerm];
      WhereTerm *pOrTerm;
      int flags = 0x10000000;
      double rTotal = 0;
      double nRow = 0;
      Bitmask used = 0;

      for(pOrTerm=pOrWC->a; pOrTerm<pOrWCEnd; pOrTerm++){
        WhereCost sTermCost;


          ;
        if( pOrTerm->eOperator==0x200 ){
          WhereClause *pAndWC = &pOrTerm->u.pAndInfo->wc;
          bestIndex(pParse, pAndWC, pSrc, notReady, notValid, 0, &sTermCost);
        }else if( pOrTerm->leftCursor==iCur ){
          WhereClause tempWC;
          tempWC.pParse = pWC->pParse;
          tempWC.pMaskSet = pWC->pMaskSet;
          tempWC.op = 69;
          tempWC.a = pOrTerm;
          tempWC.nTerm = 1;
          bestIndex(pParse, &tempWC, pSrc, notReady, notValid, 0, &sTermCost);
        }else{
          continue;
        }
        rTotal += sTermCost.rCost;
        nRow += sTermCost.plan.nRow;
        used |= sTermCost.used;
        if( rTotal>=pCost->rCost ) break;
      }



      if( pOrderBy!=0 ){

                                                      ;
        rTotal += nRow*estLog(nRow);
      }




                                                                            ;
      if( rTotal<pCost->rCost ){
        pCost->rCost = rTotal;
        pCost->used = used;
        pCost->plan.nRow = nRow;
        pCost->plan.wsFlags = flags;
        pCost->plan.u.pTerm = pTerm;
      }
    }
  }

}







static int termCanDriveIndex(
  WhereTerm *pTerm,
  struct SrcList_item *pSrc,
  Bitmask notReady
){
  char aff;
  if( pTerm->leftCursor!=pSrc->iCursor ) return 0;
  if( pTerm->eOperator!=0x002 ) return 0;
  if( (pTerm->prereqRight & notReady)!=0 ) return 0;
  aff = pSrc->pTab->aCol[pTerm->u.leftColumn].affinity;
  if( !sqlite3IndexAffinityOk(pTerm->pExpr, aff) ) return 0;
  return 1;
}
# 99268 "ext/sqlite3/libsqlite/sqlite3.c"
static void bestAutomaticIndex(
  Parse *pParse,
  WhereClause *pWC,
  struct SrcList_item *pSrc,
  Bitmask notReady,
  WhereCost *pCost
){
  double nTableRow;
  double logN;
  double costTempIdx;
  WhereTerm *pTerm;
  WhereTerm *pWCEnd;
  Table *pTable;

  if( (pParse->db->flags & 0x08000000)==0 ){

    return;
  }
  if( (pCost->plan.wsFlags & 0x100f3000)!=0 ){

    return;
  }
  if( pSrc->notIndexed ){

    return;
  }

  ((void) (0));
  pTable = pSrc->pTab;
  nTableRow = pTable->nRowEst;
  logN = estLog(nTableRow);
  costTempIdx = 2*logN*(nTableRow/pParse->nQueryLoop + 1);
  if( costTempIdx>=pCost->rCost ){


    return;
  }


  pWCEnd = &pWC->a[pWC->nTerm];
  for(pTerm=pWC->a; pTerm<pWCEnd; pTerm++){
    if( termCanDriveIndex(pTerm, pSrc, notReady) ){

                                               ;
      pCost->rCost = costTempIdx;
      pCost->plan.nRow = logN + 1;
      pCost->plan.wsFlags = 0x20000000;
      pCost->used = pTerm->prereqRight;
      break;
    }
  }
}
# 99331 "ext/sqlite3/libsqlite/sqlite3.c"
static void constructAutomaticIndex(
  Parse *pParse,
  WhereClause *pWC,
  struct SrcList_item *pSrc,
  Bitmask notReady,
  WhereLevel *pLevel
){
  int nColumn;
  WhereTerm *pTerm;
  WhereTerm *pWCEnd;
  int nByte;
  Index *pIdx;
  Vdbe *v;
  int regIsInit;
  int addrInit;
  Table *pTable;
  KeyInfo *pKeyinfo;
  int addrTop;
  int regRecord;
  int n;
  int i;
  int mxBitCol;
  CollSeq *pColl;
  Bitmask idxCols;
  Bitmask extraCols;



  v = pParse->pVdbe;
  ((void) (0));
  regIsInit = ++pParse->nMem;
  addrInit = sqlite3VdbeAddOp1(v, 26, regIsInit);
  sqlite3VdbeAddOp2(v, 7, 1, regIsInit);



  nColumn = 0;
  pTable = pSrc->pTab;
  pWCEnd = &pWC->a[pWC->nTerm];
  idxCols = 0;
  for(pTerm=pWC->a; pTerm<pWCEnd; pTerm++){
    if( termCanDriveIndex(pTerm, pSrc, notReady) ){
      int iCol = pTerm->u.leftColumn;
      Bitmask cMask = iCol>=((int)(sizeof(Bitmask)*8)) ? ((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1) : ((Bitmask)1)<<iCol;
                           ;
                             ;
      if( (idxCols & cMask)==0 ){
        nColumn++;
        idxCols |= cMask;
      }
    }
  }
  ((void) (0));
  pLevel->plan.nEq = nColumn;
# 99394 "ext/sqlite3/libsqlite/sqlite3.c"
  extraCols = pSrc->colUsed & (~idxCols | (((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1)));
  mxBitCol = (pTable->nCol >= ((int)(sizeof(Bitmask)*8))-1) ? ((int)(sizeof(Bitmask)*8))-1 : pTable->nCol;
                                 ;
                                 ;
  for(i=0; i<mxBitCol; i++){
    if( extraCols & (((Bitmask)1)<<i) ) nColumn++;
  }
  if( pSrc->colUsed & (((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1)) ){
    nColumn += pTable->nCol - ((int)(sizeof(Bitmask)*8)) + 1;
  }
  pLevel->plan.wsFlags |= 0x00010000 | 0x00800000 | 0x002;


  nByte = sizeof(Index);
  nByte += nColumn*sizeof(int);
  nByte += nColumn*sizeof(char*);
  nByte += nColumn;
  pIdx = sqlite3DbMallocZero(pParse->db, nByte);
  if( pIdx==0 ) return;
  pLevel->plan.u.pIdx = pIdx;
  pIdx->azColl = (char**)&pIdx[1];
  pIdx->aiColumn = (int*)&pIdx->azColl[nColumn];
  pIdx->aSortOrder = (u8*)&pIdx->aiColumn[nColumn];
  pIdx->zName = "auto-index";
  pIdx->nColumn = nColumn;
  pIdx->pTable = pTable;
  n = 0;
  idxCols = 0;
  for(pTerm=pWC->a; pTerm<pWCEnd; pTerm++){
    if( termCanDriveIndex(pTerm, pSrc, notReady) ){
      int iCol = pTerm->u.leftColumn;
      Bitmask cMask = iCol>=((int)(sizeof(Bitmask)*8)) ? ((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1) : ((Bitmask)1)<<iCol;
      if( (idxCols & cMask)==0 ){
        Expr *pX = pTerm->pExpr;
        idxCols |= cMask;
        pIdx->aiColumn[n] = pTerm->u.leftColumn;
        pColl = sqlite3BinaryCompareCollSeq(pParse, pX->pLeft, pX->pRight);
        pIdx->azColl[n] = (pColl) ? pColl->zName : "BINARY";
        n++;
      }
    }
  }
  ((void) (0));



  for(i=0; i<mxBitCol; i++){
    if( extraCols & (((Bitmask)1)<<i) ){
      pIdx->aiColumn[n] = i;
      pIdx->azColl[n] = "BINARY";
      n++;
    }
  }
  if( pSrc->colUsed & (((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1)) ){
    for(i=((int)(sizeof(Bitmask)*8))-1; i<pTable->nCol; i++){
      pIdx->aiColumn[n] = i;
      pIdx->azColl[n] = "BINARY";
      n++;
    }
  }
  ((void) (0));


  pKeyinfo = sqlite3IndexKeyinfo(pParse, pIdx);
  ((void) (0));
  sqlite3VdbeAddOp4(v, 40, pLevel->iIdxCur, nColumn+1, 0,
                    (char*)pKeyinfo, (-16));
                                           ;


  addrTop = sqlite3VdbeAddOp1(v, 65, pLevel->iTabCur);
  regRecord = sqlite3GetTempReg(pParse);
  sqlite3GenerateIndexKey(pParse, pIdx, pLevel->iTabCur, regRecord, 1);
  sqlite3VdbeAddOp2(v, 70, pLevel->iIdxCur, regRecord);
  sqlite3VdbeChangeP5(v, 0x10);
  sqlite3VdbeAddOp2(v, 67, pLevel->iTabCur, addrTop+1);
  sqlite3VdbeChangeP5(v, 3);
  sqlite3VdbeJumpHere(v, addrTop);
  sqlite3ReleaseTempReg(pParse, regRecord);


  sqlite3VdbeJumpHere(v, addrInit);
}
# 99485 "ext/sqlite3/libsqlite/sqlite3.c"
static sqlite3_index_info *allocateIndexInfo(
  Parse *pParse,
  WhereClause *pWC,
  struct SrcList_item *pSrc,
  ExprList *pOrderBy
){
  int i, j;
  int nTerm;
  struct sqlite3_index_constraint *pIdxCons;
  struct sqlite3_index_orderby *pIdxOrderBy;
  struct sqlite3_index_constraint_usage *pUsage;
  WhereTerm *pTerm;
  int nOrderBy;
  sqlite3_index_info *pIdxInfo;

                                                                       ;



  for(i=nTerm=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){
    if( pTerm->leftCursor != pSrc->iCursor ) continue;
    ((void) (0));
                                       ;
                                           ;
    if( pTerm->eOperator & (0x001|0x080) ) continue;
    nTerm++;
  }





  nOrderBy = 0;
  if( pOrderBy ){
    for(i=0; i<pOrderBy->nExpr; i++){
      Expr *pExpr = pOrderBy->a[i].pExpr;
      if( pExpr->op!=152 || pExpr->iTable!=pSrc->iCursor ) break;
    }
    if( i==pOrderBy->nExpr ){
      nOrderBy = pOrderBy->nExpr;
    }
  }



  pIdxInfo = sqlite3DbMallocZero(pParse->db, sizeof(*pIdxInfo)
                           + (sizeof(*pIdxCons) + sizeof(*pUsage))*nTerm
                           + sizeof(*pIdxOrderBy)*nOrderBy );
  if( pIdxInfo==0 ){
    sqlite3ErrorMsg(pParse, "out of memory");

    return 0;
  }






  pIdxCons = (struct sqlite3_index_constraint*)&pIdxInfo[1];
  pIdxOrderBy = (struct sqlite3_index_orderby*)&pIdxCons[nTerm];
  pUsage = (struct sqlite3_index_constraint_usage*)&pIdxOrderBy[nOrderBy];
  *(int*)&pIdxInfo->nConstraint = nTerm;
  *(int*)&pIdxInfo->nOrderBy = nOrderBy;
  *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint = pIdxCons;
  *(struct sqlite3_index_orderby**)&pIdxInfo->aOrderBy = pIdxOrderBy;
  *(struct sqlite3_index_constraint_usage**)&pIdxInfo->aConstraintUsage =
                                                                   pUsage;

  for(i=j=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){
    if( pTerm->leftCursor != pSrc->iCursor ) continue;
    ((void) (0));
                                       ;
                                           ;
    if( pTerm->eOperator & (0x001|0x080) ) continue;
    pIdxCons[j].iColumn = pTerm->u.leftColumn;
    pIdxCons[j].iTermOffset = i;
    pIdxCons[j].op = (u8)pTerm->eOperator;



    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
    j++;
  }
  for(i=0; i<nOrderBy; i++){
    Expr *pExpr = pOrderBy->a[i].pExpr;
    pIdxOrderBy[i].iColumn = pExpr->iColumn;
    pIdxOrderBy[i].desc = pOrderBy->a[i].sortOrder;
  }

  return pIdxInfo;
}
# 99598 "ext/sqlite3/libsqlite/sqlite3.c"
static int vtabBestIndex(Parse *pParse, Table *pTab, sqlite3_index_info *p){
  sqlite3_vtab *pVtab = sqlite3GetVTable(pParse->db, pTab)->pVtab;
  int i;
  int rc;

                                                  ;
                     ;
  rc = pVtab->pModule->xBestIndex(pVtab, p);
                      ;

  if( rc!=0 ){
    if( rc==7 ){
      pParse->db->mallocFailed = 1;
    }else if( !pVtab->zErrMsg ){
      sqlite3ErrorMsg(pParse, "%s", sqlite3ErrStr(rc));
    }else{
      sqlite3ErrorMsg(pParse, "%s", pVtab->zErrMsg);
    }
  }
  sqlite3_free(pVtab->zErrMsg);
  pVtab->zErrMsg = 0;

  for(i=0; i<p->nConstraint; i++){
    if( !p->aConstraint[i].usable && p->aConstraintUsage[i].argvIndex>0 ){
      sqlite3ErrorMsg(pParse,
          "table %s: xBestIndex returned an invalid plan", pTab->zName);
    }
  }

  return pParse->nErr;
}
# 99647 "ext/sqlite3/libsqlite/sqlite3.c"
static void bestVirtualIndex(
  Parse *pParse,
  WhereClause *pWC,
  struct SrcList_item *pSrc,
  Bitmask notReady,
  Bitmask notValid,
  ExprList *pOrderBy,
  WhereCost *pCost,
  sqlite3_index_info **ppIdxInfo
){
  Table *pTab = pSrc->pTab;
  sqlite3_index_info *pIdxInfo;
  struct sqlite3_index_constraint *pIdxCons;
  struct sqlite3_index_constraint_usage *pUsage;
  WhereTerm *pTerm;
  int i, j;
  int nOrderBy;
  double rCost;





  memset(pCost, 0, sizeof(*pCost));
  pCost->plan.wsFlags = 0x08000000;




  pIdxInfo = *ppIdxInfo;
  if( pIdxInfo==0 ){
    *ppIdxInfo = pIdxInfo = allocateIndexInfo(pParse, pWC, pSrc, pOrderBy);
  }
  if( pIdxInfo==0 ){
    return;
  }
# 99695 "ext/sqlite3/libsqlite/sqlite3.c"
  ((void) (0));
  ((void) (0));
# 99718 "ext/sqlite3/libsqlite/sqlite3.c"
  pIdxCons = *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint;
  pUsage = pIdxInfo->aConstraintUsage;
  for(i=0; i<pIdxInfo->nConstraint; i++, pIdxCons++){
    j = pIdxCons->iTermOffset;
    pTerm = &pWC->a[j];
    pIdxCons->usable = (pTerm->prereqRight&notReady) ? 0 : 1;
  }
  memset(pUsage, 0, sizeof(pUsage[0])*pIdxInfo->nConstraint);
  if( pIdxInfo->needToFreeIdxStr ){
    sqlite3_free(pIdxInfo->idxStr);
  }
  pIdxInfo->idxStr = 0;
  pIdxInfo->idxNum = 0;
  pIdxInfo->needToFreeIdxStr = 0;
  pIdxInfo->orderByConsumed = 0;

  pIdxInfo->estimatedCost = (1e99) / ((double)2);
  nOrderBy = pIdxInfo->nOrderBy;
  if( !pOrderBy ){
    pIdxInfo->nOrderBy = 0;
  }

  if( vtabBestIndex(pParse, pTab, pIdxInfo) ){
    return;
  }

  pIdxCons = *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint;
  for(i=0; i<pIdxInfo->nConstraint; i++){
    if( pUsage[i].argvIndex>0 ){
      pCost->used |= pWC->a[pIdxCons[i].iTermOffset].prereqRight;
    }
  }





  rCost = pIdxInfo->estimatedCost;
  if( pOrderBy && pIdxInfo->orderByConsumed==0 ){
    rCost += estLog(rCost)*rCost;
  }
# 99767 "ext/sqlite3/libsqlite/sqlite3.c"
  if( ((1e99)/((double)2))<rCost ){
    pCost->rCost = ((1e99)/((double)2));
  }else{
    pCost->rCost = rCost;
  }
  pCost->plan.u.pVtabIdx = pIdxInfo;
  if( pIdxInfo->orderByConsumed ){
    pCost->plan.wsFlags |= 0x01000000;
  }
  pCost->plan.nEq = 0;
  pIdxInfo->nOrderBy = nOrderBy;




  bestOrClauseIndex(pParse, pWC, pSrc, notReady, notValid, pOrderBy, pCost);
}
# 99975 "ext/sqlite3/libsqlite/sqlite3.c"
static int whereRangeScanEst(
  Parse *pParse,
  Index *p,
  int nEq,
  WhereTerm *pLower,
  WhereTerm *pUpper,
  int *piEst
){
  int rc = 0;
# 100042 "ext/sqlite3/libsqlite/sqlite3.c"
  (void)(pParse);
  (void)(p);
  (void)(nEq);

  ((void) (0));
  *piEst = 100;
  if( pLower && (pLower->wtFlags & 0x00)==0 ) *piEst /= 4;
  if( pUpper ) *piEst /= 4;
  return rc;
}
# 100218 "ext/sqlite3/libsqlite/sqlite3.c"
static void bestBtreeIndex(
  Parse *pParse,
  WhereClause *pWC,
  struct SrcList_item *pSrc,
  Bitmask notReady,
  Bitmask notValid,
  ExprList *pOrderBy,
  WhereCost *pCost
){
  int iCur = pSrc->iCursor;
  Index *pProbe;
  Index *pIdx;
  int eqTermMask;
  int idxEqTermMask;
  Index sPk;
  unsigned int aiRowEstPk[2];
  int aiColumnPk = -1;
  int wsFlagMask;


  memset(pCost, 0, sizeof(*pCost));
  pCost->rCost = (1e99);






  if( pSrc->jointype & 0x0008 ){
    idxEqTermMask = 0x002|0x001;
  }else{
    idxEqTermMask = 0x002|0x001|0x080;
  }

  if( pSrc->pIndex ){

    pIdx = pProbe = pSrc->pIndex;
    wsFlagMask = ~(0x00001000|0x00002000);
    eqTermMask = idxEqTermMask;
  }else{




    Index *pFirst;
    memset(&sPk, 0, sizeof(Index));
    sPk.nColumn = 1;
    sPk.aiColumn = &aiColumnPk;
    sPk.aiRowEst = aiRowEstPk;
    sPk.onError = 5;
    sPk.pTable = pSrc->pTab;
    aiRowEstPk[0] = pSrc->pTab->nRowEst;
    aiRowEstPk[1] = 1;
    pFirst = pSrc->pTab->pIndex;
    if( pSrc->notIndexed==0 ){


      sPk.pNext = pFirst;
    }
    pProbe = &sPk;
    wsFlagMask = ~(
        0x00040000|0x00010000|0x00080000|0x00020000
    );
    eqTermMask = 0x002|0x001;
    pIdx = 0;
  }



  for(; pProbe; pIdx=pProbe=pProbe->pNext){
    const unsigned int * const aiRowEst = pProbe->aiRowEst;
    double cost;
    double nRow;
    double log10N;
    int rev;
    int wsFlags = 0;
    Bitmask used = 0;
# 100360 "ext/sqlite3/libsqlite/sqlite3.c"
    int nEq;
    int bInEst = 0;
    int nInMul = 1;
    int estBound = 100;
    int nBound = 0;
    int bSort = 0;
    int bLookup = 0;
    WhereTerm *pTerm;





    for(nEq=0; nEq<pProbe->nColumn; nEq++){
      int j = pProbe->aiColumn[nEq];
      pTerm = findTerm(pWC, iCur, j, notReady, eqTermMask, pIdx);
      if( pTerm==0 ) break;
      wsFlags |= (0x00010000|0x00001000);
      if( pTerm->eOperator & 0x001 ){
        Expr *pExpr = pTerm->pExpr;
        wsFlags |= 0x00040000;
        if( (((pExpr)->flags&(0x0800))==(0x0800)) ){

          nInMul *= 25;
          bInEst = 1;
        }else if( (pExpr->x.pList && pExpr->x.pList->nExpr) ){

          nInMul *= pExpr->x.pList->nExpr;
        }
      }else if( pTerm->eOperator & 0x080 ){
        wsFlags |= 0x00080000;
      }



      used |= pTerm->prereqRight;
    }


    if( nEq<pProbe->nColumn && pProbe->bUnordered==0 ){
      int j = pProbe->aiColumn[nEq];
      if( findTerm(pWC, iCur, j, notReady, (0x002<<(79 -76))|(0x002<<(78 -76))|(0x002<<(77 -76))|(0x002<<(80 -76)), pIdx) ){
        WhereTerm *pTop = findTerm(pWC, iCur, j, notReady, (0x002<<(79 -76))|(0x002<<(78 -76)), pIdx);
        WhereTerm *pBtm = findTerm(pWC, iCur, j, notReady, (0x002<<(77 -76))|(0x002<<(80 -76)), pIdx);
        whereRangeScanEst(pParse, pProbe, nEq, pBtm, pTop, &estBound);
        if( pTop ){
          nBound = 1;
          wsFlags |= 0x00100000;
          used |= pTop->prereqRight;
        }
        if( pBtm ){
          nBound++;
          wsFlags |= 0x00200000;
          used |= pBtm->prereqRight;
        }
        wsFlags |= (0x00020000|0x00002000);
      }
    }else if( pProbe->onError!=0 ){
                                           ;
                                             ;
      if( (wsFlags & (0x00040000|0x00080000))==0 ){
        wsFlags |= 0x04000000;
      }
    }





    if( pOrderBy ){
      if( (wsFlags & 0x00040000)==0
        && pProbe->bUnordered==0
        && isSortingIndex(pParse, pWC->pMaskSet, pProbe, iCur, pOrderBy,
                          nEq, wsFlags, &rev)
      ){
        wsFlags |= 0x00002000|0x00020000|0x01000000;
        wsFlags |= (rev ? 0x02000000 : 0);
      }else{
        bSort = 1;
      }
    }






    if( pIdx && wsFlags ){
      Bitmask m = pSrc->colUsed;
      int j;
      for(j=0; j<pIdx->nColumn; j++){
        int x = pIdx->aiColumn[j];
        if( x<((int)(sizeof(Bitmask)*8))-1 ){
          m &= ~(((Bitmask)1)<<x);
        }
      }
      if( m==0 ){
        wsFlags |= 0x00800000;
      }else{
        bLookup = 1;
      }
    }





    nRow = (double)(aiRowEst[nEq] * nInMul);
    if( bInEst && nRow*2>aiRowEst[0] ){
      nRow = aiRowEst[0]/2;
      nInMul = (int)(nRow / aiRowEst[nEq]);
    }
# 100493 "ext/sqlite3/libsqlite/sqlite3.c"
    nRow = (nRow * (double)estBound) / (double)100;
    if( nRow<1 ) nRow = 1;
# 100509 "ext/sqlite3/libsqlite/sqlite3.c"
    if( (wsFlags & 0x100f3000)==0 ){
# 100519 "ext/sqlite3/libsqlite/sqlite3.c"
      cost = aiRowEst[0]*4;
    }else{
      log10N = estLog(aiRowEst[0]);
      cost = nRow;
      if( pIdx ){
        if( bLookup ){





          cost += (nInMul + nRow)*log10N;
        }else{




          cost += nInMul*log10N;
        }
      }else{




        cost += nInMul*log10N;
      }
    }







    if( bSort ){
      cost += nRow*estLog(nRow)*3;
    }
# 100575 "ext/sqlite3/libsqlite/sqlite3.c"
    if( nRow>2 && cost<=pCost->rCost ){
      int k;
      int nSkipEq = nEq;
      int nSkipRange = nBound;
      Bitmask thisTab;

      thisTab = getMask(pWC->pMaskSet, iCur);
      for(pTerm=pWC->a, k=pWC->nTerm; nRow>2 && k; k--, pTerm++){
        if( pTerm->wtFlags & 0x02 ) continue;
        if( (pTerm->prereqAll & notValid)!=thisTab ) continue;
        if( pTerm->eOperator & (0x002|0x001|0x080) ){
          if( nSkipEq ){


            nSkipEq--;
          }else{


            nRow /= 10;
          }
        }else if( pTerm->eOperator & ((0x002<<(79 -76))|(0x002<<(78 -76))|(0x002<<(77 -76))|(0x002<<(80 -76))) ){
          if( nSkipRange ){


            nSkipRange--;
          }else{






            nRow /= 3;
          }
        }else if( pTerm->eOperator!=0x800 ){

          nRow /= 2;
        }
      }
      if( nRow<2 ) nRow = 2;
    }
# 100624 "ext/sqlite3/libsqlite/sqlite3.c"
      ;




    if( (!pIdx || wsFlags)
     && (cost<pCost->rCost || (cost<=pCost->rCost && nRow<pCost->plan.nRow))
    ){
      pCost->rCost = cost;
      pCost->used = used;
      pCost->plan.nRow = nRow;
      pCost->plan.wsFlags = (wsFlags&wsFlagMask);
      pCost->plan.nEq = nEq;
      pCost->plan.u.pIdx = pIdx;
    }



    if( pSrc->pIndex ) break;


    wsFlagMask = ~(0x00001000|0x00002000);
    eqTermMask = idxEqTermMask;
  }






  if( !pOrderBy && pParse->db->flags & 0x01000000 ){
    pCost->plan.wsFlags |= 0x02000000;
  }

  ((void) (0));
  ((void) (0));
  ((void) (0));







    ;

  bestOrClauseIndex(pParse, pWC, pSrc, notReady, notValid, pOrderBy, pCost);
  bestAutomaticIndex(pParse, pWC, pSrc, notReady, pCost);
  pCost->plan.wsFlags |= eqTermMask;
}







static void bestIndex(
  Parse *pParse,
  WhereClause *pWC,
  struct SrcList_item *pSrc,
  Bitmask notReady,
  Bitmask notValid,
  ExprList *pOrderBy,
  WhereCost *pCost
){

  if( (((pSrc->pTab)->tabFlags & 0x10)!=0) ){
    sqlite3_index_info *p = 0;
    bestVirtualIndex(pParse, pWC, pSrc, notReady, notValid, pOrderBy, pCost,&p);
    if( p->needToFreeIdxStr ){
      sqlite3_free(p->idxStr);
    }
    sqlite3DbFree(pParse->db, p);
  }else

  {
    bestBtreeIndex(pParse, pWC, pSrc, notReady, notValid, pOrderBy, pCost);
  }
}
# 100731 "ext/sqlite3/libsqlite/sqlite3.c"
static void disableTerm(WhereLevel *pLevel, WhereTerm *pTerm){
  if( pTerm
      && (pTerm->wtFlags & 0x04)==0
      && (pLevel->iLeftJoin==0 || (((pTerm->pExpr)->flags&(0x0001))==(0x0001)))
  ){
    pTerm->wtFlags |= 0x04;
    if( pTerm->iParent>=0 ){
      WhereTerm *pOther = &pTerm->pWC->a[pTerm->iParent];
      if( (--pOther->nChild)==0 ){
        disableTerm(pLevel, pOther);
      }
    }
  }
}
# 100757 "ext/sqlite3/libsqlite/sqlite3.c"
static void codeApplyAffinity(Parse *pParse, int base, int n, char *zAff){
  Vdbe *v = pParse->pVdbe;
  if( zAff==0 ){
    ((void) (0));
    return;
  }
  ((void) (0));




  while( n>0 && zAff[0]=='b' ){
    n--;
    base++;
    zAff++;
  }
  while( n>1 && zAff[n-1]=='b' ){
    n--;
  }


  if( n>0 ){
    sqlite3VdbeAddOp2(v, 29, base, n);
    sqlite3VdbeChangeP4(v, -1, zAff, n);
    sqlite3ExprCacheAffinityChange(pParse, base, n);
  }
}
# 100797 "ext/sqlite3/libsqlite/sqlite3.c"
static int codeEqualityTerm(
  Parse *pParse,
  WhereTerm *pTerm,
  WhereLevel *pLevel,
  int iTarget
){
  Expr *pX = pTerm->pExpr;
  Vdbe *v = pParse->pVdbe;
  int iReg;

  ((void) (0));
  if( pX->op==76 ){
    iReg = sqlite3ExprCodeTarget(pParse, pX->pRight, iTarget);
  }else if( pX->op==73 ){
    iReg = iTarget;
    sqlite3VdbeAddOp2(v, 10, 0, iReg);

  }else{
    int eType;
    int iTab;
    struct InLoop *pIn;

    ((void) (0));
    iReg = iTarget;
    eType = sqlite3FindInIndex(pParse, pX, 0);
    iTab = pX->iTable;
    sqlite3VdbeAddOp2(v, 65, iTab, 0);
    ((void) (0));
    if( pLevel->u.in.nIn==0 ){
      pLevel->addrNxt = sqlite3VdbeMakeLabel(v);
    }
    pLevel->u.in.nIn++;
    pLevel->u.in.aInLoop =
       sqlite3DbReallocOrFree(pParse->db, pLevel->u.in.aInLoop,
                              sizeof(pLevel->u.in.aInLoop[0])*pLevel->u.in.nIn);
    pIn = pLevel->u.in.aInLoop;
    if( pIn ){
      pIn += pLevel->u.in.nIn - 1;
      pIn->iCur = iTab;
      if( eType==1 ){
        pIn->addrInTop = sqlite3VdbeAddOp2(v, 61, iTab, iReg);
      }else{
        pIn->addrInTop = sqlite3VdbeAddOp3(v, 28, iTab, 0, iReg);
      }
      sqlite3VdbeAddOp1(v, 73, iReg);
    }else{
      pLevel->u.in.nIn = 0;
    }

  }
  disableTerm(pLevel, pTerm);
  return iReg;
}
# 100890 "ext/sqlite3/libsqlite/sqlite3.c"
static int codeAllEqualityTerms(
  Parse *pParse,
  WhereLevel *pLevel,
  WhereClause *pWC,
  Bitmask notReady,
  int nExtraReg,
  char **pzAff
){
  int nEq = pLevel->plan.nEq;
  Vdbe *v = pParse->pVdbe;
  Index *pIdx;
  int iCur = pLevel->iTabCur;
  WhereTerm *pTerm;
  int j;
  int regBase;
  int nReg;
  char *zAff;


  ((void) (0));
  pIdx = pLevel->plan.u.pIdx;



  regBase = pParse->nMem + 1;
  nReg = pLevel->plan.nEq + nExtraReg;
  pParse->nMem += nReg;

  zAff = sqlite3DbStrDup(pParse->db, sqlite3IndexAffinityStr(v, pIdx));
  if( !zAff ){
    pParse->db->mallocFailed = 1;
  }



  ((void) (0));
  for(j=0; j<nEq; j++){
    int r1;
    int k = pIdx->aiColumn[j];
    pTerm = findTerm(pWC, iCur, k, notReady, pLevel->plan.wsFlags, pIdx);
    if( (pTerm==0) ) break;


                                                ;
                                             ;
    r1 = codeEqualityTerm(pParse, pTerm, pLevel, regBase+j);
    if( r1!=regBase+j ){
      if( nReg==1 ){
        sqlite3ReleaseTempReg(pParse, regBase);
        regBase = r1;
      }else{
        sqlite3VdbeAddOp2(v, 15, r1, regBase+j);
      }
    }
                                            ;
                                        ;
    if( (pTerm->eOperator & (0x080|0x001))==0 ){
      Expr *pRight = pTerm->pExpr->pRight;
      sqlite3ExprCodeIsNullJump(v, pRight, regBase+j, pLevel->addrBrk);
      if( zAff ){
        if( sqlite3CompareAffinity(pRight, zAff[j])=='b' ){
          zAff[j] = 'b';
        }
        if( sqlite3ExprNeedsNoAffinityChange(pRight, zAff[j]) ){
          zAff[j] = 'b';
        }
      }
    }
  }
  *pzAff = zAff;
  return regBase;
}
# 100972 "ext/sqlite3/libsqlite/sqlite3.c"
static void explainAppendTerm(
  StrAccum *pStr,
  int iTerm,
  const char *zColumn,
  const char *zOp
){
  if( iTerm ) sqlite3StrAccumAppend(pStr, " AND ", 5);
  sqlite3StrAccumAppend(pStr, zColumn, -1);
  sqlite3StrAccumAppend(pStr, zOp, 1);
  sqlite3StrAccumAppend(pStr, "?", 1);
}
# 101003 "ext/sqlite3/libsqlite/sqlite3.c"
static char *explainIndexRange(sqlite3 *db, WhereLevel *pLevel, Table *pTab){
  WherePlan *pPlan = &pLevel->plan;
  Index *pIndex = pPlan->u.pIdx;
  int nEq = pPlan->nEq;
  int i, j;
  Column *aCol = pTab->aCol;
  int *aiColumn = pIndex->aiColumn;
  StrAccum txt;

  if( nEq==0 && (pPlan->wsFlags & (0x00200000|0x00100000))==0 ){
    return 0;
  }
  sqlite3StrAccumInit(&txt, 0, 0, 1000000000);
  txt.db = db;
  sqlite3StrAccumAppend(&txt, " (", 2);
  for(i=0; i<nEq; i++){
    explainAppendTerm(&txt, i, aCol[aiColumn[i]].zName, "=");
  }

  j = i;
  if( pPlan->wsFlags&0x00200000 ){
    explainAppendTerm(&txt, i++, aCol[aiColumn[j]].zName, ">");
  }
  if( pPlan->wsFlags&0x00100000 ){
    explainAppendTerm(&txt, i, aCol[aiColumn[j]].zName, "<");
  }
  sqlite3StrAccumAppend(&txt, ")", 1);
  return sqlite3StrAccumFinish(&txt);
}







static void explainOneScan(
  Parse *pParse,
  SrcList *pTabList,
  WhereLevel *pLevel,
  int iLevel,
  int iFrom,
  u16 wctrlFlags
){
  if( pParse->explain==2 ){
    u32 flags = pLevel->plan.wsFlags;
    struct SrcList_item *pItem = &pTabList->a[pLevel->iFrom];
    Vdbe *v = pParse->pVdbe;
    sqlite3 *db = pParse->db;
    char *zMsg;
    sqlite3_int64 nRow;
    int iId = pParse->iSelectId;
    int isSearch;

    if( (flags&0x10000000) || (wctrlFlags&0x0080) ) return;

    isSearch = (pLevel->plan.nEq>0)
             || (flags&(0x00200000|0x00100000))!=0
             || (wctrlFlags&(0x0001|0x0002));

    zMsg = sqlite3MPrintf(db, "%s", isSearch?"SEARCH":"SCAN");
    if( pItem->pSelect ){
      zMsg = sqlite3MAppendf(db, zMsg, "%s SUBQUERY %d", zMsg,pItem->iSelectId);
    }else{
      zMsg = sqlite3MAppendf(db, zMsg, "%s TABLE %s", zMsg, pItem->zName);
    }

    if( pItem->zAlias ){
      zMsg = sqlite3MAppendf(db, zMsg, "%s AS %s", zMsg, pItem->zAlias);
    }
    if( (flags & 0x000f0000)!=0 ){
      char *zWhere = explainIndexRange(db, pLevel, pItem->pTab);
      zMsg = sqlite3MAppendf(db, zMsg, "%s USING %s%sINDEX%s%s%s", zMsg,
          ((flags & 0x20000000)?"AUTOMATIC ":""),
          ((flags & 0x00800000)?"COVERING ":""),
          ((flags & 0x20000000)?"":" "),
          ((flags & 0x20000000)?"": pLevel->plan.u.pIdx->zName),
          zWhere
      );
      sqlite3DbFree(db, zWhere);
    }else if( flags & (0x00001000|0x00002000) ){
      zMsg = sqlite3MAppendf(db, zMsg, "%s USING INTEGER PRIMARY KEY", zMsg);

      if( flags&0x00001000 ){
        zMsg = sqlite3MAppendf(db, zMsg, "%s (rowid=?)", zMsg);
      }else if( (flags&0x00300000)==0x00300000 ){
        zMsg = sqlite3MAppendf(db, zMsg, "%s (rowid>? AND rowid<?)", zMsg);
      }else if( flags&0x00200000 ){
        zMsg = sqlite3MAppendf(db, zMsg, "%s (rowid>?)", zMsg);
      }else if( flags&0x00100000 ){
        zMsg = sqlite3MAppendf(db, zMsg, "%s (rowid<?)", zMsg);
      }
    }

    else if( (flags & 0x08000000)!=0 ){
      sqlite3_index_info *pVtabIdx = pLevel->plan.u.pVtabIdx;
      zMsg = sqlite3MAppendf(db, zMsg, "%s VIRTUAL TABLE INDEX %d:%s", zMsg,
                  pVtabIdx->idxNum, pVtabIdx->idxStr);
    }

    if( wctrlFlags&(0x0001|0x0002) ){
                                                ;
      nRow = 1;
    }else{
      nRow = (sqlite3_int64)pLevel->plan.nRow;
    }
    zMsg = sqlite3MAppendf(db, zMsg, "%s (~%lld rows)", zMsg, nRow);
    sqlite3VdbeAddOp4(v, 138, iId, iLevel, iFrom, zMsg, (-1));
  }
}
# 101122 "ext/sqlite3/libsqlite/sqlite3.c"
static Bitmask codeOneLoopStart(
  WhereInfo *pWInfo,
  int iLevel,
  u16 wctrlFlags,
  Bitmask notReady
){
  int j, k;
  int iCur;
  int addrNxt;
  int omitTable;
  int bRev;
  WhereLevel *pLevel;
  WhereClause *pWC;
  WhereTerm *pTerm;
  Parse *pParse;
  Vdbe *v;
  struct SrcList_item *pTabItem;
  int addrBrk;
  int addrCont;
  int iRowidReg = 0;
  int iReleaseReg = 0;

  pParse = pWInfo->pParse;
  v = pParse->pVdbe;
  pWC = pWInfo->pWC;
  pLevel = &pWInfo->a[iLevel];
  pTabItem = &pWInfo->pTabList->a[pLevel->iFrom];
  iCur = pTabItem->iCursor;
  bRev = (pLevel->plan.wsFlags & 0x02000000)!=0;
  omitTable = (pLevel->plan.wsFlags & 0x00800000)!=0
           && (wctrlFlags & 0x0040)==0;
# 101164 "ext/sqlite3/libsqlite/sqlite3.c"
  addrBrk = pLevel->addrBrk = pLevel->addrNxt = sqlite3VdbeMakeLabel(v);
  addrCont = pLevel->addrCont = sqlite3VdbeMakeLabel(v);





  if( pLevel->iFrom>0 && (pTabItem[0].jointype & 0x0008)!=0 ){
    pLevel->iLeftJoin = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 7, 0, pLevel->iLeftJoin);
                                                    ;
  }


  if( (pLevel->plan.wsFlags & 0x08000000)!=0 ){



    int iReg;
    sqlite3_index_info *pVtabIdx = pLevel->plan.u.pVtabIdx;
    int nConstraint = pVtabIdx->nConstraint;
    struct sqlite3_index_constraint_usage *aUsage =
                                                pVtabIdx->aConstraintUsage;
    const struct sqlite3_index_constraint *aConstraint =
                                                pVtabIdx->aConstraint;

    sqlite3ExprCachePush(pParse);
    iReg = sqlite3GetTempRange(pParse, nConstraint+2);
    for(j=1; j<=nConstraint; j++){
      for(k=0; k<nConstraint; k++){
        if( aUsage[k].argvIndex==j ){
          int iTerm = aConstraint[k].iTermOffset;
          sqlite3ExprCode(pParse, pWC->a[iTerm].pExpr->pRight, iReg+j+1);
          break;
        }
      }
      if( k==nConstraint ) break;
    }
    sqlite3VdbeAddOp2(v, 7, pVtabIdx->idxNum, iReg);
    sqlite3VdbeAddOp2(v, 7, j-1, iReg+1);
    sqlite3VdbeAddOp4(v, 128, iCur, addrBrk, iReg, pVtabIdx->idxStr,
                      pVtabIdx->needToFreeIdxStr ? (-11) : (-2));
    pVtabIdx->needToFreeIdxStr = 0;
    for(j=0; j<nConstraint; j++){
      if( aUsage[j].omit ){
        int iTerm = aConstraint[j].iTermOffset;
        disableTerm(pLevel, &pWC->a[iTerm]);
      }
    }
    pLevel->op = 131;
    pLevel->p1 = iCur;
    pLevel->p2 = sqlite3VdbeCurrentAddr(v);
    sqlite3ReleaseTempRange(pParse, iReg, nConstraint+2);
    sqlite3ExprCachePop(pParse, 1);
  }else


  if( pLevel->plan.wsFlags & 0x00001000 ){





    iReleaseReg = sqlite3GetTempReg(pParse);
    pTerm = findTerm(pWC, iCur, -1, notReady, 0x002|0x001, 0);
    ((void) (0));
    ((void) (0));
    ((void) (0));
    ((void) (0));
                                             ;
    iRowidReg = codeEqualityTerm(pParse, pTerm, pLevel, iReleaseReg);
    addrNxt = pLevel->addrNxt;
    sqlite3VdbeAddOp2(v, 21, iRowidReg, addrNxt);
    sqlite3VdbeAddOp3(v, 52, iCur, addrNxt, iRowidReg);
    sqlite3ExprCacheStore(pParse, iCur, -1, iRowidReg);
                          ;
    pLevel->op = 137;
  }else if( pLevel->plan.wsFlags & 0x00002000 ){


    int testOp = 137;
    int start;
    int memEndValue = 0;
    WhereTerm *pStart, *pEnd;

    ((void) (0));
    pStart = findTerm(pWC, iCur, -1, notReady, (0x002<<(77 -76))|(0x002<<(80 -76)), 0);
    pEnd = findTerm(pWC, iCur, -1, notReady, (0x002<<(79 -76))|(0x002<<(78 -76)), 0);
    if( bRev ){
      pTerm = pStart;
      pStart = pEnd;
      pEnd = pTerm;
    }
    if( pStart ){
      Expr *pX;
      int r1, rTemp;




      const u8 aMoveOp[] = {
                        47,
                        45,
                        44,
                        46
      };
      ((void) (0));
      ((void) (0));
      ((void) (0));

                                                ;
      pX = pStart->pExpr;
      ((void) (0));
      ((void) (0));
      r1 = sqlite3ExprCodeTemp(pParse, pX->pRight, &rTemp);
      sqlite3VdbeAddOp3(v, aMoveOp[pX->op-77], iCur, addrBrk, r1);
                            ;
      sqlite3ExprCacheAffinityChange(pParse, r1, 1);
      sqlite3ReleaseTempReg(pParse, rTemp);
      disableTerm(pLevel, pStart);
    }else{
      sqlite3VdbeAddOp2(v, bRev ? 63 : 65, iCur, addrBrk);
    }
    if( pEnd ){
      Expr *pX;
      pX = pEnd->pExpr;
      ((void) (0));
      ((void) (0));
                                              ;
      memEndValue = ++pParse->nMem;
      sqlite3ExprCode(pParse, pX->pRight, memEndValue);
      if( pX->op==79 || pX->op==77 ){
        testOp = bRev ? 78 : 80;
      }else{
        testOp = bRev ? 79 : 77;
      }
      disableTerm(pLevel, pEnd);
    }
    start = sqlite3VdbeCurrentAddr(v);
    pLevel->op = bRev ? 66 : 67;
    pLevel->p1 = iCur;
    pLevel->p2 = start;
    if( pStart==0 && pEnd==0 ){
      pLevel->p5 = 1;
    }else{
      ((void) (0));
    }
    if( testOp!=137 ){
      iRowidReg = iReleaseReg = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp2(v, 61, iCur, iRowidReg);
      sqlite3ExprCacheStore(pParse, iCur, -1, iRowidReg);
      sqlite3VdbeAddOp3(v, testOp, memEndValue, addrBrk, iRowidReg);
      sqlite3VdbeChangeP5(v, 'c' | 0x08);
    }
  }else if( pLevel->plan.wsFlags & (0x00020000|0x00010000) ){
# 101350 "ext/sqlite3/libsqlite/sqlite3.c"
    static const u8 aStartOp[] = {
      0,
      0,
      65,
      63,
      47,
      44,
      46,
      45
    };
    static const u8 aEndOp[] = {
      137,
      92,
      81
    };
    int nEq = pLevel->plan.nEq;
    int isMinQuery = 0;
    int regBase;
    int r1;
    WhereTerm *pRangeStart = 0;
    WhereTerm *pRangeEnd = 0;
    int startEq;
    int endEq;
    int start_constraints;
    int nConstraint;
    Index *pIdx;
    int iIdxCur;
    int nExtraReg = 0;
    int op;
    char *zStartAff;
    char *zEndAff;

    pIdx = pLevel->plan.u.pIdx;
    iIdxCur = pLevel->iIdxCur;
    k = pIdx->aiColumn[nEq];
# 101394 "ext/sqlite3/libsqlite/sqlite3.c"
    if( (wctrlFlags&0x0001)!=0
     && (pLevel->plan.wsFlags&0x01000000)
     && (pIdx->nColumn>nEq)
    ){


      isMinQuery = 1;
      nExtraReg = 1;
    }




    if( pLevel->plan.wsFlags & 0x00100000 ){
      pRangeEnd = findTerm(pWC, iCur, k, notReady, ((0x002<<(79 -76))|(0x002<<(78 -76))), pIdx);
      nExtraReg = 1;
    }
    if( pLevel->plan.wsFlags & 0x00200000 ){
      pRangeStart = findTerm(pWC, iCur, k, notReady, ((0x002<<(77 -76))|(0x002<<(80 -76))), pIdx);
      nExtraReg = 1;
    }





    regBase = codeAllEqualityTerms(
        pParse, pLevel, pWC, notReady, nExtraReg, &zStartAff
    );
    zEndAff = sqlite3DbStrDup(pParse->db, zStartAff);
    addrNxt = pLevel->addrNxt;





    if( nEq<pIdx->nColumn && bRev==(pIdx->aSortOrder[nEq]==0) ){
      {WhereTerm * t=pRangeEnd; pRangeEnd=pRangeStart; pRangeStart=t;};
    }

                                                             ;
                                                             ;
                                                         ;
                                                         ;
    startEq = !pRangeStart || pRangeStart->eOperator & ((0x002<<(78 -76))|(0x002<<(80 -76)));
    endEq = !pRangeEnd || pRangeEnd->eOperator & ((0x002<<(78 -76))|(0x002<<(80 -76)));
    start_constraints = pRangeStart || nEq>0;


    nConstraint = nEq;
    if( pRangeStart ){
      Expr *pRight = pRangeStart->pExpr->pRight;
      sqlite3ExprCode(pParse, pRight, regBase+nEq);
      if( (pRangeStart->wtFlags & 0x00)==0 ){
        sqlite3ExprCodeIsNullJump(v, pRight, regBase+nEq, addrNxt);
      }
      if( zStartAff ){
        if( sqlite3CompareAffinity(pRight, zStartAff[nEq])=='b'){



          zStartAff[nEq] = 'b';
        }
        if( sqlite3ExprNeedsNoAffinityChange(pRight, zStartAff[nEq]) ){
          zStartAff[nEq] = 'b';
        }
      }
      nConstraint++;
                                                     ;
    }else if( isMinQuery ){
      sqlite3VdbeAddOp2(v, 10, 0, regBase+nEq);
      nConstraint++;
      startEq = 0;
      start_constraints = 1;
    }
    codeApplyAffinity(pParse, regBase, nConstraint, zStartAff);
    op = aStartOp[(start_constraints<<2) + (startEq<<1) + bRev];
    ((void) (0));
                             ;
                           ;
                             ;
                             ;
                             ;
                             ;
    sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);




    nConstraint = nEq;
    if( pRangeEnd ){
      Expr *pRight = pRangeEnd->pExpr->pRight;
      sqlite3ExprCacheRemove(pParse, regBase+nEq, 1);
      sqlite3ExprCode(pParse, pRight, regBase+nEq);
      if( (pRangeEnd->wtFlags & 0x00)==0 ){
        sqlite3ExprCodeIsNullJump(v, pRight, regBase+nEq, addrNxt);
      }
      if( zEndAff ){
        if( sqlite3CompareAffinity(pRight, zEndAff[nEq])=='b'){



          zEndAff[nEq] = 'b';
        }
        if( sqlite3ExprNeedsNoAffinityChange(pRight, zEndAff[nEq]) ){
          zEndAff[nEq] = 'b';
        }
      }
      codeApplyAffinity(pParse, regBase, nEq+1, zEndAff);
      nConstraint++;
                                                   ;
    }
    sqlite3DbFree(pParse->db, zStartAff);
    sqlite3DbFree(pParse->db, zEndAff);


    pLevel->p2 = sqlite3VdbeCurrentAddr(v);


    op = aEndOp[(pRangeEnd || nEq) * (1 + bRev)];
                           ;
                            ;
                            ;
    if( op!=137 ){
      sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);
      sqlite3VdbeChangeP5(v, endEq!=bRev ?1:0);
    }





    r1 = sqlite3GetTempReg(pParse);
                                                      ;
                                                      ;
    if( (pLevel->plan.wsFlags & (0x00200000|0x00100000))!=0 ){
      sqlite3VdbeAddOp3(v, 28, iIdxCur, nEq, r1);
      sqlite3VdbeAddOp2(v, 73, r1, addrCont);
    }
    sqlite3ReleaseTempReg(pParse, r1);


    disableTerm(pLevel, pRangeStart);
    disableTerm(pLevel, pRangeEnd);
    if( !omitTable ){
      iRowidReg = iReleaseReg = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp2(v, 72, iIdxCur, iRowidReg);
      sqlite3ExprCacheStore(pParse, iCur, -1, iRowidReg);
      sqlite3VdbeAddOp2(v, 48, iCur, iRowidReg);
    }




    if( pLevel->plan.wsFlags & 0x04000000 ){
      pLevel->op = 137;
    }else if( bRev ){
      pLevel->op = 66;
    }else{
      pLevel->op = 67;
    }
    pLevel->p1 = iIdxCur;
  }else


  if( pLevel->plan.wsFlags & 0x10000000 ){
# 101599 "ext/sqlite3/libsqlite/sqlite3.c"
    WhereClause *pOrWc;
    SrcList *pOrTab;

    int regReturn = ++pParse->nMem;
    int regRowset = 0;
    int regRowid = 0;
    int iLoopBody = sqlite3VdbeMakeLabel(v);
    int iRetInit;
    int untestedTerms = 0;
    int ii;

    pTerm = pLevel->plan.u.pTerm;
    ((void) (0));
    ((void) (0));
    ((void) (0));
    pOrWc = &pTerm->u.pOrInfo->wc;
    pLevel->op = 3;
    pLevel->p1 = regReturn;





    if( pWInfo->nLevel>1 ){
      int nNotReady;
      struct SrcList_item *origSrc;
      nNotReady = pWInfo->nLevel - iLevel - 1;
      pOrTab = sqlite3DbMallocRaw(pParse->db,sizeof(*pOrTab)+ nNotReady*sizeof(pOrTab->a[0]));

      if( pOrTab==0 ) return notReady;
      pOrTab->nAlloc = (i16)(nNotReady + 1);
      pOrTab->nSrc = pOrTab->nAlloc;
      memcpy(pOrTab->a, pTabItem, sizeof(*pTabItem));
      origSrc = pWInfo->pTabList->a;
      for(k=1; k<=nNotReady; k++){
        memcpy(&pOrTab->a[k], &origSrc[pLevel[k].iFrom], sizeof(pOrTab->a[k]));
      }
    }else{
      pOrTab = pWInfo->pTabList;
    }
# 101651 "ext/sqlite3/libsqlite/sqlite3.c"
    if( (wctrlFlags & 0x0008)==0 ){
      regRowset = ++pParse->nMem;
      regRowid = ++pParse->nMem;
      sqlite3VdbeAddOp2(v, 10, 0, regRowset);
    }
    iRetInit = sqlite3VdbeAddOp2(v, 7, 0, regReturn);

    for(ii=0; ii<pOrWc->nTerm; ii++){
      WhereTerm *pOrTerm = &pOrWc->a[ii];
      if( pOrTerm->leftCursor==iCur || pOrTerm->eOperator==0x200 ){
        WhereInfo *pSubWInfo;

        pSubWInfo = sqlite3WhereBegin(pParse, pOrTab, pOrTerm->pExpr, 0,
                        0x0010 | 0x0020 |
                        0x0040 | 0x0080);
        if( pSubWInfo ){
          explainOneScan(
              pParse, pOrTab, &pSubWInfo->a[0], iLevel, pLevel->iFrom, 0
          );
          if( (wctrlFlags & 0x0008)==0 ){
            int iSet = ((ii==pOrWc->nTerm-1)?-1:ii);
            int r;
            r = sqlite3ExprCodeGetColumn(pParse, pTabItem->pTab, -1, iCur,
                                         regRowid);
            sqlite3VdbeAddOp4Int(v, 107, regRowset,
                                 sqlite3VdbeCurrentAddr(v)+2, r, iSet);
          }
          sqlite3VdbeAddOp2(v, 2, regReturn, iLoopBody);






          if( pSubWInfo->untestedTerms ) untestedTerms = 1;


          sqlite3WhereEnd(pSubWInfo);
        }
      }
    }
    sqlite3VdbeChangeP1(v, iRetInit, sqlite3VdbeCurrentAddr(v));
    sqlite3VdbeAddOp2(v, 1, 0, pLevel->addrBrk);
    sqlite3VdbeResolveLabel(v, iLoopBody);

    if( pWInfo->nLevel>1 ) sqlite3DbFree(pParse->db,pOrTab);
    if( !untestedTerms ) disableTerm(pLevel, pTerm);
  }else


  {



    static const u8 aStep[] = { 67, 66 };
    static const u8 aStart[] = { 65, 63 };
    ((void) (0));
    ((void) (0));
    pLevel->op = aStep[bRev];
    pLevel->p1 = iCur;
    pLevel->p2 = 1 + sqlite3VdbeAddOp2(v, aStart[bRev], iCur, addrBrk);
    pLevel->p5 = 1;
  }
  notReady &= ~getMask(pWC->pMaskSet, iCur);
# 101723 "ext/sqlite3/libsqlite/sqlite3.c"
  for(pTerm=pWC->a, j=pWC->nTerm; j>0; j--, pTerm++){
    Expr *pE;
                                             ;
                                           ;
    if( pTerm->wtFlags & (0x02|0x04) ) continue;
    if( (pTerm->prereqAll & notReady)!=0 ){

                                                                 ;
      pWInfo->untestedTerms = 1;
      continue;
    }
    pE = pTerm->pExpr;
    ((void) (0));
    if( pLevel->iLeftJoin && !(((pE)->flags&(0x0001))==(0x0001)) ){
      continue;
    }
    sqlite3ExprIfFalse(pParse, pE, addrCont, 0x08);
    pTerm->wtFlags |= 0x04;
  }




  if( pLevel->iLeftJoin ){
    pLevel->addrFirst = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeAddOp2(v, 7, 1, pLevel->iLeftJoin);
                                            ;
    sqlite3ExprCacheClear(pParse);
    for(pTerm=pWC->a, j=0; j<pWC->nTerm; j++, pTerm++){
                                               ;
                                             ;
      if( pTerm->wtFlags & (0x02|0x04) ) continue;
      if( (pTerm->prereqAll & notReady)!=0 ){
        ((void) (0));
        continue;
      }
      ((void) (0));
      sqlite3ExprIfFalse(pParse, pTerm->pExpr, addrCont, 0x08);
      pTerm->wtFlags |= 0x04;
    }
  }
  sqlite3ReleaseTempReg(pParse, iReleaseReg);

  return notReady;
}
# 101785 "ext/sqlite3/libsqlite/sqlite3.c"
static void whereInfoFree(sqlite3 *db, WhereInfo *pWInfo){
  if( (pWInfo) ){
    int i;
    for(i=0; i<pWInfo->nLevel; i++){
      sqlite3_index_info *pInfo = pWInfo->a[i].pIdxInfo;
      if( pInfo ){

        if( pInfo->needToFreeIdxStr ){
          sqlite3_free(pInfo->idxStr);
        }
        sqlite3DbFree(db, pInfo);
      }
      if( pWInfo->a[i].plan.wsFlags & 0x20000000 ){
        Index *pIdx = pWInfo->a[i].plan.u.pIdx;
        if( pIdx ){
          sqlite3DbFree(db, pIdx->zColAff);
          sqlite3DbFree(db, pIdx);
        }
      }
    }
    whereClauseClear(pWInfo->pWC);
    sqlite3DbFree(db, pWInfo);
  }
}
# 101899 "ext/sqlite3/libsqlite/sqlite3.c"
static WhereInfo *sqlite3WhereBegin(
  Parse *pParse,
  SrcList *pTabList,
  Expr *pWhere,
  ExprList **ppOrderBy,
  u16 wctrlFlags
){
  int i;
  int nByteWInfo;
  int nTabList;
  WhereInfo *pWInfo;
  Vdbe *v = pParse->pVdbe;
  Bitmask notReady;
  WhereMaskSet *pMaskSet;
  WhereClause *pWC;
  struct SrcList_item *pTabItem;
  WhereLevel *pLevel;
  int iFrom;
  int andFlags;
  sqlite3 *db;




                                 ;
  if( pTabList->nSrc>((int)(sizeof(Bitmask)*8)) ){
    sqlite3ErrorMsg(pParse, "at most %d tables in a join", ((int)(sizeof(Bitmask)*8)));
    return 0;
  }






  nTabList = (wctrlFlags & 0x0080) ? 1 : pTabList->nSrc;
# 101943 "ext/sqlite3/libsqlite/sqlite3.c"
  db = pParse->db;
  nByteWInfo = (((sizeof(WhereInfo)+(nTabList-1)*sizeof(WhereLevel))+7)&~7);
  pWInfo = sqlite3DbMallocZero(db,
      nByteWInfo +
      sizeof(WhereClause) +
      sizeof(WhereMaskSet)
  );
  if( db->mallocFailed ){
    sqlite3DbFree(db, pWInfo);
    pWInfo = 0;
    goto whereBeginError;
  }
  pWInfo->nLevel = nTabList;
  pWInfo->pParse = pParse;
  pWInfo->pTabList = pTabList;
  pWInfo->iBreak = sqlite3VdbeMakeLabel(v);
  pWInfo->pWC = pWC = (WhereClause *)&((u8 *)pWInfo)[nByteWInfo];
  pWInfo->wctrlFlags = wctrlFlags;
  pWInfo->savedNQueryLoop = pParse->nQueryLoop;
  pMaskSet = (WhereMaskSet*)&pWC[1];




  memset(pMaskSet, 0, sizeof(*pMaskSet));
  whereClauseInit(pWC, pParse, pMaskSet);
  sqlite3ExprCodeConstants(pParse, pWhere);
  whereSplit(pWC, pWhere, 69);




  if( pWhere && (nTabList==0 || sqlite3ExprIsConstantNotJoin(pWhere)) ){
    sqlite3ExprIfFalse(pParse, pWhere, pWInfo->iBreak, 0x08);
    pWhere = 0;
  }
# 102001 "ext/sqlite3/libsqlite/sqlite3.c"
  ((void) (0));
  for(i=0; i<pTabList->nSrc; i++){
    createMask(pMaskSet, pTabList->a[i].iCursor);

    if( (pTabList->a[i].pTab) && (((pTabList->a[i].pTab)->tabFlags & 0x10)!=0) ){
      pWC->vmask |= ((Bitmask)1 << i);
    }

  }
# 102026 "ext/sqlite3/libsqlite/sqlite3.c"
  exprAnalyzeAll(pTabList, pWC);
  if( db->mallocFailed ){
    goto whereBeginError;
  }
# 102046 "ext/sqlite3/libsqlite/sqlite3.c"
  notReady = ~(Bitmask)0;
  andFlags = ~0;
                                           ;
  for(i=iFrom=0, pLevel=pWInfo->a; i<nTabList; i++, pLevel++){
    WhereCost bestPlan;
    Index *pIdx;
    int j;
    int bestJ = -1;
    Bitmask m;
    int isOptimal;
    int nUnconstrained;
    Bitmask notIndexed;

    memset(&bestPlan, 0, sizeof(bestPlan));
    bestPlan.rCost = (1e99);
                                                         ;
# 102106 "ext/sqlite3/libsqlite/sqlite3.c"
    nUnconstrained = 0;
    notIndexed = 0;
    for(isOptimal=(iFrom<nTabList-1); isOptimal>=0 && bestJ<0; isOptimal--){
      Bitmask mask;
      for(j=iFrom, pTabItem=&pTabList->a[j]; j<nTabList; j++, pTabItem++){
        int doNotReorder;
        WhereCost sCost;
        ExprList *pOrderBy;

        doNotReorder = (pTabItem->jointype & (0x0008|0x0002))!=0;
        if( j!=iFrom && doNotReorder ) break;
        m = getMask(pMaskSet, pTabItem->iCursor);
        if( (m & notReady)==0 ){
          if( j==iFrom ) iFrom++;
          continue;
        }
        mask = (isOptimal ? m : notReady);
        pOrderBy = ((i==0 && ppOrderBy )?*ppOrderBy:0);
        if( pTabItem->pIndex==0 ) nUnconstrained++;


                                  ;
        ((void) (0));

        if( (((pTabItem->pTab)->tabFlags & 0x10)!=0) ){
          sqlite3_index_info **pp = &pWInfo->a[j].pIdxInfo;
          bestVirtualIndex(pParse, pWC, pTabItem, mask, notReady, pOrderBy,
                           &sCost, pp);
        }else

        {
          bestBtreeIndex(pParse, pWC, pTabItem, mask, notReady, pOrderBy,
                         &sCost);
        }
        ((void) (0));



        ((void) (0));



        if( isOptimal && (sCost.plan.wsFlags & 0x100f3000)==0 ){
          notIndexed |= m;
        }
# 102172 "ext/sqlite3/libsqlite/sqlite3.c"
        if( (sCost.used&notReady)==0
            && (bestJ<0 || (notIndexed&m)!=0
                || (bestPlan.plan.wsFlags & 0x100f3000)==0
                || (sCost.plan.wsFlags & 0x100f3000)!=0)
            && (nUnconstrained==0 || pTabItem->pIndex==0
                || ((sCost.plan.wsFlags & 0x100f3000)!=0))
            && (bestJ<0 || sCost.rCost<bestPlan.rCost
                || (sCost.rCost<=bestPlan.rCost
                 && sCost.plan.nRow<bestPlan.plan.nRow))
        ){


                                                       ;
          bestPlan = sCost;
          bestJ = j;
        }
        if( doNotReorder ) break;
      }
    }
    ((void) (0));
    ((void) (0));


                                                                             ;
    if( (bestPlan.plan.wsFlags & 0x01000000)!=0 ){
      *ppOrderBy = 0;
    }
    andFlags &= bestPlan.plan.wsFlags;
    pLevel->plan = bestPlan.plan;
                                                     ;
                                                        ;
    if( bestPlan.plan.wsFlags & (0x000f0000|0x20000000) ){
      pLevel->iIdxCur = pParse->nTab++;
    }else{
      pLevel->iIdxCur = -1;
    }
    notReady &= ~getMask(pMaskSet, pTabList->a[bestJ].iCursor);
    pLevel->iFrom = (u8)bestJ;
    if( bestPlan.plan.nRow>=(double)1 ){
      pParse->nQueryLoop *= bestPlan.plan.nRow;
    }






    pIdx = pTabList->a[bestJ].pIndex;
    if( pIdx ){
      if( (bestPlan.plan.wsFlags & 0x000f0000)==0 ){
        sqlite3ErrorMsg(pParse, "cannot use index: %s", pIdx->zName);
        goto whereBeginError;
      }else{



        ((void) (0));
      }
    }
  }
                                              ;
  if( pParse->nErr || db->mallocFailed ){
    goto whereBeginError;
  }




  if( (andFlags & 0x04000000)!=0 && ppOrderBy ){
    *ppOrderBy = 0;
  }






  ((void) (0));
  if( (wctrlFlags & 0x0004)!=0 && (andFlags & 0x04000000)!=0 ){
    pWInfo->okOnePass = 1;
    pWInfo->a[0].plan.wsFlags &= ~0x00800000;
  }




  sqlite3CodeVerifySchema(pParse, -1);
  notReady = ~(Bitmask)0;
  pWInfo->nRowOut = (double)1;
  for(i=0, pLevel=pWInfo->a; i<nTabList; i++, pLevel++){
    Table *pTab;
    int iDb;

    pTabItem = &pTabList->a[pLevel->iFrom];
    pTab = pTabItem->pTab;
    pLevel->iTabCur = pTabItem->iCursor;
    pWInfo->nRowOut *= pLevel->plan.nRow;
    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
    if( (pTab->tabFlags & 0x02)!=0 || pTab->pSelect ){

    }else

    if( (pLevel->plan.wsFlags & 0x08000000)!=0 ){
      const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);
      int iCur = pTabItem->iCursor;
      sqlite3VdbeAddOp4(v, 127, iCur, 0, 0, pVTab, (-10));
    }else

    if( (pLevel->plan.wsFlags & 0x00800000)==0
         && (wctrlFlags & 0x0010)==0 ){
      int op = pWInfo->okOnePass ? 39 : 38;
      sqlite3OpenTable(pParse, pTabItem->iCursor, iDb, pTab, op);
                                   ;
                                 ;
      if( !pWInfo->okOnePass && pTab->nCol<((int)(sizeof(Bitmask)*8)) ){
        Bitmask b = pTabItem->colUsed;
        int n = 0;
        for(; b; b=b>>1, n++){}
        sqlite3VdbeChangeP4(v, sqlite3VdbeCurrentAddr(v)-1,
                            ((void*)(long int)(n)), (-14));
        ((void) (0));
      }
    }else{
      sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
    }

    if( (pLevel->plan.wsFlags & 0x20000000)!=0 ){
      constructAutomaticIndex(pParse, pWC, pTabItem, notReady, pLevel);
    }else

    if( (pLevel->plan.wsFlags & 0x000f0000)!=0 ){
      Index *pIx = pLevel->plan.u.pIdx;
      KeyInfo *pKey = sqlite3IndexKeyinfo(pParse, pIx);
      int iIdxCur = pLevel->iIdxCur;
      ((void) (0));
      ((void) (0));
      sqlite3VdbeAddOp4(v, 38, iIdxCur, pIx->tnum, iDb,
                        (char*)pKey, (-16));
                                        ;
    }
    sqlite3CodeVerifySchema(pParse, iDb);
    notReady &= ~getMask(pWC->pMaskSet, pTabItem->iCursor);
  }
  pWInfo->iTop = sqlite3VdbeCurrentAddr(v);
  if( db->mallocFailed ) goto whereBeginError;





  notReady = ~(Bitmask)0;
  for(i=0; i<nTabList; i++){
    pLevel = &pWInfo->a[i];
    explainOneScan(pParse, pTabList, pLevel, i, pLevel->iFrom, wctrlFlags);
    notReady = codeOneLoopStart(pWInfo, i, wctrlFlags, notReady);
    pWInfo->iContinue = pLevel->addrCont;
  }
# 102382 "ext/sqlite3/libsqlite/sqlite3.c"
  return pWInfo;


whereBeginError:
  if( pWInfo ){
    pParse->nQueryLoop = pWInfo->savedNQueryLoop;
    whereInfoFree(db, pWInfo);
  }
  return 0;
}





static void sqlite3WhereEnd(WhereInfo *pWInfo){
  Parse *pParse = pWInfo->pParse;
  Vdbe *v = pParse->pVdbe;
  int i;
  WhereLevel *pLevel;
  SrcList *pTabList = pWInfo->pTabList;
  sqlite3 *db = pParse->db;



  sqlite3ExprCacheClear(pParse);
  for(i=pWInfo->nLevel-1; i>=0; i--){
    pLevel = &pWInfo->a[i];
    sqlite3VdbeResolveLabel(v, pLevel->addrCont);
    if( pLevel->op!=137 ){
      sqlite3VdbeAddOp2(v, pLevel->op, pLevel->p1, pLevel->p2);
      sqlite3VdbeChangeP5(v, pLevel->p5);
    }
    if( pLevel->plan.wsFlags & 0x000f1000 && pLevel->u.in.nIn>0 ){
      struct InLoop *pIn;
      int j;
      sqlite3VdbeResolveLabel(v, pLevel->addrNxt);
      for(j=pLevel->u.in.nIn, pIn=&pLevel->u.in.aInLoop[j-1]; j>0; j--, pIn--){
        sqlite3VdbeJumpHere(v, pIn->addrInTop+1);
        sqlite3VdbeAddOp2(v, 67, pIn->iCur, pIn->addrInTop);
        sqlite3VdbeJumpHere(v, pIn->addrInTop-1);
      }
      sqlite3DbFree(db, pLevel->u.in.aInLoop);
    }
    sqlite3VdbeResolveLabel(v, pLevel->addrBrk);
    if( pLevel->iLeftJoin ){
      int addr;
      addr = sqlite3VdbeAddOp1(v, 113, pLevel->iLeftJoin);
      ((void) (0));

      if( (pLevel->plan.wsFlags & 0x00800000)==0 ){
        sqlite3VdbeAddOp1(v, 62, pTabList->a[i].iCursor);
      }
      if( pLevel->iIdxCur>=0 ){
        sqlite3VdbeAddOp1(v, 62, pLevel->iIdxCur);
      }
      if( pLevel->op==3 ){
        sqlite3VdbeAddOp2(v, 2, pLevel->p1, pLevel->addrFirst);
      }else{
        sqlite3VdbeAddOp2(v, 1, 0, pLevel->addrFirst);
      }
      sqlite3VdbeJumpHere(v, addr);
    }
  }




  sqlite3VdbeResolveLabel(v, pWInfo->iBreak);



  ((void) (0));
  for(i=0, pLevel=pWInfo->a; i<pWInfo->nLevel; i++, pLevel++){
    struct SrcList_item *pTabItem = &pTabList->a[pLevel->iFrom];
    Table *pTab = pTabItem->pTab;
    ((void) (0));
    if( (pTab->tabFlags & 0x02)==0
     && pTab->pSelect==0
     && (pWInfo->wctrlFlags & 0x0020)==0
    ){
      int ws = pLevel->plan.wsFlags;
      if( !pWInfo->okOnePass && (ws & 0x00800000)==0 ){
        sqlite3VdbeAddOp1(v, 43, pTabItem->iCursor);
      }
      if( (ws & 0x000f0000)!=0 && (ws & 0x20000000)==0 ){
        sqlite3VdbeAddOp1(v, 43, pLevel->iIdxCur);
      }
    }
# 102485 "ext/sqlite3/libsqlite/sqlite3.c"
    if( (pLevel->plan.wsFlags & 0x000f0000)!=0 && !db->mallocFailed){
      int k, j, last;
      VdbeOp *pOp;
      Index *pIdx = pLevel->plan.u.pIdx;

      ((void) (0));
      pOp = sqlite3VdbeGetOp(v, pWInfo->iTop);
      last = sqlite3VdbeCurrentAddr(v);
      for(k=pWInfo->iTop; k<last; k++, pOp++){
        if( pOp->p1!=pLevel->iTabCur ) continue;
        if( pOp->opcode==28 ){
          for(j=0; j<pIdx->nColumn; j++){
            if( pOp->p2==pIdx->aiColumn[j] ){
              pOp->p2 = j;
              pOp->p1 = pLevel->iIdxCur;
              break;
            }
          }
          ((void) (0));

        }else if( pOp->opcode==61 ){
          pOp->p1 = pLevel->iIdxCur;
          pOp->opcode = 72;
        }
      }
    }
  }



  pParse->nQueryLoop = pWInfo->savedNQueryLoop;
  whereInfoFree(db, pWInfo);
  return;
}
# 102550 "ext/sqlite3/libsqlite/sqlite3.c"
struct LimitVal {
  Expr *pLimit;
  Expr *pOffset;
};





struct LikeOp {
  Token eOperator;
  int not;
};
# 102573 "ext/sqlite3/libsqlite/sqlite3.c"
struct TrigEvent { int a; IdList * b; };




struct AttachKey { int type; Token key; };






  static void spanSet(ExprSpan *pOut, Token *pStart, Token *pEnd){
    pOut->zStart = pStart->z;
    pOut->zEnd = &pEnd->z[pEnd->n];
  }





  static void spanExpr(ExprSpan *pOut, Parse *pParse, int op, Token *pValue){
    pOut->pExpr = sqlite3PExpr(pParse, op, 0, 0, pValue);
    pOut->zStart = pValue->z;
    pOut->zEnd = &pValue->z[pValue->n];
  }




  static void spanBinaryExpr(
    ExprSpan *pOut,
    Parse *pParse,
    int op,
    ExprSpan *pLeft,
    ExprSpan *pRight
  ){
    pOut->pExpr = sqlite3PExpr(pParse, op, pLeft->pExpr, pRight->pExpr, 0);
    pOut->zStart = pLeft->zStart;
    pOut->zEnd = pRight->zEnd;
  }



  static void spanUnaryPostfix(
    ExprSpan *pOut,
    Parse *pParse,
    int op,
    ExprSpan *pOperand,
    Token *pPostOp
  ){
    pOut->pExpr = sqlite3PExpr(pParse, op, pOperand->pExpr, 0, 0);
    pOut->zStart = pOperand->zStart;
    pOut->zEnd = &pPostOp->z[pPostOp->n];
  }



  static void binaryToUnaryIfNull(Parse *pParse, Expr *pY, Expr *pA, int op){
    sqlite3 *db = pParse->db;
    if( db->mallocFailed==0 && pY->op==98 ){
      pA->op = (u8)op;
      sqlite3ExprDelete(db, pA->pRight);
      pA->pRight = 0;
    }
  }



  static void spanUnaryPrefix(
    ExprSpan *pOut,
    Parse *pParse,
    int op,
    ExprSpan *pOperand,
    Token *pPreOp
  ){
    pOut->pExpr = sqlite3PExpr(pParse, op, pOperand->pExpr, 0, 0);
    pOut->zStart = pPreOp->z;
    pOut->zEnd = pOperand->zEnd;
  }
# 102707 "ext/sqlite3/libsqlite/sqlite3.c"
typedef union {
  int yyinit;
  Token yy0;
  int yy4;
  struct TrigEvent yy90;
  ExprSpan yy118;
  TriggerStep* yy203;
  u8 yy210;
  struct {int value; int mask;} yy215;
  SrcList* yy259;
  struct LimitVal yy292;
  Expr* yy314;
  ExprList* yy322;
  struct LikeOp yy342;
  IdList* yy384;
  Select* yy387;
} YYMINORTYPE;
# 102740 "ext/sqlite3/libsqlite/sqlite3.c"
static const YYMINORTYPE yyzerominor = { 0 };
# 102803 "ext/sqlite3/libsqlite/sqlite3.c"
static const unsigned short int yy_action[] = {
               313, 960, 186, 419, 2, 172, 627, 597, 55, 55,
                55, 55, 48, 53, 53, 53, 53, 52, 52, 51,
                51, 51, 50, 238, 302, 283, 623, 622, 516, 515,
               590, 584, 55, 55, 55, 55, 282, 53, 53, 53,
                53, 52, 52, 51, 51, 51, 50, 238, 6, 56,
                57, 47, 582, 581, 583, 583, 54, 54, 55, 55,
                55, 55, 608, 53, 53, 53, 53, 52, 52, 51,
                51, 51, 50, 238, 313, 597, 409, 330, 579, 579,
                32, 53, 53, 53, 53, 52, 52, 51, 51, 51,
                50, 238, 330, 217, 620, 619, 166, 411, 624, 382,
               379, 378, 7, 491, 590, 584, 200, 199, 198, 58,
               377, 300, 414, 621, 481, 66, 623, 622, 621, 580,
               254, 601, 94, 56, 57, 47, 582, 581, 583, 583,
                54, 54, 55, 55, 55, 55, 671, 53, 53, 53,
                53, 52, 52, 51, 51, 51, 50, 238, 313, 532,
               226, 506, 507, 133, 177, 139, 284, 385, 279, 384,
               169, 197, 342, 398, 251, 226, 253, 275, 388, 167,
               139, 284, 385, 279, 384, 169, 570, 236, 590, 584,
               672, 240, 275, 157, 620, 619, 554, 437, 51, 51,
                51, 50, 238, 343, 439, 553, 438, 56, 57, 47,
               582, 581, 583, 583, 54, 54, 55, 55, 55, 55,
               465, 53, 53, 53, 53, 52, 52, 51, 51, 51,
                50, 238, 313, 390, 52, 52, 51, 51, 51, 50,
               238, 391, 166, 491, 566, 382, 379, 378, 409, 440,
               579, 579, 252, 440, 607, 66, 377, 513, 621, 49,
                46, 147, 590, 584, 621, 16, 466, 189, 621, 441,
               442, 673, 526, 441, 340, 577, 595, 64, 194, 482,
               434, 56, 57, 47, 582, 581, 583, 583, 54, 54,
                55, 55, 55, 55, 30, 53, 53, 53, 53, 52,
                52, 51, 51, 51, 50, 238, 313, 593, 593, 593,
               387, 578, 606, 493, 259, 351, 258, 411, 1, 623,
               622, 496, 623, 622, 65, 240, 623, 622, 597, 443,
               237, 239, 414, 341, 237, 602, 590, 584, 18, 603,
               166, 601, 87, 382, 379, 378, 67, 623, 622, 38,
               623, 622, 176, 270, 377, 56, 57, 47, 582, 581,
               583, 583, 54, 54, 55, 55, 55, 55, 175, 53,
                53, 53, 53, 52, 52, 51, 51, 51, 50, 238,
               313, 396, 233, 411, 531, 565, 317, 620, 619, 44,
               620, 619, 240, 206, 620, 619, 597, 266, 414, 268,
               409, 597, 579, 579, 352, 184, 505, 601, 73, 533,
               590, 584, 466, 548, 190, 620, 619, 576, 620, 619,
               547, 383, 551, 35, 332, 575, 574, 600, 504, 56,
                57, 47, 582, 581, 583, 583, 54, 54, 55, 55,
                55, 55, 567, 53, 53, 53, 53, 52, 52, 51,
                51, 51, 50, 238, 313, 411, 561, 561, 528, 364,
               259, 351, 258, 183, 361, 549, 524, 374, 411, 597,
               414, 240, 560, 560, 409, 604, 579, 579, 328, 601,
                93, 623, 622, 414, 590, 584, 237, 564, 559, 559,
               520, 402, 601, 87, 409, 210, 579, 579, 168, 421,
               950, 519, 950, 56, 57, 47, 582, 581, 583, 583,
                54, 54, 55, 55, 55, 55, 192, 53, 53, 53,
                53, 52, 52, 51, 51, 51, 50, 238, 313, 600,
               293, 563, 511, 234, 357, 146, 475, 475, 367, 411,
               562, 411, 358, 542, 425, 171, 411, 215, 144, 620,
               619, 544, 318, 353, 414, 203, 414, 275, 590, 584,
               549, 414, 174, 601, 94, 601, 79, 558, 471, 61,
               601, 79, 421, 949, 350, 949, 34, 56, 57, 47,
               582, 581, 583, 583, 54, 54, 55, 55, 55, 55,
               535, 53, 53, 53, 53, 52, 52, 51, 51, 51,
                50, 238, 313, 307, 424, 394, 272, 49, 46, 147,
               349, 322, 4, 411, 491, 312, 321, 425, 568, 492,
               216, 264, 407, 575, 574, 429, 66, 549, 414, 621,
               540, 602, 590, 584, 13, 603, 621, 601, 72, 12,
               618, 617, 616, 202, 210, 621, 546, 469, 422, 319,
               148, 56, 57, 47, 582, 581, 583, 583, 54, 54,
                55, 55, 55, 55, 338, 53, 53, 53, 53, 52,
                52, 51, 51, 51, 50, 238, 313, 600, 600, 411,
                39, 21, 37, 170, 237, 875, 411, 572, 572, 201,
               144, 473, 538, 331, 414, 474, 143, 146, 630, 628,
               334, 414, 353, 601, 68, 168, 590, 584, 132, 365,
               601, 96, 307, 423, 530, 336, 49, 46, 147, 568,
               406, 216, 549, 360, 529, 56, 57, 47, 582, 581,
               583, 583, 54, 54, 55, 55, 55, 55, 411, 53,
                53, 53, 53, 52, 52, 51, 51, 51, 50, 238,
               313, 411, 605, 414, 484, 510, 172, 422, 597, 318,
               496, 485, 601, 99, 411, 142, 414, 411, 231, 411,
               540, 411, 359, 629, 2, 601, 97, 426, 308, 414,
               590, 584, 414, 20, 414, 621, 414, 621, 601, 106,
               503, 601, 105, 601, 108, 601, 109, 204, 28, 56,
                57, 47, 582, 581, 583, 583, 54, 54, 55, 55,
                55, 55, 411, 53, 53, 53, 53, 52, 52, 51,
                51, 51, 50, 238, 313, 411, 597, 414, 411, 276,
               214, 600, 411, 366, 213, 381, 601, 134, 274, 500,
               414, 167, 130, 414, 621, 411, 354, 414, 376, 601,
               135, 129, 601, 100, 590, 584, 601, 104, 522, 521,
               414, 621, 224, 273, 600, 167, 327, 282, 600, 601,
               103, 468, 521, 56, 57, 47, 582, 581, 583, 583,
                54, 54, 55, 55, 55, 55, 411, 53, 53, 53,
                53, 52, 52, 51, 51, 51, 50, 238, 313, 411,
                27, 414, 411, 375, 276, 167, 359, 544, 50, 238,
               601, 95, 128, 223, 414, 411, 165, 414, 411, 621,
               411, 621, 612, 601, 102, 372, 601, 76, 590, 584,
               414, 570, 236, 414, 470, 414, 167, 621, 188, 601,
                98, 225, 601, 138, 601, 137, 232, 56, 45, 47,
               582, 581, 583, 583, 54, 54, 55, 55, 55, 55,
               411, 53, 53, 53, 53, 52, 52, 51, 51, 51,
                50, 238, 313, 276, 276, 414, 411, 276, 544, 459,
               359, 171, 209, 479, 601, 136, 628, 334, 621, 621,
               125, 414, 621, 368, 411, 621, 257, 540, 589, 588,
               601, 75, 590, 584, 458, 446, 23, 23, 124, 414,
               326, 325, 621, 427, 324, 309, 600, 288, 601, 92,
               586, 585, 57, 47, 582, 581, 583, 583, 54, 54,
                55, 55, 55, 55, 411, 53, 53, 53, 53, 52,
                52, 51, 51, 51, 50, 238, 313, 587, 411, 414,
               411, 207, 611, 476, 171, 472, 160, 123, 601, 91,
               323, 261, 15, 414, 464, 414, 411, 621, 411, 354,
               222, 411, 601, 74, 601, 90, 590, 584, 159, 264,
               158, 414, 461, 414, 621, 600, 414, 121, 120, 25,
               601, 89, 601, 101, 621, 601, 88, 47, 582, 581,
               583, 583, 54, 54, 55, 55, 55, 55, 544, 53,
                53, 53, 53, 52, 52, 51, 51, 51, 50, 238,
                43, 405, 263, 3, 610, 264, 140, 415, 622, 24,
               410, 11, 456, 594, 118, 155, 219, 452, 408, 621,
               621, 621, 156, 43, 405, 621, 3, 286, 621, 113,
               415, 622, 111, 445, 411, 400, 557, 403, 545, 10,
               411, 408, 264, 110, 205, 436, 541, 566, 453, 414,
               621, 621, 63, 621, 435, 414, 411, 621, 601, 94,
               403, 621, 411, 337, 601, 86, 150, 40, 41, 534,
               566, 414, 242, 264, 42, 413, 412, 414, 600, 595,
               601, 85, 191, 333, 107, 451, 601, 84, 621, 539,
                40, 41, 420, 230, 411, 149, 316, 42, 413, 412,
               398, 127, 595, 315, 621, 399, 278, 625, 181, 414,
               593, 593, 593, 592, 591, 14, 450, 411, 601, 71,
               240, 621, 43, 405, 264, 3, 615, 180, 264, 415,
               622, 614, 414, 593, 593, 593, 592, 591, 14, 621,
               408, 601, 70, 621, 417, 33, 405, 613, 3, 411,
               264, 411, 415, 622, 418, 626, 178, 509, 8, 403,
               241, 416, 126, 408, 414, 621, 414, 449, 208, 566,
               240, 221, 621, 601, 83, 601, 82, 599, 297, 277,
               296, 30, 403, 31, 395, 264, 295, 397, 489, 40,
                41, 411, 566, 220, 621, 294, 42, 413, 412, 271,
               621, 595, 600, 621, 59, 60, 414, 269, 267, 623,
               622, 36, 40, 41, 621, 601, 81, 598, 235, 42,
               413, 412, 621, 621, 595, 265, 344, 411, 248, 556,
               173, 185, 593, 593, 593, 592, 591, 14, 218, 29,
               621, 543, 414, 305, 304, 303, 179, 301, 411, 566,
               454, 601, 80, 289, 335, 593, 593, 593, 592, 591,
                14, 411, 287, 414, 151, 392, 246, 260, 411, 196,
               195, 523, 601, 69, 411, 245, 414, 526, 537, 285,
               389, 595, 621, 414, 536, 601, 17, 362, 153, 414,
               466, 463, 601, 78, 154, 414, 462, 152, 601, 77,
               355, 255, 621, 455, 601, 9, 621, 386, 444, 517,
               247, 621, 593, 593, 593, 621, 621, 244, 621, 243,
               430, 518, 292, 621, 329, 621, 145, 393, 280, 513,
               291, 131, 621, 514, 621, 621, 311, 621, 259, 346,
               249, 621, 621, 229, 314, 621, 228, 512, 227, 240,
               494, 488, 310, 164, 487, 486, 373, 480, 163, 262,
               369, 371, 162, 26, 212, 478, 477, 161, 141, 363,
               467, 122, 339, 187, 119, 348, 347, 117, 116, 115,
               114, 112, 182, 457, 320, 22, 433, 432, 448, 19,
               609, 431, 428, 62, 193, 596, 573, 298, 555, 552,
               571, 404, 290, 380, 498, 510, 495, 306, 281, 499,
               250, 5, 497, 460, 345, 447, 569, 550, 238, 299,
               527, 525, 508, 961, 502, 501, 961, 401, 961, 211,
               490, 356, 256, 961, 483, 961, 961, 961, 961, 961,
               961, 961, 961, 961, 961, 961, 370,
};
static const unsigned char yy_lookahead[] = {
                19, 142, 143, 144, 145, 24, 1, 26, 77, 78,
                79, 80, 81, 82, 83, 84, 85, 86, 87, 88,
                89, 90, 91, 92, 15, 98, 26, 27, 7, 8,
                49, 50, 77, 78, 79, 80, 109, 82, 83, 84,
                85, 86, 87, 88, 89, 90, 91, 92, 22, 68,
                69, 70, 71, 72, 73, 74, 75, 76, 77, 78,
                79, 80, 23, 82, 83, 84, 85, 86, 87, 88,
                89, 90, 91, 92, 19, 94, 112, 19, 114, 115,
                25, 82, 83, 84, 85, 86, 87, 88, 89, 90,
                91, 92, 19, 22, 94, 95, 96, 150, 150, 99,
               100, 101, 76, 150, 49, 50, 105, 106, 107, 54,
               110, 158, 165, 165, 161, 162, 26, 27, 165, 113,
                16, 174, 175, 68, 69, 70, 71, 72, 73, 74,
                75, 76, 77, 78, 79, 80, 118, 82, 83, 84,
                85, 86, 87, 88, 89, 90, 91, 92, 19, 23,
                92, 97, 98, 24, 96, 97, 98, 99, 100, 101,
               102, 25, 97, 216, 60, 92, 62, 109, 221, 25,
                97, 98, 99, 100, 101, 102, 86, 87, 49, 50,
               118, 116, 109, 25, 94, 95, 32, 97, 88, 89,
                90, 91, 92, 128, 104, 41, 106, 68, 69, 70,
                71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
                11, 82, 83, 84, 85, 86, 87, 88, 89, 90,
                91, 92, 19, 19, 86, 87, 88, 89, 90, 91,
                92, 27, 96, 150, 66, 99, 100, 101, 112, 150,
               114, 115, 138, 150, 161, 162, 110, 103, 165, 222,
               223, 224, 49, 50, 165, 22, 57, 24, 165, 170,
               171, 118, 94, 170, 171, 23, 98, 25, 185, 186,
               243, 68, 69, 70, 71, 72, 73, 74, 75, 76,
                77, 78, 79, 80, 126, 82, 83, 84, 85, 86,
                87, 88, 89, 90, 91, 92, 19, 129, 130, 131,
                88, 23, 172, 173, 105, 106, 107, 150, 22, 26,
                27, 181, 26, 27, 22, 116, 26, 27, 26, 230,
               231, 197, 165, 230, 231, 113, 49, 50, 204, 117,
                96, 174, 175, 99, 100, 101, 22, 26, 27, 136,
                26, 27, 118, 16, 110, 68, 69, 70, 71, 72,
                73, 74, 75, 76, 77, 78, 79, 80, 118, 82,
                83, 84, 85, 86, 87, 88, 89, 90, 91, 92,
                19, 214, 215, 150, 23, 23, 155, 94, 95, 22,
                94, 95, 116, 160, 94, 95, 94, 60, 165, 62,
               112, 26, 114, 115, 128, 23, 36, 174, 175, 88,
                49, 50, 57, 120, 22, 94, 95, 23, 94, 95,
               120, 51, 25, 136, 169, 170, 171, 194, 58, 68,
                69, 70, 71, 72, 73, 74, 75, 76, 77, 78,
                79, 80, 23, 82, 83, 84, 85, 86, 87, 88,
                89, 90, 91, 92, 19, 150, 12, 12, 23, 228,
               105, 106, 107, 23, 233, 25, 165, 19, 150, 94,
               165, 116, 28, 28, 112, 174, 114, 115, 108, 174,
               175, 26, 27, 165, 49, 50, 231, 11, 44, 44,
                46, 46, 174, 175, 112, 160, 114, 115, 50, 22,
                23, 57, 25, 68, 69, 70, 71, 72, 73, 74,
                75, 76, 77, 78, 79, 80, 119, 82, 83, 84,
                85, 86, 87, 88, 89, 90, 91, 92, 19, 194,
               225, 23, 23, 215, 19, 95, 105, 106, 107, 150,
                23, 150, 27, 23, 67, 25, 150, 206, 207, 94,
                95, 166, 104, 218, 165, 22, 165, 109, 49, 50,
               120, 165, 25, 174, 175, 174, 175, 23, 21, 234,
               174, 175, 22, 23, 239, 25, 25, 68, 69, 70,
                71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
               205, 82, 83, 84, 85, 86, 87, 88, 89, 90,
                91, 92, 19, 22, 23, 216, 23, 222, 223, 224,
                63, 220, 35, 150, 150, 163, 220, 67, 166, 167,
               168, 150, 169, 170, 171, 161, 162, 25, 165, 165,
               150, 113, 49, 50, 25, 117, 165, 174, 175, 35,
                 7, 8, 9, 160, 160, 165, 120, 100, 67, 247,
               248, 68, 69, 70, 71, 72, 73, 74, 75, 76,
                77, 78, 79, 80, 193, 82, 83, 84, 85, 86,
                87, 88, 89, 90, 91, 92, 19, 194, 194, 150,
               135, 24, 137, 35, 231, 138, 150, 129, 130, 206,
               207, 30, 27, 213, 165, 34, 118, 95, 0, 1,
                 2, 165, 218, 174, 175, 50, 49, 50, 22, 48,
               174, 175, 22, 23, 23, 244, 222, 223, 224, 166,
               167, 168, 120, 239, 23, 68, 69, 70, 71, 72,
                73, 74, 75, 76, 77, 78, 79, 80, 150, 82,
                83, 84, 85, 86, 87, 88, 89, 90, 91, 92,
                19, 150, 173, 165, 181, 182, 24, 67, 26, 104,
               181, 188, 174, 175, 150, 39, 165, 150, 52, 150,
               150, 150, 150, 144, 145, 174, 175, 249, 250, 165,
                49, 50, 165, 52, 165, 165, 165, 165, 174, 175,
                29, 174, 175, 174, 175, 174, 175, 160, 22, 68,
                69, 70, 71, 72, 73, 74, 75, 76, 77, 78,
                79, 80, 150, 82, 83, 84, 85, 86, 87, 88,
                89, 90, 91, 92, 19, 150, 94, 165, 150, 150,
               160, 194, 150, 213, 160, 52, 174, 175, 23, 23,
               165, 25, 22, 165, 165, 150, 150, 165, 52, 174,
               175, 22, 174, 175, 49, 50, 174, 175, 190, 191,
               165, 165, 240, 23, 194, 25, 187, 109, 194, 174,
               175, 190, 191, 68, 69, 70, 71, 72, 73, 74,
                75, 76, 77, 78, 79, 80, 150, 82, 83, 84,
                85, 86, 87, 88, 89, 90, 91, 92, 19, 150,
                22, 165, 150, 23, 150, 25, 150, 166, 91, 92,
               174, 175, 22, 217, 165, 150, 102, 165, 150, 165,
               150, 165, 150, 174, 175, 19, 174, 175, 49, 50,
               165, 86, 87, 165, 23, 165, 25, 165, 24, 174,
               175, 187, 174, 175, 174, 175, 205, 68, 69, 70,
                71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
               150, 82, 83, 84, 85, 86, 87, 88, 89, 90,
                91, 92, 19, 150, 150, 165, 150, 150, 166, 23,
               150, 25, 160, 20, 174, 175, 1, 2, 165, 165,
               104, 165, 165, 43, 150, 165, 240, 150, 49, 50,
               174, 175, 49, 50, 23, 23, 25, 25, 53, 165,
               187, 187, 165, 23, 187, 25, 194, 205, 174, 175,
                71, 72, 69, 70, 71, 72, 73, 74, 75, 76,
                77, 78, 79, 80, 150, 82, 83, 84, 85, 86,
                87, 88, 89, 90, 91, 92, 19, 98, 150, 165,
               150, 160, 150, 59, 25, 53, 104, 22, 174, 175,
               213, 138, 5, 165, 1, 165, 150, 165, 150, 150,
               240, 150, 174, 175, 174, 175, 49, 50, 118, 150,
                35, 165, 27, 165, 165, 194, 165, 108, 127, 76,
               174, 175, 174, 175, 165, 174, 175, 70, 71, 72,
                73, 74, 75, 76, 77, 78, 79, 80, 166, 82,
                83, 84, 85, 86, 87, 88, 89, 90, 91, 92,
                19, 20, 193, 22, 150, 150, 150, 26, 27, 76,
               150, 22, 1, 150, 119, 121, 217, 20, 37, 165,
               165, 165, 16, 19, 20, 165, 22, 205, 165, 119,
                26, 27, 108, 128, 150, 150, 150, 56, 150, 22,
               150, 37, 150, 127, 160, 23, 150, 66, 193, 165,
               165, 165, 16, 165, 23, 165, 150, 165, 174, 175,
                56, 165, 150, 65, 174, 175, 15, 86, 87, 88,
                66, 165, 140, 150, 93, 94, 95, 165, 194, 98,
               174, 175, 22, 3, 164, 193, 174, 175, 165, 150,
                86, 87, 4, 180, 150, 248, 251, 93, 94, 95,
               216, 180, 98, 251, 165, 221, 150, 149, 6, 165,
               129, 130, 131, 132, 133, 134, 193, 150, 174, 175,
               116, 165, 19, 20, 150, 22, 149, 151, 150, 26,
                27, 149, 165, 129, 130, 131, 132, 133, 134, 165,
                37, 174, 175, 165, 149, 19, 20, 13, 22, 150,
               150, 150, 26, 27, 146, 147, 151, 150, 25, 56,
               152, 159, 154, 37, 165, 165, 165, 193, 160, 66,
               116, 193, 165, 174, 175, 174, 175, 194, 199, 150,
               200, 126, 56, 124, 123, 150, 201, 122, 150, 86,
                87, 150, 66, 193, 165, 202, 93, 94, 95, 150,
               165, 98, 194, 165, 125, 22, 165, 150, 150, 26,
                27, 135, 86, 87, 165, 174, 175, 203, 226, 93,
                94, 95, 165, 165, 98, 150, 218, 150, 193, 157,
               118, 157, 129, 130, 131, 132, 133, 134, 5, 104,
               165, 211, 165, 10, 11, 12, 13, 14, 150, 66,
                17, 174, 175, 210, 246, 129, 130, 131, 132, 133,
               134, 150, 210, 165, 31, 121, 33, 150, 150, 86,
                87, 176, 174, 175, 150, 42, 165, 94, 211, 210,
               150, 98, 165, 165, 211, 174, 175, 150, 55, 165,
                57, 150, 174, 175, 61, 165, 150, 64, 174, 175,
               150, 150, 165, 150, 174, 175, 165, 104, 150, 184,
               150, 165, 129, 130, 131, 165, 165, 150, 165, 150,
               150, 176, 150, 165, 47, 165, 150, 150, 176, 103,
               150, 22, 165, 178, 165, 165, 179, 165, 105, 106,
               107, 165, 165, 229, 111, 165, 92, 176, 229, 116,
               184, 176, 179, 156, 176, 176, 18, 157, 156, 237,
                45, 157, 156, 135, 157, 157, 238, 156, 68, 157,
               189, 189, 139, 219, 22, 157, 18, 192, 192, 192,
               192, 189, 219, 199, 157, 242, 40, 157, 199, 242,
               153, 157, 38, 245, 196, 166, 232, 198, 177, 177,
               232, 227, 209, 178, 166, 182, 166, 148, 177, 177,
               209, 196, 177, 199, 209, 199, 166, 208, 92, 195,
               174, 174, 183, 252, 183, 183, 252, 191, 252, 235,
               186, 241, 241, 252, 186, 252, 252, 252, 252, 252,
               252, 252, 252, 252, 252, 252, 236,
};




static const short yy_shift_ofst[] = {
               975, 1114, 1343, 1114, 1213, 1213, 90, 90, 0, -19,
              1213, 1213, 1213, 1213, 1213, 345, 445, 721, 1091, 1213,
              1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213,
              1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213,
              1213, 1213, 1213, 1213, 1213, 1213, 1213, 1236, 1213, 1213,
              1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213,
              1213, 199, 445, 445, 835, 835, 365, 1164, 55, 647,
               573, 499, 425, 351, 277, 203, 129, 795, 795, 795,
               795, 795, 795, 795, 795, 795, 795, 795, 795, 795,
               795, 795, 795, 795, 795, 869, 795, 943, 1017, 1017,
               -69, -45, -45, -45, -45, -45, -1, 58, 138, 100,
               445, 445, 445, 445, 445, 445, 445, 445, 445, 445,
               445, 445, 445, 445, 445, 445, 537, 438, 445, 445,
               445, 445, 445, 365, 807, 1436, -74, -74, -74, 1293,
                73, 434, 434, 311, 314, 290, 283, 286, 540, 467,
               445, 445, 445, 445, 445, 445, 445, 445, 445, 445,
               445, 445, 445, 445, 445, 445, 445, 445, 445, 445,
               445, 445, 445, 445, 445, 445, 445, 445, 445, 445,
               445, 445, 65, 722, 722, 722, 688, 266, 1164, 1164,
              1164, -74, -74, -74, 136, 168, 168, 234, 360, 360,
               360, 430, 372, 435, 352, 278, 126, -36, -36, -36,
               -36, 421, 651, -36, -36, 592, 292, 212, 623, 158,
               204, 204, 505, 158, 505, 144, 365, 154, 365, 154,
               645, 154, 204, 154, 154, 535, 548, 548, 365, 387,
               508, 233, 1464, 1222, 1222, 1456, 1456, 1222, 1462, 1410,
              1165, 1468, 1468, 1468, 1468, 1222, 1165, 1462, 1410, 1410,
              1222, 1448, 1338, 1425, 1222, 1222, 1448, 1222, 1448, 1222,
              1448, 1419, 1313, 1313, 1313, 1387, 1364, 1364, 1419, 1313,
              1336, 1313, 1387, 1313, 1313, 1254, 1245, 1254, 1245, 1254,
              1245, 1222, 1222, 1186, 1189, 1175, 1169, 1171, 1165, 1164,
              1243, 1244, 1244, 1212, 1212, 1212, 1212, -74, -74, -74,
               -74, -74, -74, 939, 104, 680, 571, 327, 1, 980,
                26, 972, 971, 946, 901, 870, 830, 806, 54, 21,
               -73, 510, 242, 1198, 1190, 1170, 1042, 1161, 1108, 1146,
              1141, 1132, 1015, 1127, 1026, 1034, 1020, 1107, 1004, 1116,
              1121, 1005, 1099, 951, 1043, 1003, 969, 1045, 1035, 950,
              1053, 1047, 1025, 942, 913, 992, 1019, 945, 984, 940,
               876, 904, 953, 896, 748, 804, 880, 786, 868, 819,
               805, 810, 773, 751, 766, 706, 716, 691, 681, 568,
               655, 638, 676, 516, 541, 594, 599, 567, 541, 534,
               507, 527, 498, 523, 466, 382, 409, 384, 357, 6,
               240, 224, 143, 62, 18, 71, 39, 9, 5,
};




static const short yy_reduce_ofst[] = {
              -141, 994, 1118, 223, 157, -53, 93, 89, 83, 375,
               386, 381, 379, 308, 295, 325, -47, 27, 1240, 1234,
              1228, 1221, 1208, 1187, 1151, 1111, 1109, 1077, 1054, 1022,
              1016, 1000, 911, 908, 906, 890, 888, 874, 834, 816,
               800, 760, 758, 755, 742, 739, 726, 685, 672, 668,
               665, 652, 611, 609, 607, 604, 591, 578, 526, 519,
               453, 474, 454, 461, 443, 245, 442, 473, 484, 484,
               484, 484, 484, 484, 484, 484, 484, 484, 484, 484,
               484, 484, 484, 484, 484, 484, 484, 484, 484, 484,
               484, 484, 484, 484, 484, 484, 484, 484, 484, 484,
               484, 484, 484, 484, 484, 484, 484, 130, 484, 484,
              1145, 909, 1110, 1088, 1084, 1033, 1002, 965, 820, 837,
               746, 686, 612, 817, 610, 919, 221, 563, 814, 813,
               744, 669, 470, 543, 484, 484, 484, 484, 484, 291,
               569, 671, 658, 970, 1290, 1287, 1286, 1282, 518, 518,
              1280, 1279, 1277, 1270, 1268, 1263, 1261, 1260, 1256, 1251,
              1247, 1227, 1185, 1168, 1167, 1159, 1148, 1139, 1117, 1066,
              1049, 1006, 998, 996, 995, 973, 970, 966, 964, 892,
               762, -52, 881, 932, 802, 731, 619, 812, 664, 660,
               627, 392, 331, 124, 1358, 1357, 1356, 1354, 1352, 1351,
              1349, 1319, 1334, 1346, 1334, 1334, 1334, 1334, 1334, 1334,
              1334, 1320, 1304, 1334, 1334, 1319, 1360, 1325, 1369, 1326,
              1315, 1311, 1301, 1324, 1300, 1335, 1350, 1345, 1348, 1342,
              1333, 1341, 1303, 1332, 1331, 1284, 1278, 1274, 1339, 1309,
              1308, 1347, 1258, 1344, 1340, 1257, 1253, 1337, 1273, 1302,
              1299, 1298, 1297, 1296, 1295, 1328, 1294, 1264, 1292, 1291,
              1322, 1321, 1238, 1232, 1318, 1317, 1316, 1314, 1312, 1310,
              1307, 1283, 1289, 1288, 1285, 1276, 1229, 1224, 1267, 1281,
              1265, 1262, 1235, 1255, 1205, 1183, 1179, 1177, 1162, 1140,
              1153, 1184, 1182, 1102, 1124, 1103, 1095, 1090, 1089, 1093,
              1112, 1115, 1086, 1105, 1092, 1087, 1068, 962, 955, 957,
              1031, 1023, 1030,
};
static const unsigned short int yy_default[] = {
               635, 870, 959, 959, 959, 870, 899, 899, 959, 759,
               959, 959, 959, 959, 868, 959, 959, 933, 959, 959,
               959, 959, 959, 959, 959, 959, 959, 959, 959, 959,
               959, 959, 959, 959, 959, 959, 959, 959, 959, 959,
               959, 959, 959, 959, 959, 959, 959, 959, 959, 959,
               959, 959, 959, 959, 959, 959, 959, 959, 959, 959,
               959, 959, 959, 959, 899, 899, 674, 763, 794, 959,
               959, 959, 959, 959, 959, 959, 959, 932, 934, 809,
               808, 802, 801, 912, 774, 799, 792, 785, 796, 871,
               864, 865, 863, 867, 872, 959, 795, 831, 848, 830,
               842, 847, 854, 846, 843, 833, 832, 666, 834, 835,
               959, 959, 959, 959, 959, 959, 959, 959, 959, 959,
               959, 959, 959, 959, 959, 959, 661, 728, 959, 959,
               959, 959, 959, 959, 836, 837, 851, 850, 849, 959,
               959, 959, 959, 959, 959, 959, 959, 959, 959, 959,
               959, 939, 937, 959, 883, 959, 959, 959, 959, 959,
               959, 959, 959, 959, 959, 959, 959, 959, 959, 959,
               959, 959, 959, 959, 959, 959, 959, 959, 959, 959,
               959, 641, 959, 759, 759, 759, 635, 959, 959, 959,
               959, 951, 763, 753, 719, 959, 959, 959, 959, 959,
               959, 959, 959, 959, 959, 959, 959, 804, 742, 922,
               924, 959, 905, 740, 663, 761, 676, 751, 643, 798,
               776, 776, 917, 798, 917, 700, 959, 788, 959, 788,
               697, 788, 776, 788, 788, 866, 959, 959, 959, 760,
               751, 959, 944, 767, 767, 936, 936, 767, 810, 732,
               798, 739, 739, 739, 739, 767, 798, 810, 732, 732,
               767, 658, 911, 909, 767, 767, 658, 767, 658, 767,
               658, 876, 730, 730, 730, 715, 880, 880, 876, 730,
               700, 730, 715, 730, 730, 780, 775, 780, 775, 780,
               775, 767, 767, 959, 793, 781, 791, 789, 798, 959,
               718, 651, 651, 640, 640, 640, 640, 956, 956, 951,
               702, 702, 684, 959, 959, 959, 959, 959, 959, 959,
               885, 959, 959, 959, 959, 959, 959, 959, 959, 959,
               959, 959, 959, 959, 636, 946, 959, 959, 943, 959,
               959, 959, 959, 959, 959, 959, 959, 959, 959, 959,
               959, 959, 959, 959, 959, 959, 959, 959, 959, 915,
               959, 959, 959, 959, 959, 959, 908, 907, 959, 959,
               959, 959, 959, 959, 959, 959, 959, 959, 959, 959,
               959, 959, 959, 959, 959, 959, 959, 959, 959, 959,
               959, 959, 959, 959, 790, 959, 782, 959, 869, 959,
               959, 959, 959, 959, 959, 959, 959, 959, 959, 745,
               819, 959, 818, 822, 817, 668, 959, 649, 959, 632,
               637, 955, 958, 957, 954, 953, 952, 947, 945, 942,
               941, 940, 938, 935, 931, 889, 887, 894, 893, 892,
               891, 890, 888, 886, 884, 805, 803, 800, 797, 930,
               882, 741, 738, 737, 657, 948, 914, 923, 921, 811,
               920, 919, 918, 916, 913, 900, 807, 806, 733, 874,
               873, 660, 904, 903, 902, 906, 910, 901, 769, 659,
               656, 665, 722, 721, 729, 727, 726, 725, 724, 723,
               720, 667, 675, 686, 714, 699, 698, 879, 881, 878,
               877, 707, 706, 712, 711, 710, 709, 708, 705, 704,
               703, 696, 695, 701, 694, 717, 716, 713, 693, 736,
               735, 734, 731, 692, 691, 690, 822, 689, 688, 828,
               827, 815, 858, 756, 755, 754, 766, 765, 778, 777,
               813, 812, 779, 764, 758, 757, 773, 772, 771, 770,
               762, 752, 784, 787, 786, 783, 860, 768, 857, 929,
               928, 927, 926, 925, 862, 861, 829, 826, 679, 680,
               898, 896, 897, 895, 682, 681, 678, 677, 859, 747,
               746, 855, 852, 844, 840, 856, 853, 845, 841, 839,
               838, 824, 823, 821, 820, 816, 825, 670, 748, 744,
               743, 814, 750, 749, 687, 685, 683, 664, 662, 655,
               653, 652, 654, 650, 648, 647, 646, 645, 644, 673,
               672, 671, 669, 668, 642, 639, 638, 634, 633, 631,
};
# 103282 "ext/sqlite3/libsqlite/sqlite3.c"
static const unsigned char yyFallback[] = {
    0,
    0,
   26,
   26,
   26,
   26,
    0,
   26,
   26,
   26,
    0,
   26,
   26,
   26,
   26,
    0,
    0,
    0,
   26,
    0,
    0,
   26,
    0,
    0,
    0,
    0,
    0,
    0,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
   26,
};
# 103365 "ext/sqlite3/libsqlite/sqlite3.c"
struct yyStackEntry {
  unsigned short int stateno;
  unsigned char major;

  YYMINORTYPE minor;

};
typedef struct yyStackEntry yyStackEntry;



struct yyParser {
  int yyidx;



  int yyerrcnt;
  Parse *pParse;




  yyStackEntry yystack[100];

};
typedef struct yyParser yyParser;
# 103865 "ext/sqlite3/libsqlite/sqlite3.c"
static void *sqlite3ParserAlloc(void *(*mallocProc)(size_t)){
  yyParser *pParser;
  pParser = (yyParser*)(*mallocProc)( (size_t)sizeof(yyParser) );
  if( pParser ){
    pParser->yyidx = -1;
# 103878 "ext/sqlite3/libsqlite/sqlite3.c"
  }
  return pParser;
}






static void yy_destructor(
  yyParser *yypParser,
  unsigned char yymajor,
  YYMINORTYPE *yypminor
){
  Parse *pParse = yypParser->pParse;
  switch( yymajor ){
# 103904 "ext/sqlite3/libsqlite/sqlite3.c"
    case 160:
    case 194:
{
sqlite3SelectDelete(pParse->db, (yypminor->yy387));
}
      break;
    case 174:
    case 175:
{
sqlite3ExprDelete(pParse->db, (yypminor->yy118).pExpr);
}
      break;
    case 179:
    case 187:
    case 197:
    case 200:
    case 202:
    case 204:
    case 214:
    case 216:
    case 217:
    case 220:
    case 221:
    case 226:
{
sqlite3ExprListDelete(pParse->db, (yypminor->yy322));
}
      break;
    case 193:
    case 198:
    case 206:
    case 207:
{
sqlite3SrcListDelete(pParse->db, (yypminor->yy259));
}
      break;
    case 199:
    case 201:
    case 210:
    case 215:
    case 225:
    case 227:
    case 238:
    case 243:
{
sqlite3ExprDelete(pParse->db, (yypminor->yy314));
}
      break;
    case 211:
    case 213:
    case 219:
{
sqlite3IdListDelete(pParse->db, (yypminor->yy384));
}
      break;
    case 234:
    case 239:
{
sqlite3DeleteTriggerStep(pParse->db, (yypminor->yy203));
}
      break;
    case 236:
{
sqlite3IdListDelete(pParse->db, (yypminor->yy90).b);
}
      break;
    default: break;
  }
}
# 103982 "ext/sqlite3/libsqlite/sqlite3.c"
static int yy_pop_parser_stack(yyParser *pParser){
  unsigned char yymajor;
  yyStackEntry *yytos = &pParser->yystack[pParser->yyidx];



  if( (pParser->yyidx<0) ) return 0;







  yymajor = yytos->major;
  yy_destructor(pParser, yymajor, &yytos->minor);
  pParser->yyidx--;
  return yymajor;
}
# 104014 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3ParserFree(
  void *p,
  void (*freeProc)(void*)
){
  yyParser *pParser = (yyParser*)p;


  if( (pParser==0) ) return;
  while( pParser->yyidx>=0 ) yy_pop_parser_stack(pParser);



  (*freeProc)((void*)pParser);
}
# 104047 "ext/sqlite3/libsqlite/sqlite3.c"
static int yy_find_shift_action(
  yyParser *pParser,
  unsigned char iLookAhead
){
  int i;
  int stateno = pParser->yystack[pParser->yyidx].stateno;

  if( stateno>(418)
   || (i = yy_shift_ofst[stateno])==(-74) ){
    return yy_default[stateno];
  }
  ((void) (0));
  i += iLookAhead;
  if( i<0 || i>=(1557) || yy_lookahead[i]!=iLookAhead ){
    if( iLookAhead>0 ){

      unsigned char iFallback;
      if( iLookAhead<sizeof(yyFallback)/sizeof(yyFallback[0])
             && (iFallback = yyFallback[iLookAhead])!=0 ){






        return yy_find_shift_action(pParser, iFallback);
      }


      {
        int j = i - iLookAhead + 67;
        if(

          j>=0 &&




          yy_lookahead[j]==67
        ){






          return yy_action[j];
        }
      }

    }
    return yy_default[stateno];
  }else{
    return yy_action[i];
  }
}
# 104112 "ext/sqlite3/libsqlite/sqlite3.c"
static int yy_find_reduce_action(
  int stateno,
  unsigned char iLookAhead
){
  int i;





  ((void) (0));

  i = yy_reduce_ofst[stateno];
  ((void) (0));
  ((void) (0));
  i += iLookAhead;





  ((void) (0));
  ((void) (0));

  return yy_action[i];
}




static void yyStackOverflow(yyParser *yypParser, YYMINORTYPE *yypMinor){
   Parse *pParse = yypParser->pParse;
   yypParser->yyidx--;





   while( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser);



  (void)(yypMinor);
  sqlite3ErrorMsg(pParse, "parser stack overflow");
  pParse->parseError = 1;
   yypParser->pParse = pParse;
}




static void yy_shift(
  yyParser *yypParser,
  int yyNewState,
  int yyMajor,
  YYMINORTYPE *yypMinor
){
  yyStackEntry *yytos;
  yypParser->yyidx++;






  if( yypParser->yyidx>=100 ){
    yyStackOverflow(yypParser, yypMinor);
    return;
  }
# 104190 "ext/sqlite3/libsqlite/sqlite3.c"
  yytos = &yypParser->yystack[yypParser->yyidx];
  yytos->stateno = (unsigned short int)yyNewState;
  yytos->major = (unsigned char)yyMajor;
  yytos->minor = *yypMinor;
# 104204 "ext/sqlite3/libsqlite/sqlite3.c"
}




static const struct {
  unsigned char lhs;
  unsigned char nrhs;
} yyRuleInfo[] = {
  { 142, 1 },
  { 143, 2 },
  { 143, 1 },
  { 144, 1 },
  { 144, 3 },
  { 145, 0 },
  { 145, 1 },
  { 145, 3 },
  { 146, 1 },
  { 147, 3 },
  { 149, 0 },
  { 149, 1 },
  { 149, 2 },
  { 148, 0 },
  { 148, 1 },
  { 148, 1 },
  { 148, 1 },
  { 147, 2 },
  { 147, 2 },
  { 147, 2 },
  { 151, 1 },
  { 151, 0 },
  { 147, 2 },
  { 147, 3 },
  { 147, 5 },
  { 147, 2 },
  { 152, 6 },
  { 154, 1 },
  { 156, 0 },
  { 156, 3 },
  { 155, 1 },
  { 155, 0 },
  { 153, 4 },
  { 153, 2 },
  { 158, 3 },
  { 158, 1 },
  { 161, 3 },
  { 162, 1 },
  { 165, 1 },
  { 165, 1 },
  { 166, 1 },
  { 150, 1 },
  { 150, 1 },
  { 150, 1 },
  { 163, 0 },
  { 163, 1 },
  { 167, 1 },
  { 167, 4 },
  { 167, 6 },
  { 168, 1 },
  { 168, 2 },
  { 169, 1 },
  { 169, 1 },
  { 164, 2 },
  { 164, 0 },
  { 172, 3 },
  { 172, 1 },
  { 173, 2 },
  { 173, 4 },
  { 173, 3 },
  { 173, 3 },
  { 173, 2 },
  { 173, 2 },
  { 173, 3 },
  { 173, 5 },
  { 173, 2 },
  { 173, 4 },
  { 173, 4 },
  { 173, 1 },
  { 173, 2 },
  { 178, 0 },
  { 178, 1 },
  { 180, 0 },
  { 180, 2 },
  { 182, 2 },
  { 182, 3 },
  { 182, 3 },
  { 182, 3 },
  { 183, 2 },
  { 183, 2 },
  { 183, 1 },
  { 183, 1 },
  { 183, 2 },
  { 181, 3 },
  { 181, 2 },
  { 184, 0 },
  { 184, 2 },
  { 184, 2 },
  { 159, 0 },
  { 159, 2 },
  { 185, 3 },
  { 185, 2 },
  { 185, 1 },
  { 186, 2 },
  { 186, 7 },
  { 186, 5 },
  { 186, 5 },
  { 186, 10 },
  { 188, 0 },
  { 188, 1 },
  { 176, 0 },
  { 176, 3 },
  { 189, 0 },
  { 189, 2 },
  { 190, 1 },
  { 190, 1 },
  { 190, 1 },
  { 147, 4 },
  { 192, 2 },
  { 192, 0 },
  { 147, 8 },
  { 147, 4 },
  { 147, 1 },
  { 160, 1 },
  { 160, 3 },
  { 195, 1 },
  { 195, 2 },
  { 195, 1 },
  { 194, 9 },
  { 196, 1 },
  { 196, 1 },
  { 196, 0 },
  { 204, 2 },
  { 204, 0 },
  { 197, 3 },
  { 197, 2 },
  { 197, 4 },
  { 205, 2 },
  { 205, 1 },
  { 205, 0 },
  { 198, 0 },
  { 198, 2 },
  { 207, 2 },
  { 207, 0 },
  { 206, 7 },
  { 206, 7 },
  { 206, 7 },
  { 157, 0 },
  { 157, 2 },
  { 193, 2 },
  { 208, 1 },
  { 208, 2 },
  { 208, 3 },
  { 208, 4 },
  { 210, 2 },
  { 210, 0 },
  { 209, 0 },
  { 209, 3 },
  { 209, 2 },
  { 211, 4 },
  { 211, 0 },
  { 202, 0 },
  { 202, 3 },
  { 214, 4 },
  { 214, 2 },
  { 215, 1 },
  { 177, 1 },
  { 177, 1 },
  { 177, 0 },
  { 200, 0 },
  { 200, 3 },
  { 201, 0 },
  { 201, 2 },
  { 203, 0 },
  { 203, 2 },
  { 203, 4 },
  { 203, 4 },
  { 147, 5 },
  { 199, 0 },
  { 199, 2 },
  { 147, 7 },
  { 217, 5 },
  { 217, 3 },
  { 147, 8 },
  { 147, 5 },
  { 147, 6 },
  { 218, 2 },
  { 218, 1 },
  { 220, 3 },
  { 220, 1 },
  { 219, 0 },
  { 219, 3 },
  { 213, 3 },
  { 213, 1 },
  { 175, 1 },
  { 175, 3 },
  { 174, 1 },
  { 175, 1 },
  { 175, 1 },
  { 175, 3 },
  { 175, 5 },
  { 174, 1 },
  { 174, 1 },
  { 175, 1 },
  { 175, 1 },
  { 175, 3 },
  { 175, 6 },
  { 175, 5 },
  { 175, 4 },
  { 174, 1 },
  { 175, 3 },
  { 175, 3 },
  { 175, 3 },
  { 175, 3 },
  { 175, 3 },
  { 175, 3 },
  { 175, 3 },
  { 175, 3 },
  { 222, 1 },
  { 222, 2 },
  { 222, 1 },
  { 222, 2 },
  { 175, 3 },
  { 175, 5 },
  { 175, 2 },
  { 175, 3 },
  { 175, 3 },
  { 175, 4 },
  { 175, 2 },
  { 175, 2 },
  { 175, 2 },
  { 175, 2 },
  { 223, 1 },
  { 223, 2 },
  { 175, 5 },
  { 224, 1 },
  { 224, 2 },
  { 175, 5 },
  { 175, 3 },
  { 175, 5 },
  { 175, 4 },
  { 175, 4 },
  { 175, 5 },
  { 226, 5 },
  { 226, 4 },
  { 227, 2 },
  { 227, 0 },
  { 225, 1 },
  { 225, 0 },
  { 221, 1 },
  { 221, 0 },
  { 216, 3 },
  { 216, 1 },
  { 147, 11 },
  { 228, 1 },
  { 228, 0 },
  { 179, 0 },
  { 179, 3 },
  { 187, 5 },
  { 187, 3 },
  { 229, 0 },
  { 229, 2 },
  { 147, 4 },
  { 147, 1 },
  { 147, 2 },
  { 147, 3 },
  { 147, 5 },
  { 147, 6 },
  { 147, 5 },
  { 147, 6 },
  { 230, 1 },
  { 230, 1 },
  { 230, 1 },
  { 230, 1 },
  { 230, 1 },
  { 170, 2 },
  { 171, 2 },
  { 232, 1 },
  { 231, 1 },
  { 231, 0 },
  { 147, 5 },
  { 233, 11 },
  { 235, 1 },
  { 235, 1 },
  { 235, 2 },
  { 235, 0 },
  { 236, 1 },
  { 236, 1 },
  { 236, 3 },
  { 237, 0 },
  { 237, 3 },
  { 238, 0 },
  { 238, 2 },
  { 234, 3 },
  { 234, 2 },
  { 240, 1 },
  { 240, 3 },
  { 241, 0 },
  { 241, 3 },
  { 241, 2 },
  { 239, 7 },
  { 239, 8 },
  { 239, 5 },
  { 239, 5 },
  { 239, 1 },
  { 175, 4 },
  { 175, 6 },
  { 191, 1 },
  { 191, 1 },
  { 191, 1 },
  { 147, 4 },
  { 147, 6 },
  { 147, 3 },
  { 243, 0 },
  { 243, 2 },
  { 242, 1 },
  { 242, 0 },
  { 147, 1 },
  { 147, 3 },
  { 147, 1 },
  { 147, 3 },
  { 147, 6 },
  { 147, 6 },
  { 244, 1 },
  { 245, 0 },
  { 245, 1 },
  { 147, 1 },
  { 147, 4 },
  { 246, 7 },
  { 247, 1 },
  { 247, 3 },
  { 248, 0 },
  { 248, 2 },
  { 249, 1 },
  { 249, 3 },
  { 250, 1 },
  { 251, 0 },
  { 251, 4 },
  { 251, 2 },
};

static void yy_accept(yyParser*);





static void yy_reduce(
  yyParser *yypParser,
  int yyruleno
){
  int yygoto;
  int yyact;
  YYMINORTYPE yygotominor;
  yyStackEntry *yymsp;
  int yysize;
  Parse *pParse = yypParser->pParse;
  yymsp = &yypParser->yystack[yypParser->yyidx];
# 104584 "ext/sqlite3/libsqlite/sqlite3.c"
  yygotominor = yyzerominor;


  switch( yyruleno ){
# 104596 "ext/sqlite3/libsqlite/sqlite3.c"
      case 5:
{ sqlite3BeginParse(pParse, 0); }
        break;
      case 6:
{ sqlite3BeginParse(pParse, 1); }
        break;
      case 7:
{ sqlite3BeginParse(pParse, 2); }
        break;
      case 8:
{ sqlite3FinishCoding(pParse); }
        break;
      case 9:
{sqlite3BeginTransaction(pParse, yymsp[-1].minor.yy4);}
        break;
      case 13:
{yygotominor.yy4 = 7;}
        break;
      case 14:
      case 15: ;
      case 16: ;
      case 115: ;
      case 117: ;
{yygotominor.yy4 = yymsp[0].major;}
        break;
      case 17:
      case 18: ;
{sqlite3CommitTransaction(pParse);}
        break;
      case 19:
{sqlite3RollbackTransaction(pParse);}
        break;
      case 22:
{
  sqlite3Savepoint(pParse, 0, &yymsp[0].minor.yy0);
}
        break;
      case 23:
{
  sqlite3Savepoint(pParse, 1, &yymsp[0].minor.yy0);
}
        break;
      case 24:
{
  sqlite3Savepoint(pParse, 2, &yymsp[0].minor.yy0);
}
        break;
      case 26:
{
   sqlite3StartTable(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,yymsp[-4].minor.yy4,0,0,yymsp[-2].minor.yy4);
}
        break;
      case 27:
{
  pParse->db->lookaside.bEnabled = 0;
  yygotominor.yy0 = yymsp[0].minor.yy0;
}
        break;
      case 28:
      case 31: ;
      case 70: ;
      case 83: ;
      case 85: ;
      case 87: ;
      case 98: ;
      case 109: ;
      case 120: ;
      case 121: ;
      case 222: ;
      case 225: ;
{yygotominor.yy4 = 0;}
        break;
      case 29:
      case 30: ;
      case 71: ;
      case 86: ;
      case 108: ;
      case 119: ;
      case 223: ;
      case 226: ;
{yygotominor.yy4 = 1;}
        break;
      case 32:
{
  sqlite3EndTable(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,0);
}
        break;
      case 33:
{
  sqlite3EndTable(pParse,0,0,yymsp[0].minor.yy387);
  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy387);
}
        break;
      case 36:
{
  yygotominor.yy0.z = yymsp[-2].minor.yy0.z;
  yygotominor.yy0.n = (int)(pParse->sLastToken.z-yymsp[-2].minor.yy0.z) + pParse->sLastToken.n;
}
        break;
      case 37:
{
  sqlite3AddColumn(pParse,&yymsp[0].minor.yy0);
  yygotominor.yy0 = yymsp[0].minor.yy0;
}
        break;
      case 38:
      case 39: ;
      case 40: ;
      case 41: ;
      case 42: ;
      case 43: ;
      case 46: ;
      case 49: ;
      case 127: ;
      case 128: ;
      case 138: ;
      case 147: ;
      case 251: ;
      case 260: ;
      case 261: ;
      case 262: ;
      case 263: ;
      case 264: ;
      case 265: ;
      case 266: ;
      case 267: ;
      case 285: ;
{yygotominor.yy0 = yymsp[0].minor.yy0;}
        break;
      case 45:
{sqlite3AddColumnType(pParse,&yymsp[0].minor.yy0);}
        break;
      case 47:
{
  yygotominor.yy0.z = yymsp[-3].minor.yy0.z;
  yygotominor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-3].minor.yy0.z);
}
        break;
      case 48:
{
  yygotominor.yy0.z = yymsp[-5].minor.yy0.z;
  yygotominor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-5].minor.yy0.z);
}
        break;
      case 50:
{yygotominor.yy0.z=yymsp[-1].minor.yy0.z; yygotominor.yy0.n=yymsp[0].minor.yy0.n+(int)(yymsp[0].minor.yy0.z-yymsp[-1].minor.yy0.z);}
        break;
      case 57:
      case 59: ;
{sqlite3AddDefaultValue(pParse,&yymsp[0].minor.yy118);}
        break;
      case 58:
{sqlite3AddDefaultValue(pParse,&yymsp[-1].minor.yy118);}
        break;
      case 60:
{
  ExprSpan v;
  v.pExpr = sqlite3PExpr(pParse, 156, yymsp[0].minor.yy118.pExpr, 0, 0);
  v.zStart = yymsp[-1].minor.yy0.z;
  v.zEnd = yymsp[0].minor.yy118.zEnd;
  sqlite3AddDefaultValue(pParse,&v);
}
        break;
      case 61:
{
  ExprSpan v;
  spanExpr(&v, pParse, 94, &yymsp[0].minor.yy0);
  sqlite3AddDefaultValue(pParse,&v);
}
        break;
      case 63:
{sqlite3AddNotNull(pParse, yymsp[0].minor.yy4);}
        break;
      case 64:
{sqlite3AddPrimaryKey(pParse,0,yymsp[-1].minor.yy4,yymsp[0].minor.yy4,yymsp[-2].minor.yy4);}
        break;
      case 65:
{sqlite3CreateIndex(pParse,0,0,0,0,yymsp[0].minor.yy4,0,0,0,0);}
        break;
      case 66:
{sqlite3AddCheckConstraint(pParse,yymsp[-1].minor.yy118.pExpr);}
        break;
      case 67:
{sqlite3CreateForeignKey(pParse,0,&yymsp[-2].minor.yy0,yymsp[-1].minor.yy322,yymsp[0].minor.yy4);}
        break;
      case 68:
{sqlite3DeferForeignKey(pParse,yymsp[0].minor.yy4);}
        break;
      case 69:
{sqlite3AddCollateType(pParse, &yymsp[0].minor.yy0);}
        break;
      case 72:
{ yygotominor.yy4 = 0*0x0101; }
        break;
      case 73:
{ yygotominor.yy4 = (yymsp[-1].minor.yy4 & ~yymsp[0].minor.yy215.mask) | yymsp[0].minor.yy215.value; }
        break;
      case 74:
      case 75: ;
{ yygotominor.yy215.value = 0; yygotominor.yy215.mask = 0x000000; }
        break;
      case 76:
{ yygotominor.yy215.value = yymsp[0].minor.yy4; yygotominor.yy215.mask = 0x0000ff; }
        break;
      case 77:
{ yygotominor.yy215.value = yymsp[0].minor.yy4<<8; yygotominor.yy215.mask = 0x00ff00; }
        break;
      case 78:
{ yygotominor.yy4 = 7; }
        break;
      case 79:
{ yygotominor.yy4 = 8; }
        break;
      case 80:
{ yygotominor.yy4 = 9; }
        break;
      case 81:
{ yygotominor.yy4 = 6; }
        break;
      case 82:
{ yygotominor.yy4 = 0; }
        break;
      case 84:
      case 99: ;
      case 101: ;
      case 104: ;
{yygotominor.yy4 = yymsp[0].minor.yy4;}
        break;
      case 88:
{yygotominor.yy0.n = 0; yygotominor.yy0.z = 0;}
        break;
      case 89:
{yygotominor.yy0 = yymsp[-1].minor.yy0;}
        break;
      case 94:
{sqlite3AddPrimaryKey(pParse,yymsp[-3].minor.yy322,yymsp[0].minor.yy4,yymsp[-2].minor.yy4,0);}
        break;
      case 95:
{sqlite3CreateIndex(pParse,0,0,0,yymsp[-2].minor.yy322,yymsp[0].minor.yy4,0,0,0,0);}
        break;
      case 96:
{sqlite3AddCheckConstraint(pParse,yymsp[-2].minor.yy118.pExpr);}
        break;
      case 97:
{
    sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy322, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy322, yymsp[-1].minor.yy4);
    sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy4);
}
        break;
      case 100:
{yygotominor.yy4 = 99;}
        break;
      case 102:
{yygotominor.yy210 = 99;}
        break;
      case 103:
{yygotominor.yy210 = (u8)yymsp[0].minor.yy4;}
        break;
      case 105:
{yygotominor.yy4 = 4;}
        break;
      case 106:
{yygotominor.yy4 = 5;}
        break;
      case 107:
{
  sqlite3DropTable(pParse, yymsp[0].minor.yy259, 0, yymsp[-1].minor.yy4);
}
        break;
      case 110:
{
  sqlite3CreateView(pParse, &yymsp[-7].minor.yy0, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, yymsp[0].minor.yy387, yymsp[-6].minor.yy4, yymsp[-4].minor.yy4);
}
        break;
      case 111:
{
  sqlite3DropTable(pParse, yymsp[0].minor.yy259, 1, yymsp[-1].minor.yy4);
}
        break;
      case 112:
{
  SelectDest dest = {5, 0, 0, 0, 0};
  sqlite3Select(pParse, yymsp[0].minor.yy387, &dest);
  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy387);
}
        break;
      case 113:
{yygotominor.yy387 = yymsp[0].minor.yy387;}
        break;
      case 114:
{
  if( yymsp[0].minor.yy387 ){
    yymsp[0].minor.yy387->op = (u8)yymsp[-1].minor.yy4;
    yymsp[0].minor.yy387->pPrior = yymsp[-2].minor.yy387;
  }else{
    sqlite3SelectDelete(pParse->db, yymsp[-2].minor.yy387);
  }
  yygotominor.yy387 = yymsp[0].minor.yy387;
}
        break;
      case 116:
{yygotominor.yy4 = 113;}
        break;
      case 118:
{
  yygotominor.yy387 = sqlite3SelectNew(pParse,yymsp[-6].minor.yy322,yymsp[-5].minor.yy259,yymsp[-4].minor.yy314,yymsp[-3].minor.yy322,yymsp[-2].minor.yy314,yymsp[-1].minor.yy322,yymsp[-7].minor.yy4,yymsp[0].minor.yy292.pLimit,yymsp[0].minor.yy292.pOffset);
}
        break;
      case 122:
      case 247: ;
{yygotominor.yy322 = yymsp[-1].minor.yy322;}
        break;
      case 123:
      case 151: ;
      case 159: ;
      case 240: ;
      case 246: ;
{yygotominor.yy322 = 0;}
        break;
      case 124:
{
   yygotominor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy322, yymsp[-1].minor.yy118.pExpr);
   if( yymsp[0].minor.yy0.n>0 ) sqlite3ExprListSetName(pParse, yygotominor.yy322, &yymsp[0].minor.yy0, 1);
   sqlite3ExprListSetSpan(pParse,yygotominor.yy322,&yymsp[-1].minor.yy118);
}
        break;
      case 125:
{
  Expr *p = sqlite3Expr(pParse->db, 113, 0);
  yygotominor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-1].minor.yy322, p);
}
        break;
      case 126:
{
  Expr *pRight = sqlite3PExpr(pParse, 113, 0, 0, &yymsp[0].minor.yy0);
  Expr *pLeft = sqlite3PExpr(pParse, 26, 0, 0, &yymsp[-2].minor.yy0);
  Expr *pDot = sqlite3PExpr(pParse, 118, pLeft, pRight, 0);
  yygotominor.yy322 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy322, pDot);
}
        break;
      case 129:
{yygotominor.yy0.n = 0;}
        break;
      case 130:
{yygotominor.yy259 = sqlite3DbMallocZero(pParse->db, sizeof(*yygotominor.yy259));}
        break;
      case 131:
{
  yygotominor.yy259 = yymsp[0].minor.yy259;
  sqlite3SrcListShiftJoinType(yygotominor.yy259);
}
        break;
      case 132:
{
   yygotominor.yy259 = yymsp[-1].minor.yy259;
   if( (yygotominor.yy259 && yygotominor.yy259->nSrc>0) ) yygotominor.yy259->a[yygotominor.yy259->nSrc-1].jointype = (u8)yymsp[0].minor.yy4;
}
        break;
      case 133:
{yygotominor.yy259 = 0;}
        break;
      case 134:
{
  yygotominor.yy259 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy259,&yymsp[-5].minor.yy0,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,0,yymsp[-1].minor.yy314,yymsp[0].minor.yy384);
  sqlite3SrcListIndexedBy(pParse, yygotominor.yy259, &yymsp[-2].minor.yy0);
}
        break;
      case 135:
{
    yygotominor.yy259 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy259,0,0,&yymsp[-2].minor.yy0,yymsp[-4].minor.yy387,yymsp[-1].minor.yy314,yymsp[0].minor.yy384);
  }
        break;
      case 136:
{
    if( yymsp[-6].minor.yy259==0 && yymsp[-2].minor.yy0.n==0 && yymsp[-1].minor.yy314==0 && yymsp[0].minor.yy384==0 ){
      yygotominor.yy259 = yymsp[-4].minor.yy259;
    }else{
      Select *pSubquery;
      sqlite3SrcListShiftJoinType(yymsp[-4].minor.yy259);
      pSubquery = sqlite3SelectNew(pParse,0,yymsp[-4].minor.yy259,0,0,0,0,0,0,0);
      yygotominor.yy259 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy259,0,0,&yymsp[-2].minor.yy0,pSubquery,yymsp[-1].minor.yy314,yymsp[0].minor.yy384);
    }
  }
        break;
      case 137:
      case 146: ;
{yygotominor.yy0.z=0; yygotominor.yy0.n=0;}
        break;
      case 139:
{yygotominor.yy259 = sqlite3SrcListAppend(pParse->db,0,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0);}
        break;
      case 140:
{ yygotominor.yy4 = 0x0001; }
        break;
      case 141:
{ yygotominor.yy4 = sqlite3JoinType(pParse,&yymsp[-1].minor.yy0,0,0); }
        break;
      case 142:
{ yygotominor.yy4 = sqlite3JoinType(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,0); }
        break;
      case 143:
{ yygotominor.yy4 = sqlite3JoinType(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0); }
        break;
      case 144:
      case 155: ;
      case 162: ;
      case 169: ;
      case 235: ;
      case 237: ;
{yygotominor.yy314 = yymsp[0].minor.yy118.pExpr;}
        break;
      case 145:
      case 161: ;
      case 168: ;
      case 236: ;
      case 238: ;
{yygotominor.yy314 = 0;}
        break;
      case 148:
{yygotominor.yy0.z=0; yygotominor.yy0.n=1;}
        break;
      case 149:
      case 181: ;
{yygotominor.yy384 = yymsp[-1].minor.yy384;}
        break;
      case 150:
      case 180: ;
{yygotominor.yy384 = 0;}
        break;
      case 152:
      case 160: ;
      case 239: ;
{yygotominor.yy322 = yymsp[0].minor.yy322;}
        break;
      case 153:
{
  yygotominor.yy322 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy322,yymsp[-1].minor.yy314);
  if( yygotominor.yy322 ) yygotominor.yy322->a[yygotominor.yy322->nExpr-1].sortOrder = (u8)yymsp[0].minor.yy4;
}
        break;
      case 154:
{
  yygotominor.yy322 = sqlite3ExprListAppend(pParse,0,yymsp[-1].minor.yy314);
  if( yygotominor.yy322 && (yygotominor.yy322->a) ) yygotominor.yy322->a[0].sortOrder = (u8)yymsp[0].minor.yy4;
}
        break;
      case 156:
      case 158: ;
{yygotominor.yy4 = 0;}
        break;
      case 157:
{yygotominor.yy4 = 1;}
        break;
      case 163:
{yygotominor.yy292.pLimit = 0; yygotominor.yy292.pOffset = 0;}
        break;
      case 164:
{yygotominor.yy292.pLimit = yymsp[0].minor.yy118.pExpr; yygotominor.yy292.pOffset = 0;}
        break;
      case 165:
{yygotominor.yy292.pLimit = yymsp[-2].minor.yy118.pExpr; yygotominor.yy292.pOffset = yymsp[0].minor.yy118.pExpr;}
        break;
      case 166:
{yygotominor.yy292.pOffset = yymsp[-2].minor.yy118.pExpr; yygotominor.yy292.pLimit = yymsp[0].minor.yy118.pExpr;}
        break;
      case 167:
{
  sqlite3SrcListIndexedBy(pParse, yymsp[-2].minor.yy259, &yymsp[-1].minor.yy0);
  sqlite3DeleteFrom(pParse,yymsp[-2].minor.yy259,yymsp[0].minor.yy314);
}
        break;
      case 170:
{
  sqlite3SrcListIndexedBy(pParse, yymsp[-4].minor.yy259, &yymsp[-3].minor.yy0);
  sqlite3ExprListCheckLength(pParse,yymsp[-1].minor.yy322,"set list");
  sqlite3Update(pParse,yymsp[-4].minor.yy259,yymsp[-1].minor.yy322,yymsp[0].minor.yy314,yymsp[-5].minor.yy210);
}
        break;
      case 171:
{
  yygotominor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy322, yymsp[0].minor.yy118.pExpr);
  sqlite3ExprListSetName(pParse, yygotominor.yy322, &yymsp[-2].minor.yy0, 1);
}
        break;
      case 172:
{
  yygotominor.yy322 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy118.pExpr);
  sqlite3ExprListSetName(pParse, yygotominor.yy322, &yymsp[-2].minor.yy0, 1);
}
        break;
      case 173:
{sqlite3Insert(pParse, yymsp[-5].minor.yy259, yymsp[-1].minor.yy322, 0, yymsp[-4].minor.yy384, yymsp[-7].minor.yy210);}
        break;
      case 174:
{sqlite3Insert(pParse, yymsp[-2].minor.yy259, 0, yymsp[0].minor.yy387, yymsp[-1].minor.yy384, yymsp[-4].minor.yy210);}
        break;
      case 175:
{sqlite3Insert(pParse, yymsp[-3].minor.yy259, 0, 0, yymsp[-2].minor.yy384, yymsp[-5].minor.yy210);}
        break;
      case 176:
{yygotominor.yy210 = yymsp[0].minor.yy210;}
        break;
      case 177:
{yygotominor.yy210 = 5;}
        break;
      case 178:
      case 241: ;
{yygotominor.yy322 = sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy322,yymsp[0].minor.yy118.pExpr);}
        break;
      case 179:
      case 242: ;
{yygotominor.yy322 = sqlite3ExprListAppend(pParse,0,yymsp[0].minor.yy118.pExpr);}
        break;
      case 182:
{yygotominor.yy384 = sqlite3IdListAppend(pParse->db,yymsp[-2].minor.yy384,&yymsp[0].minor.yy0);}
        break;
      case 183:
{yygotominor.yy384 = sqlite3IdListAppend(pParse->db,0,&yymsp[0].minor.yy0);}
        break;
      case 184:
{yygotominor.yy118 = yymsp[0].minor.yy118;}
        break;
      case 185:
{yygotominor.yy118.pExpr = yymsp[-1].minor.yy118.pExpr; spanSet(&yygotominor.yy118,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0);}
        break;
      case 186:
      case 191: ;
      case 192: ;
{spanExpr(&yygotominor.yy118, pParse, yymsp[0].major, &yymsp[0].minor.yy0);}
        break;
      case 187:
      case 188: ;
{spanExpr(&yygotominor.yy118, pParse, 26, &yymsp[0].minor.yy0);}
        break;
      case 189:
{
  Expr *temp1 = sqlite3PExpr(pParse, 26, 0, 0, &yymsp[-2].minor.yy0);
  Expr *temp2 = sqlite3PExpr(pParse, 26, 0, 0, &yymsp[0].minor.yy0);
  yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 118, temp1, temp2, 0);
  spanSet(&yygotominor.yy118,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0);
}
        break;
      case 190:
{
  Expr *temp1 = sqlite3PExpr(pParse, 26, 0, 0, &yymsp[-4].minor.yy0);
  Expr *temp2 = sqlite3PExpr(pParse, 26, 0, 0, &yymsp[-2].minor.yy0);
  Expr *temp3 = sqlite3PExpr(pParse, 26, 0, 0, &yymsp[0].minor.yy0);
  Expr *temp4 = sqlite3PExpr(pParse, 118, temp2, temp3, 0);
  yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 118, temp1, temp4, 0);
  spanSet(&yygotominor.yy118,&yymsp[-4].minor.yy0,&yymsp[0].minor.yy0);
}
        break;
      case 193:
{



  if( pParse->nested==0 ){
    sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", &yymsp[0].minor.yy0);
    yygotominor.yy118.pExpr = 0;
  }else{
    yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 132, 0, 0, &yymsp[0].minor.yy0);
    if( yygotominor.yy118.pExpr ) sqlite3GetInt32(&yymsp[0].minor.yy0.z[1], &yygotominor.yy118.pExpr->iTable);
  }
  spanSet(&yygotominor.yy118, &yymsp[0].minor.yy0, &yymsp[0].minor.yy0);
}
        break;
      case 194:
{
  spanExpr(&yygotominor.yy118, pParse, 133, &yymsp[0].minor.yy0);
  sqlite3ExprAssignVarNumber(pParse, yygotominor.yy118.pExpr);
  spanSet(&yygotominor.yy118, &yymsp[0].minor.yy0, &yymsp[0].minor.yy0);
}
        break;
      case 195:
{
  yygotominor.yy118.pExpr = sqlite3ExprSetCollByToken(pParse, yymsp[-2].minor.yy118.pExpr, &yymsp[0].minor.yy0);
  yygotominor.yy118.zStart = yymsp[-2].minor.yy118.zStart;
  yygotominor.yy118.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
}
        break;
      case 196:
{
  yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 37, yymsp[-3].minor.yy118.pExpr, 0, &yymsp[-1].minor.yy0);
  spanSet(&yygotominor.yy118,&yymsp[-5].minor.yy0,&yymsp[0].minor.yy0);
}
        break;
      case 197:
{
  if( yymsp[-1].minor.yy322 && yymsp[-1].minor.yy322->nExpr>pParse->db->aLimit[6] ){
    sqlite3ErrorMsg(pParse, "too many arguments on function %T", &yymsp[-4].minor.yy0);
  }
  yygotominor.yy118.pExpr = sqlite3ExprFunction(pParse, yymsp[-1].minor.yy322, &yymsp[-4].minor.yy0);
  spanSet(&yygotominor.yy118,&yymsp[-4].minor.yy0,&yymsp[0].minor.yy0);
  if( yymsp[-2].minor.yy4 && yygotominor.yy118.pExpr ){
    yygotominor.yy118.pExpr->flags |= 0x0010;
  }
}
        break;
      case 198:
{
  yygotominor.yy118.pExpr = sqlite3ExprFunction(pParse, 0, &yymsp[-3].minor.yy0);
  spanSet(&yygotominor.yy118,&yymsp[-3].minor.yy0,&yymsp[0].minor.yy0);
}
        break;
      case 199:
{


  yygotominor.yy118.pExpr = sqlite3ExprFunction(pParse, 0,&yymsp[0].minor.yy0);
  if( yygotominor.yy118.pExpr ){
    yygotominor.yy118.pExpr->op = 155;
  }
  spanSet(&yygotominor.yy118, &yymsp[0].minor.yy0, &yymsp[0].minor.yy0);
}
        break;
      case 200:
      case 201: ;
      case 202: ;
      case 203: ;
      case 204: ;
      case 205: ;
      case 206: ;
      case 207: ;
{spanBinaryExpr(&yygotominor.yy118,pParse,yymsp[-1].major,&yymsp[-2].minor.yy118,&yymsp[0].minor.yy118);}
        break;
      case 208:
      case 210: ;
{yygotominor.yy342.eOperator = yymsp[0].minor.yy0; yygotominor.yy342.not = 0;}
        break;
      case 209:
      case 211: ;
{yygotominor.yy342.eOperator = yymsp[0].minor.yy0; yygotominor.yy342.not = 1;}
        break;
      case 212:
{
  ExprList *pList;
  pList = sqlite3ExprListAppend(pParse,0, yymsp[0].minor.yy118.pExpr);
  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-2].minor.yy118.pExpr);
  yygotominor.yy118.pExpr = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy342.eOperator);
  if( yymsp[-1].minor.yy342.not ) yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 19, yygotominor.yy118.pExpr, 0, 0);
  yygotominor.yy118.zStart = yymsp[-2].minor.yy118.zStart;
  yygotominor.yy118.zEnd = yymsp[0].minor.yy118.zEnd;
  if( yygotominor.yy118.pExpr ) yygotominor.yy118.pExpr->flags |= 0x0080;
}
        break;
      case 213:
{
  ExprList *pList;
  pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy118.pExpr);
  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-4].minor.yy118.pExpr);
  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy118.pExpr);
  yygotominor.yy118.pExpr = sqlite3ExprFunction(pParse, pList, &yymsp[-3].minor.yy342.eOperator);
  if( yymsp[-3].minor.yy342.not ) yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 19, yygotominor.yy118.pExpr, 0, 0);
  yygotominor.yy118.zStart = yymsp[-4].minor.yy118.zStart;
  yygotominor.yy118.zEnd = yymsp[0].minor.yy118.zEnd;
  if( yygotominor.yy118.pExpr ) yygotominor.yy118.pExpr->flags |= 0x0080;
}
        break;
      case 214:
{spanUnaryPostfix(&yygotominor.yy118,pParse,yymsp[0].major,&yymsp[-1].minor.yy118,&yymsp[0].minor.yy0);}
        break;
      case 215:
{spanUnaryPostfix(&yygotominor.yy118,pParse,74,&yymsp[-2].minor.yy118,&yymsp[0].minor.yy0);}
        break;
      case 216:
{
  spanBinaryExpr(&yygotominor.yy118,pParse,70,&yymsp[-2].minor.yy118,&yymsp[0].minor.yy118);
  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy118.pExpr, yygotominor.yy118.pExpr, 73);
}
        break;
      case 217:
{
  spanBinaryExpr(&yygotominor.yy118,pParse,146,&yymsp[-3].minor.yy118,&yymsp[0].minor.yy118);
  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy118.pExpr, yygotominor.yy118.pExpr, 74);
}
        break;
      case 218:
      case 219: ;
{spanUnaryPrefix(&yygotominor.yy118,pParse,yymsp[-1].major,&yymsp[0].minor.yy118,&yymsp[-1].minor.yy0);}
        break;
      case 220:
{spanUnaryPrefix(&yygotominor.yy118,pParse,156,&yymsp[0].minor.yy118,&yymsp[-1].minor.yy0);}
        break;
      case 221:
{spanUnaryPrefix(&yygotominor.yy118,pParse,157,&yymsp[0].minor.yy118,&yymsp[-1].minor.yy0);}
        break;
      case 224:
{
  ExprList *pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy118.pExpr);
  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy118.pExpr);
  yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 71, yymsp[-4].minor.yy118.pExpr, 0, 0);
  if( yygotominor.yy118.pExpr ){
    yygotominor.yy118.pExpr->x.pList = pList;
  }else{
    sqlite3ExprListDelete(pParse->db, pList);
  }
  if( yymsp[-3].minor.yy4 ) yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 19, yygotominor.yy118.pExpr, 0, 0);
  yygotominor.yy118.zStart = yymsp[-4].minor.yy118.zStart;
  yygotominor.yy118.zEnd = yymsp[0].minor.yy118.zEnd;
}
        break;
      case 227:
{
    if( yymsp[-1].minor.yy322==0 ){
# 105309 "ext/sqlite3/libsqlite/sqlite3.c"
      yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 129, 0, 0, &sqlite3IntTokens[yymsp[-3].minor.yy4]);
      sqlite3ExprDelete(pParse->db, yymsp[-4].minor.yy118.pExpr);
    }else{
      yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 72, yymsp[-4].minor.yy118.pExpr, 0, 0);
      if( yygotominor.yy118.pExpr ){
        yygotominor.yy118.pExpr->x.pList = yymsp[-1].minor.yy322;
        sqlite3ExprSetHeight(pParse, yygotominor.yy118.pExpr);
      }else{
        sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy322);
      }
      if( yymsp[-3].minor.yy4 ) yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 19, yygotominor.yy118.pExpr, 0, 0);
    }
    yygotominor.yy118.zStart = yymsp[-4].minor.yy118.zStart;
    yygotominor.yy118.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
  }
        break;
      case 228:
{
    yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 116, 0, 0, 0);
    if( yygotominor.yy118.pExpr ){
      yygotominor.yy118.pExpr->x.pSelect = yymsp[-1].minor.yy387;
      (yygotominor.yy118.pExpr)->flags|=(0x0800);
      sqlite3ExprSetHeight(pParse, yygotominor.yy118.pExpr);
    }else{
      sqlite3SelectDelete(pParse->db, yymsp[-1].minor.yy387);
    }
    yygotominor.yy118.zStart = yymsp[-2].minor.yy0.z;
    yygotominor.yy118.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
  }
        break;
      case 229:
{
    yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 72, yymsp[-4].minor.yy118.pExpr, 0, 0);
    if( yygotominor.yy118.pExpr ){
      yygotominor.yy118.pExpr->x.pSelect = yymsp[-1].minor.yy387;
      (yygotominor.yy118.pExpr)->flags|=(0x0800);
      sqlite3ExprSetHeight(pParse, yygotominor.yy118.pExpr);
    }else{
      sqlite3SelectDelete(pParse->db, yymsp[-1].minor.yy387);
    }
    if( yymsp[-3].minor.yy4 ) yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 19, yygotominor.yy118.pExpr, 0, 0);
    yygotominor.yy118.zStart = yymsp[-4].minor.yy118.zStart;
    yygotominor.yy118.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
  }
        break;
      case 230:
{
    SrcList *pSrc = sqlite3SrcListAppend(pParse->db, 0,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0);
    yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 72, yymsp[-3].minor.yy118.pExpr, 0, 0);
    if( yygotominor.yy118.pExpr ){
      yygotominor.yy118.pExpr->x.pSelect = sqlite3SelectNew(pParse, 0,pSrc,0,0,0,0,0,0,0);
      (yygotominor.yy118.pExpr)->flags|=(0x0800);
      sqlite3ExprSetHeight(pParse, yygotominor.yy118.pExpr);
    }else{
      sqlite3SrcListDelete(pParse->db, pSrc);
    }
    if( yymsp[-2].minor.yy4 ) yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 19, yygotominor.yy118.pExpr, 0, 0);
    yygotominor.yy118.zStart = yymsp[-3].minor.yy118.zStart;
    yygotominor.yy118.zEnd = yymsp[0].minor.yy0.z ? &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] : &yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n];
  }
        break;
      case 231:
{
    Expr *p = yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 20, 0, 0, 0);
    if( p ){
      p->x.pSelect = yymsp[-1].minor.yy387;
      (p)->flags|=(0x0800);
      sqlite3ExprSetHeight(pParse, p);
    }else{
      sqlite3SelectDelete(pParse->db, yymsp[-1].minor.yy387);
    }
    yygotominor.yy118.zStart = yymsp[-3].minor.yy0.z;
    yygotominor.yy118.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
  }
        break;
      case 232:
{
  yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 134, yymsp[-3].minor.yy314, yymsp[-1].minor.yy314, 0);
  if( yygotominor.yy118.pExpr ){
    yygotominor.yy118.pExpr->x.pList = yymsp[-2].minor.yy322;
    sqlite3ExprSetHeight(pParse, yygotominor.yy118.pExpr);
  }else{
    sqlite3ExprListDelete(pParse->db, yymsp[-2].minor.yy322);
  }
  yygotominor.yy118.zStart = yymsp[-4].minor.yy0.z;
  yygotominor.yy118.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
}
        break;
      case 233:
{
  yygotominor.yy322 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy322, yymsp[-2].minor.yy118.pExpr);
  yygotominor.yy322 = sqlite3ExprListAppend(pParse,yygotominor.yy322, yymsp[0].minor.yy118.pExpr);
}
        break;
      case 234:
{
  yygotominor.yy322 = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy118.pExpr);
  yygotominor.yy322 = sqlite3ExprListAppend(pParse,yygotominor.yy322, yymsp[0].minor.yy118.pExpr);
}
        break;
      case 243:
{
  sqlite3CreateIndex(pParse, &yymsp[-6].minor.yy0, &yymsp[-5].minor.yy0,
                     sqlite3SrcListAppend(pParse->db,0,&yymsp[-3].minor.yy0,0), yymsp[-1].minor.yy322, yymsp[-9].minor.yy4,
                      &yymsp[-10].minor.yy0, &yymsp[0].minor.yy0, 0, yymsp[-7].minor.yy4);
}
        break;
      case 244:
      case 298: ;
{yygotominor.yy4 = 2;}
        break;
      case 245:
{yygotominor.yy4 = 0;}
        break;
      case 248:
{
  Expr *p = 0;
  if( yymsp[-1].minor.yy0.n>0 ){
    p = sqlite3Expr(pParse->db, 152, 0);
    sqlite3ExprSetCollByToken(pParse, p, &yymsp[-1].minor.yy0);
  }
  yygotominor.yy322 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy322, p);
  sqlite3ExprListSetName(pParse,yygotominor.yy322,&yymsp[-2].minor.yy0,1);
  sqlite3ExprListCheckLength(pParse, yygotominor.yy322, "index");
  if( yygotominor.yy322 ) yygotominor.yy322->a[yygotominor.yy322->nExpr-1].sortOrder = (u8)yymsp[0].minor.yy4;
}
        break;
      case 249:
{
  Expr *p = 0;
  if( yymsp[-1].minor.yy0.n>0 ){
    p = sqlite3PExpr(pParse, 152, 0, 0, 0);
    sqlite3ExprSetCollByToken(pParse, p, &yymsp[-1].minor.yy0);
  }
  yygotominor.yy322 = sqlite3ExprListAppend(pParse,0, p);
  sqlite3ExprListSetName(pParse, yygotominor.yy322, &yymsp[-2].minor.yy0, 1);
  sqlite3ExprListCheckLength(pParse, yygotominor.yy322, "index");
  if( yygotominor.yy322 ) yygotominor.yy322->a[yygotominor.yy322->nExpr-1].sortOrder = (u8)yymsp[0].minor.yy4;
}
        break;
      case 250:
{yygotominor.yy0.z = 0; yygotominor.yy0.n = 0;}
        break;
      case 252:
{sqlite3DropIndex(pParse, yymsp[0].minor.yy259, yymsp[-1].minor.yy4);}
        break;
      case 253:
      case 254: ;
{sqlite3Vacuum(pParse);}
        break;
      case 255:
{sqlite3Pragma(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,0,0);}
        break;
      case 256:
{sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,0);}
        break;
      case 257:
{sqlite3Pragma(pParse,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,0);}
        break;
      case 258:
{sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,1);}
        break;
      case 259:
{sqlite3Pragma(pParse,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,1);}
        break;
      case 270:
{
  Token all;
  all.z = yymsp[-3].minor.yy0.z;
  all.n = (int)(yymsp[0].minor.yy0.z - yymsp[-3].minor.yy0.z) + yymsp[0].minor.yy0.n;
  sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy203, &all);
}
        break;
      case 271:
{
  sqlite3BeginTrigger(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, yymsp[-5].minor.yy4, yymsp[-4].minor.yy90.a, yymsp[-4].minor.yy90.b, yymsp[-2].minor.yy259, yymsp[0].minor.yy314, yymsp[-10].minor.yy4, yymsp[-8].minor.yy4);
  yygotominor.yy0 = (yymsp[-6].minor.yy0.n==0?yymsp[-7].minor.yy0:yymsp[-6].minor.yy0);
}
        break;
      case 272:
      case 275: ;
{ yygotominor.yy4 = 34; }
        break;
      case 273:
{ yygotominor.yy4 = 30; }
        break;
      case 274:
{ yygotominor.yy4 = 48;}
        break;
      case 276:
      case 277: ;
{yygotominor.yy90.a = yymsp[0].major; yygotominor.yy90.b = 0;}
        break;
      case 278:
{yygotominor.yy90.a = 107; yygotominor.yy90.b = yymsp[0].minor.yy384;}
        break;
      case 281:
      case 303: ;
{ yygotominor.yy314 = 0; }
        break;
      case 282:
      case 304: ;
{ yygotominor.yy314 = yymsp[0].minor.yy118.pExpr; }
        break;
      case 283:
{
  ((void) (0));
  yymsp[-2].minor.yy203->pLast->pNext = yymsp[-1].minor.yy203;
  yymsp[-2].minor.yy203->pLast = yymsp[-1].minor.yy203;
  yygotominor.yy203 = yymsp[-2].minor.yy203;
}
        break;
      case 284:
{
  ((void) (0));
  yymsp[-1].minor.yy203->pLast = yymsp[-1].minor.yy203;
  yygotominor.yy203 = yymsp[-1].minor.yy203;
}
        break;
      case 286:
{
  yygotominor.yy0 = yymsp[0].minor.yy0;
  sqlite3ErrorMsg(pParse,
        "qualified table names are not allowed on INSERT, UPDATE, and DELETE "
        "statements within triggers");
}
        break;
      case 288:
{
  sqlite3ErrorMsg(pParse,
        "the INDEXED BY clause is not allowed on UPDATE or DELETE statements "
        "within triggers");
}
        break;
      case 289:
{
  sqlite3ErrorMsg(pParse,
        "the NOT INDEXED clause is not allowed on UPDATE or DELETE statements "
        "within triggers");
}
        break;
      case 290:
{ yygotominor.yy203 = sqlite3TriggerUpdateStep(pParse->db, &yymsp[-4].minor.yy0, yymsp[-1].minor.yy322, yymsp[0].minor.yy314, yymsp[-5].minor.yy210); }
        break;
      case 291:
{yygotominor.yy203 = sqlite3TriggerInsertStep(pParse->db, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy384, yymsp[-1].minor.yy322, 0, yymsp[-7].minor.yy210);}
        break;
      case 292:
{yygotominor.yy203 = sqlite3TriggerInsertStep(pParse->db, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy384, 0, yymsp[0].minor.yy387, yymsp[-4].minor.yy210);}
        break;
      case 293:
{yygotominor.yy203 = sqlite3TriggerDeleteStep(pParse->db, &yymsp[-2].minor.yy0, yymsp[0].minor.yy314);}
        break;
      case 294:
{yygotominor.yy203 = sqlite3TriggerSelectStep(pParse->db, yymsp[0].minor.yy387); }
        break;
      case 295:
{
  yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 56, 0, 0, 0);
  if( yygotominor.yy118.pExpr ){
    yygotominor.yy118.pExpr->affinity = 4;
  }
  yygotominor.yy118.zStart = yymsp[-3].minor.yy0.z;
  yygotominor.yy118.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
}
        break;
      case 296:
{
  yygotominor.yy118.pExpr = sqlite3PExpr(pParse, 56, 0, 0, &yymsp[-1].minor.yy0);
  if( yygotominor.yy118.pExpr ) {
    yygotominor.yy118.pExpr->affinity = (char)yymsp[-3].minor.yy4;
  }
  yygotominor.yy118.zStart = yymsp[-5].minor.yy0.z;
  yygotominor.yy118.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];
}
        break;
      case 297:
{yygotominor.yy4 = 1;}
        break;
      case 299:
{yygotominor.yy4 = 3;}
        break;
      case 300:
{
  sqlite3DropTrigger(pParse,yymsp[0].minor.yy259,yymsp[-1].minor.yy4);
}
        break;
      case 301:
{
  sqlite3Attach(pParse, yymsp[-3].minor.yy118.pExpr, yymsp[-1].minor.yy118.pExpr, yymsp[0].minor.yy314);
}
        break;
      case 302:
{
  sqlite3Detach(pParse, yymsp[0].minor.yy118.pExpr);
}
        break;
      case 307:
{sqlite3Reindex(pParse, 0, 0);}
        break;
      case 308:
{sqlite3Reindex(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);}
        break;
      case 309:
{sqlite3Analyze(pParse, 0, 0);}
        break;
      case 310:
{sqlite3Analyze(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);}
        break;
      case 311:
{
  sqlite3AlterRenameTable(pParse,yymsp[-3].minor.yy259,&yymsp[0].minor.yy0);
}
        break;
      case 312:
{
  sqlite3AlterFinishAddColumn(pParse, &yymsp[0].minor.yy0);
}
        break;
      case 313:
{
  pParse->db->lookaside.bEnabled = 0;
  sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy259);
}
        break;
      case 316:
{sqlite3VtabFinishParse(pParse,0);}
        break;
      case 317:
{sqlite3VtabFinishParse(pParse,&yymsp[0].minor.yy0);}
        break;
      case 318:
{
    sqlite3VtabBeginParse(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0);
}
        break;
      case 321:
{sqlite3VtabArgInit(pParse);}
        break;
      case 323:
      case 324: ;
      case 325: ;
{sqlite3VtabArgExtend(pParse,&yymsp[0].minor.yy0);}
        break;
      default:
                                                         ;
                                                                ;
                                                        ;
                                                     ;
                                                                  ;
                                                       ;
                                                                   ;
                                                                      ;
                                                                     ;
                                                           ;
                                                                                ;
                                                                                ;
                                                               ;
                                                  ;
                                                             ;
                                                              ;
                                                                    ;
                                                      ;
                                                                      ;
                                                        ;
                                                               ;
                                                                           ;
                                                                     ;
                                                            ;
                                                                 ;
                                                             ;
                                                        ;
                                                              ;
                                                                           ;
                                                       ;
                                                                        ;
                                                               ;
                                                            ;
                                                                     ;
                                                                   ;
                                                                                     ;
                                                                            ;
                                                       ;
                                                                             ;
                                                                   ;
        break;
  };
  yygoto = yyRuleInfo[yyruleno].lhs;
  yysize = yyRuleInfo[yyruleno].nrhs;
  yypParser->yyidx -= yysize;
  yyact = yy_find_reduce_action(yymsp[-yysize].stateno,(unsigned char)yygoto);
  if( yyact < 630 ){





    if( yysize ){
      yypParser->yyidx++;
      yymsp -= yysize-1;
      yymsp->stateno = (unsigned short int)yyact;
      yymsp->major = (unsigned char)yygoto;
      yymsp->minor = yygotominor;
    }else

    {
      yy_shift(yypParser,yyact,yygoto,&yygotominor);
    }
  }else{
    ((void) (0));
    yy_accept(yypParser);
  }
}
# 105746 "ext/sqlite3/libsqlite/sqlite3.c"
static void yy_syntax_error(
  yyParser *yypParser,
  int yymajor,
  YYMINORTYPE yyminor
){
  Parse *pParse = yypParser->pParse;


  (void)(yymajor);
  ((void) (0));
  sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", &(yyminor.yy0));
  pParse->parseError = 1;
  yypParser->pParse = pParse;
}




static void yy_accept(
  yyParser *yypParser
){
  Parse *pParse = yypParser->pParse;





  while( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser);


  yypParser->pParse = pParse;
}
# 105798 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3Parser(
  void *yyp,
  int yymajor,
  Token yyminor
  ,Parse *pParse
){
  YYMINORTYPE yyminorunion;
  int yyact;
  int yyendofinput;



  yyParser *yypParser;


  yypParser = (yyParser*)yyp;
  if( yypParser->yyidx<0 ){
# 105823 "ext/sqlite3/libsqlite/sqlite3.c"
    yypParser->yyidx = 0;
    yypParser->yyerrcnt = -1;
    yypParser->yystack[0].stateno = 0;
    yypParser->yystack[0].major = 0;
  }
  yyminorunion.yy0 = yyminor;
  yyendofinput = (yymajor==0);
  yypParser->pParse = pParse;







  do{
    yyact = yy_find_shift_action(yypParser,(unsigned char)yymajor);
    if( yyact<630 ){
      ((void) (0));
      yy_shift(yypParser,yyact,yymajor,&yyminorunion);
      yypParser->yyerrcnt--;
      yymajor = 253;
    }else if( yyact < 630 + 329 ){
      yy_reduce(yypParser,yyact-630);
    }else{
      ((void) (0));
# 105920 "ext/sqlite3/libsqlite/sqlite3.c"
      yy_syntax_error(yypParser,yymajor,yyminorunion);
      yy_destructor(yypParser,(unsigned char)yymajor,&yyminorunion);
      yymajor = 253;
# 105944 "ext/sqlite3/libsqlite/sqlite3.c"
    }
  }while( yymajor!=253 && yypParser->yyidx>=0 );
  return;
}
# 106029 "ext/sqlite3/libsqlite/sqlite3.c"
static int keywordCode(const char *z, int n){
# 106041 "ext/sqlite3/libsqlite/sqlite3.c"
  static const char zText[540] = {
    'R','E','I','N','D','E','X','E','D','E','S','C','A','P','E','A','C','H',
    'E','C','K','E','Y','B','E','F','O','R','E','I','G','N','O','R','E','G',
    'E','X','P','L','A','I','N','S','T','E','A','D','D','A','T','A','B','A',
    'S','E','L','E','C','T','A','B','L','E','F','T','H','E','N','D','E','F',
    'E','R','R','A','B','L','E','L','S','E','X','C','E','P','T','R','A','N',
    'S','A','C','T','I','O','N','A','T','U','R','A','L','T','E','R','A','I',
    'S','E','X','C','L','U','S','I','V','E','X','I','S','T','S','A','V','E',
    'P','O','I','N','T','E','R','S','E','C','T','R','I','G','G','E','R','E',
    'F','E','R','E','N','C','E','S','C','O','N','S','T','R','A','I','N','T',
    'O','F','F','S','E','T','E','M','P','O','R','A','R','Y','U','N','I','Q',
    'U','E','R','Y','A','T','T','A','C','H','A','V','I','N','G','R','O','U',
    'P','D','A','T','E','B','E','G','I','N','N','E','R','E','L','E','A','S',
    'E','B','E','T','W','E','E','N','O','T','N','U','L','L','I','K','E','C',
    'A','S','C','A','D','E','L','E','T','E','C','A','S','E','C','O','L','L',
    'A','T','E','C','R','E','A','T','E','C','U','R','R','E','N','T','_','D',
    'A','T','E','D','E','T','A','C','H','I','M','M','E','D','I','A','T','E',
    'J','O','I','N','S','E','R','T','M','A','T','C','H','P','L','A','N','A',
    'L','Y','Z','E','P','R','A','G','M','A','B','O','R','T','V','A','L','U',
    'E','S','V','I','R','T','U','A','L','I','M','I','T','W','H','E','N','W',
    'H','E','R','E','N','A','M','E','A','F','T','E','R','E','P','L','A','C',
    'E','A','N','D','E','F','A','U','L','T','A','U','T','O','I','N','C','R',
    'E','M','E','N','T','C','A','S','T','C','O','L','U','M','N','C','O','M',
    'M','I','T','C','O','N','F','L','I','C','T','C','R','O','S','S','C','U',
    'R','R','E','N','T','_','T','I','M','E','S','T','A','M','P','R','I','M',
    'A','R','Y','D','E','F','E','R','R','E','D','I','S','T','I','N','C','T',
    'D','R','O','P','F','A','I','L','F','R','O','M','F','U','L','L','G','L',
    'O','B','Y','I','F','I','S','N','U','L','L','O','R','D','E','R','E','S',
    'T','R','I','C','T','O','U','T','E','R','I','G','H','T','R','O','L','L',
    'B','A','C','K','R','O','W','U','N','I','O','N','U','S','I','N','G','V',
    'A','C','U','U','M','V','I','E','W','I','N','I','T','I','A','L','L','Y',
  };
  static const unsigned char aHash[127] = {
      72, 101, 114, 70, 0, 45, 0, 0, 78, 0, 73, 0, 0,
      42, 12, 74, 15, 0, 113, 81, 50, 108, 0, 19, 0, 0,
     118, 0, 116, 111, 0, 22, 89, 0, 9, 0, 0, 66, 67,
       0, 65, 6, 0, 48, 86, 98, 0, 115, 97, 0, 0, 44,
       0, 99, 24, 0, 17, 0, 119, 49, 23, 0, 5, 106, 25,
      92, 0, 0, 121, 102, 56, 120, 53, 28, 51, 0, 87, 0,
      96, 26, 0, 95, 0, 0, 0, 91, 88, 93, 84, 105, 14,
      39, 104, 0, 77, 0, 18, 85, 107, 32, 0, 117, 76, 109,
      58, 46, 80, 0, 0, 90, 40, 0, 112, 0, 36, 0, 0,
      29, 0, 82, 59, 60, 0, 20, 57, 0, 52,
  };
  static const unsigned char aNext[121] = {
       0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 2, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0,
       0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 33, 0, 21, 0, 0, 0, 43, 3, 47,
       0, 0, 0, 0, 30, 0, 54, 0, 38, 0, 0, 0, 1,
      62, 0, 0, 63, 0, 41, 0, 0, 0, 0, 0, 0, 0,
      61, 0, 0, 0, 0, 31, 55, 16, 34, 10, 0, 0, 0,
       0, 0, 0, 0, 11, 68, 75, 0, 8, 0, 100, 94, 0,
     103, 0, 83, 0, 71, 0, 0, 110, 27, 37, 69, 79, 0,
      35, 64, 0, 0,
  };
  static const unsigned char aLen[121] = {
       7, 7, 5, 4, 6, 4, 5, 3, 6, 7, 3, 6, 6,
       7, 7, 3, 8, 2, 6, 5, 4, 4, 3, 10, 4, 6,
      11, 6, 2, 7, 5, 5, 9, 6, 9, 9, 7, 10, 10,
       4, 6, 2, 3, 9, 4, 2, 6, 5, 6, 6, 5, 6,
       5, 5, 7, 7, 7, 3, 2, 4, 4, 7, 3, 6, 4,
       7, 6, 12, 6, 9, 4, 6, 5, 4, 7, 6, 5, 6,
       7, 5, 4, 5, 6, 5, 7, 3, 7, 13, 2, 2, 4,
       6, 6, 8, 5, 17, 12, 7, 8, 8, 2, 4, 4, 4,
       4, 4, 2, 2, 6, 5, 8, 5, 5, 8, 3, 5, 5,
       6, 4, 9, 3,
  };
  static const unsigned short int aOffset[121] = {
       0, 2, 2, 8, 9, 14, 16, 20, 23, 25, 25, 29, 33,
      36, 41, 46, 48, 53, 54, 59, 62, 65, 67, 69, 78, 81,
      86, 91, 95, 96, 101, 105, 109, 117, 122, 128, 136, 142, 152,
     159, 162, 162, 165, 167, 167, 171, 176, 179, 184, 189, 194, 197,
     203, 206, 210, 217, 223, 223, 223, 226, 229, 233, 234, 238, 244,
     248, 255, 261, 273, 279, 288, 290, 296, 301, 303, 310, 315, 320,
     326, 332, 337, 341, 344, 350, 354, 361, 363, 370, 372, 374, 383,
     387, 393, 399, 407, 412, 412, 428, 435, 442, 443, 450, 454, 458,
     462, 466, 469, 471, 473, 479, 483, 491, 495, 500, 508, 511, 516,
     521, 527, 531, 536,
  };
  static const unsigned char aCode[121] = {
    64, 27, 138, 41, 81,
    43, 101, 52, 34, 110,
    45, 46, 49, 2, 48,
    140, 40, 24, 116, 16,
    95, 136, 11, 109, 137,
    114, 6,29, 104, 95,
    139, 56, 9, 20, 13,
    115, 60, 102, 96, 127,
    54, 53, 108, 21, 21,
    68, 100, 3, 33, 124,
    123, 107, 5, 95, 14,
    71, 74, 19, 51, 98,
    49, 36, 32, 106, 134,
    92, 17, 66, 42, 8,
    120, 105, 50, 4, 31,
    55, 28, 128, 63, 125,
    135, 126, 65, 30, 57,
    69, 97, 103, 15, 72,
    37, 38, 10, 39, 95,
    66, 66, 99, 7, 117,
    70, 111, 44, 119, 95,
    49, 35, 18, 73, 122,
    58, 95, 95, 12, 59,
    112, 121, 61, 62, 47,
    113,
  };
  int h, i;
  if( n<2 ) return 26;
  h = ((sqlite3UpperToLower[(unsigned char)z[0]]*4) ^
      (sqlite3UpperToLower[(unsigned char)z[n-1]]*3) ^
      n) % 127;
  for(i=((int)aHash[h])-1; i>=0; i=((int)aNext[i])-1){
    if( aLen[i]==n && sqlite3_strnicmp(&zText[aOffset[i]],z,n)==0 ){
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                      ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                       ;
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;
                        ;
      return aCode[i];
    }
  }
  return 26;
}
static int sqlite3KeywordCode(const unsigned char *z, int n){
  return keywordCode((char*)z, n);
}
# 106333 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3GetToken(const unsigned char *z, int *tokenType){
  int i, c;
  switch( *z ){
    case ' ': case '\t': case '\n': case '\f': case '\r': {
                           ;
                            ;
                            ;
                            ;
                            ;
      for(i=1; (sqlite3CtypeMap[(unsigned char)(z[i])]&0x01); i++){}
      *tokenType = 149;
      return i;
    }
    case '-': {
      if( z[1]=='-' ){

        for(i=2; (c=z[i])!=0 && c!='\n'; i++){}
        *tokenType = 149;
        return i;
      }
      *tokenType = 87;
      return 1;
    }
    case '(': {
      *tokenType = 22;
      return 1;
    }
    case ')': {
      *tokenType = 23;
      return 1;
    }
    case ';': {
      *tokenType = 1;
      return 1;
    }
    case '+': {
      *tokenType = 86;
      return 1;
    }
    case '*': {
      *tokenType = 88;
      return 1;
    }
    case '/': {
      if( z[1]!='*' || z[2]==0 ){
        *tokenType = 89;
        return 1;
      }

      for(i=3, c=z[2]; (c!='*' || z[i]!='/') && (c=z[i])!=0; i++){}
      if( c ) i++;
      *tokenType = 149;
      return i;
    }
    case '%': {
      *tokenType = 90;
      return 1;
    }
    case '=': {
      *tokenType = 76;
      return 1 + (z[1]=='=');
    }
    case '<': {
      if( (c=z[1])=='=' ){
        *tokenType = 78;
        return 2;
      }else if( c=='>' ){
        *tokenType = 75;
        return 2;
      }else if( c=='<' ){
        *tokenType = 84;
        return 2;
      }else{
        *tokenType = 79;
        return 1;
      }
    }
    case '>': {
      if( (c=z[1])=='=' ){
        *tokenType = 80;
        return 2;
      }else if( c=='>' ){
        *tokenType = 85;
        return 2;
      }else{
        *tokenType = 77;
        return 1;
      }
    }
    case '!': {
      if( z[1]!='=' ){
        *tokenType = 148;
        return 2;
      }else{
        *tokenType = 75;
        return 2;
      }
    }
    case '|': {
      if( z[1]!='|' ){
        *tokenType = 83;
        return 1;
      }else{
        *tokenType = 91;
        return 2;
      }
    }
    case ',': {
      *tokenType = 25;
      return 1;
    }
    case '&': {
      *tokenType = 82;
      return 1;
    }
    case '~': {
      *tokenType = 93;
      return 1;
    }
    case '`':
    case '\'':
    case '"': {
      int delim = z[0];
                            ;
                             ;
                            ;
      for(i=1; (c=z[i])!=0; i++){
        if( c==delim ){
          if( z[i+1]==delim ){
            i++;
          }else{
            break;
          }
        }
      }
      if( c=='\'' ){
        *tokenType = 94;
        return i+1;
      }else if( c!=0 ){
        *tokenType = 26;
        return i+1;
      }else{
        *tokenType = 148;
        return i;
      }
    }
    case '.': {

      if( !(sqlite3CtypeMap[(unsigned char)(z[1])]&0x04) )

      {
        *tokenType = 118;
        return 1;
      }


    }
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9': {
                           ; ; ;
                           ; ; ;
                           ; ; ;
                           ;
      *tokenType = 129;
      for(i=0; (sqlite3CtypeMap[(unsigned char)(z[i])]&0x04); i++){}

      if( z[i]=='.' ){
        i++;
        while( (sqlite3CtypeMap[(unsigned char)(z[i])]&0x04) ){ i++; }
        *tokenType = 130;
      }
      if( (z[i]=='e' || z[i]=='E') &&
           ( (sqlite3CtypeMap[(unsigned char)(z[i+1])]&0x04)
            || ((z[i+1]=='+' || z[i+1]=='-') && (sqlite3CtypeMap[(unsigned char)(z[i+2])]&0x04))
           )
      ){
        i += 2;
        while( (sqlite3CtypeMap[(unsigned char)(z[i])]&0x04) ){ i++; }
        *tokenType = 130;
      }

      while( ((sqlite3CtypeMap[(unsigned char)z[i]]&0x46)!=0) ){
        *tokenType = 148;
        i++;
      }
      return i;
    }
    case '[': {
      for(i=1, c=z[0]; c!=']' && (c=z[i])!=0; i++){}
      *tokenType = c==']' ? 26 : 148;
      return i;
    }
    case '?': {
      *tokenType = 133;
      for(i=1; (sqlite3CtypeMap[(unsigned char)(z[i])]&0x04); i++){}
      return i;
    }
    case '#': {
      for(i=1; (sqlite3CtypeMap[(unsigned char)(z[i])]&0x04); i++){}
      if( i>1 ){


        *tokenType = 132;
        return i;
      }


    }

    case '$':

    case '@':
    case ':': {
      int n = 0;
                           ; ; ;
      *tokenType = 133;
      for(i=1; (c=z[i])!=0; i++){
        if( ((sqlite3CtypeMap[(unsigned char)c]&0x46)!=0) ){
          n++;

        }else if( c=='(' && n>0 ){
          do{
            i++;
          }while( (c=z[i])!=0 && !(sqlite3CtypeMap[(unsigned char)(c)]&0x01) && c!=')' );
          if( c==')' ){
            i++;
          }else{
            *tokenType = 148;
          }
          break;
        }else if( c==':' && z[i+1]==':' ){
          i++;

        }else{
          break;
        }
      }
      if( n==0 ) *tokenType = 148;
      return i;
    }

    case 'x': case 'X': {
                           ; ;
      if( z[1]=='\'' ){
        *tokenType = 131;
        for(i=2; (c=z[i])!=0 && c!='\''; i++){
          if( !(sqlite3CtypeMap[(unsigned char)(c)]&0x08) ){
            *tokenType = 148;
          }
        }
        if( i%2 || !c ) *tokenType = 148;
        if( c ) i++;
        return i;
      }

    }

    default: {
      if( !((sqlite3CtypeMap[(unsigned char)*z]&0x46)!=0) ){
        break;
      }
      for(i=1; ((sqlite3CtypeMap[(unsigned char)z[i]]&0x46)!=0); i++){}
      *tokenType = keywordCode((char*)z, i);
      return i;
    }
  }
  *tokenType = 148;
  return 1;
}
# 106610 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzErrMsg){
  int nErr = 0;
  int i;
  void *pEngine;
  int tokenType;
  int lastTokenParsed = -1;
  u8 enableLookaside;
  sqlite3 *db = pParse->db;
  int mxSqlLen;


  mxSqlLen = db->aLimit[1];
  if( db->activeVdbeCnt==0 ){
    db->u1.isInterrupted = 0;
  }
  pParse->rc = 0;
  pParse->zTail = zSql;
  i = 0;
  ((void) (0));
  pEngine = sqlite3ParserAlloc((void*(*)(size_t))sqlite3Malloc);
  if( pEngine==0 ){
    db->mallocFailed = 1;
    return 7;
  }
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  enableLookaside = db->lookaside.bEnabled;
  if( db->lookaside.pStart ) db->lookaside.bEnabled = 1;
  while( !db->mallocFailed && zSql[i]!=0 ){
    ((void) (0));
    pParse->sLastToken.z = &zSql[i];
    pParse->sLastToken.n = sqlite3GetToken((unsigned char*)&zSql[i],&tokenType);
    i += pParse->sLastToken.n;
    if( i>mxSqlLen ){
      pParse->rc = 18;
      break;
    }
    switch( tokenType ){
      case 149: {
        if( db->u1.isInterrupted ){
          sqlite3ErrorMsg(pParse, "interrupt");
          pParse->rc = 9;
          goto abort_parse;
        }
        break;
      }
      case 148: {
        sqlite3DbFree(db, *pzErrMsg);
        *pzErrMsg = sqlite3MPrintf(db, "unrecognized token: \"%T\"",
                        &pParse->sLastToken);
        nErr++;
        goto abort_parse;
      }
      case 1: {
        pParse->zTail = &zSql[i];

      }
      default: {
        sqlite3Parser(pEngine, tokenType, pParse->sLastToken, pParse);
        lastTokenParsed = tokenType;
        if( pParse->rc!=0 ){
          goto abort_parse;
        }
        break;
      }
    }
  }
abort_parse:
  if( zSql[i]==0 && nErr==0 && pParse->rc==0 ){
    if( lastTokenParsed!=1 ){
      sqlite3Parser(pEngine, 1, pParse->sLastToken, pParse);
      pParse->zTail = &zSql[i];
    }
    sqlite3Parser(pEngine, 0, pParse->sLastToken, pParse);
  }





  sqlite3ParserFree(pEngine, sqlite3_free);
  db->lookaside.bEnabled = enableLookaside;
  if( db->mallocFailed ){
    pParse->rc = 7;
  }
  if( pParse->rc!=0 && pParse->rc!=101 && pParse->zErrMsg==0 ){
    sqlite3SetString(&pParse->zErrMsg, db, "%s", sqlite3ErrStr(pParse->rc));
  }
  ((void) (0));
  if( pParse->zErrMsg ){
    *pzErrMsg = pParse->zErrMsg;
    sqlite3_log(pParse->rc, "%s", *pzErrMsg);
    pParse->zErrMsg = 0;
    nErr++;
  }
  if( pParse->pVdbe && pParse->nErr>0 && pParse->nested==0 ){
    sqlite3VdbeDelete(pParse->pVdbe);
    pParse->pVdbe = 0;
  }

  if( pParse->nested==0 ){
    sqlite3DbFree(db, pParse->aTableLock);
    pParse->aTableLock = 0;
    pParse->nTableLock = 0;
  }


  sqlite3_free(pParse->apVtabLock);


  if( !(pParse->declareVtab) ){




    sqlite3DeleteTable(db, pParse->pNewTable);
  }

  sqlite3DeleteTrigger(db, pParse->pNewTrigger);
  sqlite3DbFree(db, pParse->apVarExpr);
  sqlite3DbFree(db, pParse->aAlias);
  while( pParse->pAinc ){
    AutoincInfo *p = pParse->pAinc;
    pParse->pAinc = p->pNext;
    sqlite3DbFree(db, p);
  }
  while( pParse->pZombieTab ){
    Table *p = pParse->pZombieTab;
    pParse->pZombieTab = p->pNextZombie;
    sqlite3DeleteTable(db, p);
  }
  if( nErr>0 && pParse->rc==0 ){
    pParse->rc = 1;
  }
  return nErr;
}
# 106855 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_complete(const char *zSql){
  u8 state = 0;
  u8 token;





  static const u8 trans[8][8] = {


                      { 1, 0, 2, 3, 4, 2, 2, 2, },
                      { 1, 1, 2, 3, 4, 2, 2, 2, },
                      { 1, 2, 2, 2, 2, 2, 2, 2, },
                      { 1, 3, 3, 2, 4, 2, 2, 2, },
                      { 1, 4, 2, 2, 2, 4, 5, 2, },
                      { 6, 5, 5, 5, 5, 5, 5, 5, },
                      { 6, 6, 5, 5, 5, 5, 5, 7, },
                      { 1, 7, 5, 5, 5, 5, 5, 5, },
  };
# 106888 "ext/sqlite3/libsqlite/sqlite3.c"
  while( *zSql ){
    switch( *zSql ){
      case ';': {
        token = 0;
        break;
      }
      case ' ':
      case '\r':
      case '\t':
      case '\n':
      case '\f': {
        token = 1;
        break;
      }
      case '/': {
        if( zSql[1]!='*' ){
          token = 2;
          break;
        }
        zSql += 2;
        while( zSql[0] && (zSql[0]!='*' || zSql[1]!='/') ){ zSql++; }
        if( zSql[0]==0 ) return 0;
        zSql++;
        token = 1;
        break;
      }
      case '-': {
        if( zSql[1]!='-' ){
          token = 2;
          break;
        }
        while( *zSql && *zSql!='\n' ){ zSql++; }
        if( *zSql==0 ) return state==1;
        token = 1;
        break;
      }
      case '[': {
        zSql++;
        while( *zSql && *zSql!=']' ){ zSql++; }
        if( *zSql==0 ) return 0;
        token = 2;
        break;
      }
      case '`':
      case '"':
      case '\'': {
        int c = *zSql;
        zSql++;
        while( *zSql && *zSql!=c ){ zSql++; }
        if( *zSql==0 ) return 0;
        token = 2;
        break;
      }
      default: {



        if( ((sqlite3CtypeMap[(unsigned char)(u8)*zSql]&0x46)!=0) ){

          int nId;
          for(nId=1; ((sqlite3CtypeMap[(unsigned char)zSql[nId]]&0x46)!=0); nId++){}



          switch( *zSql ){
            case 'c': case 'C': {
              if( nId==6 && sqlite3_strnicmp(zSql, "create", 6)==0 ){
                token = 4;
              }else{
                token = 2;
              }
              break;
            }
            case 't': case 'T': {
              if( nId==7 && sqlite3_strnicmp(zSql, "trigger", 7)==0 ){
                token = 6;
              }else if( nId==4 && sqlite3_strnicmp(zSql, "temp", 4)==0 ){
                token = 5;
              }else if( nId==9 && sqlite3_strnicmp(zSql, "temporary", 9)==0 ){
                token = 5;
              }else{
                token = 2;
              }
              break;
            }
            case 'e': case 'E': {
              if( nId==3 && sqlite3_strnicmp(zSql, "end", 3)==0 ){
                token = 7;
              }else

              if( nId==7 && sqlite3_strnicmp(zSql, "explain", 7)==0 ){
                token = 3;
              }else

              {
                token = 2;
              }
              break;
            }
            default: {
              token = 2;
              break;
            }
          }

          zSql += nId-1;
        }else{

          token = 2;
        }
        break;
      }
    }
    state = trans[state][token];
    zSql++;
  }
  return state==1;
}







           int sqlite3_complete16(const void *zSql){
  sqlite3_value *pVal;
  char const *zSql8;
  int rc = 7;


  rc = sqlite3_initialize();
  if( rc ) return rc;

  pVal = sqlite3ValueNew(0);
  sqlite3ValueSetStr(pVal, -1, zSql, 2, ((sqlite3_destructor_type)0));
  zSql8 = sqlite3ValueText(pVal, 1);
  if( zSql8 ){
    rc = sqlite3_complete(zSql8);
  }else{
    rc = 7;
  }
  sqlite3ValueFree(pVal);
  return sqlite3ApiExit(0, rc);
}
# 107078 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Fts3Init(sqlite3 *db);
# 107163 "ext/sqlite3/libsqlite/sqlite3.c"
           const char *sqlite3_libversion(void){ return sqlite3_version; }





           const char *sqlite3_sourceid(void){ return "2011-05-19 13:26:54 ed1da510a239ea767a01dc332b667119fa3c908e"; }




           int sqlite3_libversion_number(void){ return 3007006; }





           int sqlite3_threadsafe(void){ return 0; }
# 107199 "ext/sqlite3/libsqlite/sqlite3.c"
           char *sqlite3_temp_directory = 0;
# 107232 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_initialize(void){
  sqlite3_mutex *pMaster;
  int rc;
# 107248 "ext/sqlite3/libsqlite/sqlite3.c"
  if( sqlite3Config.isInit ) return 0;
# 107258 "ext/sqlite3/libsqlite/sqlite3.c"
  rc = 0;
  if( rc ) return rc;







  pMaster = ((sqlite3_mutex*)8);
                              ;
  sqlite3Config.isMutexInit = 1;
  if( !sqlite3Config.isMallocInit ){
    rc = sqlite3MallocInit();
  }
  if( rc==0 ){
    sqlite3Config.isMallocInit = 1;
    if( !sqlite3Config.pInitMutex ){
      sqlite3Config.pInitMutex =
           ((sqlite3_mutex*)8);
      if( sqlite3Config.bCoreMutex && !sqlite3Config.pInitMutex ){
        rc = 7;
      }
    }
  }
  if( rc==0 ){
    sqlite3Config.nRefInitMutex++;
  }
                              ;




  if( rc!=0 ){
    return rc;
  }
# 107308 "ext/sqlite3/libsqlite/sqlite3.c"
                                                     ;
  if( sqlite3Config.isInit==0 && sqlite3Config.inProgress==0 ){
    FuncDefHash *pHash = &sqlite3GlobalFunctions;
    sqlite3Config.inProgress = 1;
    memset(pHash, 0, sizeof(sqlite3GlobalFunctions));
    sqlite3RegisterGlobalFunctions();
    if( sqlite3Config.isPCacheInit==0 ){
      rc = sqlite3PcacheInitialize();
    }
    if( rc==0 ){
      sqlite3Config.isPCacheInit = 1;
      rc = sqlite3OsInit();
    }
    if( rc==0 ){
      sqlite3PCacheBufferSetup( sqlite3Config.pPage,
          sqlite3Config.szPage, sqlite3Config.nPage);
      sqlite3Config.isInit = 1;
    }
    sqlite3Config.inProgress = 0;
  }
                                                     ;




                              ;
  sqlite3Config.nRefInitMutex--;
  if( sqlite3Config.nRefInitMutex<=0 ){
    ((void) (0));
                                                      ;
    sqlite3Config.pInitMutex = 0;
  }
                              ;
# 107361 "ext/sqlite3/libsqlite/sqlite3.c"
  return rc;
}
# 107372 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_shutdown(void){
  if( sqlite3Config.isInit ){
    sqlite3_os_end();
    sqlite3_reset_auto_extension();
    sqlite3Config.isInit = 0;
  }
  if( sqlite3Config.isPCacheInit ){
    sqlite3PcacheShutdown();
    sqlite3Config.isPCacheInit = 0;
  }
  if( sqlite3Config.isMallocInit ){
    sqlite3MallocEnd();
    sqlite3Config.isMallocInit = 0;
  }
  if( sqlite3Config.isMutexInit ){
                     ;
    sqlite3Config.isMutexInit = 0;
  }

  return 0;
}
# 107403 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_config(int op, ...){
  va_list ap;
  int rc = 0;



  if( sqlite3Config.isInit ) return sqlite3MisuseError(107409);

  __builtin_va_start(ap, op);
  switch( op ){
# 107450 "ext/sqlite3/libsqlite/sqlite3.c"
    case 4: {

      sqlite3Config.m = *__builtin_va_arg(ap, sqlite3_mem_methods*);
      break;
    }
    case 5: {

      if( sqlite3Config.m.xMalloc==0 ) sqlite3MemSetDefault();
      *__builtin_va_arg(ap, sqlite3_mem_methods*) = sqlite3Config.m;
      break;
    }
    case 9: {

      sqlite3Config.bMemstat = __builtin_va_arg(ap, int);
      break;
    }
    case 6: {

      sqlite3Config.pScratch = __builtin_va_arg(ap, void*);
      sqlite3Config.szScratch = __builtin_va_arg(ap, int);
      sqlite3Config.nScratch = __builtin_va_arg(ap, int);
      break;
    }
    case 7: {

      sqlite3Config.pPage = __builtin_va_arg(ap, void*);
      sqlite3Config.szPage = __builtin_va_arg(ap, int);
      sqlite3Config.nPage = __builtin_va_arg(ap, int);
      break;
    }

    case 14: {

      sqlite3Config.pcache = *__builtin_va_arg(ap, sqlite3_pcache_methods*);
      break;
    }

    case 15: {
      if( sqlite3Config.pcache.xInit==0 ){
        sqlite3PCacheSetDefault();
      }
      *__builtin_va_arg(ap, sqlite3_pcache_methods*) = sqlite3Config.pcache;
      break;
    }
# 107532 "ext/sqlite3/libsqlite/sqlite3.c"
    case 13: {
      sqlite3Config.szLookaside = __builtin_va_arg(ap, int);
      sqlite3Config.nLookaside = __builtin_va_arg(ap, int);
      break;
    }





    case 16: {




      typedef void(*LOGFUNC_t)(void*,int,const char*);
      sqlite3Config.xLog = __builtin_va_arg(ap, LOGFUNC_t);
      sqlite3Config.pLogArg = __builtin_va_arg(ap, void*);
      break;
    }

    default: {
      rc = 1;
      break;
    }
  }
  __builtin_va_end(ap);
  return rc;
}
# 107573 "ext/sqlite3/libsqlite/sqlite3.c"
static int setupLookaside(sqlite3 *db, void *pBuf, int sz, int cnt){
  void *pStart;
  if( db->lookaside.nOut ){
    return 5;
  }




  if( db->lookaside.bMalloced ){
    sqlite3_free(db->lookaside.pStart);
  }



  if( sz<=(int)sizeof(LookasideSlot*) ) sz = 0;
  if( cnt<0 ) cnt = 0;
  if( sz==0 || cnt==0 ){
    sz = 0;
    pStart = 0;
  }else if( pBuf==0 ){
    sz = ((sz)&~7);
    sqlite3BeginBenignMalloc();
    pStart = sqlite3Malloc( sz*cnt );
    sqlite3EndBenignMalloc();
  }else{
    sz = ((sz)&~7);
    pStart = pBuf;
  }
  db->lookaside.pStart = pStart;
  db->lookaside.pFree = 0;
  db->lookaside.sz = (u16)sz;
  if( pStart ){
    int i;
    LookasideSlot *p;
    ((void) (0));
    p = (LookasideSlot*)pStart;
    for(i=cnt-1; i>=0; i--){
      p->pNext = db->lookaside.pFree;
      db->lookaside.pFree = p;
      p = (LookasideSlot*)&((u8*)p)[sz];
    }
    db->lookaside.pEnd = p;
    db->lookaside.bEnabled = 1;
    db->lookaside.bMalloced = pBuf==0 ?1:0;
  }else{
    db->lookaside.pEnd = 0;
    db->lookaside.bEnabled = 0;
    db->lookaside.bMalloced = 0;
  }
  return 0;
}




           sqlite3_mutex *sqlite3_db_mutex(sqlite3 *db){
  return db->mutex;
}




           int sqlite3_db_config(sqlite3 *db, int op, ...){
  va_list ap;
  int rc;
  __builtin_va_start(ap, op);
  switch( op ){
    case 1001: {
      void *pBuf = __builtin_va_arg(ap, void*);
      int sz = __builtin_va_arg(ap, int);
      int cnt = __builtin_va_arg(ap, int);
      rc = setupLookaside(db, pBuf, sz, cnt);
      break;
    }
    default: {
      static const struct {
        int op;
        u32 mask;
      } aFlagOp[] = {
        { 1002, 0x04000000 },
        { 1003, 0x40000000 },
      };
      unsigned int i;
      rc = 1;
      for(i=0; i<((int)(sizeof(aFlagOp)/sizeof(aFlagOp[0]))); i++){
        if( aFlagOp[i].op==op ){
          int onoff = __builtin_va_arg(ap, int);
          int *pRes = __builtin_va_arg(ap, int*);
          int oldFlags = db->flags;
          if( onoff>0 ){
            db->flags |= aFlagOp[i].mask;
          }else if( onoff==0 ){
            db->flags &= ~aFlagOp[i].mask;
          }
          if( oldFlags!=db->flags ){
            sqlite3ExpirePreparedStatements(db);
          }
          if( pRes ){
            *pRes = (db->flags & aFlagOp[i].mask)!=0;
          }
          rc = 0;
          break;
        }
      }
      break;
    }
  }
  __builtin_va_end(ap);
  return rc;
}





static int allSpaces(const char *z, int n){
  while( n>0 && z[n-1]==' ' ){ n--; }
  return n==0;
}
# 107701 "ext/sqlite3/libsqlite/sqlite3.c"
static int binCollFunc(
  void *padFlag,
  int nKey1, const void *pKey1,
  int nKey2, const void *pKey2
){
  int rc, n;
  n = nKey1<nKey2 ? nKey1 : nKey2;
  rc = memcmp(pKey1, pKey2, n);
  if( rc==0 ){
    if( padFlag
     && allSpaces(((char*)pKey1)+n, nKey1-n)
     && allSpaces(((char*)pKey2)+n, nKey2-n)
    ){

    }else{
      rc = nKey1 - nKey2;
    }
  }
  return rc;
}
# 107731 "ext/sqlite3/libsqlite/sqlite3.c"
static int nocaseCollatingFunc(
  void *NotUsed,
  int nKey1, const void *pKey1,
  int nKey2, const void *pKey2
){
  int r = sqlite3_strnicmp(
      (const char *)pKey1, (const char *)pKey2, (nKey1<nKey2)?nKey1:nKey2);
  (void)(NotUsed);
  if( 0==r ){
    r = nKey1-nKey2;
  }
  return r;
}




           sqlite_int64 sqlite3_last_insert_rowid(sqlite3 *db){
  return db->lastRowid;
}




           int sqlite3_changes(sqlite3 *db){
  return db->nChange;
}




           int sqlite3_total_changes(sqlite3 *db){
  return db->nTotalChange;
}






static void sqlite3CloseSavepoints(sqlite3 *db){
  while( db->pSavepoint ){
    Savepoint *pTmp = db->pSavepoint;
    db->pSavepoint = pTmp->pNext;
    sqlite3DbFree(db, pTmp);
  }
  db->nSavepoint = 0;
  db->nStatement = 0;
  db->isTransactionSavepoint = 0;
}







static void functionDestroy(sqlite3 *db, FuncDef *p){
  FuncDestructor *pDestructor = p->pDestructor;
  if( pDestructor ){
    pDestructor->nRef--;
    if( pDestructor->nRef==0 ){
      pDestructor->xDestroy(pDestructor->pUserData);
      sqlite3DbFree(db, pDestructor);
    }
  }
}




           int sqlite3_close(sqlite3 *db){
  HashElem *i;
  int j;

  if( !db ){
    return 0;
  }
  if( !sqlite3SafetyCheckSickOrOk(db) ){
    return sqlite3MisuseError(107810);
  }
                                ;


  sqlite3ResetInternalSchema(db, -1);
# 107824 "ext/sqlite3/libsqlite/sqlite3.c"
  sqlite3VtabRollback(db);


  if( db->pVdbe ){
    sqlite3Error(db, 5,
        "unable to close due to unfinalised statements");
                                  ;
    return 5;
  }
  ((void) (0));

  for(j=0; j<db->nDb; j++){
    Btree *pBt = db->aDb[j].pBt;
    if( pBt && sqlite3BtreeIsInBackup(pBt) ){
      sqlite3Error(db, 5,
          "unable to close due to unfinished backup operation");
                                    ;
      return 5;
    }
  }


  sqlite3CloseSavepoints(db);

  for(j=0; j<db->nDb; j++){
    struct Db *pDb = &db->aDb[j];
    if( pDb->pBt ){
      sqlite3BtreeClose(pDb->pBt);
      pDb->pBt = 0;
      if( j!=1 ){
        pDb->pSchema = 0;
      }
    }
  }
  sqlite3ResetInternalSchema(db, -1);




                             ;

  ((void) (0));
  ((void) (0));
  for(j=0; j<((int)(sizeof(db->aFunc.a)/sizeof(db->aFunc.a[0]))); j++){
    FuncDef *pNext, *pHash, *p;
    for(p=db->aFunc.a[j]; p; p=pHash){
      pHash = p->pHash;
      while( p ){
        functionDestroy(db, p);
        pNext = p->pNext;
        sqlite3DbFree(db, p);
        p = pNext;
      }
    }
  }
  for(i=((&db->aCollSeq)->first); i; i=((i)->next)){
    CollSeq *pColl = (CollSeq *)((i)->data);

    for(j=0; j<3; j++){
      if( pColl[j].xDel ){
        pColl[j].xDel(pColl[j].pUser);
      }
    }
    sqlite3DbFree(db, pColl);
  }
  sqlite3HashClear(&db->aCollSeq);

  for(i=((&db->aModule)->first); i; i=((i)->next)){
    Module *pMod = (Module *)((i)->data);
    if( pMod->xDestroy ){
      pMod->xDestroy(pMod->pAux);
    }
    sqlite3DbFree(db, pMod);
  }
  sqlite3HashClear(&db->aModule);


  sqlite3Error(db, 0, 0);
  if( db->pErr ){
    sqlite3ValueFree(db->pErr);
  }
  sqlite3CloseExtensions(db);

  db->magic = 0xb5357930;







  sqlite3DbFree(db, db->aDb[1].pSchema);
                                ;
  db->magic = 0x9f3c2d33;
                               ;
  ((void) (0));
  if( db->lookaside.bMalloced ){
    sqlite3_free(db->lookaside.pStart);
  }
  sqlite3_free(db);
  return 0;
}




static void sqlite3RollbackAll(sqlite3 *db){
  int i;
  int inTrans = 0;
  ((void) (0));
  sqlite3BeginBenignMalloc();
  for(i=0; i<db->nDb; i++){
    if( db->aDb[i].pBt ){
      if( sqlite3BtreeIsInTrans(db->aDb[i].pBt) ){
        inTrans = 1;
      }
      sqlite3BtreeRollback(db->aDb[i].pBt);
      db->aDb[i].inTrans = 0;
    }
  }
  sqlite3VtabRollback(db);
  sqlite3EndBenignMalloc();

  if( db->flags&0x00000200 ){
    sqlite3ExpirePreparedStatements(db);
    sqlite3ResetInternalSchema(db, -1);
  }


  db->nDeferredCons = 0;


  if( db->xRollbackCallback && (inTrans || !db->autoCommit) ){
    db->xRollbackCallback(db->pRollbackArg);
  }
}





static const char *sqlite3ErrStr(int rc){
  static const char* const aMsg[] = {
                             "not an error",
                             "SQL logic error or missing database",
                             0,
                             "access permission denied",
                             "callback requested query abort",
                             "database is locked",
                             "database table is locked",
                             "out of memory",
                             "attempt to write a readonly database",
                             "interrupted",
                             "disk I/O error",
                             "database disk image is malformed",
                             "unknown operation",
                             "database or disk is full",
                             "unable to open database file",
                             "locking protocol",
                             "table contains no data",
                             "database schema has changed",
                             "string or blob too big",
                             "constraint failed",
                             "datatype mismatch",
                             "library routine called out of sequence",
                             "large file support is disabled",
                             "authorization denied",
                             "auxiliary database format error",
                             "bind or column index out of range",
                             "file is encrypted or is not a database",
  };
  rc &= 0xff;
  if( (rc>=0) && rc<(int)(sizeof(aMsg)/sizeof(aMsg[0])) && aMsg[rc]!=0 ){
    return aMsg[rc];
  }else{
    return "unknown error";
  }
}







static int sqliteDefaultBusyCallback(
 void *ptr,
 int count
){
# 108038 "ext/sqlite3/libsqlite/sqlite3.c"
  sqlite3 *db = (sqlite3 *)ptr;
  int timeout = ((sqlite3 *)ptr)->busyTimeout;
  if( (count+1)*1000 > timeout ){
    return 0;
  }
  sqlite3OsSleep(db->pVfs, 1000000);
  return 1;

}
# 108055 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3InvokeBusyHandler(BusyHandler *p){
  int rc;
  if( (p==0) || p->xFunc==0 || p->nBusy<0 ) return 0;
  rc = p->xFunc(p->pArg, p->nBusy);
  if( rc==0 ){
    p->nBusy = -1;
  }else{
    p->nBusy++;
  }
  return rc;
}





           int sqlite3_busy_handler(
  sqlite3 *db,
  int (*xBusy)(void*,int),
  void *pArg
){
                                ;
  db->busyHandler.xFunc = xBusy;
  db->busyHandler.pArg = pArg;
  db->busyHandler.nBusy = 0;
                                ;
  return 0;
}







           void sqlite3_progress_handler(
  sqlite3 *db,
  int nOps,
  int (*xProgress)(void*),
  void *pArg
){
                                ;
  if( nOps>0 ){
    db->xProgress = xProgress;
    db->nProgressOps = nOps;
    db->pProgressArg = pArg;
  }else{
    db->xProgress = 0;
    db->nProgressOps = 0;
    db->pProgressArg = 0;
  }
                                ;
}







           int sqlite3_busy_timeout(sqlite3 *db, int ms){
  if( ms>0 ){
    db->busyTimeout = ms;
    sqlite3_busy_handler(db, sqliteDefaultBusyCallback, (void*)db);
  }else{
    sqlite3_busy_handler(db, 0, 0);
  }
  return 0;
}




           void sqlite3_interrupt(sqlite3 *db){
  db->u1.isInterrupted = 1;
}
# 108139 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3CreateFunc(
  sqlite3 *db,
  const char *zFunctionName,
  int nArg,
  int enc,
  void *pUserData,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value **),
  void (*xStep)(sqlite3_context*,int,sqlite3_value **),
  void (*xFinal)(sqlite3_context*),
  FuncDestructor *pDestructor
){
  FuncDef *p;
  int nName;

  ((void) (0));
  if( zFunctionName==0 ||
      (xFunc && (xFinal || xStep)) ||
      (!xFunc && (xFinal && !xStep)) ||
      (!xFunc && (!xFinal && xStep)) ||
      (nArg<-1 || nArg>127) ||
      (255<(nName = sqlite3Strlen30( zFunctionName))) ){
    return sqlite3MisuseError(108160);
  }
# 108171 "ext/sqlite3/libsqlite/sqlite3.c"
  if( enc==4 ){
    enc = 2;
  }else if( enc==5 ){
    int rc;
    rc = sqlite3CreateFunc(db, zFunctionName, nArg, 1,
         pUserData, xFunc, xStep, xFinal, pDestructor);
    if( rc==0 ){
      rc = sqlite3CreateFunc(db, zFunctionName, nArg, 2,
          pUserData, xFunc, xStep, xFinal, pDestructor);
    }
    if( rc!=0 ){
      return rc;
    }
    enc = 3;
  }
# 108195 "ext/sqlite3/libsqlite/sqlite3.c"
  p = sqlite3FindFunction(db, zFunctionName, nName, nArg, (u8)enc, 0);
  if( p && p->iPrefEnc==enc && p->nArg==nArg ){
    if( db->activeVdbeCnt ){
      sqlite3Error(db, 5,
        "unable to delete/modify user-function due to active statements");
      ((void) (0));
      return 5;
    }else{
      sqlite3ExpirePreparedStatements(db);
    }
  }

  p = sqlite3FindFunction(db, zFunctionName, nName, nArg, (u8)enc, 1);
  ((void) (0));
  if( !p ){
    return 7;
  }



  functionDestroy(db, p);

  if( pDestructor ){
    pDestructor->nRef++;
  }
  p->pDestructor = pDestructor;
  p->flags = 0;
  p->xFunc = xFunc;
  p->xStep = xStep;
  p->xFinalize = xFinal;
  p->pUserData = pUserData;
  p->nArg = (u16)nArg;
  return 0;
}




           int sqlite3_create_function(
  sqlite3 *db,
  const char *zFunc,
  int nArg,
  int enc,
  void *p,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value **),
  void (*xStep)(sqlite3_context*,int,sqlite3_value **),
  void (*xFinal)(sqlite3_context*)
){
  return sqlite3_create_function_v2(db, zFunc, nArg, enc, p, xFunc, xStep,
                                    xFinal, 0);
}

           int sqlite3_create_function_v2(
  sqlite3 *db,
  const char *zFunc,
  int nArg,
  int enc,
  void *p,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value **),
  void (*xStep)(sqlite3_context*,int,sqlite3_value **),
  void (*xFinal)(sqlite3_context*),
  void (*xDestroy)(void *)
){
  int rc = 1;
  FuncDestructor *pArg = 0;
                                ;
  if( xDestroy ){
    pArg = (FuncDestructor *)sqlite3DbMallocZero(db, sizeof(FuncDestructor));
    if( !pArg ){
      xDestroy(p);
      goto out;
    }
    pArg->xDestroy = xDestroy;
    pArg->pUserData = p;
  }
  rc = sqlite3CreateFunc(db, zFunc, nArg, enc, p, xFunc, xStep, xFinal, pArg);
  if( pArg && pArg->nRef==0 ){
    ((void) (0));
    xDestroy(p);
    sqlite3DbFree(db, pArg);
  }

 out:
  rc = sqlite3ApiExit(db, rc);
                                ;
  return rc;
}


           int sqlite3_create_function16(
  sqlite3 *db,
  const void *zFunctionName,
  int nArg,
  int eTextRep,
  void *p,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*)
){
  int rc;
  char *zFunc8;
                                ;
  ((void) (0));
  zFunc8 = sqlite3Utf16to8(db, zFunctionName, -1, 2);
  rc = sqlite3CreateFunc(db, zFunc8, nArg, eTextRep, p, xFunc, xStep, xFinal,0);
  sqlite3DbFree(db, zFunc8);
  rc = sqlite3ApiExit(db, rc);
                                ;
  return rc;
}
# 108320 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_overload_function(
  sqlite3 *db,
  const char *zName,
  int nArg
){
  int nName = sqlite3Strlen30(zName);
  int rc;
                                ;
  if( sqlite3FindFunction(db, zName, nName, nArg, 1, 0)==0 ){
    sqlite3CreateFunc(db, zName, nArg, 1,
                      0, sqlite3InvalidFunction, 0, 0, 0);
  }
  rc = sqlite3ApiExit(db, 0);
                                ;
  return rc;
}
# 108346 "ext/sqlite3/libsqlite/sqlite3.c"
           void *sqlite3_trace(sqlite3 *db, void (*xTrace)(void*,const char*), void *pArg){
  void *pOld;
                                ;
  pOld = db->pTraceArg;
  db->xTrace = xTrace;
  db->pTraceArg = pArg;
                                ;
  return pOld;
}
# 108363 "ext/sqlite3/libsqlite/sqlite3.c"
           void *sqlite3_profile(
  sqlite3 *db,
  void (*xProfile)(void*,const char*,sqlite_uint64),
  void *pArg
){
  void *pOld;
                                ;
  pOld = db->pProfileArg;
  db->xProfile = xProfile;
  db->pProfileArg = pArg;
                                ;
  return pOld;
}
# 108384 "ext/sqlite3/libsqlite/sqlite3.c"
           void *sqlite3_commit_hook(
  sqlite3 *db,
  int (*xCallback)(void*),
  void *pArg
){
  void *pOld;
                                ;
  pOld = db->pCommitArg;
  db->xCommitCallback = xCallback;
  db->pCommitArg = pArg;
                                ;
  return pOld;
}





           void *sqlite3_update_hook(
  sqlite3 *db,
  void (*xCallback)(void*,int,char const *,char const *,sqlite_int64),
  void *pArg
){
  void *pRet;
                                ;
  pRet = db->pUpdateArg;
  db->xUpdateCallback = xCallback;
  db->pUpdateArg = pArg;
                                ;
  return pRet;
}





           void *sqlite3_rollback_hook(
  sqlite3 *db,
  void (*xCallback)(void*),
  void *pArg
){
  void *pRet;
                                ;
  pRet = db->pRollbackArg;
  db->xRollbackCallback = xCallback;
  db->pRollbackArg = pArg;
                                ;
  return pRet;
}
# 108441 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3WalDefaultHook(
  void *pClientData,
  sqlite3 *db,
  const char *zDb,
  int nFrame
){
  if( nFrame>=((int)(long int)(pClientData)) ){
    sqlite3BeginBenignMalloc();
    sqlite3_wal_checkpoint(db, zDb);
    sqlite3EndBenignMalloc();
  }
  return 0;
}
# 108467 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_wal_autocheckpoint(sqlite3 *db, int nFrame){




  if( nFrame>0 ){
    sqlite3_wal_hook(db, sqlite3WalDefaultHook, ((void*)(long int)(nFrame)));
  }else{
    sqlite3_wal_hook(db, 0, 0);
  }

  return 0;
}





           void *sqlite3_wal_hook(
  sqlite3 *db,
  int(*xCallback)(void *, sqlite3*, const char*, int),
  void *pArg
){

  void *pRet;
                                ;
  pRet = db->pWalArg;
  db->xWalCallback = xCallback;
  db->pWalArg = pArg;
                                ;
  return pRet;



}




           int sqlite3_wal_checkpoint_v2(
  sqlite3 *db,
  const char *zDb,
  int eMode,
  int *pnLog,
  int *pnCkpt
){



  int rc;
  int iDb = 10;


  if( pnLog ) *pnLog = -1;
  if( pnCkpt ) *pnCkpt = -1;

  ((void) (0));
  ((void) (0));
  ((void) (0));
  if( eMode<0 || eMode>2 ){
    return 21;
  }

                                ;
  if( zDb && zDb[0] ){
    iDb = sqlite3FindDbName(db, zDb);
  }
  if( iDb<0 ){
    rc = 1;
    sqlite3Error(db, 1, "unknown database: %s", zDb);
  }else{
    rc = sqlite3Checkpoint(db, iDb, eMode, pnLog, pnCkpt);
    sqlite3Error(db, rc, 0);
  }
  rc = sqlite3ApiExit(db, rc);
                                ;
  return rc;

}







           int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb){
  return sqlite3_wal_checkpoint_v2(db, zDb, 0, 0, 0);
}
# 108577 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Checkpoint(sqlite3 *db, int iDb, int eMode, int *pnLog, int *pnCkpt){
  int rc = 0;
  int i;
  int bBusy = 0;

  ((void) (0));
  ((void) (0));
  ((void) (0));

  for(i=0; i<db->nDb && rc==0; i++){
    if( i==iDb || iDb==10 ){
      rc = sqlite3BtreeCheckpoint(db->aDb[i].pBt, eMode, pnLog, pnCkpt);
      pnLog = 0;
      pnCkpt = 0;
      if( rc==5 ){
        bBusy = 1;
        rc = 0;
      }
    }
  }

  return (rc==0 && bBusy) ? 5 : rc;
}
# 108621 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3TempInMemory(const sqlite3 *db){

  return ( db->temp_store==2 );
# 108634 "ext/sqlite3/libsqlite/sqlite3.c"
}





           const char *sqlite3_errmsg(sqlite3 *db){
  const char *z;
  if( !db ){
    return sqlite3ErrStr(7);
  }
  if( !sqlite3SafetyCheckSickOrOk(db) ){
    return sqlite3ErrStr(sqlite3MisuseError(108646));
  }
                                ;
  if( db->mallocFailed ){
    z = sqlite3ErrStr(7);
  }else{
    z = (char*)sqlite3_value_text(db->pErr);
    ((void) (0));
    if( z==0 ){
      z = sqlite3ErrStr(db->errCode);
    }
  }
                                ;
  return z;
}






           const void *sqlite3_errmsg16(sqlite3 *db){
  static const u16 outOfMem[] = {
    'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', 0
  };
  static const u16 misuse[] = {
    'l', 'i', 'b', 'r', 'a', 'r', 'y', ' ',
    'r', 'o', 'u', 't', 'i', 'n', 'e', ' ',
    'c', 'a', 'l', 'l', 'e', 'd', ' ',
    'o', 'u', 't', ' ',
    'o', 'f', ' ',
    's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', 0
  };

  const void *z;
  if( !db ){
    return (void *)outOfMem;
  }
  if( !sqlite3SafetyCheckSickOrOk(db) ){
    return (void *)misuse;
  }
                                ;
  if( db->mallocFailed ){
    z = (void *)outOfMem;
  }else{
    z = sqlite3_value_text16(db->pErr);
    if( z==0 ){
      sqlite3ValueSetStr(db->pErr, -1, sqlite3ErrStr(db->errCode),
           1, ((sqlite3_destructor_type)0));
      z = sqlite3_value_text16(db->pErr);
    }





    db->mallocFailed = 0;
  }
                                ;
  return z;
}






           int sqlite3_errcode(sqlite3 *db){
  if( db && !sqlite3SafetyCheckSickOrOk(db) ){
    return sqlite3MisuseError(108715);
  }
  if( !db || db->mallocFailed ){
    return 7;
  }
  return db->errCode & db->errMask;
}
           int sqlite3_extended_errcode(sqlite3 *db){
  if( db && !sqlite3SafetyCheckSickOrOk(db) ){
    return sqlite3MisuseError(108724);
  }
  if( !db || db->mallocFailed ){
    return 7;
  }
  return db->errCode;
}





static int createCollation(
  sqlite3* db,
  const char *zName,
  u8 enc,
  u8 collType,
  void* pCtx,
  int(*xCompare)(void*,int,const void*,int,const void*),
  void(*xDel)(void*)
){
  CollSeq *pColl;
  int enc2;
  int nName = sqlite3Strlen30(zName);

  ((void) (0));





  enc2 = enc;
                                ;
                                        ;
  if( enc2==4 || enc2==8 ){
    enc2 = 2;
  }
  if( enc2<1 || enc2>3 ){
    return sqlite3MisuseError(108762);
  }





  pColl = sqlite3FindCollSeq(db, (u8)enc2, zName, 0);
  if( pColl && pColl->xCmp ){
    if( db->activeVdbeCnt ){
      sqlite3Error(db, 5,
        "unable to delete/modify collation sequence due to active statements");
      return 5;
    }
    sqlite3ExpirePreparedStatements(db);







    if( (pColl->enc & ~8)==enc2 ){
      CollSeq *aColl = sqlite3HashFind(&db->aCollSeq, zName, nName);
      int j;
      for(j=0; j<3; j++){
        CollSeq *p = &aColl[j];
        if( p->enc==pColl->enc ){
          if( p->xDel ){
            p->xDel(p->pUser);
          }
          p->xCmp = 0;
        }
      }
    }
  }

  pColl = sqlite3FindCollSeq(db, (u8)enc2, zName, 1);
  if( pColl==0 ) return 7;
  pColl->xCmp = xCompare;
  pColl->pUser = pCtx;
  pColl->xDel = xDel;
  pColl->enc = (u8)(enc2 | (enc & 8));
  pColl->type = collType;
  sqlite3Error(db, 0, 0);
  return 0;
}







static const int aHardLimit[] = {
  1000000000,
  1000000000,
  2000,
  1000,
  500,
  25000,
  127,
  10,
  50000,
  999,
  1000,
};
# 108875 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_limit(sqlite3 *db, int limitId, int newLimit){
  int oldLimit;







  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));

  ((void) (0));
  ((void) (0));
  ((void) (0));


  if( limitId<0 || limitId>=(10 +1) ){
    return -1;
  }
  oldLimit = db->aLimit[limitId];
  if( newLimit>=0 ){
    if( newLimit>aHardLimit[limitId] ){
      newLimit = aHardLimit[limitId];
    }
    db->aLimit[limitId] = newLimit;
  }
  return oldLimit;
}






static int openDatabase(
  const char *zFilename,
  sqlite3 **ppDb,
  unsigned flags,
  const char *zVfs
){
  sqlite3 *db;
  int rc;
  int isThreadsafe;

  *ppDb = 0;

  rc = sqlite3_initialize();
  if( rc ) return rc;
# 108943 "ext/sqlite3/libsqlite/sqlite3.c"
  ((void) (0));
  ((void) (0));
  ((void) (0));
                                  ;
                                  ;
                                  ;
  if( ((1<<(flags&7)) & 0x46)==0 ) return 21;

  if( sqlite3Config.bCoreMutex==0 ){
    isThreadsafe = 0;
  }else if( flags & 0x00008000 ){
    isThreadsafe = 0;
  }else if( flags & 0x00010000 ){
    isThreadsafe = 1;
  }else{
    isThreadsafe = sqlite3Config.bFullMutex;
  }
  if( flags & 0x00040000 ){
    flags &= ~0x00020000;
  }else if( sqlite3Config.sharedCacheEnabled ){
    flags |= 0x00020000;
  }
# 108975 "ext/sqlite3/libsqlite/sqlite3.c"
  flags &= ~( 0x00000008 |
               0x00000010 |
               0x00000100 |
               0x00000200 |
               0x00000400 |
               0x00000800 |
               0x00001000 |
               0x00002000 |
               0x00004000 |
               0x00008000 |
               0x00010000 |
               0x00080000
             );


  db = sqlite3MallocZero( sizeof(sqlite3) );
  if( db==0 ) goto opendb_out;
  if( isThreadsafe ){
    db->mutex = ((sqlite3_mutex*)8);
    if( db->mutex==0 ){
      sqlite3_free(db);
      db = 0;
      goto opendb_out;
    }
  }
                                ;
  db->errMask = 0xff;
  db->nDb = 2;
  db->magic = 0xf03b7906;
  db->aDb = db->aDbStatic;

  ((void) (0));
  memcpy(db->aLimit, aHardLimit, sizeof(db->aLimit));
  db->autoCommit = 1;
  db->nextAutovac = -1;
  db->nextPagesize = 0;
  db->flags |= 0x00000800 | 0x08000000 | 0x40000000

                 | 0x00100000
# 109024 "ext/sqlite3/libsqlite/sqlite3.c"
      ;
  sqlite3HashInit(&db->aCollSeq);

  sqlite3HashInit(&db->aModule);


  db->pVfs = sqlite3_vfs_find(zVfs);
  if( !db->pVfs ){
    rc = 1;
    sqlite3Error(db, rc, "no such vfs: %s", zVfs);
    goto opendb_out;
  }





  createCollation(db, "BINARY", 1, 1, 0,
                  binCollFunc, 0);
  createCollation(db, "BINARY", 3, 1, 0,
                  binCollFunc, 0);
  createCollation(db, "BINARY", 2, 1, 0,
                  binCollFunc, 0);
  createCollation(db, "RTRIM", 1, 0, (void*)1,
                  binCollFunc, 0);
  if( db->mallocFailed ){
    goto opendb_out;
  }
  db->pDfltColl = sqlite3FindCollSeq(db, 1, "BINARY", 0);
  ((void) (0));


  createCollation(db, "NOCASE", 1, 2, 0,
                  nocaseCollatingFunc, 0);


  db->openFlags = flags;
  rc = sqlite3BtreeOpen(zFilename, db, &db->aDb[0].pBt, 0,
                        flags | 0x00000100);
  if( rc!=0 ){
    if( rc==(10 | (12<<8)) ){
      rc = 7;
    }
    sqlite3Error(db, rc, 0);
    goto opendb_out;
  }
  db->aDb[0].pSchema = sqlite3SchemaGet(db, db->aDb[0].pBt);
  db->aDb[1].pSchema = sqlite3SchemaGet(db, 0);





  db->aDb[0].zName = "main";
  db->aDb[0].safety_level = 3;
  db->aDb[1].zName = "temp";
  db->aDb[1].safety_level = 1;

  db->magic = 0xa029a697;
  if( db->mallocFailed ){
    goto opendb_out;
  }





  sqlite3Error(db, 0, 0);
  sqlite3RegisterBuiltinFunctions(db);




  sqlite3AutoLoadExtensions(db);
  rc = sqlite3_errcode(db);
  if( rc!=0 ){
    goto opendb_out;
  }
# 109118 "ext/sqlite3/libsqlite/sqlite3.c"
  if( !db->mallocFailed && rc==0 ){
    rc = sqlite3Fts3Init(db);
  }
# 109135 "ext/sqlite3/libsqlite/sqlite3.c"
  sqlite3Error(db, rc, 0);
# 109148 "ext/sqlite3/libsqlite/sqlite3.c"
  setupLookaside(db, 0, sqlite3Config.szLookaside,
                        sqlite3Config.nLookaside);

  sqlite3_wal_autocheckpoint(db, 1000);

opendb_out:
  if( db ){
    ((void) (0));
                                  ;
  }
  rc = sqlite3_errcode(db);
  if( rc==7 ){
    sqlite3_close(db);
    db = 0;
  }else if( rc!=0 ){
    db->magic = 0x4b771290;
  }
  *ppDb = db;
  return sqlite3ApiExit(0, rc);
}




           int sqlite3_open(
  const char *zFilename,
  sqlite3 **ppDb
){
  return openDatabase(zFilename, ppDb,
                      0x00000002 | 0x00000004, 0);
}
           int sqlite3_open_v2(
  const char *filename,
  sqlite3 **ppDb,
  int flags,
  const char *zVfs
){
  return openDatabase(filename, ppDb, flags, zVfs);
}





           int sqlite3_open16(
  const void *zFilename,
  sqlite3 **ppDb
){
  char const *zFilename8;
  sqlite3_value *pVal;
  int rc;

  ((void) (0));
  ((void) (0));
  *ppDb = 0;

  rc = sqlite3_initialize();
  if( rc ) return rc;

  pVal = sqlite3ValueNew(0);
  sqlite3ValueSetStr(pVal, -1, zFilename, 2, ((sqlite3_destructor_type)0));
  zFilename8 = sqlite3ValueText(pVal, 1);
  if( zFilename8 ){
    rc = openDatabase(zFilename8, ppDb,
                      0x00000002 | 0x00000004, 0);
    ((void) (0));
    if( rc==0 && !(((*ppDb)->aDb[0].pSchema->flags&(0x0001))==(0x0001)) ){
      ((*ppDb)->aDb[0].pSchema->enc) = 2;
    }
  }else{
    rc = 7;
  }
  sqlite3ValueFree(pVal);

  return sqlite3ApiExit(0, rc);
}





           int sqlite3_create_collation(
  sqlite3* db,
  const char *zName,
  int enc,
  void* pCtx,
  int(*xCompare)(void*,int,const void*,int,const void*)
){
  int rc;
                                ;
  ((void) (0));
  rc = createCollation(db, zName, (u8)enc, 0, pCtx, xCompare, 0);
  rc = sqlite3ApiExit(db, rc);
                                ;
  return rc;
}




           int sqlite3_create_collation_v2(
  sqlite3* db,
  const char *zName,
  int enc,
  void* pCtx,
  int(*xCompare)(void*,int,const void*,int,const void*),
  void(*xDel)(void*)
){
  int rc;
                                ;
  ((void) (0));
  rc = createCollation(db, zName, (u8)enc, 0, pCtx, xCompare, xDel);
  rc = sqlite3ApiExit(db, rc);
                                ;
  return rc;
}





           int sqlite3_create_collation16(
  sqlite3* db,
  const void *zName,
  int enc,
  void* pCtx,
  int(*xCompare)(void*,int,const void*,int,const void*)
){
  int rc = 0;
  char *zName8;
                                ;
  ((void) (0));
  zName8 = sqlite3Utf16to8(db, zName, -1, 2);
  if( zName8 ){
    rc = createCollation(db, zName8, (u8)enc, 0, pCtx, xCompare, 0);
    sqlite3DbFree(db, zName8);
  }
  rc = sqlite3ApiExit(db, rc);
                                ;
  return rc;
}






           int sqlite3_collation_needed(
  sqlite3 *db,
  void *pCollNeededArg,
  void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*)
){
                                ;
  db->xCollNeeded = xCollNeeded;
  db->xCollNeeded16 = 0;
  db->pCollNeededArg = pCollNeededArg;
                                ;
  return 0;
}






           int sqlite3_collation_needed16(
  sqlite3 *db,
  void *pCollNeededArg,
  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*)
){
                                ;
  db->xCollNeeded = 0;
  db->xCollNeeded16 = xCollNeeded16;
  db->pCollNeededArg = pCollNeededArg;
                                ;
  return 0;
}







           int sqlite3_global_recover(void){
  return 0;
}
# 109345 "ext/sqlite3/libsqlite/sqlite3.c"
           int sqlite3_get_autocommit(sqlite3 *db){
  return db->autoCommit;
}
# 109360 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3CorruptError(int lineno){
                                         ;
  sqlite3_log(11,
              "database corruption at line %d of [%.10s]",
              lineno, 20+sqlite3_sourceid());
  return 11;
}
static int sqlite3MisuseError(int lineno){
                                         ;
  sqlite3_log(21,
              "misuse at line %d of [%.10s]",
              lineno, 20+sqlite3_sourceid());
  return 21;
}
static int sqlite3CantopenError(int lineno){
                                         ;
  sqlite3_log(14,
              "cannot open file at line %d of [%.10s]",
              lineno, 20+sqlite3_sourceid());
  return 14;
}
# 109391 "ext/sqlite3/libsqlite/sqlite3.c"
           void sqlite3_thread_cleanup(void){
}







           int sqlite3_table_column_metadata(
  sqlite3 *db,
  const char *zDbName,
  const char *zTableName,
  const char *zColumnName,
  char const **pzDataType,
  char const **pzCollSeq,
  int *pNotNull,
  int *pPrimaryKey,
  int *pAutoinc
){
  int rc;
  char *zErrMsg = 0;
  Table *pTab = 0;
  Column *pCol = 0;
  int iCol;

  char const *zDataType = 0;
  char const *zCollSeq = 0;
  int notnull = 0;
  int primarykey = 0;
  int autoinc = 0;


                                ;
  sqlite3BtreeEnterAll(db);
  rc = sqlite3Init(db, &zErrMsg);
  if( 0!=rc ){
    goto error_out;
  }


  pTab = sqlite3FindTable(db, zTableName, zDbName);
  if( !pTab || pTab->pSelect ){
    pTab = 0;
    goto error_out;
  }


  if( sqlite3IsRowid(zColumnName) ){
    iCol = pTab->iPKey;
    if( iCol>=0 ){
      pCol = &pTab->aCol[iCol];
    }
  }else{
    for(iCol=0; iCol<pTab->nCol; iCol++){
      pCol = &pTab->aCol[iCol];
      if( 0==sqlite3StrICmp(pCol->zName, zColumnName) ){
        break;
      }
    }
    if( iCol==pTab->nCol ){
      pTab = 0;
      goto error_out;
    }
  }
# 109467 "ext/sqlite3/libsqlite/sqlite3.c"
  if( pCol ){
    zDataType = pCol->zType;
    zCollSeq = pCol->zColl;
    notnull = pCol->notNull!=0;
    primarykey = pCol->isPrimKey!=0;
    autoinc = pTab->iPKey==iCol && (pTab->tabFlags & 0x08)!=0;
  }else{
    zDataType = "INTEGER";
    primarykey = 1;
  }
  if( !zCollSeq ){
    zCollSeq = "BINARY";
  }

error_out:
                          ;





  if( pzDataType ) *pzDataType = zDataType;
  if( pzCollSeq ) *pzCollSeq = zCollSeq;
  if( pNotNull ) *pNotNull = notnull;
  if( pPrimaryKey ) *pPrimaryKey = primarykey;
  if( pAutoinc ) *pAutoinc = autoinc;

  if( 0==rc && !pTab ){
    sqlite3DbFree(db, zErrMsg);
    zErrMsg = sqlite3MPrintf(db, "no such table column: %s.%s", zTableName,
        zColumnName);
    rc = 1;
  }
  sqlite3Error(db, rc, (zErrMsg?"%s":0), zErrMsg);
  sqlite3DbFree(db, zErrMsg);
  rc = sqlite3ApiExit(db, rc);
                                ;
  return rc;
}





           int sqlite3_sleep(int ms){
  sqlite3_vfs *pVfs;
  int rc;
  pVfs = sqlite3_vfs_find(0);
  if( pVfs==0 ) return 0;




  rc = (sqlite3OsSleep(pVfs, 1000*ms)/1000);
  return rc;
}




           int sqlite3_extended_result_codes(sqlite3 *db, int onoff){
                                ;
  db->errMask = onoff ? 0xffffffff : 0xff;
                                ;
  return 0;
}




           int sqlite3_file_control(sqlite3 *db, const char *zDbName, int op, void *pArg){
  int rc = 1;
  int iDb;
                                ;
  if( zDbName==0 ){
    iDb = 0;
  }else{
    for(iDb=0; iDb<db->nDb; iDb++){
      if( __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (db->aDb[iDb].zName) && __builtin_constant_p (zDbName) && (__s1_len = __builtin_strlen (db->aDb[iDb].zName), __s2_len = __builtin_strlen (zDbName), (!((size_t)(const void *)((db->aDb[iDb].zName) + 1) - (size_t)(const void *)(db->aDb[iDb].zName) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((zDbName) + 1) - (size_t)(const void *)(zDbName) == 1) || __s2_len >= 4)) ? __builtin_strcmp (db->aDb[iDb].zName, zDbName) : (__builtin_constant_p (db->aDb[iDb].zName) && ((size_t)(const void *)((db->aDb[iDb].zName) + 1) - (size_t)(const void *)(db->aDb[iDb].zName) == 1) && (__s1_len = __builtin_strlen (db->aDb[iDb].zName), __s1_len < 4) ? (__builtin_constant_p (zDbName) && ((size_t)(const void *)((zDbName) + 1) - (size_t)(const void *)(zDbName) == 1) ? __builtin_strcmp (db->aDb[iDb].zName, zDbName) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (zDbName); int __result = (((const unsigned char *) (const char *) (db->aDb[iDb].zName))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (db->aDb[iDb].zName))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (db->aDb[iDb].zName))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (db->aDb[iDb].zName))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (zDbName) && ((size_t)(const void *)((zDbName) + 1) - (size_t)(const void *)(zDbName) == 1) && (__s2_len = __builtin_strlen (zDbName), __s2_len < 4) ? (__builtin_constant_p (db->aDb[iDb].zName) && ((size_t)(const void *)((db->aDb[iDb].zName) + 1) - (size_t)(const void *)(db->aDb[iDb].zName) == 1) ? __builtin_strcmp (db->aDb[iDb].zName, zDbName) : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (db->aDb[iDb].zName); int __result = (((const unsigned char *) (const char *) (zDbName))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (zDbName))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (zDbName))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (zDbName))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (db->aDb[iDb].zName, zDbName)))); })==0 ) break;
    }
  }
  if( iDb<db->nDb ){
    Btree *pBtree = db->aDb[iDb].pBt;
    if( pBtree ){
      Pager *pPager;
      sqlite3_file *fd;
      sqlite3BtreeEnter(pBtree);
      pPager = sqlite3BtreePager(pBtree);
      ((void) (0));
      fd = sqlite3PagerFile(pPager);
      ((void) (0));
      if( op==7 ){
        *(sqlite3_file**)pArg = fd;
        rc = 0;
      }else if( fd->pMethods ){
        rc = sqlite3OsFileControl(fd, op, pArg);
      }else{
        rc = 12;
      }
                               ;
    }
  }
                                ;
  return rc;
}




           int sqlite3_test_control(int op, ...){
  int rc = 0;

  va_list ap;
  __builtin_va_start(ap, op);
  switch( op ){




    case 5: {
      sqlite3PrngSaveState();
      break;
    }






    case 6: {
      sqlite3PrngRestoreState();
      break;
    }






    case 7: {
      sqlite3PrngResetState();
      break;
    }
# 109619 "ext/sqlite3/libsqlite/sqlite3.c"
    case 8: {
      int sz = __builtin_va_arg(ap, int);
      int *aProg = __builtin_va_arg(ap, int*);
      rc = sqlite3BitvecBuiltinTest(sz, aProg);
      break;
    }







    case 10: {
      typedef void (*void_function)(void);
      void_function xBenignBegin;
      void_function xBenignEnd;
      xBenignBegin = __builtin_va_arg(ap, void_function);
      xBenignEnd = __builtin_va_arg(ap, void_function);
      sqlite3BenignMallocHooks(xBenignBegin, xBenignEnd);
      break;
    }
# 109654 "ext/sqlite3/libsqlite/sqlite3.c"
    case 11: {
      rc = sqlite3PendingByte;

      {
        unsigned int newVal = __builtin_va_arg(ap, unsigned int);
        if( newVal ) sqlite3PendingByte = newVal;
      }

      break;
    }
# 109676 "ext/sqlite3/libsqlite/sqlite3.c"
    case 12: {
      volatile int x = 0;
      ((void) (0));
      rc = x;
      break;
    }
# 109711 "ext/sqlite3/libsqlite/sqlite3.c"
    case 13: {
      int x = __builtin_va_arg(ap, int);
      rc = (x);
      break;
    }






    case 14: {
      sqlite3 *db = __builtin_va_arg(ap, sqlite3*);
      int x = __builtin_va_arg(ap, int);
                                    ;
      sqlite3BtreeSetPageSize(db->aDb[0].pBt, 0, x, 0);
                                    ;
      break;
    }
# 109740 "ext/sqlite3/libsqlite/sqlite3.c"
    case 15: {
      sqlite3 *db = __builtin_va_arg(ap, sqlite3*);
      int x = __builtin_va_arg(ap, int);
      db->flags = (x & 0xff) | (db->flags & ~0xff);
      break;
    }
# 109757 "ext/sqlite3/libsqlite/sqlite3.c"
    case 16: {
      const char *zWord = __builtin_va_arg(ap, const char*);
      int n = sqlite3Strlen30(zWord);
      rc = (sqlite3KeywordCode((u8*)zWord, n)!=26) ? 121 : 0;
      break;
    }






    case 17: {
      rc = sizeof(PgHdr);
      break;
    }






    case 18: {
      void *pFree, **ppNew;
      int sz;
      sz = __builtin_va_arg(ap, int);
      ppNew = __builtin_va_arg(ap, void**);
      pFree = __builtin_va_arg(ap, void*);
      if( sz ) *ppNew = sqlite3ScratchMalloc(sz);
      sqlite3ScratchFree(pFree);
      break;
    }

  }
  __builtin_va_end(ap);

  return rc;
}
# 110502 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct sqlite3_tokenizer_module sqlite3_tokenizer_module;
typedef struct sqlite3_tokenizer sqlite3_tokenizer;
typedef struct sqlite3_tokenizer_cursor sqlite3_tokenizer_cursor;

struct sqlite3_tokenizer_module {




  int iVersion;
# 110530 "ext/sqlite3/libsqlite/sqlite3.c"
  int (*xCreate)(
    int argc,
    const char *const*argv,
    sqlite3_tokenizer **ppTokenizer
  );





  int (*xDestroy)(sqlite3_tokenizer *pTokenizer);






  int (*xOpen)(
    sqlite3_tokenizer *pTokenizer,
    const char *pInput, int nBytes,
    sqlite3_tokenizer_cursor **ppCursor
  );





  int (*xClose)(sqlite3_tokenizer_cursor *pCursor);
# 110583 "ext/sqlite3/libsqlite/sqlite3.c"
  int (*xNext)(
    sqlite3_tokenizer_cursor *pCursor,
    const char **ppToken, int *pnBytes,
    int *piStartOffset,
    int *piEndOffset,
    int *piPosition
  );
};

struct sqlite3_tokenizer {
  const sqlite3_tokenizer_module *pModule;

};

struct sqlite3_tokenizer_cursor {
  sqlite3_tokenizer *pTokenizer;

};

int fts3_global_term_cnt(int iTerm, int iCol);
int fts3_term_cnt(int iTerm, int iCol);
# 110632 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct Fts3Hash Fts3Hash;
typedef struct Fts3HashElem Fts3HashElem;
# 110643 "ext/sqlite3/libsqlite/sqlite3.c"
struct Fts3Hash {
  char keyClass;
  char copyKey;
  int count;
  Fts3HashElem *first;
  int htsize;
  struct _fts3ht {
    int count;
    Fts3HashElem *chain;
  } *ht;
};







struct Fts3HashElem {
  Fts3HashElem *next, *prev;
  void *data;
  void *pKey; int nKey;
};
# 110685 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3Fts3HashInit(Fts3Hash *pNew, char keyClass, char copyKey);
static void *sqlite3Fts3HashInsert(Fts3Hash*, const void *pKey, int nKey, void *pData);
static void *sqlite3Fts3HashFind(const Fts3Hash*, const void *pKey, int nKey);
static void sqlite3Fts3HashClear(Fts3Hash*);
static Fts3HashElem *sqlite3Fts3HashFindElem(const Fts3Hash *, const void *, int);
# 110803 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct Fts3Table Fts3Table;
typedef struct Fts3Cursor Fts3Cursor;
typedef struct Fts3Expr Fts3Expr;
typedef struct Fts3Phrase Fts3Phrase;
typedef struct Fts3PhraseToken Fts3PhraseToken;

typedef struct Fts3SegFilter Fts3SegFilter;
typedef struct Fts3DeferredToken Fts3DeferredToken;
typedef struct Fts3SegReader Fts3SegReader;
typedef struct Fts3SegReaderCursor Fts3SegReaderCursor;
# 110821 "ext/sqlite3/libsqlite/sqlite3.c"
struct Fts3Table {
  sqlite3_vtab base;
  sqlite3 *db;
  const char *zDb;
  const char *zName;
  int nColumn;
  char **azColumn;
  sqlite3_tokenizer *pTokenizer;




  sqlite3_stmt *aStmt[24];

  char *zReadExprlist;
  char *zWriteExprlist;

  int nNodeSize;
  u8 bHasStat;
  u8 bHasDocsize;
  int nPgsz;
  char *zSegmentsTbl;
  sqlite3_blob *pSegments;
# 110852 "ext/sqlite3/libsqlite/sqlite3.c"
  int nMaxPendingData;
  int nPendingData;
  sqlite_int64 iPrevDocid;
  Fts3Hash pendingTerms;
};






struct Fts3Cursor {
  sqlite3_vtab_cursor base;
  i16 eSearch;
  u8 isEof;
  u8 isRequireSeek;
  sqlite3_stmt *pStmt;
  Fts3Expr *pExpr;
  int nPhrase;
  Fts3DeferredToken *pDeferred;
  sqlite3_int64 iPrevId;
  char *pNextId;
  char *aDoclist;
  int nDoclist;
  int eEvalmode;
  int nRowAvg;

  int isMatchinfoNeeded;
  u32 *aMatchinfo;
  int nMatchinfo;
  char *zMatchinfo;
};
# 110920 "ext/sqlite3/libsqlite/sqlite3.c"
struct Fts3PhraseToken {
  char *z;
  int n;
  int isPrefix;
  int bFulltext;
  Fts3SegReaderCursor *pSegcsr;
  Fts3DeferredToken *pDeferred;
};

struct Fts3Phrase {

  int nToken;
  int iColumn;
  int isNot;
  Fts3PhraseToken aToken[1];
};
# 110950 "ext/sqlite3/libsqlite/sqlite3.c"
struct Fts3Expr {
  int eType;
  int nNear;
  Fts3Expr *pParent;
  Fts3Expr *pLeft;
  Fts3Expr *pRight;
  Fts3Phrase *pPhrase;

  int isLoaded;
  char *aDoclist;
  int nDoclist;

  sqlite3_int64 iCurrent;
  char *pCurrent;
};
# 110985 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Fts3UpdateMethod(sqlite3_vtab*,int,sqlite3_value**,sqlite3_int64*);
static int sqlite3Fts3PendingTermsFlush(Fts3Table *);
static void sqlite3Fts3PendingTermsClear(Fts3Table *);
static int sqlite3Fts3Optimize(Fts3Table *);
static int sqlite3Fts3SegReaderNew(int, sqlite3_int64,
  sqlite3_int64, sqlite3_int64, const char *, int, Fts3SegReader**);
static int sqlite3Fts3SegReaderPending(Fts3Table*,const char*,int,int,Fts3SegReader**);
static void sqlite3Fts3SegReaderFree(Fts3SegReader *);
static int sqlite3Fts3SegReaderCost(Fts3Cursor *, Fts3SegReader *, int *);
static int sqlite3Fts3AllSegdirs(Fts3Table*, int, sqlite3_stmt **);
static int sqlite3Fts3ReadLock(Fts3Table *);
static int sqlite3Fts3ReadBlock(Fts3Table*, sqlite3_int64, char **, int*);

static int sqlite3Fts3SelectDoctotal(Fts3Table *, sqlite3_stmt **);
static int sqlite3Fts3SelectDocsize(Fts3Table *, sqlite3_int64, sqlite3_stmt **);

static void sqlite3Fts3FreeDeferredTokens(Fts3Cursor *);
static int sqlite3Fts3DeferToken(Fts3Cursor *, Fts3PhraseToken *, int);
static int sqlite3Fts3CacheDeferredDoclists(Fts3Cursor *);
static void sqlite3Fts3FreeDeferredDoclists(Fts3Cursor *);
static char *sqlite3Fts3DeferredDoclist(Fts3DeferredToken *, int *);
static void sqlite3Fts3SegmentsClose(Fts3Table *);




static int sqlite3Fts3SegReaderStart(Fts3Table*, Fts3SegReaderCursor*, Fts3SegFilter*);
static int sqlite3Fts3SegReaderStep(Fts3Table *, Fts3SegReaderCursor *);
static void sqlite3Fts3SegReaderFinish(Fts3SegReaderCursor *);
static int sqlite3Fts3SegReaderCursor(
    Fts3Table *, int, const char *, int, int, int, Fts3SegReaderCursor *);
# 111025 "ext/sqlite3/libsqlite/sqlite3.c"
struct Fts3SegFilter {
  const char *zTerm;
  int nTerm;
  int iCol;
  int flags;
};

struct Fts3SegReaderCursor {

  Fts3SegReader **apSegment;
  int nSegment;
  int nAdvance;
  Fts3SegFilter *pFilter;
  char *aBuffer;
  int nBuffer;


  int nCost;


  char *zTerm;
  int nTerm;
  char *aDoclist;
  int nDoclist;
};


static int sqlite3Fts3PutVarint(char *, sqlite3_int64);
static int sqlite3Fts3GetVarint(const char *, sqlite_int64 *);
static int sqlite3Fts3GetVarint32(const char *, int *);
static int sqlite3Fts3VarintLen(sqlite3_uint64);
static void sqlite3Fts3Dequote(char *);

static char *sqlite3Fts3FindPositions(Fts3Expr *, sqlite3_int64, int);
static int sqlite3Fts3ExprLoadDoclist(Fts3Cursor *, Fts3Expr *);
static int sqlite3Fts3ExprLoadFtDoclist(Fts3Cursor *, Fts3Expr *, char **, int *);
static int sqlite3Fts3ExprNearTrim(Fts3Expr *, Fts3Expr *, int);


static const char *sqlite3Fts3NextToken(const char *, int *);
static int sqlite3Fts3InitHashTable(sqlite3 *, Fts3Hash *, const char *);
static int sqlite3Fts3InitTokenizer(Fts3Hash *pHash, const char *,
    sqlite3_tokenizer **, char **
);
static int sqlite3Fts3IsIdChar(char);


static void sqlite3Fts3Offsets(sqlite3_context*, Fts3Cursor*);
static void sqlite3Fts3Snippet(sqlite3_context *, Fts3Cursor *, const char *,
  const char *, const char *, int, int
);
static void sqlite3Fts3Matchinfo(sqlite3_context *, Fts3Cursor *, const char *);


static int sqlite3Fts3ExprParse(sqlite3_tokenizer *,
  char **, int, int, const char *, int, Fts3Expr **
);
static void sqlite3Fts3ExprFree(Fts3Expr *);





static int sqlite3Fts3InitAux(sqlite3 *db);
# 111105 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Fts3PutVarint(char *p, sqlite_int64 v){
  unsigned char *q = (unsigned char *) p;
  sqlite_uint64 vu = v;
  do{
    *q++ = (unsigned char) ((vu & 0x7f) | 0x80);
    vu >>= 7;
  }while( vu!=0 );
  q[-1] &= 0x7f;
  ((void) (0));
  return (int) (q - (unsigned char *)p);
}






static int sqlite3Fts3GetVarint(const char *p, sqlite_int64 *v){
  const unsigned char *q = (const unsigned char *) p;
  sqlite_uint64 x = 0, y = 1;
  while( (*q&0x80)==0x80 && q-(unsigned char *)p<10 ){
    x += y * (*q++ & 0x7f);
    y <<= 7;
  }
  x += y * (*q++);
  *v = (sqlite_int64) x;
  return (int) (q - (unsigned char *)p);
}





static int sqlite3Fts3GetVarint32(const char *p, int *pi){
 sqlite_int64 i;
 int ret = sqlite3Fts3GetVarint(p, &i);
 *pi = (int) i;
 return ret;
}




static int sqlite3Fts3VarintLen(sqlite3_uint64 v){
  int i = 0;
  do{
    i++;
    v >>= 7;
  }while( v!=0 );
  return i;
}
# 111171 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3Fts3Dequote(char *z){
  char quote;

  quote = z[0];
  if( quote=='[' || quote=='\'' || quote=='"' || quote=='`' ){
    int iIn = 1;
    int iOut = 0;


    if( quote=='[' ) quote = ']';

    while( (z[iIn]) ){
      if( z[iIn]==quote ){
        if( z[iIn+1]!=quote ) break;
        z[iOut++] = quote;
        iIn += 2;
      }else{
        z[iOut++] = z[iIn++];
      }
    }
    z[iOut] = '\0';
  }
}






static void fts3GetDeltaVarint(char **pp, sqlite3_int64 *pVal){
  sqlite3_int64 iVal;
  *pp += sqlite3Fts3GetVarint(*pp, &iVal);
  *pVal += iVal;
}







static void fts3GetDeltaVarint2(char **pp, char *pEnd, sqlite3_int64 *pVal){
  if( *pp>=pEnd ){
    *pp = 0;
  }else{
    fts3GetDeltaVarint(pp, pVal);
  }
}




static int fts3DisconnectMethod(sqlite3_vtab *pVtab){
  Fts3Table *p = (Fts3Table *)pVtab;
  int i;

  ((void) (0));
  ((void) (0));


  for(i=0; i<((int)(sizeof(p->aStmt)/sizeof(p->aStmt[0]))); i++){
    sqlite3_finalize(p->aStmt[i]);
  }
  sqlite3_free(p->zSegmentsTbl);
  sqlite3_free(p->zReadExprlist);
  sqlite3_free(p->zWriteExprlist);


  p->pTokenizer->pModule->xDestroy(p->pTokenizer);

  sqlite3_free(p);
  return 0;
}
# 111252 "ext/sqlite3/libsqlite/sqlite3.c"
static void fts3DbExec(
  int *pRc,
  sqlite3 *db,
  const char *zFormat,
  ...
){
  va_list ap;
  char *zSql;
  if( *pRc ) return;
  __builtin_va_start(ap, zFormat);
  zSql = sqlite3_vmprintf(zFormat, ap);
  __builtin_va_end(ap);
  if( zSql==0 ){
    *pRc = 7;
  }else{
    *pRc = sqlite3_exec(db, zSql, 0, 0, 0);
    sqlite3_free(zSql);
  }
}




static int fts3DestroyMethod(sqlite3_vtab *pVtab){
  int rc = 0;
  Fts3Table *p = (Fts3Table *)pVtab;
  sqlite3 *db = p->db;


  fts3DbExec(&rc, db, "DROP TABLE IF EXISTS %Q.'%q_content'", p->zDb, p->zName);
  fts3DbExec(&rc, db, "DROP TABLE IF EXISTS %Q.'%q_segments'", p->zDb,p->zName);
  fts3DbExec(&rc, db, "DROP TABLE IF EXISTS %Q.'%q_segdir'", p->zDb, p->zName);
  fts3DbExec(&rc, db, "DROP TABLE IF EXISTS %Q.'%q_docsize'", p->zDb, p->zName);
  fts3DbExec(&rc, db, "DROP TABLE IF EXISTS %Q.'%q_stat'", p->zDb, p->zName);





  return (rc==0 ? fts3DisconnectMethod(pVtab) : rc);
}
# 111304 "ext/sqlite3/libsqlite/sqlite3.c"
static void fts3DeclareVtab(int *pRc, Fts3Table *p){
  if( *pRc==0 ){
    int i;
    int rc;
    char *zSql;
    char *zCols;


    zCols = sqlite3_mprintf("%Q, ", p->azColumn[0]);
    for(i=1; zCols && i<p->nColumn; i++){
      zCols = sqlite3_mprintf("%z%Q, ", zCols, p->azColumn[i]);
    }


    zSql = sqlite3_mprintf(
        "CREATE TABLE x(%s %Q HIDDEN, docid HIDDEN)", zCols, p->zName
    );
    if( !zCols || !zSql ){
      rc = 7;
    }else{
      rc = sqlite3_declare_vtab(p->db, zSql);
    }

    sqlite3_free(zSql);
    sqlite3_free(zCols);
    *pRc = rc;
  }
}
# 111342 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3CreateTables(Fts3Table *p){
  int rc = 0;
  int i;
  char *zContentCols;
  sqlite3 *db = p->db;


  zContentCols = sqlite3_mprintf("docid INTEGER PRIMARY KEY");
  for(i=0; zContentCols && i<p->nColumn; i++){
    char *z = p->azColumn[i];
    zContentCols = sqlite3_mprintf("%z, 'c%d%q'", zContentCols, i, z);
  }
  if( zContentCols==0 ) rc = 7;


  fts3DbExec(&rc, db,
     "CREATE TABLE %Q.'%q_content'(%s)",
     p->zDb, p->zName, zContentCols
  );
  sqlite3_free(zContentCols);

  fts3DbExec(&rc, db,
      "CREATE TABLE %Q.'%q_segments'(blockid INTEGER PRIMARY KEY, block BLOB);",
      p->zDb, p->zName
  );
  fts3DbExec(&rc, db,
      "CREATE TABLE %Q.'%q_segdir'("
        "level INTEGER,"
        "idx INTEGER,"
        "start_block INTEGER,"
        "leaves_end_block INTEGER,"
        "end_block INTEGER,"
        "root BLOB,"
        "PRIMARY KEY(level, idx)"
      ");",
      p->zDb, p->zName
  );
  if( p->bHasDocsize ){
    fts3DbExec(&rc, db,
        "CREATE TABLE %Q.'%q_docsize'(docid INTEGER PRIMARY KEY, size BLOB);",
        p->zDb, p->zName
    );
  }
  if( p->bHasStat ){
    fts3DbExec(&rc, db,
        "CREATE TABLE %Q.'%q_stat'(id INTEGER PRIMARY KEY, value BLOB);",
        p->zDb, p->zName
    );
  }
  return rc;
}
# 111401 "ext/sqlite3/libsqlite/sqlite3.c"
static void fts3DatabasePageSize(int *pRc, Fts3Table *p){
  if( *pRc==0 ){
    int rc;
    char *zSql;
    sqlite3_stmt *pStmt;

    zSql = sqlite3_mprintf("PRAGMA %Q.page_size", p->zDb);
    if( !zSql ){
      rc = 7;
    }else{
      rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);
      if( rc==0 ){
        sqlite3_step(pStmt);
        p->nPgsz = sqlite3_column_int(pStmt, 0);
        rc = sqlite3_finalize(pStmt);
      }
    }
    ((void) (0));
    sqlite3_free(zSql);
    *pRc = rc;
  }
}
# 111432 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3IsSpecialColumn(
  const char *z,
  int *pnKey,
  char **pzValue
){
  char *zValue;
  const char *zCsr = z;

  while( *zCsr!='=' ){
    if( *zCsr=='\0' ) return 0;
    zCsr++;
  }

  *pnKey = (int)(zCsr-z);
  zValue = sqlite3_mprintf("%s", &zCsr[1]);
  if( zValue ){
    sqlite3Fts3Dequote(zValue);
  }
  *pzValue = zValue;
  return 1;
}




static void fts3Appendf(
  int *pRc,
  char **pz,
  const char *zFormat,
  ...
){
  if( *pRc==0 ){
    va_list ap;
    char *z;
    __builtin_va_start(ap, zFormat);
    z = sqlite3_vmprintf(zFormat, ap);
    if( z && *pz ){
      char *z2 = sqlite3_mprintf("%s%s", *pz, z);
      sqlite3_free(z);
      z = z2;
    }
    if( z==0 ) *pRc = 7;
    __builtin_va_end(ap);
    sqlite3_free(*pz);
    *pz = z;
  }
}
# 111490 "ext/sqlite3/libsqlite/sqlite3.c"
static char *fts3QuoteId(char const *zInput){
  int nRet;
  char *zRet;
  nRet = 2 + strlen(zInput)*2 + 1;
  zRet = sqlite3_malloc(nRet);
  if( zRet ){
    int i;
    char *z = zRet;
    *(z++) = '"';
    for(i=0; zInput[i]; i++){
      if( zInput[i]=='"' ) *(z++) = '"';
      *(z++) = zInput[i];
    }
    *(z++) = '"';
    *(z++) = '\0';
  }
  return zRet;
}
# 111532 "ext/sqlite3/libsqlite/sqlite3.c"
static char *fts3ReadExprList(Fts3Table *p, const char *zFunc, int *pRc){
  char *zRet = 0;
  char *zFree = 0;
  char *zFunction;
  int i;

  if( !zFunc ){
    zFunction = "";
  }else{
    zFree = zFunction = fts3QuoteId(zFunc);
  }
  fts3Appendf(pRc, &zRet, "docid");
  for(i=0; i<p->nColumn; i++){
    fts3Appendf(pRc, &zRet, ",%s(x.'c%d%q')", zFunction, i, p->azColumn[i]);
  }
  sqlite3_free(zFree);
  return zRet;
}
# 111571 "ext/sqlite3/libsqlite/sqlite3.c"
static char *fts3WriteExprList(Fts3Table *p, const char *zFunc, int *pRc){
  char *zRet = 0;
  char *zFree = 0;
  char *zFunction;
  int i;

  if( !zFunc ){
    zFunction = "";
  }else{
    zFree = zFunction = fts3QuoteId(zFunc);
  }
  fts3Appendf(pRc, &zRet, "?");
  for(i=0; i<p->nColumn; i++){
    fts3Appendf(pRc, &zRet, ",%s(?)", zFunction);
  }
  sqlite3_free(zFree);
  return zRet;
}
# 111601 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3InitVtab(
  int isCreate,
  sqlite3 *db,
  void *pAux,
  int argc,
  const char * const *argv,
  sqlite3_vtab **ppVTab,
  char **pzErr
){
  Fts3Hash *pHash = (Fts3Hash *)pAux;
  Fts3Table *p = 0;
  int rc = 0;
  int i;
  int nByte;
  int iCol;
  int nString = 0;
  int nCol = 0;
  char *zCsr;
  int nDb;
  int nName;
  int isFts4 = (argv[0][3]=='4');
  int bNoDocsize = 0;
  const char **aCol;
  sqlite3_tokenizer *pTokenizer = 0;

  char *zCompress = 0;
  char *zUncompress = 0;

  ((void) (0));
  ((void) (0));



  nDb = (int)strlen(argv[1]) + 1;
  nName = (int)strlen(argv[2]) + 1;

  aCol = (const char **)sqlite3_malloc(sizeof(const char *) * (argc-2) );
  if( !aCol ) return 7;
  memset((void *)aCol, 0, sizeof(const char *) * (argc-2));
# 111652 "ext/sqlite3/libsqlite/sqlite3.c"
  for(i=3; rc==0 && i<argc; i++){
    char const *z = argv[i];
    int nKey;
    char *zVal;


    if( !pTokenizer
     && strlen(z)>8
     && 0==sqlite3_strnicmp(z, "tokenize", 8)
     && 0==sqlite3Fts3IsIdChar(z[8])
    ){
      rc = sqlite3Fts3InitTokenizer(pHash, &z[9], &pTokenizer, pzErr);
    }


    else if( isFts4 && fts3IsSpecialColumn(z, &nKey, &zVal) ){
      if( !zVal ){
        rc = 7;
        goto fts3_init_out;
      }
      if( nKey==9 && 0==sqlite3_strnicmp(z, "matchinfo", 9) ){
        if( strlen(zVal)==4 && 0==sqlite3_strnicmp(zVal, "fts3", 4) ){
          bNoDocsize = 1;
        }else{
          *pzErr = sqlite3_mprintf("unrecognized matchinfo: %s", zVal);
          rc = 1;
        }
      }else if( nKey==8 && 0==sqlite3_strnicmp(z, "compress", 8) ){
        zCompress = zVal;
        zVal = 0;
      }else if( nKey==10 && 0==sqlite3_strnicmp(z, "uncompress", 10) ){
        zUncompress = zVal;
        zVal = 0;
      }else{
        *pzErr = sqlite3_mprintf("unrecognized parameter: %s", z);
        rc = 1;
      }
      sqlite3_free(zVal);
    }


    else {
      nString += (int)(strlen(z) + 1);
      aCol[nCol++] = z;
    }
  }
  if( rc!=0 ) goto fts3_init_out;

  if( nCol==0 ){
    ((void) (0));
    aCol[0] = "content";
    nString = 8;
    nCol = 1;
  }

  if( pTokenizer==0 ){
    rc = sqlite3Fts3InitTokenizer(pHash, "simple", &pTokenizer, pzErr);
    if( rc!=0 ) goto fts3_init_out;
  }
  ((void) (0));



  nByte = sizeof(Fts3Table) +
          nCol * sizeof(char *) +
          nName +
          nDb +
          nString;
  p = (Fts3Table*)sqlite3_malloc(nByte);
  if( p==0 ){
    rc = 7;
    goto fts3_init_out;
  }
  memset(p, 0, nByte);
  p->db = db;
  p->nColumn = nCol;
  p->nPendingData = 0;
  p->azColumn = (char **)&p[1];
  p->pTokenizer = pTokenizer;
  p->nNodeSize = 1000;
  p->nMaxPendingData = (1*1024*1024);
  p->bHasDocsize = (isFts4 && bNoDocsize==0);
  p->bHasStat = isFts4;
  sqlite3Fts3HashInit(&p->pendingTerms, 1, 1);


  zCsr = (char *)&p->azColumn[nCol];
  p->zName = zCsr;
  memcpy(zCsr, argv[2], nName);
  zCsr += nName;
  p->zDb = zCsr;
  memcpy(zCsr, argv[1], nDb);
  zCsr += nDb;


  for(iCol=0; iCol<nCol; iCol++){
    char *z;
    int n;
    z = (char *)sqlite3Fts3NextToken(aCol[iCol], &n);
    memcpy(zCsr, z, n);
    zCsr[n] = '\0';
    sqlite3Fts3Dequote(zCsr);
    p->azColumn[iCol] = zCsr;
    zCsr += n+1;
    ((void) (0));
  }

  if( (zCompress==0)!=(zUncompress==0) ){
    char const *zMiss = (zCompress==0 ? "compress" : "uncompress");
    rc = 1;
    *pzErr = sqlite3_mprintf("missing %s parameter in fts4 constructor", zMiss);
  }
  p->zReadExprlist = fts3ReadExprList(p, zUncompress, &rc);
  p->zWriteExprlist = fts3WriteExprList(p, zCompress, &rc);
  if( rc!=0 ) goto fts3_init_out;




  if( isCreate ){
    rc = fts3CreateTables(p);
  }





  fts3DatabasePageSize(&rc, p);


  fts3DeclareVtab(&rc, p);

fts3_init_out:
  sqlite3_free(zCompress);
  sqlite3_free(zUncompress);
  sqlite3_free((void *)aCol);
  if( rc!=0 ){
    if( p ){
      fts3DisconnectMethod((sqlite3_vtab *)p);
    }else if( pTokenizer ){
      pTokenizer->pModule->xDestroy(pTokenizer);
    }
  }else{
    *ppVTab = &p->base;
  }
  return rc;
}





static int fts3ConnectMethod(
  sqlite3 *db,
  void *pAux,
  int argc,
  const char * const *argv,
  sqlite3_vtab **ppVtab,
  char **pzErr
){
  return fts3InitVtab(0, db, pAux, argc, argv, ppVtab, pzErr);
}
static int fts3CreateMethod(
  sqlite3 *db,
  void *pAux,
  int argc,
  const char * const *argv,
  sqlite3_vtab **ppVtab,
  char **pzErr
){
  return fts3InitVtab(1, db, pAux, argc, argv, ppVtab, pzErr);
}
# 111833 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3BestIndexMethod(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){
  Fts3Table *p = (Fts3Table *)pVTab;
  int i;
  int iCons = -1;





  pInfo->idxNum = 0;
  pInfo->estimatedCost = 500000;
  for(i=0; i<pInfo->nConstraint; i++){
    struct sqlite3_index_constraint *pCons = &pInfo->aConstraint[i];
    if( pCons->usable==0 ) continue;


    if( pCons->op==2
     && (pCons->iColumn<0 || pCons->iColumn==p->nColumn+1 )
    ){
      pInfo->idxNum = 1;
      pInfo->estimatedCost = 1.0;
      iCons = i;
    }
# 111866 "ext/sqlite3/libsqlite/sqlite3.c"
    if( pCons->op==64
     && pCons->iColumn>=0 && pCons->iColumn<=p->nColumn
    ){
      pInfo->idxNum = 2 + pCons->iColumn;
      pInfo->estimatedCost = 2.0;
      iCons = i;
      break;
    }
  }

  if( iCons>=0 ){
    pInfo->aConstraintUsage[iCons].argvIndex = 1;
    pInfo->aConstraintUsage[iCons].omit = 1;
  }
  return 0;
}




static int fts3OpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr){
  sqlite3_vtab_cursor *pCsr;

  (void)(pVTab);





  *ppCsr = pCsr = (sqlite3_vtab_cursor *)sqlite3_malloc(sizeof(Fts3Cursor));
  if( !pCsr ){
    return 7;
  }
  memset(pCsr, 0, sizeof(Fts3Cursor));
  return 0;
}





static int fts3CloseMethod(sqlite3_vtab_cursor *pCursor){
  Fts3Cursor *pCsr = (Fts3Cursor *)pCursor;
  ((void) (0));
  sqlite3_finalize(pCsr->pStmt);
  sqlite3Fts3ExprFree(pCsr->pExpr);
  sqlite3Fts3FreeDeferredTokens(pCsr);
  sqlite3_free(pCsr->aDoclist);
  sqlite3_free(pCsr->aMatchinfo);
  sqlite3_free(pCsr);
  return 0;
}






static int fts3CursorSeek(sqlite3_context *pContext, Fts3Cursor *pCsr){
  if( pCsr->isRequireSeek ){
    pCsr->isRequireSeek = 0;
    sqlite3_bind_int64(pCsr->pStmt, 1, pCsr->iPrevId);
    if( 100==sqlite3_step(pCsr->pStmt) ){
      return 0;
    }else{
      int rc = sqlite3_reset(pCsr->pStmt);
      if( rc==0 ){




        rc = 11;
      }
      pCsr->isEof = 1;
      if( pContext ){
        sqlite3_result_error_code(pContext, rc);
      }
      return rc;
    }
  }else{
    return 0;
  }
}
# 111965 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3ScanInteriorNode(
  const char *zTerm,
  int nTerm,
  const char *zNode,
  int nNode,
  sqlite3_int64 *piFirst,
  sqlite3_int64 *piLast
){
  int rc = 0;
  const char *zCsr = zNode;
  const char *zEnd = &zCsr[nNode];
  char *zBuffer = 0;
  int nAlloc = 0;
  int isFirstTerm = 1;
  sqlite3_int64 iChild;
# 111994 "ext/sqlite3/libsqlite/sqlite3.c"
  zCsr += sqlite3Fts3GetVarint(zCsr, &iChild);
  zCsr += sqlite3Fts3GetVarint(zCsr, &iChild);
  if( zCsr>zEnd ){
    return 11;
  }

  while( zCsr<zEnd && (piFirst || piLast) ){
    int cmp;
    int nSuffix;
    int nPrefix = 0;
    int nBuffer;



    if( !isFirstTerm ){
      zCsr += sqlite3Fts3GetVarint32(zCsr, &nPrefix);
    }
    isFirstTerm = 0;
    zCsr += sqlite3Fts3GetVarint32(zCsr, &nSuffix);

    if( nPrefix<0 || nSuffix<0 || &zCsr[nSuffix]>zEnd ){
      rc = 11;
      goto finish_scan;
    }
    if( nPrefix+nSuffix>nAlloc ){
      char *zNew;
      nAlloc = (nPrefix+nSuffix) * 2;
      zNew = (char *)sqlite3_realloc(zBuffer, nAlloc);
      if( !zNew ){
        rc = 7;
        goto finish_scan;
      }
      zBuffer = zNew;
    }
    memcpy(&zBuffer[nPrefix], zCsr, nSuffix);
    nBuffer = nPrefix + nSuffix;
    zCsr += nSuffix;
# 112041 "ext/sqlite3/libsqlite/sqlite3.c"
    cmp = memcmp(zTerm, zBuffer, (nBuffer>nTerm ? nTerm : nBuffer));
    if( piFirst && (cmp<0 || (cmp==0 && nBuffer>nTerm)) ){
      *piFirst = iChild;
      piFirst = 0;
    }

    if( piLast && cmp<0 ){
      *piLast = iChild;
      piLast = 0;
    }

    iChild++;
  };

  if( piFirst ) *piFirst = iChild;
  if( piLast ) *piLast = iChild;

 finish_scan:
  sqlite3_free(zBuffer);
  return rc;
}
# 112085 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3SelectLeaf(
  Fts3Table *p,
  const char *zTerm,
  int nTerm,
  const char *zNode,
  int nNode,
  sqlite3_int64 *piLeaf,
  sqlite3_int64 *piLeaf2
){
  int rc;
  int iHeight;

  ((void) (0));

  sqlite3Fts3GetVarint32(zNode, &iHeight);
  rc = fts3ScanInteriorNode(zTerm, nTerm, zNode, nNode, piLeaf, piLeaf2);
  ((void) (0));

  if( rc==0 && iHeight>1 ){
    char *zBlob = 0;
    int nBlob;

    if( piLeaf && piLeaf2 && (*piLeaf!=*piLeaf2) ){
      rc = sqlite3Fts3ReadBlock(p, *piLeaf, &zBlob, &nBlob);
      if( rc==0 ){
        rc = fts3SelectLeaf(p, zTerm, nTerm, zBlob, nBlob, piLeaf, 0);
      }
      sqlite3_free(zBlob);
      piLeaf = 0;
      zBlob = 0;
    }

    if( rc==0 ){
      rc = sqlite3Fts3ReadBlock(p, piLeaf ? *piLeaf : *piLeaf2, &zBlob, &nBlob);
    }
    if( rc==0 ){
      rc = fts3SelectLeaf(p, zTerm, nTerm, zBlob, nBlob, piLeaf, piLeaf2);
    }
    sqlite3_free(zBlob);
  }

  return rc;
}





static void fts3PutDeltaVarint(
  char **pp,
  sqlite3_int64 *piPrev,
  sqlite3_int64 iVal
){
  ((void) (0));
  *pp += sqlite3Fts3PutVarint(*pp, iVal-*piPrev);
  *piPrev = iVal;
}
# 112157 "ext/sqlite3/libsqlite/sqlite3.c"
static void fts3PoslistCopy(char **pp, char **ppPoslist){
  char *pEnd = *ppPoslist;
  char c = 0;
# 112171 "ext/sqlite3/libsqlite/sqlite3.c"
  while( *pEnd | c ){
    c = *pEnd++ & 0x80;
                                  ;
  }
  pEnd++;

  if( pp ){
    int n = (int)(pEnd - *ppPoslist);
    char *p = *pp;
    memcpy(p, *ppPoslist, n);
    p += n;
    *pp = p;
  }
  *ppPoslist = pEnd;
}
# 112204 "ext/sqlite3/libsqlite/sqlite3.c"
static void fts3ColumnlistCopy(char **pp, char **ppPoslist){
  char *pEnd = *ppPoslist;
  char c = 0;




  while( 0xFE & (*pEnd | c) ){
    c = *pEnd++ & 0x80;
                                         ;
  }
  if( pp ){
    int n = (int)(pEnd - *ppPoslist);
    char *p = *pp;
    memcpy(p, *ppPoslist, n);
    p += n;
    *pp = p;
  }
  *ppPoslist = pEnd;
}
# 112249 "ext/sqlite3/libsqlite/sqlite3.c"
static void fts3ReadNextPos(
  char **pp,
  sqlite3_int64 *pi
){
  if( (**pp)&0xFE ){
    fts3GetDeltaVarint(pp, pi);
    *pi -= 2;
  }else{
    *pi = 0x7fffffff;
  }
}
# 112270 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3PutColNumber(char **pp, int iCol){
  int n = 0;
  if( iCol ){
    char *p = *pp;
    n = 1 + sqlite3Fts3PutVarint(&p[1], iCol);
    *p = 0x01;
    *pp = &p[n];
  }
  return n;
}
# 112288 "ext/sqlite3/libsqlite/sqlite3.c"
static void fts3PoslistMerge(
  char **pp,
  char **pp1,
  char **pp2
){
  char *p = *pp;
  char *p1 = *pp1;
  char *p2 = *pp2;

  while( *p1 || *p2 ){
    int iCol1;
    int iCol2;

    if( *p1==(1) ) sqlite3Fts3GetVarint32(&p1[1], &iCol1);
    else if( *p1==(0) ) iCol1 = 0x7fffffff;
    else iCol1 = 0;

    if( *p2==(1) ) sqlite3Fts3GetVarint32(&p2[1], &iCol2);
    else if( *p2==(0) ) iCol2 = 0x7fffffff;
    else iCol2 = 0;

    if( iCol1==iCol2 ){
      sqlite3_int64 i1 = 0;
      sqlite3_int64 i2 = 0;
      sqlite3_int64 iPrev = 0;
      int n = fts3PutColNumber(&p, iCol1);
      p1 += n;
      p2 += n;
# 112326 "ext/sqlite3/libsqlite/sqlite3.c"
      fts3GetDeltaVarint(&p1, &i1);
      fts3GetDeltaVarint(&p2, &i2);
      do {
        fts3PutDeltaVarint(&p, &iPrev, (i1<i2) ? i1 : i2);
        iPrev -= 2;
        if( i1==i2 ){
          fts3ReadNextPos(&p1, &i1);
          fts3ReadNextPos(&p2, &i2);
        }else if( i1<i2 ){
          fts3ReadNextPos(&p1, &i1);
        }else{
          fts3ReadNextPos(&p2, &i2);
        }
      }while( i1!=0x7fffffff || i2!=0x7fffffff );
    }else if( iCol1<iCol2 ){
      p1 += fts3PutColNumber(&p, iCol1);
      fts3ColumnlistCopy(&p, &p1);
    }else{
      p2 += fts3PutColNumber(&p, iCol2);
      fts3ColumnlistCopy(&p, &p2);
    }
  }

  *p++ = (0);
  *pp = p;
  *pp1 = p1 + 1;
  *pp2 = p2 + 1;
}
# 112378 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3PoslistPhraseMerge(
  char **pp,
  int nToken,
  int isSaveLeft,
  int isExact,
  char **pp1,
  char **pp2
){
  char *p = (pp ? *pp : 0);
  char *p1 = *pp1;
  char *p2 = *pp2;
  int iCol1 = 0;
  int iCol2 = 0;


  ((void) (0));

  ((void) (0));
  if( *p1==(1) ){
    p1++;
    p1 += sqlite3Fts3GetVarint32(p1, &iCol1);
  }
  if( *p2==(1) ){
    p2++;
    p2 += sqlite3Fts3GetVarint32(p2, &iCol2);
  }

  while( 1 ){
    if( iCol1==iCol2 ){
      char *pSave = p;
      sqlite3_int64 iPrev = 0;
      sqlite3_int64 iPos1 = 0;
      sqlite3_int64 iPos2 = 0;

      if( pp && iCol1 ){
        *p++ = (1);
        p += sqlite3Fts3PutVarint(p, iCol1);
      }

      ((void) (0));
      ((void) (0));
      fts3GetDeltaVarint(&p1, &iPos1); iPos1 -= 2;
      fts3GetDeltaVarint(&p2, &iPos2); iPos2 -= 2;

      while( 1 ){
        if( iPos2==iPos1+nToken
         || (isExact==0 && iPos2>iPos1 && iPos2<=iPos1+nToken)
        ){
          sqlite3_int64 iSave;
          if( !pp ){
            fts3PoslistCopy(0, &p2);
            fts3PoslistCopy(0, &p1);
            *pp1 = p1;
            *pp2 = p2;
            return 1;
          }
          iSave = isSaveLeft ? iPos1 : iPos2;
          fts3PutDeltaVarint(&p, &iPrev, iSave+2); iPrev -= 2;
          pSave = 0;
        }
        if( (!isSaveLeft && iPos2<=(iPos1+nToken)) || iPos2<=iPos1 ){
          if( (*p2&0xFE)==0 ) break;
          fts3GetDeltaVarint(&p2, &iPos2); iPos2 -= 2;
        }else{
          if( (*p1&0xFE)==0 ) break;
          fts3GetDeltaVarint(&p1, &iPos1); iPos1 -= 2;
        }
      }

      if( pSave ){
        ((void) (0));
        p = pSave;
      }

      fts3ColumnlistCopy(0, &p1);
      fts3ColumnlistCopy(0, &p2);
      ((void) (0));
      if( 0==*p1 || 0==*p2 ) break;

      p1++;
      p1 += sqlite3Fts3GetVarint32(p1, &iCol1);
      p2++;
      p2 += sqlite3Fts3GetVarint32(p2, &iCol2);
    }






    else if( iCol1<iCol2 ){
      fts3ColumnlistCopy(0, &p1);
      if( 0==*p1 ) break;
      p1++;
      p1 += sqlite3Fts3GetVarint32(p1, &iCol1);
    }else{
      fts3ColumnlistCopy(0, &p2);
      if( 0==*p2 ) break;
      p2++;
      p2 += sqlite3Fts3GetVarint32(p2, &iCol2);
    }
  }

  fts3PoslistCopy(0, &p2);
  fts3PoslistCopy(0, &p1);
  *pp1 = p1;
  *pp2 = p2;
  if( !pp || *pp==p ){
    return 0;
  }
  *p++ = 0x00;
  *pp = p;
  return 1;
}




static int fts3PoslistNearMerge(
  char **pp,
  char *aTmp,
  int nRight,
  int nLeft,
  char **pp1,
  char **pp2
){
  char *p1 = *pp1;
  char *p2 = *pp2;

  if( !pp ){
    if( fts3PoslistPhraseMerge(0, nRight, 0, 0, pp1, pp2) ) return 1;
    *pp1 = p1;
    *pp2 = p2;
    return fts3PoslistPhraseMerge(0, nLeft, 0, 0, pp2, pp1);
  }else{
    char *pTmp1 = aTmp;
    char *pTmp2;
    char *aTmp2;
    int res = 1;

    fts3PoslistPhraseMerge(&pTmp1, nRight, 0, 0, pp1, pp2);
    aTmp2 = pTmp2 = pTmp1;
    *pp1 = p1;
    *pp2 = p2;
    fts3PoslistPhraseMerge(&pTmp2, nLeft, 1, 0, pp2, pp1);
    if( pTmp1!=aTmp && pTmp2!=aTmp2 ){
      fts3PoslistMerge(pp, &aTmp, &aTmp2);
    }else if( pTmp1!=aTmp ){
      fts3PoslistCopy(pp, &aTmp);
    }else if( pTmp2!=aTmp2 ){
      fts3PoslistCopy(pp, &aTmp2);
    }else{
      res = 0;
    }

    return res;
  }
}
# 112559 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3DoclistMerge(
  int mergetype,
  int nParam1,
  int nParam2,
  char *aBuffer,
  int *pnBuffer,
  char *a1,
  int n1,
  char *a2,
  int n2,
  int *pnDoc
){
  sqlite3_int64 i1 = 0;
  sqlite3_int64 i2 = 0;
  sqlite3_int64 iPrev = 0;

  char *p = aBuffer;
  char *p1 = a1;
  char *p2 = a2;
  char *pEnd1 = &a1[n1];
  char *pEnd2 = &a2[n2];
  int nDoc = 0;

  ((void) (0));





  if( !aBuffer ){
    *pnBuffer = 0;
    return 7;
  }


  fts3GetDeltaVarint2(&p1, pEnd1, &i1);
  fts3GetDeltaVarint2(&p2, pEnd2, &i2);

  switch( mergetype ){
    case 4:
    case 5:
      while( p1 || p2 ){
        if( p2 && p1 && i1==i2 ){
          fts3PutDeltaVarint(&p, &iPrev, i1);
          if( mergetype==5 ) fts3PoslistMerge(&p, &p1, &p2);
          fts3GetDeltaVarint2(&p1, pEnd1, &i1);
          fts3GetDeltaVarint2(&p2, pEnd2, &i2);
        }else if( !p2 || (p1 && i1<i2) ){
          fts3PutDeltaVarint(&p, &iPrev, i1);
          if( mergetype==5 ) fts3PoslistCopy(&p, &p1);
          fts3GetDeltaVarint2(&p1, pEnd1, &i1);
        }else{
          fts3PutDeltaVarint(&p, &iPrev, i2);
          if( mergetype==5 ) fts3PoslistCopy(&p, &p2);
          fts3GetDeltaVarint2(&p2, pEnd2, &i2);
        }
      }
      break;

    case 3:
      while( p1 && p2 ){
        if( i1==i2 ){
          fts3PutDeltaVarint(&p, &iPrev, i1);
          fts3GetDeltaVarint2(&p1, pEnd1, &i1);
          fts3GetDeltaVarint2(&p2, pEnd2, &i2);
          nDoc++;
        }else if( i1<i2 ){
          fts3GetDeltaVarint2(&p1, pEnd1, &i1);
        }else{
          fts3GetDeltaVarint2(&p2, pEnd2, &i2);
        }
      }
      break;

    case 2:
      while( p1 ){
        if( p2 && i1==i2 ){
          fts3GetDeltaVarint2(&p1, pEnd1, &i1);
          fts3GetDeltaVarint2(&p2, pEnd2, &i2);
        }else if( !p2 || i1<i2 ){
          fts3PutDeltaVarint(&p, &iPrev, i1);
          fts3GetDeltaVarint2(&p1, pEnd1, &i1);
        }else{
          fts3GetDeltaVarint2(&p2, pEnd2, &i2);
        }
      }
      break;

    case 7:
    case 6: {
      char **ppPos = (mergetype==6 ? 0 : &p);
      while( p1 && p2 ){
        if( i1==i2 ){
          char *pSave = p;
          sqlite3_int64 iPrevSave = iPrev;
          fts3PutDeltaVarint(&p, &iPrev, i1);
          if( 0==fts3PoslistPhraseMerge(ppPos, nParam1, 0, 1, &p1, &p2) ){
            p = pSave;
            iPrev = iPrevSave;
          }else{
            nDoc++;
          }
          fts3GetDeltaVarint2(&p1, pEnd1, &i1);
          fts3GetDeltaVarint2(&p2, pEnd2, &i2);
        }else if( i1<i2 ){
          fts3PoslistCopy(0, &p1);
          fts3GetDeltaVarint2(&p1, pEnd1, &i1);
        }else{
          fts3PoslistCopy(0, &p2);
          fts3GetDeltaVarint2(&p2, pEnd2, &i2);
        }
      }
      break;
    }

    default: ((void) (0)); {
      char *aTmp = 0;
      char **ppPos = 0;

      if( mergetype==9 ){
        ppPos = &p;
        aTmp = sqlite3_malloc(2*(n1+n2+1));
        if( !aTmp ){
          return 7;
        }
      }

      while( p1 && p2 ){
        if( i1==i2 ){
          char *pSave = p;
          sqlite3_int64 iPrevSave = iPrev;
          fts3PutDeltaVarint(&p, &iPrev, i1);

          if( !fts3PoslistNearMerge(ppPos, aTmp, nParam1, nParam2, &p1, &p2) ){
            iPrev = iPrevSave;
            p = pSave;
          }

          fts3GetDeltaVarint2(&p1, pEnd1, &i1);
          fts3GetDeltaVarint2(&p2, pEnd2, &i2);
        }else if( i1<i2 ){
          fts3PoslistCopy(0, &p1);
          fts3GetDeltaVarint2(&p1, pEnd1, &i1);
        }else{
          fts3PoslistCopy(0, &p2);
          fts3GetDeltaVarint2(&p2, pEnd2, &i2);
        }
      }
      sqlite3_free(aTmp);
      break;
    }
  }

  if( pnDoc ) *pnDoc = nDoc;
  *pnBuffer = (int)(p-aBuffer);
  return 0;
}





typedef struct TermSelect TermSelect;
struct TermSelect {
  int isReqPos;
  char *aaOutput[16];
  int anOutput[16];
};
# 112737 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3TermSelectMerge(TermSelect *pTS){
  int mergetype = (pTS->isReqPos ? 5 : 4);
  char *aOut = 0;
  int nOut = 0;
  int i;




  for(i=0; i<((int)(sizeof(pTS->aaOutput)/sizeof(pTS->aaOutput[0]))); i++){
    if( pTS->aaOutput[i] ){
      if( !aOut ){
        aOut = pTS->aaOutput[i];
        nOut = pTS->anOutput[i];
        pTS->aaOutput[i] = 0;
      }else{
        int nNew = nOut + pTS->anOutput[i];
        char *aNew = sqlite3_malloc(nNew);
        if( !aNew ){
          sqlite3_free(aOut);
          return 7;
        }
        fts3DoclistMerge(mergetype, 0, 0,
            aNew, &nNew, pTS->aaOutput[i], pTS->anOutput[i], aOut, nOut, 0
        );
        sqlite3_free(pTS->aaOutput[i]);
        sqlite3_free(aOut);
        pTS->aaOutput[i] = 0;
        aOut = aNew;
        nOut = nNew;
      }
    }
  }

  pTS->aaOutput[0] = aOut;
  pTS->anOutput[0] = nOut;
  return 0;
}






static int fts3TermSelectCb(
  Fts3Table *p,
  void *pContext,
  char *zTerm,
  int nTerm,
  char *aDoclist,
  int nDoclist
){
  TermSelect *pTS = (TermSelect *)pContext;

  (void)(p);
  (void)(zTerm);
  (void)(nTerm);

  if( pTS->aaOutput[0]==0 ){




    pTS->aaOutput[0] = sqlite3_malloc(nDoclist);
    pTS->anOutput[0] = nDoclist;
    if( pTS->aaOutput[0] ){
      memcpy(pTS->aaOutput[0], aDoclist, nDoclist);
    }else{
      return 7;
    }
  }else{
    int mergetype = (pTS->isReqPos ? 5 : 4);
    char *aMerge = aDoclist;
    int nMerge = nDoclist;
    int iOut;

    for(iOut=0; iOut<((int)(sizeof(pTS->aaOutput)/sizeof(pTS->aaOutput[0]))); iOut++){
      char *aNew;
      int nNew;
      if( pTS->aaOutput[iOut]==0 ){
        ((void) (0));
        pTS->aaOutput[iOut] = aMerge;
        pTS->anOutput[iOut] = nMerge;
        break;
      }

      nNew = nMerge + pTS->anOutput[iOut];
      aNew = sqlite3_malloc(nNew);
      if( !aNew ){
        if( aMerge!=aDoclist ){
          sqlite3_free(aMerge);
        }
        return 7;
      }
      fts3DoclistMerge(mergetype, 0, 0, aNew, &nNew,
          pTS->aaOutput[iOut], pTS->anOutput[iOut], aMerge, nMerge, 0
      );

      if( iOut>0 ) sqlite3_free(aMerge);
      sqlite3_free(pTS->aaOutput[iOut]);
      pTS->aaOutput[iOut] = 0;

      aMerge = aNew;
      nMerge = nNew;
      if( (iOut+1)==((int)(sizeof(pTS->aaOutput)/sizeof(pTS->aaOutput[0]))) ){
        pTS->aaOutput[iOut] = aMerge;
        pTS->anOutput[iOut] = nMerge;
      }
    }
  }
  return 0;
}

static int fts3DeferredTermSelect(
  Fts3DeferredToken *pToken,
  int isTermPos,
  int *pnOut,
  char **ppOut
){
  char *aSource;
  int nSource;

  aSource = sqlite3Fts3DeferredDoclist(pToken, &nSource);
  if( !aSource ){
    *pnOut = 0;
    *ppOut = 0;
  }else if( isTermPos ){
    *ppOut = sqlite3_malloc(nSource);
    if( !*ppOut ) return 7;
    memcpy(*ppOut, aSource, nSource);
    *pnOut = nSource;
  }else{
    sqlite3_int64 docid;
    *pnOut = sqlite3Fts3GetVarint(aSource, &docid);
    *ppOut = sqlite3_malloc(*pnOut);
    if( !*ppOut ) return 7;
    sqlite3Fts3PutVarint(*ppOut, docid);
  }

  return 0;
}

static int sqlite3Fts3SegReaderCursor(
  Fts3Table *p,
  int iLevel,
  const char *zTerm,
  int nTerm,
  int isPrefix,
  int isScan,
  Fts3SegReaderCursor *pCsr
){
  int rc = 0;
  int rc2;
  int iAge = 0;
  sqlite3_stmt *pStmt = 0;
  Fts3SegReader *pPending = 0;

  ((void) (0));



  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));


  memset(pCsr, 0, sizeof(Fts3SegReaderCursor));


  ((void) (0));
  if( iLevel<0 && isScan==0 ){
    rc = sqlite3Fts3SegReaderPending(p, zTerm, nTerm, isPrefix, &pPending);
    if( rc==0 && pPending ){
      int nByte = (sizeof(Fts3SegReader *) * 16);
      pCsr->apSegment = (Fts3SegReader **)sqlite3_malloc(nByte);
      if( pCsr->apSegment==0 ){
        rc = 7;
      }else{
        pCsr->apSegment[0] = pPending;
        pCsr->nSegment = 1;
        pPending = 0;
      }
    }
  }

  if( iLevel!=-1 ){
    if( rc==0 ){
      rc = sqlite3Fts3AllSegdirs(p, iLevel, &pStmt);
    }
    while( rc==0 && 100==(rc = sqlite3_step(pStmt)) ){


      sqlite3_int64 iStartBlock = sqlite3_column_int64(pStmt, 1);
      sqlite3_int64 iLeavesEndBlock = sqlite3_column_int64(pStmt, 2);
      sqlite3_int64 iEndBlock = sqlite3_column_int64(pStmt, 3);
      int nRoot = sqlite3_column_bytes(pStmt, 4);
      char const *zRoot = sqlite3_column_blob(pStmt, 4);


      if( (pCsr->nSegment%16)==0 ){
        Fts3SegReader **apNew;
        int nByte = (pCsr->nSegment + 16)*sizeof(Fts3SegReader*);
        apNew = (Fts3SegReader **)sqlite3_realloc(pCsr->apSegment, nByte);
        if( !apNew ){
          rc = 7;
          goto finished;
        }
        pCsr->apSegment = apNew;
      }



      if( iStartBlock && zTerm ){
        sqlite3_int64 *pi = (isPrefix ? &iLeavesEndBlock : 0);
        rc = fts3SelectLeaf(p, zTerm, nTerm, zRoot, nRoot, &iStartBlock, pi);
        if( rc!=0 ) goto finished;
        if( isPrefix==0 && isScan==0 ) iLeavesEndBlock = iStartBlock;
      }

      rc = sqlite3Fts3SegReaderNew(iAge, iStartBlock, iLeavesEndBlock,
          iEndBlock, zRoot, nRoot, &pCsr->apSegment[pCsr->nSegment]
      );
      if( rc!=0 ) goto finished;
      pCsr->nSegment++;
      iAge++;
    }
  }

 finished:
  rc2 = sqlite3_reset(pStmt);
  if( rc==101 ) rc = rc2;
  sqlite3Fts3SegReaderFree(pPending);

  return rc;
}


static int fts3TermSegReaderCursor(
  Fts3Cursor *pCsr,
  const char *zTerm,
  int nTerm,
  int isPrefix,
  Fts3SegReaderCursor **ppSegcsr
){
  Fts3SegReaderCursor *pSegcsr;
  int rc = 7;

  pSegcsr = sqlite3_malloc(sizeof(Fts3SegReaderCursor));
  if( pSegcsr ){
    Fts3Table *p = (Fts3Table *)pCsr->base.pVtab;
    int i;
    int nCost = 0;
    rc = sqlite3Fts3SegReaderCursor(
        p, -2, zTerm, nTerm, isPrefix, 0, pSegcsr);

    for(i=0; rc==0 && i<pSegcsr->nSegment; i++){
      rc = sqlite3Fts3SegReaderCost(pCsr, pSegcsr->apSegment[i], &nCost);
    }
    pSegcsr->nCost = nCost;
  }

  *ppSegcsr = pSegcsr;
  return rc;
}

static void fts3SegReaderCursorFree(Fts3SegReaderCursor *pSegcsr){
  sqlite3Fts3SegReaderFinish(pSegcsr);
  sqlite3_free(pSegcsr);
}
# 113019 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3TermSelect(
  Fts3Table *p,
  Fts3PhraseToken *pTok,
  int iColumn,
  int isReqPos,
  int *pnOut,
  char **ppOut
){
  int rc;
  Fts3SegReaderCursor *pSegcsr;
  TermSelect tsc;
  Fts3SegFilter filter;

  pSegcsr = pTok->pSegcsr;
  memset(&tsc, 0, sizeof(TermSelect));
  tsc.isReqPos = isReqPos;

  filter.flags = 0x00000002
        | (pTok->isPrefix ? 0x00000008 : 0)
        | (isReqPos ? 0x00000001 : 0)
        | (iColumn<p->nColumn ? 0x00000004 : 0);
  filter.iCol = iColumn;
  filter.zTerm = pTok->z;
  filter.nTerm = pTok->n;

  rc = sqlite3Fts3SegReaderStart(p, pSegcsr, &filter);
  while( 0==rc
      && 100==(rc = sqlite3Fts3SegReaderStep(p, pSegcsr))
  ){
    rc = fts3TermSelectCb(p, (void *)&tsc,
        pSegcsr->zTerm, pSegcsr->nTerm, pSegcsr->aDoclist, pSegcsr->nDoclist
    );
  }

  if( rc==0 ){
    rc = fts3TermSelectMerge(&tsc);
  }
  if( rc==0 ){
    *ppOut = tsc.aaOutput[0];
    *pnOut = tsc.anOutput[0];
  }else{
    int i;
    for(i=0; i<((int)(sizeof(tsc.aaOutput)/sizeof(tsc.aaOutput[0]))); i++){
      sqlite3_free(tsc.aaOutput[i]);
    }
  }

  fts3SegReaderCursorFree(pSegcsr);
  pTok->pSegcsr = 0;
  return rc;
}
# 113080 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3DoclistCountDocids(int isPoslist, char *aList, int nList){
  int nDoc = 0;
  if( aList ){
    char *aEnd = &aList[nList];
    char *p = aList;
    if( !isPoslist ){





      while( p<aEnd ) nDoc += (((*p++)&0x80)==0);
    }else{
      while( p<aEnd ){
        nDoc++;
        while( (*p++)&0x80 );
        fts3PoslistCopy(0, &p);
      }
    }
  }

  return nDoc;
}




static int fts3DeferExpression(Fts3Cursor *pCsr, Fts3Expr *pExpr){
  int rc = 0;
  if( pExpr ){
    rc = fts3DeferExpression(pCsr, pExpr->pLeft);
    if( rc==0 ){
      rc = fts3DeferExpression(pCsr, pExpr->pRight);
    }
    if( pExpr->eType==5 ){
      int iCol = pExpr->pPhrase->iColumn;
      int i;
      for(i=0; rc==0 && i<pExpr->pPhrase->nToken; i++){
        Fts3PhraseToken *pToken = &pExpr->pPhrase->aToken[i];
        if( pToken->pDeferred==0 ){
          rc = sqlite3Fts3DeferToken(pCsr, pToken, iCol);
        }
      }
    }
  }
  return rc;
}
# 113135 "ext/sqlite3/libsqlite/sqlite3.c"
static void fts3DoclistStripPositions(
  char *aList,
  int *pnList
){
  if( aList ){
    char *aEnd = &aList[*pnList];
    char *p = aList;
    char *pOut = aList;

    while( p<aEnd ){
      sqlite3_int64 delta;
      p += sqlite3Fts3GetVarint(p, &delta);
      fts3PoslistCopy(0, &p);
      pOut += sqlite3Fts3PutVarint(pOut, delta);
    }

    *pnList = (int)(pOut - aList);
  }
}
# 113164 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3PhraseSelect(
  Fts3Cursor *pCsr,
  Fts3Phrase *pPhrase,
  int isReqPos,
  char **paOut,
  int *pnOut
){
  char *pOut = 0;
  int nOut = 0;
  int rc = 0;
  int ii;
  int iCol = pPhrase->iColumn;
  int isTermPos = (pPhrase->nToken>1 || isReqPos);
  Fts3Table *p = (Fts3Table *)pCsr->base.pVtab;
  int isFirst = 1;

  int iPrevTok = 0;
  int nDoc = 0;






  for(ii=0; ii<pPhrase->nToken; ii++){
    Fts3PhraseToken *pTok = &pPhrase->aToken[ii];
    if( pTok->pSegcsr==0 ){
      if( (pCsr->eEvalmode==0)
       || (pCsr->eEvalmode==1 && pCsr->pDeferred==0)
       || (pCsr->eEvalmode==2 && pTok->bFulltext)
      ){
        rc = fts3TermSegReaderCursor(
            pCsr, pTok->z, pTok->n, pTok->isPrefix, &pTok->pSegcsr
        );
        if( rc!=0 ) return rc;
      }
    }
  }

  for(ii=0; ii<pPhrase->nToken; ii++){
    Fts3PhraseToken *pTok;
    int iTok = 0;
    char *pList = 0;
    int nList = 0;





    if( pCsr->eEvalmode==2 ){
      ((void) (0));
      iTok = ii;
      pTok = &pPhrase->aToken[iTok];
      if( pTok->bFulltext==0 ) continue;
    }else if( pCsr->eEvalmode==1 || isReqPos ){
      iTok = ii;
      pTok = &pPhrase->aToken[iTok];
    }else{
      int nMinCost = 0x7FFFFFFF;
      int jj;


      for(jj=0; jj<pPhrase->nToken; jj++){
        Fts3SegReaderCursor *pSegcsr = pPhrase->aToken[jj].pSegcsr;
        if( pSegcsr && pSegcsr->nCost<nMinCost ){
          iTok = jj;
          nMinCost = pSegcsr->nCost;
        }
      }
      pTok = &pPhrase->aToken[iTok];






      if( nMinCost>nDoc && ii>0 ){
        rc = fts3DeferExpression(pCsr, pCsr->pExpr);
        break;
      }
    }

    if( pCsr->eEvalmode==1 && pTok->pDeferred ){
      rc = fts3DeferredTermSelect(pTok->pDeferred, isTermPos, &nList, &pList);
    }else{
      if( pTok->pSegcsr ){
        rc = fts3TermSelect(p, pTok, iCol, isTermPos, &nList, &pList);
      }
      pTok->bFulltext = 1;
    }
    ((void) (0));
    if( rc!=0 ) break;

    if( isFirst ){
      pOut = pList;
      nOut = nList;
      if( pCsr->eEvalmode==0 && pPhrase->nToken>1 ){
        nDoc = fts3DoclistCountDocids(1, pOut, nOut);
      }
      isFirst = 0;
      iPrevTok = iTok;
    }else{

      char *aLeft, *aRight;
      int nLeft, nRight;
      int nDist;
      int mt;





      mt = 7;
      if( ii==pPhrase->nToken-1 && !isReqPos ) mt = 6;

      ((void) (0));
      if( iPrevTok<iTok ){
        aLeft = pOut;
        nLeft = nOut;
        aRight = pList;
        nRight = nList;
        nDist = iTok-iPrevTok;
        iPrevTok = iTok;
      }else{
        aRight = pOut;
        nRight = nOut;
        aLeft = pList;
        nLeft = nList;
        nDist = iPrevTok-iTok;
      }
      pOut = aRight;
      fts3DoclistMerge(
          mt, nDist, 0, pOut, &nOut, aLeft, nLeft, aRight, nRight, &nDoc
      );
      sqlite3_free(aLeft);
    }
    ((void) (0));
  }

  if( rc==0 ){
    if( ii!=pPhrase->nToken ){
      ((void) (0));
      fts3DoclistStripPositions(pOut, &nOut);
    }
    *paOut = pOut;
    *pnOut = nOut;
  }else{
    sqlite3_free(pOut);
  }
  return rc;
}
# 113324 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3NearMerge(
  int mergetype,
  int nNear,
  int nTokenLeft,
  char *aLeft,
  int nLeft,
  int nTokenRight,
  char *aRight,
  int nRight,
  char **paOut,
  int *pnOut
){
  char *aOut;
  int rc;

  ((void) (0));

  aOut = sqlite3_malloc(nLeft+nRight+1);
  if( aOut==0 ){
    rc = 7;
  }else{
    rc = fts3DoclistMerge(mergetype, nNear+nTokenRight, nNear+nTokenLeft,
      aOut, pnOut, aLeft, nLeft, aRight, nRight, 0
    );
    if( rc!=0 ){
      sqlite3_free(aOut);
      aOut = 0;
    }
  }

  *paOut = aOut;
  return rc;
}
# 113368 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Fts3ExprNearTrim(Fts3Expr *pLeft, Fts3Expr *pRight, int nNear){
  int rc;

  ((void) (0));
  ((void) (0));
  ((void) (0));

  if( pLeft->aDoclist==0 || pRight->aDoclist==0 ){
    sqlite3_free(pLeft->aDoclist);
    sqlite3_free(pRight->aDoclist);
    pRight->aDoclist = 0;
    pLeft->aDoclist = 0;
    rc = 0;
  }else{
    char *aOut;
    int nOut;

    rc = fts3NearMerge(9, nNear,
        pLeft->pPhrase->nToken, pLeft->aDoclist, pLeft->nDoclist,
        pRight->pPhrase->nToken, pRight->aDoclist, pRight->nDoclist,
        &aOut, &nOut
    );
    if( rc!=0 ) return rc;
    sqlite3_free(pRight->aDoclist);
    pRight->aDoclist = aOut;
    pRight->nDoclist = nOut;

    rc = fts3NearMerge(9, nNear,
        pRight->pPhrase->nToken, pRight->aDoclist, pRight->nDoclist,
        pLeft->pPhrase->nToken, pLeft->aDoclist, pLeft->nDoclist,
        &aOut, &nOut
    );
    sqlite3_free(pLeft->aDoclist);
    pLeft->aDoclist = aOut;
    pLeft->nDoclist = nOut;
  }
  return rc;
}







static int fts3ExprAllocateSegReaders(
  Fts3Cursor *pCsr,
  Fts3Expr *pExpr,
  int *pnExpr
){
  int rc = 0;

  ((void) (0));
  if( pnExpr && pExpr->eType!=3 ){
    (*pnExpr)++;
    pnExpr = 0;
  }

  if( pExpr->eType==5 ){
    Fts3Phrase *pPhrase = pExpr->pPhrase;
    int ii;

    for(ii=0; rc==0 && ii<pPhrase->nToken; ii++){
      Fts3PhraseToken *pTok = &pPhrase->aToken[ii];
      if( pTok->pSegcsr==0 ){
        rc = fts3TermSegReaderCursor(
            pCsr, pTok->z, pTok->n, pTok->isPrefix, &pTok->pSegcsr
        );
      }
    }
  }else{
    rc = fts3ExprAllocateSegReaders(pCsr, pExpr->pLeft, pnExpr);
    if( rc==0 ){
      rc = fts3ExprAllocateSegReaders(pCsr, pExpr->pRight, pnExpr);
    }
  }
  return rc;
}






static void fts3ExprFreeSegReaders(Fts3Expr *pExpr){
  if( pExpr ){
    Fts3Phrase *pPhrase = pExpr->pPhrase;
    if( pPhrase ){
      int kk;
      for(kk=0; kk<pPhrase->nToken; kk++){
        fts3SegReaderCursorFree(pPhrase->aToken[kk].pSegcsr);
        pPhrase->aToken[kk].pSegcsr = 0;
      }
    }
    fts3ExprFreeSegReaders(pExpr->pLeft);
    fts3ExprFreeSegReaders(pExpr->pRight);
  }
}






static int fts3ExprCost(Fts3Expr *pExpr){
  int nCost;
  if( pExpr->eType==5 ){
    Fts3Phrase *pPhrase = pExpr->pPhrase;
    int ii;
    nCost = 0;
    for(ii=0; ii<pPhrase->nToken; ii++){
      Fts3SegReaderCursor *pSegcsr = pPhrase->aToken[ii].pSegcsr;
      if( pSegcsr ) nCost += pSegcsr->nCost;
    }
  }else{
    nCost = fts3ExprCost(pExpr->pLeft) + fts3ExprCost(pExpr->pRight);
  }
  return nCost;
}







typedef struct ExprAndCost ExprAndCost;
struct ExprAndCost {
  Fts3Expr *pExpr;
  int nCost;
};
static void fts3ExprAssignCosts(
  Fts3Expr *pExpr,
  ExprAndCost **ppExprCost
){
  if( pExpr->eType==3 ){
    fts3ExprAssignCosts(pExpr->pLeft, ppExprCost);
    fts3ExprAssignCosts(pExpr->pRight, ppExprCost);
  }else{
    (*ppExprCost)->pExpr = pExpr;
    (*ppExprCost)->nCost = fts3ExprCost(pExpr);
    (*ppExprCost)++;
  }
}
# 113553 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3EvalExpr(
  Fts3Cursor *p,
  Fts3Expr *pExpr,
  char **paOut,
  int *pnOut,
  int isReqPos
){
  int rc = 0;


  *paOut = 0;
  *pnOut = 0;

  if( pExpr ){
    ((void) (0));



    ((void) (0));

    if( pExpr->eType==5 ){
      rc = fts3PhraseSelect(p, pExpr->pPhrase,
          isReqPos || (pExpr->pParent && pExpr->pParent->eType==1),
          paOut, pnOut
      );
      fts3ExprFreeSegReaders(pExpr);
    }else if( p->eEvalmode==0 && pExpr->eType==3 ){
      ExprAndCost *aExpr = 0;
      int nExpr = 0;
      char *aRet = 0;
      int nRet = 0;
      int nDoc = 0x7FFFFFFF;

      ((void) (0));

      rc = fts3ExprAllocateSegReaders(p, pExpr, &nExpr);
      if( rc==0 ){
        ((void) (0));
        aExpr = sqlite3_malloc(sizeof(ExprAndCost) * nExpr);
        if( !aExpr ) rc = 7;
      }
      if( rc==0 ){
        int ii;

        fts3ExprAssignCosts(pExpr, &aExpr);
        aExpr -= nExpr;
        for(ii=0; ii<nExpr; ii++){
          char *aNew;
          int nNew;
          int jj;
          ExprAndCost *pBest = 0;

          for(jj=0; jj<nExpr; jj++){
            ExprAndCost *pCand = &aExpr[jj];
            if( pCand->pExpr && (pBest==0 || pCand->nCost<pBest->nCost) ){
              pBest = pCand;
            }
          }

          if( pBest->nCost>nDoc ){
            rc = fts3DeferExpression(p, p->pExpr);
            break;
          }else{
            rc = fts3EvalExpr(p, pBest->pExpr, &aNew, &nNew, 0);
            if( rc!=0 ) break;
            pBest->pExpr = 0;
            if( ii==0 ){
              aRet = aNew;
              nRet = nNew;
              nDoc = fts3DoclistCountDocids(0, aRet, nRet);
            }else{
              fts3DoclistMerge(
                  3, 0, 0, aRet, &nRet, aRet, nRet, aNew, nNew, &nDoc
              );
              sqlite3_free(aNew);
            }
          }
        }
      }

      if( rc==0 ){
        *paOut = aRet;
        *pnOut = nRet;
      }else{
        ((void) (0));
        sqlite3_free(aRet);
      }
      sqlite3_free(aExpr);
      fts3ExprFreeSegReaders(pExpr);

    }else{
      char *aLeft;
      char *aRight;
      int nLeft;
      int nRight;

      ((void) (0));





      if( 0==(rc = fts3EvalExpr(p, pExpr->pRight, &aRight, &nRight, isReqPos))
       && 0==(rc = fts3EvalExpr(p, pExpr->pLeft, &aLeft, &nLeft, isReqPos))
      ){
        switch( pExpr->eType ){
          case 1: {
            Fts3Expr *pLeft;
            Fts3Expr *pRight;
            int mergetype = 8;
            if( pExpr->pParent && pExpr->pParent->eType==1 ){
              mergetype = 9;
            }
            pLeft = pExpr->pLeft;
            while( pLeft->eType==1 ){
              pLeft=pLeft->pRight;
            }
            pRight = pExpr->pRight;
            ((void) (0));
            ((void) (0));

            rc = fts3NearMerge(mergetype, pExpr->nNear,
                pLeft->pPhrase->nToken, aLeft, nLeft,
                pRight->pPhrase->nToken, aRight, nRight,
                paOut, pnOut
            );
            sqlite3_free(aLeft);
            break;
          }

          case 4: {





            char *aBuffer = sqlite3_malloc(nRight+nLeft+1);
            rc = fts3DoclistMerge(4, 0, 0, aBuffer, pnOut,
                aLeft, nLeft, aRight, nRight, 0
            );
            *paOut = aBuffer;
            sqlite3_free(aLeft);
            break;
          }

          default: {
            ((void) (0));
            fts3DoclistMerge(pExpr->eType, 0, 0, aLeft, pnOut,
                aLeft, nLeft, aRight, nRight, 0
            );
            *paOut = aLeft;
            break;
          }
        }
      }
      sqlite3_free(aRight);
    }
  }

  ((void) (0));
  return rc;
}
# 113733 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3EvalDeferred(
  Fts3Cursor *pCsr,
  int *pbRes
){
  int rc = 0;
  if( pCsr->pDeferred==0 ){
    *pbRes = 1;
  }else{
    rc = fts3CursorSeek(0, pCsr);
    if( rc==0 ){
      sqlite3Fts3FreeDeferredDoclists(pCsr);
      rc = sqlite3Fts3CacheDeferredDoclists(pCsr);
    }
    if( rc==0 ){
      char *a = 0;
      int n = 0;
      rc = fts3EvalExpr(pCsr, pCsr->pExpr, &a, &n, 0);
      ((void) (0));
      *pbRes = (n>0);
      sqlite3_free(a);
    }
  }
  return rc;
}
# 113769 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3NextMethod(sqlite3_vtab_cursor *pCursor){
  int res;
  int rc = 0;
  Fts3Cursor *pCsr = (Fts3Cursor *)pCursor;

  pCsr->eEvalmode = 1;
  do {
    if( pCsr->aDoclist==0 ){
      if( 100!=sqlite3_step(pCsr->pStmt) ){
        pCsr->isEof = 1;
        rc = sqlite3_reset(pCsr->pStmt);
        break;
      }
      pCsr->iPrevId = sqlite3_column_int64(pCsr->pStmt, 0);
    }else{
      if( pCsr->pNextId>=&pCsr->aDoclist[pCsr->nDoclist] ){
        pCsr->isEof = 1;
        break;
      }
      sqlite3_reset(pCsr->pStmt);
      fts3GetDeltaVarint(&pCsr->pNextId, &pCsr->iPrevId);
      pCsr->isRequireSeek = 1;
      pCsr->isMatchinfoNeeded = 1;
    }
  }while( 0==(rc = fts3EvalDeferred(pCsr, &res)) && res==0 );

  return rc;
}
# 113814 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3FilterMethod(
  sqlite3_vtab_cursor *pCursor,
  int idxNum,
  const char *idxStr,
  int nVal,
  sqlite3_value **apVal
){
  const char *azSql[] = {
    "SELECT %s FROM %Q.'%q_content' AS x WHERE docid = ?",
    "SELECT %s FROM %Q.'%q_content' AS x ",
  };
  int rc;
  char *zSql;
  Fts3Table *p = (Fts3Table *)pCursor->pVtab;
  Fts3Cursor *pCsr = (Fts3Cursor *)pCursor;

  (void)(idxStr);
  (void)(nVal);

  ((void) (0));
  ((void) (0));
  ((void) (0));
  ((void) (0));


  sqlite3_finalize(pCsr->pStmt);
  sqlite3_free(pCsr->aDoclist);
  sqlite3Fts3ExprFree(pCsr->pExpr);
  memset(&pCursor[1], 0, sizeof(Fts3Cursor)-sizeof(sqlite3_vtab_cursor));

  if( idxNum!=1 && idxNum!=0 ){
    int iCol = idxNum-2;
    const char *zQuery = (const char *)sqlite3_value_text(apVal[0]);

    if( zQuery==0 && sqlite3_value_type(apVal[0])!=5 ){
      return 7;
    }

    rc = sqlite3Fts3ExprParse(p->pTokenizer, p->azColumn, p->nColumn,
        iCol, zQuery, -1, &pCsr->pExpr
    );
    if( rc!=0 ){
      if( rc==1 ){
        p->base.zErrMsg = sqlite3_mprintf("malformed MATCH expression: [%s]",
                                          zQuery);
      }
      return rc;
    }

    rc = sqlite3Fts3ReadLock(p);
    if( rc!=0 ) return rc;

    rc = fts3EvalExpr(pCsr, pCsr->pExpr, &pCsr->aDoclist, &pCsr->nDoclist, 0);
    sqlite3Fts3SegmentsClose(p);
    if( rc!=0 ) return rc;
    pCsr->pNextId = pCsr->aDoclist;
    pCsr->iPrevId = 0;
  }






  zSql = (char *)azSql[idxNum==0];
  zSql = sqlite3_mprintf(zSql, p->zReadExprlist, p->zDb, p->zName);
  if( !zSql ){
    rc = 7;
  }else{
    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pCsr->pStmt, 0);
    sqlite3_free(zSql);
  }
  if( rc==0 && idxNum==1 ){
    rc = sqlite3_bind_value(pCsr->pStmt, 1, apVal[0]);
  }
  pCsr->eSearch = (i16)idxNum;

  if( rc!=0 ) return rc;
  return fts3NextMethod(pCursor);
}





static int fts3EofMethod(sqlite3_vtab_cursor *pCursor){
  return ((Fts3Cursor *)pCursor)->isEof;
}







static int fts3RowidMethod(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){
  Fts3Cursor *pCsr = (Fts3Cursor *) pCursor;
  if( pCsr->aDoclist ){
    *pRowid = pCsr->iPrevId;
  }else{




    ((void) (0));
    *pRowid = sqlite3_column_int64(pCsr->pStmt, 0);
  }
  return 0;
}





static int fts3ColumnMethod(
  sqlite3_vtab_cursor *pCursor,
  sqlite3_context *pContext,
  int iCol
){
  int rc;
  Fts3Cursor *pCsr = (Fts3Cursor *) pCursor;
  Fts3Table *p = (Fts3Table *)pCursor->pVtab;


  ((void) (0));

  if( iCol==p->nColumn+1 ){



    sqlite3_int64 iRowid;
    rc = fts3RowidMethod(pCursor, &iRowid);
    sqlite3_result_int64(pContext, iRowid);
  }else if( iCol==p->nColumn ){



    sqlite3_result_blob(pContext, &pCsr, sizeof(pCsr), ((sqlite3_destructor_type)-1));
    rc = 0;
  }else{
    rc = fts3CursorSeek(0, pCsr);
    if( rc==0 ){
      sqlite3_result_value(pContext, sqlite3_column_value(pCsr->pStmt, iCol+1));
    }
  }
  return rc;
}






static int fts3UpdateMethod(
  sqlite3_vtab *pVtab,
  int nArg,
  sqlite3_value **apVal,
  sqlite_int64 *pRowid
){
  return sqlite3Fts3UpdateMethod(pVtab, nArg, apVal, pRowid);
}





static int fts3SyncMethod(sqlite3_vtab *pVtab){
  int rc = sqlite3Fts3PendingTermsFlush((Fts3Table *)pVtab);
  sqlite3Fts3SegmentsClose((Fts3Table *)pVtab);
  return rc;
}




static int fts3BeginMethod(sqlite3_vtab *pVtab){
  (void)(pVtab);
  ((void) (0));
  return 0;
}






static int fts3CommitMethod(sqlite3_vtab *pVtab){
  (void)(pVtab);
  ((void) (0));
  return 0;
}





static int fts3RollbackMethod(sqlite3_vtab *pVtab){
  sqlite3Fts3PendingTermsClear((Fts3Table *)pVtab);
  return 0;
}







static int sqlite3Fts3ExprLoadDoclist(Fts3Cursor *pCsr, Fts3Expr *pExpr){
  int rc;
  ((void) (0));
  ((void) (0));
  rc = fts3EvalExpr(pCsr, pExpr, &pExpr->aDoclist, &pExpr->nDoclist, 1);
  return rc;
}

static int sqlite3Fts3ExprLoadFtDoclist(
  Fts3Cursor *pCsr,
  Fts3Expr *pExpr,
  char **paDoclist,
  int *pnDoclist
){
  int rc;
  ((void) (0));
  ((void) (0));
  pCsr->eEvalmode = 2;
  rc = fts3EvalExpr(pCsr, pExpr, paDoclist, pnDoclist, 1);
  pCsr->eEvalmode = 1;
  return rc;
}






static char *sqlite3Fts3FindPositions(
  Fts3Expr *pExpr,
  sqlite3_int64 iDocid,
  int iCol
){
  ((void) (0));
  if( pExpr->aDoclist ){
    char *pEnd = &pExpr->aDoclist[pExpr->nDoclist];
    char *pCsr;

    if( pExpr->pCurrent==0 ){
      pExpr->pCurrent = pExpr->aDoclist;
      pExpr->iCurrent = 0;
      pExpr->pCurrent += sqlite3Fts3GetVarint(pExpr->pCurrent,&pExpr->iCurrent);
    }
    pCsr = pExpr->pCurrent;
    ((void) (0));

    while( pCsr<pEnd ){
      if( pExpr->iCurrent<iDocid ){
        fts3PoslistCopy(0, &pCsr);
        if( pCsr<pEnd ){
          fts3GetDeltaVarint(&pCsr, &pExpr->iCurrent);
        }
        pExpr->pCurrent = pCsr;
      }else{
        if( pExpr->iCurrent==iDocid ){
          int iThis = 0;
          if( iCol<0 ){




            return pCsr;
          }
          while( iThis<iCol ){
            fts3ColumnlistCopy(0, &pCsr);
            if( *pCsr==0x00 ) return 0;
            pCsr++;
            pCsr += sqlite3Fts3GetVarint32(pCsr, &iThis);
          }
          if( iCol==iThis && (*pCsr&0xFE) ) return pCsr;
        }
        return 0;
      }
    }
  }

  return 0;
}
# 114110 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3FunctionArg(
  sqlite3_context *pContext,
  const char *zFunc,
  sqlite3_value *pVal,
  Fts3Cursor **ppCsr
){
  Fts3Cursor *pRet;
  if( sqlite3_value_type(pVal)!=4
   || sqlite3_value_bytes(pVal)!=sizeof(Fts3Cursor *)
  ){
    char *zErr = sqlite3_mprintf("illegal first argument to %s", zFunc);
    sqlite3_result_error(pContext, zErr, -1);
    sqlite3_free(zErr);
    return 1;
  }
  memcpy(&pRet, sqlite3_value_blob(pVal), sizeof(Fts3Cursor *));
  *ppCsr = pRet;
  return 0;
}




static void fts3SnippetFunc(
  sqlite3_context *pContext,
  int nVal,
  sqlite3_value **apVal
){
  Fts3Cursor *pCsr;
  const char *zStart = "<b>";
  const char *zEnd = "</b>";
  const char *zEllipsis = "<b>...</b>";
  int iCol = -1;
  int nToken = 15;




  ((void) (0));

  if( nVal>6 ){
    sqlite3_result_error(pContext,
        "wrong number of arguments to function snippet()", -1);
    return;
  }
  if( fts3FunctionArg(pContext, "snippet", apVal[0], &pCsr) ) return;

  switch( nVal ){
    case 6: nToken = sqlite3_value_int(apVal[5]);
    case 5: iCol = sqlite3_value_int(apVal[4]);
    case 4: zEllipsis = (const char*)sqlite3_value_text(apVal[3]);
    case 3: zEnd = (const char*)sqlite3_value_text(apVal[2]);
    case 2: zStart = (const char*)sqlite3_value_text(apVal[1]);
  }
  if( !zEllipsis || !zEnd || !zStart ){
    sqlite3_result_error_nomem(pContext);
  }else if( 0==fts3CursorSeek(pContext, pCsr) ){
    sqlite3Fts3Snippet(pContext, pCsr, zStart, zEnd, zEllipsis, iCol, nToken);
  }
}




static void fts3OffsetsFunc(
  sqlite3_context *pContext,
  int nVal,
  sqlite3_value **apVal
){
  Fts3Cursor *pCsr;

  (void)(nVal);

  ((void) (0));
  if( fts3FunctionArg(pContext, "offsets", apVal[0], &pCsr) ) return;
  ((void) (0));
  if( 0==fts3CursorSeek(pContext, pCsr) ){
    sqlite3Fts3Offsets(pContext, pCsr);
  }
}
# 114200 "ext/sqlite3/libsqlite/sqlite3.c"
static void fts3OptimizeFunc(
  sqlite3_context *pContext,
  int nVal,
  sqlite3_value **apVal
){
  int rc;
  Fts3Table *p;
  Fts3Cursor *pCursor;

  (void)(nVal);

  ((void) (0));
  if( fts3FunctionArg(pContext, "optimize", apVal[0], &pCursor) ) return;
  p = (Fts3Table *)pCursor->base.pVtab;
  ((void) (0));

  rc = sqlite3Fts3Optimize(p);

  switch( rc ){
    case 0:
      sqlite3_result_text(pContext, "Index optimized", -1, ((sqlite3_destructor_type)0));
      break;
    case 101:
      sqlite3_result_text(pContext, "Index already optimal", -1, ((sqlite3_destructor_type)0));
      break;
    default:
      sqlite3_result_error_code(pContext, rc);
      break;
  }
}




static void fts3MatchinfoFunc(
  sqlite3_context *pContext,
  int nVal,
  sqlite3_value **apVal
){
  Fts3Cursor *pCsr;
  ((void) (0));
  if( 0==fts3FunctionArg(pContext, "matchinfo", apVal[0], &pCsr) ){
    const char *zArg = 0;
    if( nVal>1 ){
      zArg = (const char *)sqlite3_value_text(apVal[1]);
    }
    sqlite3Fts3Matchinfo(pContext, pCsr, zArg);
  }
}





static int fts3FindFunctionMethod(
  sqlite3_vtab *pVtab,
  int nArg,
  const char *zName,
  void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),
  void **ppArg
){
  struct Overloaded {
    const char *zName;
    void (*xFunc)(sqlite3_context*,int,sqlite3_value**);
  } aOverload[] = {
    { "snippet", fts3SnippetFunc },
    { "offsets", fts3OffsetsFunc },
    { "optimize", fts3OptimizeFunc },
    { "matchinfo", fts3MatchinfoFunc },
  };
  int i;

  (void)(pVtab);
  (void)(nArg);
  (void)(ppArg);

  for(i=0; i<((int)(sizeof(aOverload)/sizeof(aOverload[0]))); i++){
    if( __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (zName) && __builtin_constant_p (aOverload[i].zName) && (__s1_len = __builtin_strlen (zName), __s2_len = __builtin_strlen (aOverload[i].zName), (!((size_t)(const void *)((zName) + 1) - (size_t)(const void *)(zName) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((aOverload[i].zName) + 1) - (size_t)(const void *)(aOverload[i].zName) == 1) || __s2_len >= 4)) ? __builtin_strcmp (zName, aOverload[i].zName) : (__builtin_constant_p (zName) && ((size_t)(const void *)((zName) + 1) - (size_t)(const void *)(zName) == 1) && (__s1_len = __builtin_strlen (zName), __s1_len < 4) ? (__builtin_constant_p (aOverload[i].zName) && ((size_t)(const void *)((aOverload[i].zName) + 1) - (size_t)(const void *)(aOverload[i].zName) == 1) ? __builtin_strcmp (zName, aOverload[i].zName) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (aOverload[i].zName); int __result = (((const unsigned char *) (const char *) (zName))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (zName))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (zName))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (zName))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (aOverload[i].zName) && ((size_t)(const void *)((aOverload[i].zName) + 1) - (size_t)(const void *)(aOverload[i].zName) == 1) && (__s2_len = __builtin_strlen (aOverload[i].zName), __s2_len < 4) ? (__builtin_constant_p (zName) && ((size_t)(const void *)((zName) + 1) - (size_t)(const void *)(zName) == 1) ? __builtin_strcmp (zName, aOverload[i].zName) : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (zName); int __result = (((const unsigned char *) (const char *) (aOverload[i].zName))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (aOverload[i].zName))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (aOverload[i].zName))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (aOverload[i].zName))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (zName, aOverload[i].zName)))); })==0 ){
      *pxFunc = aOverload[i].xFunc;
      return 1;
    }
  }


  return 0;
}




static int fts3RenameMethod(
  sqlite3_vtab *pVtab,
  const char *zName
){
  Fts3Table *p = (Fts3Table *)pVtab;
  sqlite3 *db = p->db;
  int rc;

  rc = sqlite3Fts3PendingTermsFlush(p);
  if( rc!=0 ){
    return rc;
  }

  fts3DbExec(&rc, db,
    "ALTER TABLE %Q.'%q_content'  RENAME TO '%q_content';",
    p->zDb, p->zName, zName
  );
  if( p->bHasDocsize ){
    fts3DbExec(&rc, db,
      "ALTER TABLE %Q.'%q_docsize'  RENAME TO '%q_docsize';",
      p->zDb, p->zName, zName
    );
  }
  if( p->bHasStat ){
    fts3DbExec(&rc, db,
      "ALTER TABLE %Q.'%q_stat'  RENAME TO '%q_stat';",
      p->zDb, p->zName, zName
    );
  }
  fts3DbExec(&rc, db,
    "ALTER TABLE %Q.'%q_segments' RENAME TO '%q_segments';",
    p->zDb, p->zName, zName
  );
  fts3DbExec(&rc, db,
    "ALTER TABLE %Q.'%q_segdir'   RENAME TO '%q_segdir';",
    p->zDb, p->zName, zName
  );
  return rc;
}

static const sqlite3_module fts3Module = {
                      0,
                      fts3CreateMethod,
                      fts3ConnectMethod,
                      fts3BestIndexMethod,
                      fts3DisconnectMethod,
                      fts3DestroyMethod,
                      fts3OpenMethod,
                      fts3CloseMethod,
                      fts3FilterMethod,
                      fts3NextMethod,
                      fts3EofMethod,
                      fts3ColumnMethod,
                      fts3RowidMethod,
                      fts3UpdateMethod,
                      fts3BeginMethod,
                      fts3SyncMethod,
                      fts3CommitMethod,
                      fts3RollbackMethod,
                      fts3FindFunctionMethod,
                      fts3RenameMethod,
};






static void hashDestroy(void *p){
  Fts3Hash *pHash = (Fts3Hash *)p;
  sqlite3Fts3HashClear(pHash);
  sqlite3_free(pHash);
}
# 114374 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3Fts3SimpleTokenizerModule(sqlite3_tokenizer_module const**ppModule);
static void sqlite3Fts3PorterTokenizerModule(sqlite3_tokenizer_module const**ppModule);
# 114386 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Fts3Init(sqlite3 *db){
  int rc = 0;
  Fts3Hash *pHash = 0;
  const sqlite3_tokenizer_module *pSimple = 0;
  const sqlite3_tokenizer_module *pPorter = 0;






  rc = sqlite3Fts3InitAux(db);
  if( rc!=0 ) return rc;

  sqlite3Fts3SimpleTokenizerModule(&pSimple);
  sqlite3Fts3PorterTokenizerModule(&pPorter);


  pHash = sqlite3_malloc(sizeof(Fts3Hash));
  if( !pHash ){
    rc = 7;
  }else{
    sqlite3Fts3HashInit(pHash, 1, 1);
  }


  if( rc==0 ){
    if( sqlite3Fts3HashInsert(pHash, "simple", 7, (void *)pSimple)
     || sqlite3Fts3HashInsert(pHash, "porter", 7, (void *)pPorter)



    ){
      rc = 7;
    }
  }
# 114433 "ext/sqlite3/libsqlite/sqlite3.c"
  if( 0==rc
   && 0==(rc = sqlite3Fts3InitHashTable(db, pHash, "fts3_tokenizer"))
   && 0==(rc = sqlite3_overload_function(db, "snippet", -1))
   && 0==(rc = sqlite3_overload_function(db, "offsets", 1))
   && 0==(rc = sqlite3_overload_function(db, "matchinfo", 1))
   && 0==(rc = sqlite3_overload_function(db, "matchinfo", 2))
   && 0==(rc = sqlite3_overload_function(db, "optimize", 1))
  ){
    rc = sqlite3_create_module_v2(
        db, "fts3", &fts3Module, (void *)pHash, hashDestroy
    );
    if( rc==0 ){
      rc = sqlite3_create_module_v2(
          db, "fts4", &fts3Module, (void *)pHash, 0
      );
    }
    return rc;
  }


  ((void) (0));
  if( pHash ){
    sqlite3Fts3HashClear(pHash);
    sqlite3_free(pHash);
  }
  return rc;
}
# 114493 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct Fts3auxTable Fts3auxTable;
typedef struct Fts3auxCursor Fts3auxCursor;

struct Fts3auxTable {
  sqlite3_vtab base;
  Fts3Table *pFts3Tab;
};

struct Fts3auxCursor {
  sqlite3_vtab_cursor base;
  Fts3SegReaderCursor csr;
  Fts3SegFilter filter;
  char *zStop;
  int nStop;
  int isEof;
  sqlite3_int64 iRowid;

  int iCol;
  int nStat;
  struct Fts3auxColstats {
    sqlite3_int64 nDoc;
    sqlite3_int64 nOcc;
  } *aStat;
};
# 114528 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3auxConnectMethod(
  sqlite3 *db,
  void *pUnused,
  int argc,
  const char * const *argv,
  sqlite3_vtab **ppVtab,
  char **pzErr
){
  char const *zDb;
  char const *zFts3;
  int nDb;
  int nFts3;
  int nByte;
  int rc;
  Fts3auxTable *p;

  (void)(pUnused);


  if( argc!=4 ){
    *pzErr = sqlite3_mprintf(
        "wrong number of arguments to fts4aux constructor"
    );
    return 1;
  }

  zDb = argv[1];
  nDb = strlen(zDb);
  zFts3 = argv[3];
  nFts3 = strlen(zFts3);

  rc = sqlite3_declare_vtab(db, "CREATE TABLE x(term, col, documents, occurrences)");
  if( rc!=0 ) return rc;

  nByte = sizeof(Fts3auxTable) + sizeof(Fts3Table) + nDb + nFts3 + 2;
  p = (Fts3auxTable *)sqlite3_malloc(nByte);
  if( !p ) return 7;
  memset(p, 0, nByte);

  p->pFts3Tab = (Fts3Table *)&p[1];
  p->pFts3Tab->zDb = (char *)&p->pFts3Tab[1];
  p->pFts3Tab->zName = &p->pFts3Tab->zDb[nDb+1];
  p->pFts3Tab->db = db;

  memcpy((char *)p->pFts3Tab->zDb, zDb, nDb);
  memcpy((char *)p->pFts3Tab->zName, zFts3, nFts3);
  sqlite3Fts3Dequote((char *)p->pFts3Tab->zName);

  *ppVtab = (sqlite3_vtab *)p;
  return 0;
}






static int fts3auxDisconnectMethod(sqlite3_vtab *pVtab){
  Fts3auxTable *p = (Fts3auxTable *)pVtab;
  Fts3Table *pFts3 = p->pFts3Tab;
  int i;


  for(i=0; i<((int)(sizeof(pFts3->aStmt)/sizeof(pFts3->aStmt[0]))); i++){
    sqlite3_finalize(pFts3->aStmt[i]);
  }
  sqlite3_free(pFts3->zSegmentsTbl);
  sqlite3_free(p);
  return 0;
}
# 114606 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3auxBestIndexMethod(
  sqlite3_vtab *pVTab,
  sqlite3_index_info *pInfo
){
  int i;
  int iEq = -1;
  int iGe = -1;
  int iLe = -1;

  (void)(pVTab);


  if( pInfo->nOrderBy==1
   && pInfo->aOrderBy[0].iColumn==0
   && pInfo->aOrderBy[0].desc==0
  ){
    pInfo->orderByConsumed = 1;
  }


  for(i=0; i<pInfo->nConstraint; i++){
    if( pInfo->aConstraint[i].usable && pInfo->aConstraint[i].iColumn==0 ){
      int op = pInfo->aConstraint[i].op;
      if( op==2 ) iEq = i;
      if( op==16 ) iLe = i;
      if( op==8 ) iLe = i;
      if( op==4 ) iGe = i;
      if( op==32 ) iGe = i;
    }
  }

  if( iEq>=0 ){
    pInfo->idxNum = 1;
    pInfo->aConstraintUsage[iEq].argvIndex = 1;
    pInfo->estimatedCost = 5;
  }else{
    pInfo->idxNum = 0;
    pInfo->estimatedCost = 20000;
    if( iGe>=0 ){
      pInfo->idxNum += 2;
      pInfo->aConstraintUsage[iGe].argvIndex = 1;
      pInfo->estimatedCost /= 2;
    }
    if( iLe>=0 ){
      pInfo->idxNum += 4;
      pInfo->aConstraintUsage[iLe].argvIndex = 1 + (iGe>=0);
      pInfo->estimatedCost /= 2;
    }
  }

  return 0;
}




static int fts3auxOpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr){
  Fts3auxCursor *pCsr;

  (void)(pVTab);

  pCsr = (Fts3auxCursor *)sqlite3_malloc(sizeof(Fts3auxCursor));
  if( !pCsr ) return 7;
  memset(pCsr, 0, sizeof(Fts3auxCursor));

  *ppCsr = (sqlite3_vtab_cursor *)pCsr;
  return 0;
}




static int fts3auxCloseMethod(sqlite3_vtab_cursor *pCursor){
  Fts3Table *pFts3 = ((Fts3auxTable *)pCursor->pVtab)->pFts3Tab;
  Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;

  sqlite3Fts3SegmentsClose(pFts3);
  sqlite3Fts3SegReaderFinish(&pCsr->csr);
  sqlite3_free((void *)pCsr->filter.zTerm);
  sqlite3_free(pCsr->zStop);
  sqlite3_free(pCsr->aStat);
  sqlite3_free(pCsr);
  return 0;
}

static int fts3auxGrowStatArray(Fts3auxCursor *pCsr, int nSize){
  if( nSize>pCsr->nStat ){
    struct Fts3auxColstats *aNew;
    aNew = (struct Fts3auxColstats *)sqlite3_realloc(pCsr->aStat,
        sizeof(struct Fts3auxColstats) * nSize
    );
    if( aNew==0 ) return 7;
    memset(&aNew[pCsr->nStat], 0,
        sizeof(struct Fts3auxColstats) * (nSize - pCsr->nStat)
    );
    pCsr->aStat = aNew;
    pCsr->nStat = nSize;
  }
  return 0;
}




static int fts3auxNextMethod(sqlite3_vtab_cursor *pCursor){
  Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;
  Fts3Table *pFts3 = ((Fts3auxTable *)pCursor->pVtab)->pFts3Tab;
  int rc;


  pCsr->iRowid++;

  for(pCsr->iCol++; pCsr->iCol<pCsr->nStat; pCsr->iCol++){
    if( pCsr->aStat[pCsr->iCol].nDoc>0 ) return 0;
  }

  rc = sqlite3Fts3SegReaderStep(pFts3, &pCsr->csr);
  if( rc==100 ){
    int i = 0;
    int nDoclist = pCsr->csr.nDoclist;
    char *aDoclist = pCsr->csr.aDoclist;
    int iCol;

    int eState = 0;

    if( pCsr->zStop ){
      int n = (pCsr->nStop<pCsr->csr.nTerm) ? pCsr->nStop : pCsr->csr.nTerm;
      int mc = memcmp(pCsr->zStop, pCsr->csr.zTerm, n);
      if( mc<0 || (mc==0 && pCsr->csr.nTerm>pCsr->nStop) ){
        pCsr->isEof = 1;
        return 0;
      }
    }

    if( fts3auxGrowStatArray(pCsr, 2) ) return 7;
    memset(pCsr->aStat, 0, sizeof(struct Fts3auxColstats) * pCsr->nStat);
    iCol = 0;

    while( i<nDoclist ){
      sqlite3_int64 v = 0;

      i += sqlite3Fts3GetVarint(&aDoclist[i], &v);
      switch( eState ){

        case 0:
          pCsr->aStat[0].nDoc++;
          eState = 1;
          iCol = 0;
          break;
# 114764 "ext/sqlite3/libsqlite/sqlite3.c"
        case 1:
          ((void) (0));
          if( v>1 ){
            pCsr->aStat[1].nDoc++;
          }
          eState = 2;


        case 2:
          if( v==0 ){
            eState = 0;
          }else if( v==1 ){
            eState = 3;
          }else{
            pCsr->aStat[iCol+1].nOcc++;
            pCsr->aStat[0].nOcc++;
          }
          break;


        default: ((void) (0));
          iCol = (int)v;
          if( fts3auxGrowStatArray(pCsr, iCol+2) ) return 7;
          pCsr->aStat[iCol+1].nDoc++;
          eState = 2;
          break;
      }
    }

    pCsr->iCol = 0;
    rc = 0;
  }else{
    pCsr->isEof = 1;
  }
  return rc;
}




static int fts3auxFilterMethod(
  sqlite3_vtab_cursor *pCursor,
  int idxNum,
  const char *idxStr,
  int nVal,
  sqlite3_value **apVal
){
  Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;
  Fts3Table *pFts3 = ((Fts3auxTable *)pCursor->pVtab)->pFts3Tab;
  int rc;
  int isScan;

  (void)(nVal);

  ((void) (0));
  ((void) (0));



  isScan = (idxNum!=1);


                              ;
  sqlite3Fts3SegReaderFinish(&pCsr->csr);
  sqlite3_free((void *)pCsr->filter.zTerm);
  sqlite3_free(pCsr->aStat);
  memset(&pCsr->csr, 0, ((u8*)&pCsr[1]) - (u8*)&pCsr->csr);

  pCsr->filter.flags = 0x00000001|0x00000002;
  if( isScan ) pCsr->filter.flags |= 0x00000010;

  if( idxNum&(1|2) ){
    const unsigned char *zStr = sqlite3_value_text(apVal[0]);
    if( zStr ){
      pCsr->filter.zTerm = sqlite3_mprintf("%s", zStr);
      pCsr->filter.nTerm = sqlite3_value_bytes(apVal[0]);
      if( pCsr->filter.zTerm==0 ) return 7;
    }
  }
  if( idxNum&4 ){
    int iIdx = (idxNum&2) ? 1 : 0;
    pCsr->zStop = sqlite3_mprintf("%s", sqlite3_value_text(apVal[iIdx]));
    pCsr->nStop = sqlite3_value_bytes(apVal[iIdx]);
    if( pCsr->zStop==0 ) return 7;
  }

  rc = sqlite3Fts3SegReaderCursor(pFts3, -2,
      pCsr->filter.zTerm, pCsr->filter.nTerm, 0, isScan, &pCsr->csr
  );
  if( rc==0 ){
    rc = sqlite3Fts3SegReaderStart(pFts3, &pCsr->csr, &pCsr->filter);
  }

  if( rc==0 ) rc = fts3auxNextMethod(pCursor);
  return rc;
}




static int fts3auxEofMethod(sqlite3_vtab_cursor *pCursor){
  Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;
  return pCsr->isEof;
}




static int fts3auxColumnMethod(
  sqlite3_vtab_cursor *pCursor,
  sqlite3_context *pContext,
  int iCol
){
  Fts3auxCursor *p = (Fts3auxCursor *)pCursor;

  ((void) (0));
  if( iCol==0 ){
    sqlite3_result_text(pContext, p->csr.zTerm, p->csr.nTerm, ((sqlite3_destructor_type)-1));
  }else if( iCol==1 ){
    if( p->iCol ){
      sqlite3_result_int(pContext, p->iCol-1);
    }else{
      sqlite3_result_text(pContext, "*", -1, ((sqlite3_destructor_type)0));
    }
  }else if( iCol==2 ){
    sqlite3_result_int64(pContext, p->aStat[p->iCol].nDoc);
  }else{
    sqlite3_result_int64(pContext, p->aStat[p->iCol].nOcc);
  }

  return 0;
}




static int fts3auxRowidMethod(
  sqlite3_vtab_cursor *pCursor,
  sqlite_int64 *pRowid
){
  Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;
  *pRowid = pCsr->iRowid;
  return 0;
}





static int sqlite3Fts3InitAux(sqlite3 *db){
  static const sqlite3_module fts3aux_module = {
     0,
     fts3auxConnectMethod,
     fts3auxConnectMethod,
     fts3auxBestIndexMethod,
     fts3auxDisconnectMethod,
     fts3auxDisconnectMethod,
     fts3auxOpenMethod,
     fts3auxCloseMethod,
     fts3auxFilterMethod,
     fts3auxNextMethod,
     fts3auxEofMethod,
     fts3auxColumnMethod,
     fts3auxRowidMethod,
     0,
     0,
     0,
     0,
     0,
     0,
     0
  };
  int rc;

  rc = sqlite3_create_module(db, "fts4aux", &fts3aux_module, 0);
  return rc;
}
# 115026 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct ParseContext ParseContext;
struct ParseContext {
  sqlite3_tokenizer *pTokenizer;
  const char **azCol;
  int nCol;
  int iDefaultCol;
  sqlite3_context *pCtx;
  int nNest;
};
# 115047 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3isspace(char c){
  return c==' ' || c=='\t' || c=='\n' || c=='\r' || c=='\v' || c=='\f';
}






static void *fts3MallocZero(int nByte){
  void *pRet = sqlite3_malloc(nByte);
  if( pRet ) memset(pRet, 0, nByte);
  return pRet;
}
# 115075 "ext/sqlite3/libsqlite/sqlite3.c"
static int getNextToken(
  ParseContext *pParse,
  int iCol,
  const char *z, int n,
  Fts3Expr **ppExpr,
  int *pnConsumed
){
  sqlite3_tokenizer *pTokenizer = pParse->pTokenizer;
  sqlite3_tokenizer_module const *pModule = pTokenizer->pModule;
  int rc;
  sqlite3_tokenizer_cursor *pCursor;
  Fts3Expr *pRet = 0;
  int nConsumed = 0;

  rc = pModule->xOpen(pTokenizer, z, n, &pCursor);
  if( rc==0 ){
    const char *zToken;
    int nToken, iStart, iEnd, iPosition;
    int nByte;

    pCursor->pTokenizer = pTokenizer;
    rc = pModule->xNext(pCursor, &zToken, &nToken, &iStart, &iEnd, &iPosition);

    if( rc==0 ){
      nByte = sizeof(Fts3Expr) + sizeof(Fts3Phrase) + nToken;
      pRet = (Fts3Expr *)fts3MallocZero(nByte);
      if( !pRet ){
        rc = 7;
      }else{
        pRet->eType = 5;
        pRet->pPhrase = (Fts3Phrase *)&pRet[1];
        pRet->pPhrase->nToken = 1;
        pRet->pPhrase->iColumn = iCol;
        pRet->pPhrase->aToken[0].n = nToken;
        pRet->pPhrase->aToken[0].z = (char *)&pRet->pPhrase[1];
        memcpy(pRet->pPhrase->aToken[0].z, zToken, nToken);

        if( iEnd<n && z[iEnd]=='*' ){
          pRet->pPhrase->aToken[0].isPrefix = 1;
          iEnd++;
        }
        if( !0 && iStart>0 && z[iStart-1]=='-' ){
          pRet->pPhrase->isNot = 1;
        }
      }
      nConsumed = iEnd;
    }

    pModule->xClose(pCursor);
  }

  *pnConsumed = nConsumed;
  *ppExpr = pRet;
  return rc;
}






static void *fts3ReallocOrFree(void *pOrig, int nNew){
  void *pRet = sqlite3_realloc(pOrig, nNew);
  if( !pRet ){
    sqlite3_free(pOrig);
  }
  return pRet;
}
# 115156 "ext/sqlite3/libsqlite/sqlite3.c"
static int getNextString(
  ParseContext *pParse,
  const char *zInput, int nInput,
  Fts3Expr **ppExpr
){
  sqlite3_tokenizer *pTokenizer = pParse->pTokenizer;
  sqlite3_tokenizer_module const *pModule = pTokenizer->pModule;
  int rc;
  Fts3Expr *p = 0;
  sqlite3_tokenizer_cursor *pCursor = 0;
  char *zTemp = 0;
  int nTemp = 0;

  rc = pModule->xOpen(pTokenizer, zInput, nInput, &pCursor);
  if( rc==0 ){
    int ii;
    pCursor->pTokenizer = pTokenizer;
    for(ii=0; rc==0; ii++){
      const char *zToken;
      int nToken, iBegin, iEnd, iPos;
      rc = pModule->xNext(pCursor, &zToken, &nToken, &iBegin, &iEnd, &iPos);
      if( rc==0 ){
        int nByte = sizeof(Fts3Expr) + sizeof(Fts3Phrase);
        p = fts3ReallocOrFree(p, nByte+ii*sizeof(Fts3PhraseToken));
        zTemp = fts3ReallocOrFree(zTemp, nTemp + nToken);
        if( !p || !zTemp ){
          goto no_mem;
        }
        if( ii==0 ){
          memset(p, 0, nByte);
          p->pPhrase = (Fts3Phrase *)&p[1];
        }
        p->pPhrase = (Fts3Phrase *)&p[1];
        memset(&p->pPhrase->aToken[ii], 0, sizeof(Fts3PhraseToken));
        p->pPhrase->nToken = ii+1;
        p->pPhrase->aToken[ii].n = nToken;
        memcpy(&zTemp[nTemp], zToken, nToken);
        nTemp += nToken;
        if( iEnd<nInput && zInput[iEnd]=='*' ){
          p->pPhrase->aToken[ii].isPrefix = 1;
        }else{
          p->pPhrase->aToken[ii].isPrefix = 0;
        }
      }
    }

    pModule->xClose(pCursor);
    pCursor = 0;
  }

  if( rc==101 ){
    int jj;
    char *zNew = ((void*)0);
    int nNew = 0;
    int nByte = sizeof(Fts3Expr) + sizeof(Fts3Phrase);
    nByte += (p?(p->pPhrase->nToken-1):0) * sizeof(Fts3PhraseToken);
    p = fts3ReallocOrFree(p, nByte + nTemp);
    if( !p ){
      goto no_mem;
    }
    if( zTemp ){
      zNew = &(((char *)p)[nByte]);
      memcpy(zNew, zTemp, nTemp);
    }else{
      memset(p, 0, nByte+nTemp);
    }
    p->pPhrase = (Fts3Phrase *)&p[1];
    for(jj=0; jj<p->pPhrase->nToken; jj++){
      p->pPhrase->aToken[jj].z = &zNew[nNew];
      nNew += p->pPhrase->aToken[jj].n;
    }
    sqlite3_free(zTemp);
    p->eType = 5;
    p->pPhrase->iColumn = pParse->iDefaultCol;
    rc = 0;
  }

  *ppExpr = p;
  return rc;
no_mem:

  if( pCursor ){
    pModule->xClose(pCursor);
  }
  sqlite3_free(zTemp);
  sqlite3_free(p);
  *ppExpr = 0;
  return 7;
}





static int fts3ExprParse(ParseContext *, const char *, int, Fts3Expr **, int *);
# 115260 "ext/sqlite3/libsqlite/sqlite3.c"
static int getNextNode(
  ParseContext *pParse,
  const char *z, int n,
  Fts3Expr **ppExpr,
  int *pnConsumed
){
  static const struct Fts3Keyword {
    char *z;
    unsigned char n;
    unsigned char parenOnly;
    unsigned char eType;
  } aKeyword[] = {
    { "OR" , 2, 0, 4 },
    { "AND", 3, 1, 3 },
    { "NOT", 3, 1, 2 },
    { "NEAR", 4, 0, 1 }
  };
  int ii;
  int iCol;
  int iColLen;
  int rc;
  Fts3Expr *pRet = 0;

  const char *zInput = z;
  int nInput = n;




  while( nInput>0 && fts3isspace(*zInput) ){
    nInput--;
    zInput++;
  }
  if( nInput==0 ){
    return 101;
  }


  for(ii=0; ii<(int)(sizeof(aKeyword)/sizeof(struct Fts3Keyword)); ii++){
    const struct Fts3Keyword *pKey = &aKeyword[ii];

    if( (pKey->parenOnly & ~0)!=0 ){
      continue;
    }

    if( nInput>=pKey->n && 0==memcmp(zInput, pKey->z, pKey->n) ){
      int nNear = 10;
      int nKey = pKey->n;
      char cNext;


      if( pKey->eType==1 ){
        ((void) (0));
        if( zInput[4]=='/' && zInput[5]>='0' && zInput[5]<='9' ){
          nNear = 0;
          for(nKey=5; zInput[nKey]>='0' && zInput[nKey]<='9'; nKey++){
            nNear = nNear * 10 + (zInput[nKey] - '0');
          }
        }
      }





      cNext = zInput[nKey];
      if( fts3isspace(cNext)
       || cNext=='"' || cNext=='(' || cNext==')' || cNext==0
      ){
        pRet = (Fts3Expr *)fts3MallocZero(sizeof(Fts3Expr));
        if( !pRet ){
          return 7;
        }
        pRet->eType = pKey->eType;
        pRet->nNear = nNear;
        *ppExpr = pRet;
        *pnConsumed = (int)((zInput - z) + nKey);
        return 0;
      }




    }
  }


  if( 0 ){
    if( *zInput=='(' ){
      int nConsumed;
      pParse->nNest++;
      rc = fts3ExprParse(pParse, &zInput[1], nInput-1, ppExpr, &nConsumed);
      if( rc==0 && !*ppExpr ){
        rc = 101;
      }
      *pnConsumed = (int)((zInput - z) + 1 + nConsumed);
      return rc;
    }


    if( *zInput==')' ){
      pParse->nNest--;
      *pnConsumed = (int)((zInput - z) + 1);
      return 101;
    }
  }






  if( *zInput=='"' ){
    for(ii=1; ii<nInput && zInput[ii]!='"'; ii++);
    *pnConsumed = (int)((zInput - z) + ii + 1);
    if( ii==nInput ){
      return 1;
    }
    return getNextString(pParse, &zInput[1], ii-1, ppExpr);
  }
# 115393 "ext/sqlite3/libsqlite/sqlite3.c"
  iCol = pParse->iDefaultCol;
  iColLen = 0;
  for(ii=0; ii<pParse->nCol; ii++){
    const char *zStr = pParse->azCol[ii];
    int nStr = (int)strlen(zStr);
    if( nInput>nStr && zInput[nStr]==':'
     && sqlite3_strnicmp(zStr, zInput, nStr)==0
    ){
      iCol = ii;
      iColLen = (int)((zInput - z) + nStr + 1);
      break;
    }
  }
  rc = getNextToken(pParse, iCol, &z[iColLen], n-iColLen, ppExpr, pnConsumed);
  *pnConsumed += iColLen;
  return rc;
}
# 115430 "ext/sqlite3/libsqlite/sqlite3.c"
static int opPrecedence(Fts3Expr *p){
  ((void) (0));
  if( 0 ){
    return p->eType;
  }else if( p->eType==1 ){
    return 1;
  }else if( p->eType==4 ){
    return 2;
  }
  ((void) (0));
  return 3;
}
# 115451 "ext/sqlite3/libsqlite/sqlite3.c"
static void insertBinaryOperator(
  Fts3Expr **ppHead,
  Fts3Expr *pPrev,
  Fts3Expr *pNew
){
  Fts3Expr *pSplit = pPrev;
  while( pSplit->pParent && opPrecedence(pSplit->pParent)<=opPrecedence(pNew) ){
    pSplit = pSplit->pParent;
  }

  if( pSplit->pParent ){
    ((void) (0));
    pSplit->pParent->pRight = pNew;
    pNew->pParent = pSplit->pParent;
  }else{
    *ppHead = pNew;
  }
  pNew->pLeft = pSplit;
  pSplit->pParent = pNew;
}
# 115482 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3ExprParse(
  ParseContext *pParse,
  const char *z, int n,
  Fts3Expr **ppExpr,
  int *pnConsumed
){
  Fts3Expr *pRet = 0;
  Fts3Expr *pPrev = 0;
  Fts3Expr *pNotBranch = 0;
  int nIn = n;
  const char *zIn = z;
  int rc = 0;
  int isRequirePhrase = 1;

  while( rc==0 ){
    Fts3Expr *p = 0;
    int nByte = 0;
    rc = getNextNode(pParse, zIn, nIn, &p, &nByte);
    if( rc==0 ){
      int isPhrase;

      if( !0
       && p->eType==5 && p->pPhrase->isNot
      ){

        Fts3Expr *pNot = fts3MallocZero(sizeof(Fts3Expr));
        if( !pNot ){
          sqlite3Fts3ExprFree(p);
          rc = 7;
          goto exprparse_out;
        }
        pNot->eType = 2;
        pNot->pRight = p;
        if( pNotBranch ){
          pNot->pLeft = pNotBranch;
        }
        pNotBranch = pNot;
        p = pPrev;
      }else{
        int eType = p->eType;
        ((void) (0));
        isPhrase = (eType==5 || p->pLeft);






        if( !isPhrase && isRequirePhrase ){
          sqlite3Fts3ExprFree(p);
          rc = 1;
          goto exprparse_out;
        }

        if( isPhrase && !isRequirePhrase ){

          Fts3Expr *pAnd;
          ((void) (0));
          pAnd = fts3MallocZero(sizeof(Fts3Expr));
          if( !pAnd ){
            sqlite3Fts3ExprFree(p);
            rc = 7;
            goto exprparse_out;
          }
          pAnd->eType = 3;
          insertBinaryOperator(&pRet, pPrev, pAnd);
          pPrev = pAnd;
        }
# 115560 "ext/sqlite3/libsqlite/sqlite3.c"
        if( pPrev && (
            (eType==1 && !isPhrase && pPrev->eType!=5)
         || (eType!=5 && isPhrase && pPrev->eType==1)
        )){
          sqlite3Fts3ExprFree(p);
          rc = 1;
          goto exprparse_out;
        }

        if( isPhrase ){
          if( pRet ){
            ((void) (0));
            pPrev->pRight = p;
            p->pParent = pPrev;
          }else{
            pRet = p;
          }
        }else{
          insertBinaryOperator(&pRet, pPrev, p);
        }
        isRequirePhrase = !isPhrase;
      }
      ((void) (0));
    }
    ((void) (0));
    nIn -= nByte;
    zIn += nByte;
    pPrev = p;
  }

  if( rc==101 && pRet && isRequirePhrase ){
    rc = 1;
  }

  if( rc==101 ){
    rc = 0;
    if( !0 && pNotBranch ){
      if( !pRet ){
        rc = 1;
      }else{
        Fts3Expr *pIter = pNotBranch;
        while( pIter->pLeft ){
          pIter = pIter->pLeft;
        }
        pIter->pLeft = pRet;
        pRet = pNotBranch;
      }
    }
  }
  *pnConsumed = n - nIn;

exprparse_out:
  if( rc!=0 ){
    sqlite3Fts3ExprFree(pRet);
    sqlite3Fts3ExprFree(pNotBranch);
    pRet = 0;
  }
  *ppExpr = pRet;
  return rc;
}
# 115645 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Fts3ExprParse(
  sqlite3_tokenizer *pTokenizer,
  char **azCol,
  int nCol,
  int iDefaultCol,
  const char *z, int n,
  Fts3Expr **ppExpr
){
  int nParsed;
  int rc;
  ParseContext sParse;
  sParse.pTokenizer = pTokenizer;
  sParse.azCol = (const char **)azCol;
  sParse.nCol = nCol;
  sParse.iDefaultCol = iDefaultCol;
  sParse.nNest = 0;
  if( z==0 ){
    *ppExpr = 0;
    return 0;
  }
  if( n<0 ){
    n = (int)strlen(z);
  }
  rc = fts3ExprParse(&sParse, z, n, ppExpr, &nParsed);


  if( rc==0 && sParse.nNest ){
    rc = 1;
    sqlite3Fts3ExprFree(*ppExpr);
    *ppExpr = 0;
  }

  return rc;
}




static void sqlite3Fts3ExprFree(Fts3Expr *p){
  if( p ){
    sqlite3Fts3ExprFree(p->pLeft);
    sqlite3Fts3ExprFree(p->pRight);
    sqlite3_free(p->aDoclist);
    sqlite3_free(p);
  }
}
# 115914 "ext/sqlite3/libsqlite/sqlite3.c"
static void *fts3HashMalloc(int n){
  void *p = sqlite3_malloc(n);
  if( p ){
    memset(p, 0, n);
  }
  return p;
}
static void fts3HashFree(void *p){
  sqlite3_free(p);
}
# 115935 "ext/sqlite3/libsqlite/sqlite3.c"
static void sqlite3Fts3HashInit(Fts3Hash *pNew, char keyClass, char copyKey){
  ((void) (0));
  ((void) (0));
  pNew->keyClass = keyClass;
  pNew->copyKey = copyKey;
  pNew->first = 0;
  pNew->count = 0;
  pNew->htsize = 0;
  pNew->ht = 0;
}





static void sqlite3Fts3HashClear(Fts3Hash *pH){
  Fts3HashElem *elem;

  ((void) (0));
  elem = pH->first;
  pH->first = 0;
  fts3HashFree(pH->ht);
  pH->ht = 0;
  pH->htsize = 0;
  while( elem ){
    Fts3HashElem *next_elem = elem->next;
    if( pH->copyKey && elem->pKey ){
      fts3HashFree(elem->pKey);
    }
    fts3HashFree(elem);
    elem = next_elem;
  }
  pH->count = 0;
}




static int fts3StrHash(const void *pKey, int nKey){
  const char *z = (const char *)pKey;
  int h = 0;
  if( nKey<=0 ) nKey = (int) strlen(z);
  while( nKey > 0 ){
    h = (h<<3) ^ h ^ *z++;
    nKey--;
  }
  return h & 0x7fffffff;
}
static int fts3StrCompare(const void *pKey1, int n1, const void *pKey2, int n2){
  if( n1!=n2 ) return 1;
  return (__extension__ (__builtin_constant_p (n1) && ((__builtin_constant_p ((const char*)pKey1) && strlen ((const char*)pKey1) < ((size_t) (n1))) || (__builtin_constant_p ((const char*)pKey2) && strlen ((const char*)pKey2) < ((size_t) (n1)))) ? __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p ((const char*)pKey1) && __builtin_constant_p ((const char*)pKey2) && (__s1_len = __builtin_strlen ((const char*)pKey1), __s2_len = __builtin_strlen ((const char*)pKey2), (!((size_t)(const void *)(((const char*)pKey1) + 1) - (size_t)(const void *)((const char*)pKey1) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(((const char*)pKey2) + 1) - (size_t)(const void *)((const char*)pKey2) == 1) || __s2_len >= 4)) ? __builtin_strcmp ((const char*)pKey1, (const char*)pKey2) : (__builtin_constant_p ((const char*)pKey1) && ((size_t)(const void *)(((const char*)pKey1) + 1) - (size_t)(const void *)((const char*)pKey1) == 1) && (__s1_len = __builtin_strlen ((const char*)pKey1), __s1_len < 4) ? (__builtin_constant_p ((const char*)pKey2) && ((size_t)(const void *)(((const char*)pKey2) + 1) - (size_t)(const void *)((const char*)pKey2) == 1) ? __builtin_strcmp ((const char*)pKey1, (const char*)pKey2) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ((const char*)pKey2); int __result = (((const unsigned char *) (const char *) ((const char*)pKey1))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ((const char*)pKey1))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ((const char*)pKey1))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ((const char*)pKey1))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ((const char*)pKey2) && ((size_t)(const void *)(((const char*)pKey2) + 1) - (size_t)(const void *)((const char*)pKey2) == 1) && (__s2_len = __builtin_strlen ((const char*)pKey2), __s2_len < 4) ? (__builtin_constant_p ((const char*)pKey1) && ((size_t)(const void *)(((const char*)pKey1) + 1) - (size_t)(const void *)((const char*)pKey1) == 1) ? __builtin_strcmp ((const char*)pKey1, (const char*)pKey2) : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ((const char*)pKey1); int __result = (((const unsigned char *) (const char *) ((const char*)pKey2))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) ((const char*)pKey2))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) ((const char*)pKey2))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) ((const char*)pKey2))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp ((const char*)pKey1, (const char*)pKey2)))); }) : strncmp ((const char*)pKey1, (const char*)pKey2, n1)));
}




static int fts3BinHash(const void *pKey, int nKey){
  int h = 0;
  const char *z = (const char *)pKey;
  while( nKey-- > 0 ){
    h = (h<<3) ^ h ^ *(z++);
  }
  return h & 0x7fffffff;
}
static int fts3BinCompare(const void *pKey1, int n1, const void *pKey2, int n2){
  if( n1!=n2 ) return 1;
  return memcmp(pKey1,pKey2,n1);
}
# 116016 "ext/sqlite3/libsqlite/sqlite3.c"
static int (*ftsHashFunction(int keyClass))(const void*,int){
  if( keyClass==1 ){
    return &fts3StrHash;
  }else{
    ((void) (0));
    return &fts3BinHash;
  }
}







static int (*ftsCompareFunction(int keyClass))(const void*,int,const void*,int){
  if( keyClass==1 ){
    return &fts3StrCompare;
  }else{
    ((void) (0));
    return &fts3BinCompare;
  }
}



static void fts3HashInsertElement(
  Fts3Hash *pH,
  struct _fts3ht *pEntry,
  Fts3HashElem *pNew
){
  Fts3HashElem *pHead;
  pHead = pEntry->chain;
  if( pHead ){
    pNew->next = pHead;
    pNew->prev = pHead->prev;
    if( pHead->prev ){ pHead->prev->next = pNew; }
    else { pH->first = pNew; }
    pHead->prev = pNew;
  }else{
    pNew->next = pH->first;
    if( pH->first ){ pH->first->prev = pNew; }
    pNew->prev = 0;
    pH->first = pNew;
  }
  pEntry->count++;
  pEntry->chain = pNew;
}
# 116072 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3Rehash(Fts3Hash *pH, int new_size){
  struct _fts3ht *new_ht;
  Fts3HashElem *elem, *next_elem;
  int (*xHash)(const void*,int);

  ((void) (0));
  new_ht = (struct _fts3ht *)fts3HashMalloc( new_size*sizeof(struct _fts3ht) );
  if( new_ht==0 ) return 1;
  fts3HashFree(pH->ht);
  pH->ht = new_ht;
  pH->htsize = new_size;
  xHash = ftsHashFunction(pH->keyClass);
  for(elem=pH->first, pH->first=0; elem; elem = next_elem){
    int h = (*xHash)(elem->pKey, elem->nKey) & (new_size-1);
    next_elem = elem->next;
    fts3HashInsertElement(pH, &new_ht[h], elem);
  }
  return 0;
}





static Fts3HashElem *fts3FindElementByHash(
  const Fts3Hash *pH,
  const void *pKey,
  int nKey,
  int h
){
  Fts3HashElem *elem;
  int count;
  int (*xCompare)(const void*,int,const void*,int);

  if( pH->ht ){
    struct _fts3ht *pEntry = &pH->ht[h];
    elem = pEntry->chain;
    count = pEntry->count;
    xCompare = ftsCompareFunction(pH->keyClass);
    while( count-- && elem ){
      if( (*xCompare)(elem->pKey,elem->nKey,pKey,nKey)==0 ){
        return elem;
      }
      elem = elem->next;
    }
  }
  return 0;
}




static void fts3RemoveElementByHash(
  Fts3Hash *pH,
  Fts3HashElem* elem,
  int h
){
  struct _fts3ht *pEntry;
  if( elem->prev ){
    elem->prev->next = elem->next;
  }else{
    pH->first = elem->next;
  }
  if( elem->next ){
    elem->next->prev = elem->prev;
  }
  pEntry = &pH->ht[h];
  if( pEntry->chain==elem ){
    pEntry->chain = elem->next;
  }
  pEntry->count--;
  if( pEntry->count<=0 ){
    pEntry->chain = 0;
  }
  if( pH->copyKey && elem->pKey ){
    fts3HashFree(elem->pKey);
  }
  fts3HashFree( elem );
  pH->count--;
  if( pH->count<=0 ){
    ((void) (0));
    ((void) (0));
    sqlite3Fts3HashClear(pH);
  }
}

static Fts3HashElem *sqlite3Fts3HashFindElem(
  const Fts3Hash *pH,
  const void *pKey,
  int nKey
){
  int h;
  int (*xHash)(const void*,int);

  if( pH==0 || pH->ht==0 ) return 0;
  xHash = ftsHashFunction(pH->keyClass);
  ((void) (0));
  h = (*xHash)(pKey,nKey);
  ((void) (0));
  return fts3FindElementByHash(pH,pKey,nKey, h & (pH->htsize-1));
}






static void *sqlite3Fts3HashFind(const Fts3Hash *pH, const void *pKey, int nKey){
  Fts3HashElem *pElem;

  pElem = sqlite3Fts3HashFindElem(pH, pKey, nKey);
  return pElem ? pElem->data : 0;
}
# 116201 "ext/sqlite3/libsqlite/sqlite3.c"
static void *sqlite3Fts3HashInsert(
  Fts3Hash *pH,
  const void *pKey,
  int nKey,
  void *data
){
  int hraw;
  int h;
  Fts3HashElem *elem;
  Fts3HashElem *new_elem;
  int (*xHash)(const void*,int);

  ((void) (0));
  xHash = ftsHashFunction(pH->keyClass);
  ((void) (0));
  hraw = (*xHash)(pKey, nKey);
  ((void) (0));
  h = hraw & (pH->htsize-1);
  elem = fts3FindElementByHash(pH,pKey,nKey,h);
  if( elem ){
    void *old_data = elem->data;
    if( data==0 ){
      fts3RemoveElementByHash(pH,elem,h);
    }else{
      elem->data = data;
    }
    return old_data;
  }
  if( data==0 ) return 0;
  if( (pH->htsize==0 && fts3Rehash(pH,8))
   || (pH->count>=pH->htsize && fts3Rehash(pH, pH->htsize*2))
  ){
    pH->count = 0;
    return data;
  }
  ((void) (0));
  new_elem = (Fts3HashElem*)fts3HashMalloc( sizeof(Fts3HashElem) );
  if( new_elem==0 ) return data;
  if( pH->copyKey && pKey!=0 ){
    new_elem->pKey = fts3HashMalloc( nKey );
    if( new_elem->pKey==0 ){
      fts3HashFree(new_elem);
      return data;
    }
    memcpy((void*)new_elem->pKey, pKey, nKey);
  }else{
    new_elem->pKey = (void*)pKey;
  }
  new_elem->nKey = nKey;
  pH->count++;
  ((void) (0));
  ((void) (0));
  h = hraw & (pH->htsize-1);
  fts3HashInsertElement(pH, &pH->ht[h], new_elem);
  new_elem->data = data;
  return 0;
}
# 116295 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct porter_tokenizer {
  sqlite3_tokenizer base;
} porter_tokenizer;




typedef struct porter_tokenizer_cursor {
  sqlite3_tokenizer_cursor base;
  const char *zInput;
  int nInput;
  int iOffset;
  int iToken;
  char *zToken;
  int nAllocated;
} porter_tokenizer_cursor;





static int porterCreate(
  int argc, const char * const *argv,
  sqlite3_tokenizer **ppTokenizer
){
  porter_tokenizer *t;

  (void)(argc);
  (void)(argv);

  t = (porter_tokenizer *) sqlite3_malloc(sizeof(*t));
  if( t==((void*)0) ) return 7;
  memset(t, 0, sizeof(*t));
  *ppTokenizer = &t->base;
  return 0;
}




static int porterDestroy(sqlite3_tokenizer *pTokenizer){
  sqlite3_free(pTokenizer);
  return 0;
}







static int porterOpen(
  sqlite3_tokenizer *pTokenizer,
  const char *zInput, int nInput,
  sqlite3_tokenizer_cursor **ppCursor
){
  porter_tokenizer_cursor *c;

  (void)(pTokenizer);

  c = (porter_tokenizer_cursor *) sqlite3_malloc(sizeof(*c));
  if( c==((void*)0) ) return 7;

  c->zInput = zInput;
  if( zInput==0 ){
    c->nInput = 0;
  }else if( nInput<0 ){
    c->nInput = (int)strlen(zInput);
  }else{
    c->nInput = nInput;
  }
  c->iOffset = 0;
  c->iToken = 0;
  c->zToken = ((void*)0);
  c->nAllocated = 0;

  *ppCursor = &c->base;
  return 0;
}





static int porterClose(sqlite3_tokenizer_cursor *pCursor){
  porter_tokenizer_cursor *c = (porter_tokenizer_cursor *) pCursor;
  sqlite3_free(c->zToken);
  sqlite3_free(c);
  return 0;
}



static const char cType[] = {
   0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0,
   1, 1, 1, 2, 1
};
# 116406 "ext/sqlite3/libsqlite/sqlite3.c"
static int isVowel(const char*);
static int isConsonant(const char *z){
  int j;
  char x = *z;
  if( x==0 ) return 0;
  ((void) (0));
  j = cType[x-'a'];
  if( j<2 ) return j;
  return z[1]==0 || isVowel(z + 1);
}
static int isVowel(const char *z){
  int j;
  char x = *z;
  if( x==0 ) return 0;
  ((void) (0));
  j = cType[x-'a'];
  if( j<2 ) return 1-j;
  return isConsonant(z + 1);
}
# 116445 "ext/sqlite3/libsqlite/sqlite3.c"
static int m_gt_0(const char *z){
  while( isVowel(z) ){ z++; }
  if( *z==0 ) return 0;
  while( isConsonant(z) ){ z++; }
  return *z!=0;
}




static int m_eq_1(const char *z){
  while( isVowel(z) ){ z++; }
  if( *z==0 ) return 0;
  while( isConsonant(z) ){ z++; }
  if( *z==0 ) return 0;
  while( isVowel(z) ){ z++; }
  if( *z==0 ) return 1;
  while( isConsonant(z) ){ z++; }
  return *z==0;
}




static int m_gt_1(const char *z){
  while( isVowel(z) ){ z++; }
  if( *z==0 ) return 0;
  while( isConsonant(z) ){ z++; }
  if( *z==0 ) return 0;
  while( isVowel(z) ){ z++; }
  if( *z==0 ) return 0;
  while( isConsonant(z) ){ z++; }
  return *z!=0;
}




static int hasVowel(const char *z){
  while( isConsonant(z) ){ z++; }
  return *z!=0;
}







static int doubleConsonant(const char *z){
  return isConsonant(z) && z[0]==z[1];
}
# 116506 "ext/sqlite3/libsqlite/sqlite3.c"
static int star_oh(const char *z){
  return
    isConsonant(z) &&
    z[0]!='w' && z[0]!='x' && z[0]!='y' &&
    isVowel(z+1) &&
    isConsonant(z+2);
}
# 116526 "ext/sqlite3/libsqlite/sqlite3.c"
static int stem(
  char **pz,
  const char *zFrom,
  const char *zTo,
  int (*xCond)(const char*)
){
  char *z = *pz;
  while( *zFrom && *zFrom==*z ){ z++; zFrom++; }
  if( *zFrom!=0 ) return 0;
  if( xCond && !xCond(z) ) return 1;
  while( *zTo ){
    *(--z) = *(zTo++);
  }
  *pz = z;
  return 1;
}
# 116551 "ext/sqlite3/libsqlite/sqlite3.c"
static void copy_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){
  int i, mx, j;
  int hasDigit = 0;
  for(i=0; i<nIn; i++){
    char c = zIn[i];
    if( c>='A' && c<='Z' ){
      zOut[i] = c - 'A' + 'a';
    }else{
      if( c>='0' && c<='9' ) hasDigit = 1;
      zOut[i] = c;
    }
  }
  mx = hasDigit ? 3 : 10;
  if( nIn>mx*2 ){
    for(j=mx, i=nIn-mx; i<nIn; i++, j++){
      zOut[j] = zOut[i];
    }
    i = j;
  }
  zOut[i] = 0;
  *pnOut = i;
}
# 116598 "ext/sqlite3/libsqlite/sqlite3.c"
static void porter_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){
  int i, j;
  char zReverse[28];
  char *z, *z2;
  if( nIn<3 || nIn>=(int)sizeof(zReverse)-7 ){


    copy_stemmer(zIn, nIn, zOut, pnOut);
    return;
  }
  for(i=0, j=sizeof(zReverse)-6; i<nIn; i++, j--){
    char c = zIn[i];
    if( c>='A' && c<='Z' ){
      zReverse[j] = c + 'a' - 'A';
    }else if( c>='a' && c<='z' ){
      zReverse[j] = c;
    }else{


      copy_stemmer(zIn, nIn, zOut, pnOut);
      return;
    }
  }
  memset(&zReverse[sizeof(zReverse)-5], 0, 5);
  z = &zReverse[j+1];



  if( z[0]=='s' ){
    if(
     !stem(&z, "sess", "ss", 0) &&
     !stem(&z, "sei", "i", 0) &&
     !stem(&z, "ss", "ss", 0)
    ){
      z++;
    }
  }


  z2 = z;
  if( stem(&z, "dee", "ee", m_gt_0) ){

  }else if(
     (stem(&z, "gni", "", hasVowel) || stem(&z, "de", "", hasVowel))
      && z!=z2
  ){
     if( stem(&z, "ta", "ate", 0) ||
         stem(&z, "lb", "ble", 0) ||
         stem(&z, "zi", "ize", 0) ){

     }else if( doubleConsonant(z) && (*z!='l' && *z!='s' && *z!='z') ){
       z++;
     }else if( m_eq_1(z) && star_oh(z) ){
       *(--z) = 'e';
     }
  }


  if( z[0]=='y' && hasVowel(z+1) ){
    z[0] = 'i';
  }


  switch( z[1] ){
   case 'a':
     stem(&z, "lanoita", "ate", m_gt_0) ||
     stem(&z, "lanoit", "tion", m_gt_0);
     break;
   case 'c':
     stem(&z, "icne", "ence", m_gt_0) ||
     stem(&z, "icna", "ance", m_gt_0);
     break;
   case 'e':
     stem(&z, "rezi", "ize", m_gt_0);
     break;
   case 'g':
     stem(&z, "igol", "log", m_gt_0);
     break;
   case 'l':
     stem(&z, "ilb", "ble", m_gt_0) ||
     stem(&z, "illa", "al", m_gt_0) ||
     stem(&z, "iltne", "ent", m_gt_0) ||
     stem(&z, "ile", "e", m_gt_0) ||
     stem(&z, "ilsuo", "ous", m_gt_0);
     break;
   case 'o':
     stem(&z, "noitazi", "ize", m_gt_0) ||
     stem(&z, "noita", "ate", m_gt_0) ||
     stem(&z, "rota", "ate", m_gt_0);
     break;
   case 's':
     stem(&z, "msila", "al", m_gt_0) ||
     stem(&z, "ssenevi", "ive", m_gt_0) ||
     stem(&z, "ssenluf", "ful", m_gt_0) ||
     stem(&z, "ssensuo", "ous", m_gt_0);
     break;
   case 't':
     stem(&z, "itila", "al", m_gt_0) ||
     stem(&z, "itivi", "ive", m_gt_0) ||
     stem(&z, "itilib", "ble", m_gt_0);
     break;
  }


  switch( z[0] ){
   case 'e':
     stem(&z, "etaci", "ic", m_gt_0) ||
     stem(&z, "evita", "", m_gt_0) ||
     stem(&z, "ezila", "al", m_gt_0);
     break;
   case 'i':
     stem(&z, "itici", "ic", m_gt_0);
     break;
   case 'l':
     stem(&z, "laci", "ic", m_gt_0) ||
     stem(&z, "luf", "", m_gt_0);
     break;
   case 's':
     stem(&z, "ssen", "", m_gt_0);
     break;
  }


  switch( z[1] ){
   case 'a':
     if( z[0]=='l' && m_gt_1(z+2) ){
       z += 2;
     }
     break;
   case 'c':
     if( z[0]=='e' && z[2]=='n' && (z[3]=='a' || z[3]=='e') && m_gt_1(z+4) ){
       z += 4;
     }
     break;
   case 'e':
     if( z[0]=='r' && m_gt_1(z+2) ){
       z += 2;
     }
     break;
   case 'i':
     if( z[0]=='c' && m_gt_1(z+2) ){
       z += 2;
     }
     break;
   case 'l':
     if( z[0]=='e' && z[2]=='b' && (z[3]=='a' || z[3]=='i') && m_gt_1(z+4) ){
       z += 4;
     }
     break;
   case 'n':
     if( z[0]=='t' ){
       if( z[2]=='a' ){
         if( m_gt_1(z+3) ){
           z += 3;
         }
       }else if( z[2]=='e' ){
         stem(&z, "tneme", "", m_gt_1) ||
         stem(&z, "tnem", "", m_gt_1) ||
         stem(&z, "tne", "", m_gt_1);
       }
     }
     break;
   case 'o':
     if( z[0]=='u' ){
       if( m_gt_1(z+2) ){
         z += 2;
       }
     }else if( z[3]=='s' || z[3]=='t' ){
       stem(&z, "noi", "", m_gt_1);
     }
     break;
   case 's':
     if( z[0]=='m' && z[2]=='i' && m_gt_1(z+3) ){
       z += 3;
     }
     break;
   case 't':
     stem(&z, "eta", "", m_gt_1) ||
     stem(&z, "iti", "", m_gt_1);
     break;
   case 'u':
     if( z[0]=='s' && z[2]=='o' && m_gt_1(z+3) ){
       z += 3;
     }
     break;
   case 'v':
   case 'z':
     if( z[0]=='e' && z[2]=='i' && m_gt_1(z+3) ){
       z += 3;
     }
     break;
  }


  if( z[0]=='e' ){
    if( m_gt_1(z+1) ){
      z++;
    }else if( m_eq_1(z+1) && !star_oh(z+1) ){
      z++;
    }
  }


  if( m_gt_1(z) && z[0]=='l' && z[1]=='l' ){
    z++;
  }




  *pnOut = i = (int)strlen(z);
  zOut[i] = 0;
  while( *z ){
    zOut[--i] = *(z++);
  }
}







static const char porterIdChar[] = {

    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,
    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
};






static int porterNext(
  sqlite3_tokenizer_cursor *pCursor,
  const char **pzToken,
  int *pnBytes,
  int *piStartOffset,
  int *piEndOffset,
  int *piPosition
){
  porter_tokenizer_cursor *c = (porter_tokenizer_cursor *) pCursor;
  const char *z = c->zInput;

  while( c->iOffset<c->nInput ){
    int iStartOffset, ch;


    while( c->iOffset<c->nInput && (((ch=z[c->iOffset])&0x80)==0 && (ch<0x30 || !porterIdChar[ch-0x30])) ){
      c->iOffset++;
    }


    iStartOffset = c->iOffset;
    while( c->iOffset<c->nInput && !(((ch=z[c->iOffset])&0x80)==0 && (ch<0x30 || !porterIdChar[ch-0x30])) ){
      c->iOffset++;
    }

    if( c->iOffset>iStartOffset ){
      int n = c->iOffset-iStartOffset;
      if( n>c->nAllocated ){
        char *pNew;
        c->nAllocated = n+20;
        pNew = sqlite3_realloc(c->zToken, c->nAllocated);
        if( !pNew ) return 7;
        c->zToken = pNew;
      }
      porter_stemmer(&z[iStartOffset], n, c->zToken, pnBytes);
      *pzToken = c->zToken;
      *piStartOffset = iStartOffset;
      *piEndOffset = c->iOffset;
      *piPosition = c->iToken++;
      return 0;
    }
  }
  return 101;
}




static const sqlite3_tokenizer_module porterTokenizerModule = {
  0,
  porterCreate,
  porterDestroy,
  porterOpen,
  porterClose,
  porterNext,
};





static void sqlite3Fts3PorterTokenizerModule(
  sqlite3_tokenizer_module const**ppModule
){
  *ppModule = &porterTokenizerModule;
}
# 116958 "ext/sqlite3/libsqlite/sqlite3.c"
static void scalarFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  Fts3Hash *pHash;
  void *pPtr = 0;
  const unsigned char *zName;
  int nName;

  ((void) (0));

  pHash = (Fts3Hash *)sqlite3_user_data(context);

  zName = sqlite3_value_text(argv[0]);
  nName = sqlite3_value_bytes(argv[0])+1;

  if( argc==2 ){
    void *pOld;
    int n = sqlite3_value_bytes(argv[1]);
    if( n!=sizeof(pPtr) ){
      sqlite3_result_error(context, "argument type mismatch", -1);
      return;
    }
    pPtr = *(void **)sqlite3_value_blob(argv[1]);
    pOld = sqlite3Fts3HashInsert(pHash, (void *)zName, nName, pPtr);
    if( pOld==pPtr ){
      sqlite3_result_error(context, "out of memory", -1);
      return;
    }
  }else{
    pPtr = sqlite3Fts3HashFind(pHash, zName, nName);
    if( !pPtr ){
      char *zErr = sqlite3_mprintf("unknown tokenizer: %s", zName);
      sqlite3_result_error(context, zErr, -1);
      sqlite3_free(zErr);
      return;
    }
  }

  sqlite3_result_blob(context, (void *)&pPtr, sizeof(pPtr), ((sqlite3_destructor_type)-1));
}

static int sqlite3Fts3IsIdChar(char c){
  static const char isFtsIdChar[] = {
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
      0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,
      0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,
  };
  return (c&0x80 || isFtsIdChar[(int)(c)]);
}

static const char *sqlite3Fts3NextToken(const char *zStr, int *pn){
  const char *z1;
  const char *z2 = 0;


  z1 = zStr;
  while( z2==0 ){
    char c = *z1;
    switch( c ){
      case '\0': return 0;
      case '\'':
      case '"':
      case '`': {
        z2 = z1;
        while( *++z2 && (*z2!=c || *++z2==c) );
        break;
      }
      case '[':
        z2 = &z1[1];
        while( *z2 && z2[0]!=']' ) z2++;
        if( *z2 ) z2++;
        break;

      default:
        if( sqlite3Fts3IsIdChar(*z1) ){
          z2 = &z1[1];
          while( sqlite3Fts3IsIdChar(*z2) ) z2++;
        }else{
          z1++;
        }
    }
  }

  *pn = (int)(z2-z1);
  return z1;
}

static int sqlite3Fts3InitTokenizer(
  Fts3Hash *pHash,
  const char *zArg,
  sqlite3_tokenizer **ppTok,
  char **pzErr
){
  int rc;
  char *z = (char *)zArg;
  int n;
  char *zCopy;
  char *zEnd;
  sqlite3_tokenizer_module *m;

  zCopy = sqlite3_mprintf("%s", zArg);
  if( !zCopy ) return 7;
  zEnd = &zCopy[strlen(zCopy)];

  z = (char *)sqlite3Fts3NextToken(zCopy, &n);
  z[n] = '\0';
  sqlite3Fts3Dequote(z);

  m = (sqlite3_tokenizer_module *)sqlite3Fts3HashFind(pHash,z,(int)strlen(z)+1);
  if( !m ){
    *pzErr = sqlite3_mprintf("unknown tokenizer: %s", z);
    rc = 1;
  }else{
    char const **aArg = 0;
    int iArg = 0;
    z = &z[n+1];
    while( z<zEnd && (((void*)0)!=(z = (char *)sqlite3Fts3NextToken(z, &n))) ){
      int nNew = sizeof(char *)*(iArg+1);
      char const **aNew = (const char **)sqlite3_realloc((void *)aArg, nNew);
      if( !aNew ){
        sqlite3_free(zCopy);
        sqlite3_free((void *)aArg);
        return 7;
      }
      aArg = aNew;
      aArg[iArg++] = z;
      z[n] = '\0';
      sqlite3Fts3Dequote(z);
      z = &z[n+1];
    }
    rc = m->xCreate(iArg, aArg, ppTok);
    ((void) (0));
    if( rc!=0 ){
      *pzErr = sqlite3_mprintf("unknown tokenizer");
    }else{
      (*ppTok)->pModule = m;
    }
    sqlite3_free((void *)aArg);
  }

  sqlite3_free(zCopy);
  return rc;
}
# 117347 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Fts3InitHashTable(
  sqlite3 *db,
  Fts3Hash *pHash,
  const char *zName
){
  int rc = 0;
  void *p = (void *)pHash;
  const int any = 5;
# 117367 "ext/sqlite3/libsqlite/sqlite3.c"
  if( 0==rc ){
    rc = sqlite3_create_function(db, zName, 1, any, p, scalarFunc, 0, 0);
  }
  if( 0==rc ){
    rc = sqlite3_create_function(db, zName, 2, any, p, scalarFunc, 0, 0);
  }
# 117390 "ext/sqlite3/libsqlite/sqlite3.c"
  return rc;
}
# 117426 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct simple_tokenizer {
  sqlite3_tokenizer base;
  char delim[128];
} simple_tokenizer;

typedef struct simple_tokenizer_cursor {
  sqlite3_tokenizer_cursor base;
  const char *pInput;
  int nBytes;
  int iOffset;
  int iToken;
  char *pToken;
  int nTokenAllocated;
} simple_tokenizer_cursor;


static int simpleDelim(simple_tokenizer *t, unsigned char c){
  return c<0x80 && t->delim[c];
}
static int fts3_isalnum(int x){
  return (x>='0' && x<='9') || (x>='A' && x<='Z') || (x>='a' && x<='z');
}




static int simpleCreate(
  int argc, const char * const *argv,
  sqlite3_tokenizer **ppTokenizer
){
  simple_tokenizer *t;

  t = (simple_tokenizer *) sqlite3_malloc(sizeof(*t));
  if( t==((void*)0) ) return 7;
  memset(t, 0, sizeof(*t));






  if( argc>1 ){
    int i, n = (int)strlen(argv[1]);
    for(i=0; i<n; i++){
      unsigned char ch = argv[1][i];

      if( ch>=0x80 ){
        sqlite3_free(t);
        return 1;
      }
      t->delim[ch] = 1;
    }
  } else {

    int i;
    for(i=1; i<0x80; i++){
      t->delim[i] = !fts3_isalnum(i) ? -1 : 0;
    }
  }

  *ppTokenizer = &t->base;
  return 0;
}




static int simpleDestroy(sqlite3_tokenizer *pTokenizer){
  sqlite3_free(pTokenizer);
  return 0;
}







static int simpleOpen(
  sqlite3_tokenizer *pTokenizer,
  const char *pInput, int nBytes,
  sqlite3_tokenizer_cursor **ppCursor
){
  simple_tokenizer_cursor *c;

  (void)(pTokenizer);

  c = (simple_tokenizer_cursor *) sqlite3_malloc(sizeof(*c));
  if( c==((void*)0) ) return 7;

  c->pInput = pInput;
  if( pInput==0 ){
    c->nBytes = 0;
  }else if( nBytes<0 ){
    c->nBytes = (int)strlen(pInput);
  }else{
    c->nBytes = nBytes;
  }
  c->iOffset = 0;
  c->iToken = 0;
  c->pToken = ((void*)0);
  c->nTokenAllocated = 0;

  *ppCursor = &c->base;
  return 0;
}





static int simpleClose(sqlite3_tokenizer_cursor *pCursor){
  simple_tokenizer_cursor *c = (simple_tokenizer_cursor *) pCursor;
  sqlite3_free(c->pToken);
  sqlite3_free(c);
  return 0;
}





static int simpleNext(
  sqlite3_tokenizer_cursor *pCursor,
  const char **ppToken,
  int *pnBytes,
  int *piStartOffset,
  int *piEndOffset,
  int *piPosition
){
  simple_tokenizer_cursor *c = (simple_tokenizer_cursor *) pCursor;
  simple_tokenizer *t = (simple_tokenizer *) pCursor->pTokenizer;
  unsigned char *p = (unsigned char *)c->pInput;

  while( c->iOffset<c->nBytes ){
    int iStartOffset;


    while( c->iOffset<c->nBytes && simpleDelim(t, p[c->iOffset]) ){
      c->iOffset++;
    }


    iStartOffset = c->iOffset;
    while( c->iOffset<c->nBytes && !simpleDelim(t, p[c->iOffset]) ){
      c->iOffset++;
    }

    if( c->iOffset>iStartOffset ){
      int i, n = c->iOffset-iStartOffset;
      if( n>c->nTokenAllocated ){
        char *pNew;
        c->nTokenAllocated = n+20;
        pNew = sqlite3_realloc(c->pToken, c->nTokenAllocated);
        if( !pNew ) return 7;
        c->pToken = pNew;
      }
      for(i=0; i<n; i++){



        unsigned char ch = p[iStartOffset+i];
        c->pToken[i] = (char)((ch>='A' && ch<='Z') ? ch-'A'+'a' : ch);
      }
      *ppToken = c->pToken;
      *pnBytes = n;
      *piStartOffset = iStartOffset;
      *piEndOffset = c->iOffset;
      *piPosition = c->iToken++;

      return 0;
    }
  }
  return 101;
}




static const sqlite3_tokenizer_module simpleTokenizerModule = {
  0,
  simpleCreate,
  simpleDestroy,
  simpleOpen,
  simpleClose,
  simpleNext,
};





static void sqlite3Fts3SimpleTokenizerModule(
  sqlite3_tokenizer_module const**ppModule
){
  *ppModule = &simpleTokenizerModule;
}
# 117662 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct PendingList PendingList;
typedef struct SegmentNode SegmentNode;
typedef struct SegmentWriter SegmentWriter;






struct PendingList {
  int nData;
  char *aData;
  int nSpace;
  sqlite3_int64 iLastDocid;
  sqlite3_int64 iLastCol;
  sqlite3_int64 iLastPos;
};





struct Fts3DeferredToken {
  Fts3PhraseToken *pToken;
  int iCol;
  Fts3DeferredToken *pNext;
  PendingList *pList;
};
# 117709 "ext/sqlite3/libsqlite/sqlite3.c"
struct Fts3SegReader {
  int iIdx;

  sqlite3_int64 iStartBlock;
  sqlite3_int64 iLeafEndBlock;
  sqlite3_int64 iEndBlock;
  sqlite3_int64 iCurrentBlock;

  char *aNode;
  int nNode;
  Fts3HashElem **ppNextElem;






  int nTerm;
  char *zTerm;
  int nTermAlloc;
  char *aDoclist;
  int nDoclist;


  char *pOffsetList;
  sqlite3_int64 iDocid;
};
# 117749 "ext/sqlite3/libsqlite/sqlite3.c"
struct SegmentWriter {
  SegmentNode *pTree;
  sqlite3_int64 iFirst;
  sqlite3_int64 iFree;
  char *zTerm;
  int nTerm;
  int nMalloc;
  char *zMalloc;
  int nSize;
  int nData;
  char *aData;
};
# 117772 "ext/sqlite3/libsqlite/sqlite3.c"
struct SegmentNode {
  SegmentNode *pParent;
  SegmentNode *pRight;
  SegmentNode *pLeftmost;
  int nEntry;
  char *zTerm;
  int nTerm;
  int nMalloc;
  char *zMalloc;
  int nData;
  char *aData;
};
# 117824 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3SqlStmt(
  Fts3Table *p,
  int eStmt,
  sqlite3_stmt **pp,
  sqlite3_value **apVal
){
  const char *azSql[] = {
          "DELETE FROM %Q.'%q_content' WHERE rowid = ?",
          "SELECT NOT EXISTS(SELECT docid FROM %Q.'%q_content' WHERE rowid!=?)",
          "DELETE FROM %Q.'%q_content'",
          "DELETE FROM %Q.'%q_segments'",
          "DELETE FROM %Q.'%q_segdir'",
          "DELETE FROM %Q.'%q_docsize'",
          "DELETE FROM %Q.'%q_stat'",
          "SELECT %s FROM %Q.'%q_content' AS x WHERE rowid=?",
          "SELECT (SELECT max(idx) FROM %Q.'%q_segdir' WHERE level = ?) + 1",
          "INSERT INTO %Q.'%q_segments'(blockid, block) VALUES(?, ?)",
          "SELECT coalesce((SELECT max(blockid) FROM %Q.'%q_segments') + 1, 1)",
          "INSERT INTO %Q.'%q_segdir' VALUES(?,?,?,?,?,?)",


          "SELECT idx, start_block, leaves_end_block, end_block, root "
            "FROM %Q.'%q_segdir' WHERE level = ? ORDER BY idx ASC",
          "SELECT idx, start_block, leaves_end_block, end_block, root "
            "FROM %Q.'%q_segdir' ORDER BY level DESC, idx ASC",

          "SELECT count(*) FROM %Q.'%q_segdir' WHERE level = ?",
          "SELECT count(*), max(level) FROM %Q.'%q_segdir'",

          "DELETE FROM %Q.'%q_segdir' WHERE level = ?",
          "DELETE FROM %Q.'%q_segments' WHERE blockid BETWEEN ? AND ?",
          "INSERT INTO %Q.'%q_content' VALUES(%s)",
          "DELETE FROM %Q.'%q_docsize' WHERE docid = ?",
          "REPLACE INTO %Q.'%q_docsize' VALUES(?,?)",
          "SELECT size FROM %Q.'%q_docsize' WHERE docid=?",
          "SELECT value FROM %Q.'%q_stat' WHERE id=0",
          "REPLACE INTO %Q.'%q_stat' VALUES(0,?)",
  };
  int rc = 0;
  sqlite3_stmt *pStmt;

  ((void) (0));
  ((void) (0));

  pStmt = p->aStmt[eStmt];
  if( !pStmt ){
    char *zSql;
    if( eStmt==18 ){
      zSql = sqlite3_mprintf(azSql[eStmt], p->zDb, p->zName, p->zWriteExprlist);
    }else if( eStmt==7 ){
      zSql = sqlite3_mprintf(azSql[eStmt], p->zReadExprlist, p->zDb, p->zName);
    }else{
      zSql = sqlite3_mprintf(azSql[eStmt], p->zDb, p->zName);
    }
    if( !zSql ){
      rc = 7;
    }else{
      rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, ((void*)0));
      sqlite3_free(zSql);
      ((void) (0));
      p->aStmt[eStmt] = pStmt;
    }
  }
  if( apVal ){
    int i;
    int nParam = sqlite3_bind_parameter_count(pStmt);
    for(i=0; rc==0 && i<nParam; i++){
      rc = sqlite3_bind_value(pStmt, i+1, apVal[i]);
    }
  }
  *pp = pStmt;
  return rc;
}

static int fts3SelectDocsize(
  Fts3Table *pTab,
  int eStmt,
  sqlite3_int64 iDocid,
  sqlite3_stmt **ppStmt
){
  sqlite3_stmt *pStmt = 0;
  int rc;

  ((void) (0));

  rc = fts3SqlStmt(pTab, eStmt, &pStmt, 0);
  if( rc==0 ){
    if( eStmt==21 ){
      sqlite3_bind_int64(pStmt, 1, iDocid);
    }
    rc = sqlite3_step(pStmt);
    if( rc!=100 || sqlite3_column_type(pStmt, 0)!=4 ){
      rc = sqlite3_reset(pStmt);
      if( rc==0 ) rc = 11;
      pStmt = 0;
    }else{
      rc = 0;
    }
  }

  *ppStmt = pStmt;
  return rc;
}

static int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,
  sqlite3_stmt **ppStmt
){
  return fts3SelectDocsize(pTab, 22, 0, ppStmt);
}

static int sqlite3Fts3SelectDocsize(
  Fts3Table *pTab,
  sqlite3_int64 iDocid,
  sqlite3_stmt **ppStmt
){
  return fts3SelectDocsize(pTab, 21, iDocid, ppStmt);
}
# 117951 "ext/sqlite3/libsqlite/sqlite3.c"
static void fts3SqlExec(
  int *pRC,
  Fts3Table *p,
  int eStmt,
  sqlite3_value **apVal
){
  sqlite3_stmt *pStmt;
  int rc;
  if( *pRC ) return;
  rc = fts3SqlStmt(p, eStmt, &pStmt, apVal);
  if( rc==0 ){
    sqlite3_step(pStmt);
    rc = sqlite3_reset(pStmt);
  }
  *pRC = rc;
}
# 117986 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Fts3ReadLock(Fts3Table *p){
  int rc;
  sqlite3_stmt *pStmt;

  rc = fts3SqlStmt(p, 7, &pStmt, 0);
  if( rc==0 ){
    sqlite3_bind_null(pStmt, 1);
    sqlite3_step(pStmt);
    rc = sqlite3_reset(pStmt);
  }
  return rc;
}
# 118016 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Fts3AllSegdirs(Fts3Table *p, int iLevel, sqlite3_stmt **ppStmt){
  int rc;
  sqlite3_stmt *pStmt = 0;
  if( iLevel<0 ){
    rc = fts3SqlStmt(p, 13, &pStmt, 0);
  }else{
    rc = fts3SqlStmt(p, 12, &pStmt, 0);
    if( rc==0 ) sqlite3_bind_int(pStmt, 1, iLevel);
  }
  *ppStmt = pStmt;
  return rc;
}
# 118042 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3PendingListAppendVarint(
  PendingList **pp,
  sqlite3_int64 i
){
  PendingList *p = *pp;


  if( !p ){
    p = sqlite3_malloc(sizeof(*p) + 100);
    if( !p ){
      return 7;
    }
    p->nSpace = 100;
    p->aData = (char *)&p[1];
    p->nData = 0;
  }
  else if( p->nData+10 +1>p->nSpace ){
    int nNew = p->nSpace * 2;
    p = sqlite3_realloc(p, sizeof(*p) + nNew);
    if( !p ){
      sqlite3_free(*pp);
      *pp = 0;
      return 7;
    }
    p->nSpace = nNew;
    p->aData = (char *)&p[1];
  }


  p->nData += sqlite3Fts3PutVarint(&p->aData[p->nData], i);
  p->aData[p->nData] = '\0';
  *pp = p;
  return 0;
}
# 118086 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3PendingListAppend(
  PendingList **pp,
  sqlite3_int64 iDocid,
  sqlite3_int64 iCol,
  sqlite3_int64 iPos,
  int *pRc
){
  PendingList *p = *pp;
  int rc = 0;

  ((void) (0));

  if( !p || p->iLastDocid!=iDocid ){
    sqlite3_int64 iDelta = iDocid - (p ? p->iLastDocid : 0);
    if( p ){
      ((void) (0));
      ((void) (0));
      p->nData++;
    }
    if( 0!=(rc = fts3PendingListAppendVarint(&p, iDelta)) ){
      goto pendinglistappend_out;
    }
    p->iLastCol = -1;
    p->iLastPos = 0;
    p->iLastDocid = iDocid;
  }
  if( iCol>0 && p->iLastCol!=iCol ){
    if( 0!=(rc = fts3PendingListAppendVarint(&p, 1))
     || 0!=(rc = fts3PendingListAppendVarint(&p, iCol))
    ){
      goto pendinglistappend_out;
    }
    p->iLastCol = iCol;
    p->iLastPos = 0;
  }
  if( iCol>=0 ){
    ((void) (0));
    rc = fts3PendingListAppendVarint(&p, 2+iPos-p->iLastPos);
    if( rc==0 ){
      p->iLastPos = iPos;
    }
  }

 pendinglistappend_out:
  *pRc = rc;
  if( p!=*pp ){
    *pp = p;
    return 1;
  }
  return 0;
}
# 118145 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3PendingTermsAdd(
  Fts3Table *p,
  const char *zText,
  int iCol,
  u32 *pnWord
){
  int rc;
  int iStart;
  int iEnd;
  int iPos;
  int nWord = 0;

  char const *zToken;
  int nToken;

  sqlite3_tokenizer *pTokenizer = p->pTokenizer;
  sqlite3_tokenizer_module const *pModule = pTokenizer->pModule;
  sqlite3_tokenizer_cursor *pCsr;
  int (*xNext)(sqlite3_tokenizer_cursor *pCursor,
      const char**,int*,int*,int*,int*);

  ((void) (0));

  rc = pModule->xOpen(pTokenizer, zText, -1, &pCsr);
  if( rc!=0 ){
    return rc;
  }
  pCsr->pTokenizer = pTokenizer;

  xNext = pModule->xNext;
  while( 0==rc
      && 0==(rc = xNext(pCsr, &zToken, &nToken, &iStart, &iEnd, &iPos))
  ){
    PendingList *pList;

    if( iPos>=nWord ) nWord = iPos+1;




    if( iPos<0 || !zToken || nToken<=0 ){
      rc = 1;
      break;
    }

    pList = (PendingList *)sqlite3Fts3HashFind(&p->pendingTerms, zToken, nToken);
    if( pList ){
      p->nPendingData -= (pList->nData + nToken + sizeof(Fts3HashElem));
    }
    if( fts3PendingListAppend(&pList, p->iPrevDocid, iCol, iPos, &rc) ){
      if( pList==sqlite3Fts3HashInsert(&p->pendingTerms, zToken, nToken, pList) ){



        ((void) (0));
        sqlite3_free(pList);
        rc = 7;
      }
    }
    if( rc==0 ){
      p->nPendingData += (pList->nData + nToken + sizeof(Fts3HashElem));
    }
  }

  pModule->xClose(pCsr);
  *pnWord = nWord;
  return (rc==101 ? 0 : rc);
}






static int fts3PendingTermsDocid(Fts3Table *p, sqlite_int64 iDocid){






  if( iDocid<=p->iPrevDocid || p->nPendingData>p->nMaxPendingData ){
    int rc = sqlite3Fts3PendingTermsFlush(p);
    if( rc!=0 ) return rc;
  }
  p->iPrevDocid = iDocid;
  return 0;
}




static void sqlite3Fts3PendingTermsClear(Fts3Table *p){
  Fts3HashElem *pElem;
  for(pElem=((&p->pendingTerms)->first); pElem; pElem=((pElem)->next)){
    sqlite3_free(((pElem)->data));
  }
  sqlite3Fts3HashClear(&p->pendingTerms);
  p->nPendingData = 0;
}
# 118254 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3InsertTerms(Fts3Table *p, sqlite3_value **apVal, u32 *aSz){
  int i;
  for(i=2; i<p->nColumn+2; i++){
    const char *zText = (const char *)sqlite3_value_text(apVal[i]);
    if( zText ){
      int rc = fts3PendingTermsAdd(p, zText, i-2, &aSz[i-2]);
      if( rc!=0 ){
        return rc;
      }
    }
    aSz[p->nColumn] += sqlite3_value_bytes(apVal[i]);
  }
  return 0;
}
# 118282 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3InsertData(
  Fts3Table *p,
  sqlite3_value **apVal,
  sqlite3_int64 *piDocid
){
  int rc;
  sqlite3_stmt *pContentInsert;
# 118298 "ext/sqlite3/libsqlite/sqlite3.c"
  rc = fts3SqlStmt(p, 18, &pContentInsert, &apVal[1]);
  if( rc!=0 ){
    return rc;
  }
# 118313 "ext/sqlite3/libsqlite/sqlite3.c"
  if( 5!=sqlite3_value_type(apVal[3+p->nColumn]) ){
    if( 5==sqlite3_value_type(apVal[0])
     && 5!=sqlite3_value_type(apVal[1])
    ){

      return 1;
    }
    rc = sqlite3_bind_value(pContentInsert, 1, apVal[3+p->nColumn]);
    if( rc!=0 ) return rc;
  }




  sqlite3_step(pContentInsert);
  rc = sqlite3_reset(pContentInsert);

  *piDocid = sqlite3_last_insert_rowid(p->db);
  return rc;
}







static int fts3DeleteAll(Fts3Table *p){
  int rc = 0;


  sqlite3Fts3PendingTermsClear(p);


  fts3SqlExec(&rc, p, 2, 0);
  fts3SqlExec(&rc, p, 3, 0);
  fts3SqlExec(&rc, p, 4, 0);
  if( p->bHasDocsize ){
    fts3SqlExec(&rc, p, 5, 0);
  }
  if( p->bHasStat ){
    fts3SqlExec(&rc, p, 6, 0);
  }
  return rc;
}






static void fts3DeleteTerms(
  int *pRC,
  Fts3Table *p,
  sqlite3_value **apVal,
  u32 *aSz
){
  int rc;
  sqlite3_stmt *pSelect;

  if( *pRC ) return;
  rc = fts3SqlStmt(p, 7, &pSelect, apVal);
  if( rc==0 ){
    if( 100==sqlite3_step(pSelect) ){
      int i;
      for(i=1; i<=p->nColumn; i++){
        const char *zText = (const char *)sqlite3_column_text(pSelect, i);
        rc = fts3PendingTermsAdd(p, zText, -1, &aSz[i-1]);
        if( rc!=0 ){
          sqlite3_reset(pSelect);
          *pRC = rc;
          return;
        }
        aSz[p->nColumn] += sqlite3_column_bytes(pSelect, i);
      }
    }
    rc = sqlite3_reset(pSelect);
  }else{
    sqlite3_reset(pSelect);
  }
  *pRC = rc;
}





static int fts3SegmentMerge(Fts3Table *, int);
# 118417 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3AllocateSegdirIdx(Fts3Table *p, int iLevel, int *piIdx){
  int rc;
  sqlite3_stmt *pNextIdx;
  int iNext = 0;


  rc = fts3SqlStmt(p, 8, &pNextIdx, 0);
  if( rc==0 ){
    sqlite3_bind_int(pNextIdx, 1, iLevel);
    if( 100==sqlite3_step(pNextIdx) ){
      iNext = sqlite3_column_int(pNextIdx, 0);
    }
    rc = sqlite3_reset(pNextIdx);
  }

  if( rc==0 ){





    if( iNext>=16 ){
      rc = fts3SegmentMerge(p, iLevel);
      *piIdx = 0;
    }else{
      *piIdx = iNext;
    }
  }

  return rc;
}
# 118476 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Fts3ReadBlock(
  Fts3Table *p,
  sqlite3_int64 iBlockid,
  char **paBlob,
  int *pnBlob
){
  int rc;


  ((void) (0));

  if( p->pSegments ){
    rc = sqlite3_blob_reopen(p->pSegments, iBlockid);
  }else{
    if( 0==p->zSegmentsTbl ){
      p->zSegmentsTbl = sqlite3_mprintf("%s_segments", p->zName);
      if( 0==p->zSegmentsTbl ) return 7;
    }
    rc = sqlite3_blob_open(
       p->db, p->zDb, p->zSegmentsTbl, "block", iBlockid, 0, &p->pSegments
    );
  }

  if( rc==0 ){
    int nByte = sqlite3_blob_bytes(p->pSegments);
    if( paBlob ){
      char *aByte = sqlite3_malloc(nByte + (10*2));
      if( !aByte ){
        rc = 7;
      }else{
        rc = sqlite3_blob_read(p->pSegments, aByte, nByte, 0);
        memset(&aByte[nByte], 0, (10*2));
        if( rc!=0 ){
          sqlite3_free(aByte);
          aByte = 0;
        }
      }
      *paBlob = aByte;
    }
    *pnBlob = nByte;
  }

  return rc;
}





static void sqlite3Fts3SegmentsClose(Fts3Table *p){
  sqlite3_blob_close(p->pSegments);
  p->pSegments = 0;
}






static int fts3SegReaderNext(Fts3Table *p, Fts3SegReader *pReader){
  char *pNext;
  int nPrefix;
  int nSuffix;

  if( !pReader->aDoclist ){
    pNext = pReader->aNode;
  }else{
    pNext = &pReader->aDoclist[pReader->nDoclist];
  }

  if( !pNext || pNext>=&pReader->aNode[pReader->nNode] ){
    int rc;

    if( ((pReader)->ppNextElem!=0) ){
      Fts3HashElem *pElem = *(pReader->ppNextElem);
      if( pElem==0 ){
        pReader->aNode = 0;
      }else{
        PendingList *pList = (PendingList *)((pElem)->data);
        pReader->zTerm = (char *)((pElem)->pKey);
        pReader->nTerm = ((pElem)->nKey);
        pReader->nNode = pReader->nDoclist = pList->nData + 1;
        pReader->aNode = pReader->aDoclist = pList->aData;
        pReader->ppNextElem++;
        ((void) (0));
      }
      return 0;
    }

    if( !((pReader)->aNode==(char *)&(pReader)[1]) ){
      sqlite3_free(pReader->aNode);
    }
    pReader->aNode = 0;



    ((void) (0));
    if( pReader->iCurrentBlock>=pReader->iLeafEndBlock ){
      return 0;
    }

    rc = sqlite3Fts3ReadBlock(
        p, ++pReader->iCurrentBlock, &pReader->aNode, &pReader->nNode
    );
    if( rc!=0 ) return rc;
    pNext = pReader->aNode;
  }




  pNext += sqlite3Fts3GetVarint32(pNext, &nPrefix);
  pNext += sqlite3Fts3GetVarint32(pNext, &nSuffix);
  if( nPrefix<0 || nSuffix<=0
   || &pNext[nSuffix]>&pReader->aNode[pReader->nNode]
  ){
    return 11;
  }

  if( nPrefix+nSuffix>pReader->nTermAlloc ){
    int nNew = (nPrefix+nSuffix)*2;
    char *zNew = sqlite3_realloc(pReader->zTerm, nNew);
    if( !zNew ){
      return 7;
    }
    pReader->zTerm = zNew;
    pReader->nTermAlloc = nNew;
  }
  memcpy(&pReader->zTerm[nPrefix], pNext, nSuffix);
  pReader->nTerm = nPrefix+nSuffix;
  pNext += nSuffix;
  pNext += sqlite3Fts3GetVarint32(pNext, &pReader->nDoclist);
  pReader->aDoclist = pNext;
  pReader->pOffsetList = 0;





  if( &pReader->aDoclist[pReader->nDoclist]>&pReader->aNode[pReader->nNode]
   || pReader->aDoclist[pReader->nDoclist-1]
  ){
    return 11;
  }
  return 0;
}





static void fts3SegReaderFirstDocid(Fts3SegReader *pReader){
  int n;
  ((void) (0));
  ((void) (0));
  n = sqlite3Fts3GetVarint(pReader->aDoclist, &pReader->iDocid);
  pReader->pOffsetList = &pReader->aDoclist[n];
}
# 118645 "ext/sqlite3/libsqlite/sqlite3.c"
static void fts3SegReaderNextDocid(
  Fts3SegReader *pReader,
  char **ppOffsetList,
  int *pnOffsetList
){
  char *p = pReader->pOffsetList;
  char c = 0;





  while( *p | c ) c = *p++ & 0x80;
  p++;




  if( ppOffsetList ){
    *ppOffsetList = pReader->pOffsetList;
    *pnOffsetList = (int)(p - pReader->pOffsetList - 1);
  }






  if( p>=&pReader->aDoclist[pReader->nDoclist] ){
    pReader->pOffsetList = 0;
  }else{
    sqlite3_int64 iDelta;
    pReader->pOffsetList = p + sqlite3Fts3GetVarint(p, &iDelta);
    pReader->iDocid += iDelta;
  }
}
# 118692 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Fts3SegReaderCost(
  Fts3Cursor *pCsr,
  Fts3SegReader *pReader,
  int *pnCost
){
  Fts3Table *p = (Fts3Table*)pCsr->base.pVtab;
  int rc = 0;
  int nCost = 0;
  int pgsz = p->nPgsz;





  if( p->bHasStat
   && !((pReader)->ppNextElem!=0)
   && !((pReader)->aNode==(char *)&(pReader)[1])
  ){
    int nBlob = 0;
    sqlite3_int64 iBlock;

    if( pCsr->nRowAvg==0 ){
# 118725 "ext/sqlite3/libsqlite/sqlite3.c"
      sqlite3_stmt *pStmt;
      sqlite3_int64 nDoc = 0;
      sqlite3_int64 nByte = 0;
      const char *pEnd;
      const char *a;

      rc = sqlite3Fts3SelectDoctotal(p, &pStmt);
      if( rc!=0 ) return rc;
      a = sqlite3_column_blob(pStmt, 0);
      ((void) (0));

      pEnd = &a[sqlite3_column_bytes(pStmt, 0)];
      a += sqlite3Fts3GetVarint(a, &nDoc);
      while( a<pEnd ){
        a += sqlite3Fts3GetVarint(a, &nByte);
      }
      if( nDoc==0 || nByte==0 ){
        sqlite3_reset(pStmt);
        return 11;
      }

      pCsr->nRowAvg = (int)(((nByte / nDoc) + pgsz) / pgsz);
      ((void) (0));
      rc = sqlite3_reset(pStmt);
      if( rc!=0 ) return rc;
    }





    for(iBlock=pReader->iStartBlock; iBlock<=pReader->iLeafEndBlock; iBlock++){
      rc = sqlite3Fts3ReadBlock(p, iBlock, 0, &nBlob);
      if( rc!=0 ) break;
      if( (nBlob+35)>pgsz ){
        int nOvfl = (nBlob + 34)/pgsz;
        nCost += ((nOvfl + pCsr->nRowAvg - 1)/pCsr->nRowAvg);
      }
    }
  }

  *pnCost += nCost;
  return rc;
}





static void sqlite3Fts3SegReaderFree(Fts3SegReader *pReader){
  if( pReader && !((pReader)->ppNextElem!=0) ){
    sqlite3_free(pReader->zTerm);
    if( !((pReader)->aNode==(char *)&(pReader)[1]) ){
      sqlite3_free(pReader->aNode);
    }
  }
  sqlite3_free(pReader);
}




static int sqlite3Fts3SegReaderNew(
  int iAge,
  sqlite3_int64 iStartLeaf,
  sqlite3_int64 iEndLeaf,
  sqlite3_int64 iEndBlock,
  const char *zRoot,
  int nRoot,
  Fts3SegReader **ppReader
){
  int rc = 0;
  Fts3SegReader *pReader;
  int nExtra = 0;

  ((void) (0));
  if( iStartLeaf==0 ){
    nExtra = nRoot + (10*2);
  }

  pReader = (Fts3SegReader *)sqlite3_malloc(sizeof(Fts3SegReader) + nExtra);
  if( !pReader ){
    return 7;
  }
  memset(pReader, 0, sizeof(Fts3SegReader));
  pReader->iIdx = iAge;
  pReader->iStartBlock = iStartLeaf;
  pReader->iLeafEndBlock = iEndLeaf;
  pReader->iEndBlock = iEndBlock;

  if( nExtra ){

    pReader->aNode = (char *)&pReader[1];
    pReader->nNode = nRoot;
    memcpy(pReader->aNode, zRoot, nRoot);
    memset(&pReader->aNode[nRoot], 0, (10*2));
  }else{
    pReader->iCurrentBlock = iStartLeaf-1;
  }

  if( rc==0 ){
    *ppReader = pReader;
  }else{
    sqlite3Fts3SegReaderFree(pReader);
  }
  return rc;
}






static int fts3CompareElemByTerm(const void *lhs, const void *rhs){
  char *z1 = ((*(Fts3HashElem **)lhs)->pKey);
  char *z2 = ((*(Fts3HashElem **)rhs)->pKey);
  int n1 = ((*(Fts3HashElem **)lhs)->nKey);
  int n2 = ((*(Fts3HashElem **)rhs)->nKey);

  int n = (n1<n2 ? n1 : n2);
  int c = memcmp(z1, z2, n);
  if( c==0 ){
    c = n1 - n2;
  }
  return c;
}





static int sqlite3Fts3SegReaderPending(
  Fts3Table *p,
  const char *zTerm,
  int nTerm,
  int isPrefix,
  Fts3SegReader **ppReader
){
  Fts3SegReader *pReader = 0;
  Fts3HashElem **aElem = 0;
  int nElem = 0;
  int rc = 0;

  if( isPrefix ){
    int nAlloc = 0;
    Fts3HashElem *pE = 0;

    for(pE=((&p->pendingTerms)->first); pE; pE=((pE)->next)){
      char *zKey = (char *)((pE)->pKey);
      int nKey = ((pE)->nKey);
      if( nTerm==0 || (nKey>=nTerm && 0==memcmp(zKey, zTerm, nTerm)) ){
        if( nElem==nAlloc ){
          Fts3HashElem **aElem2;
          nAlloc += 16;
          aElem2 = (Fts3HashElem **)sqlite3_realloc(
              aElem, nAlloc*sizeof(Fts3HashElem *)
          );
          if( !aElem2 ){
            rc = 7;
            nElem = 0;
            break;
          }
          aElem = aElem2;
        }
        aElem[nElem++] = pE;
      }
    }





    if( nElem>1 ){
      qsort(aElem, nElem, sizeof(Fts3HashElem *), fts3CompareElemByTerm);
    }

  }else{
    Fts3HashElem *pE = sqlite3Fts3HashFindElem(&p->pendingTerms, zTerm, nTerm);
    if( pE ){
      aElem = &pE;
      nElem = 1;
    }
  }

  if( nElem>0 ){
    int nByte = sizeof(Fts3SegReader) + (nElem+1)*sizeof(Fts3HashElem *);
    pReader = (Fts3SegReader *)sqlite3_malloc(nByte);
    if( !pReader ){
      rc = 7;
    }else{
      memset(pReader, 0, nByte);
      pReader->iIdx = 0x7FFFFFFF;
      pReader->ppNextElem = (Fts3HashElem **)&pReader[1];
      memcpy(pReader->ppNextElem, aElem, nElem*sizeof(Fts3HashElem *));
    }
  }

  if( isPrefix ){
    sqlite3_free(aElem);
  }
  *ppReader = pReader;
  return rc;
}
# 118941 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3SegReaderCmp(Fts3SegReader *pLhs, Fts3SegReader *pRhs){
  int rc;
  if( pLhs->aNode && pRhs->aNode ){
    int rc2 = pLhs->nTerm - pRhs->nTerm;
    if( rc2<0 ){
      rc = memcmp(pLhs->zTerm, pRhs->zTerm, pLhs->nTerm);
    }else{
      rc = memcmp(pLhs->zTerm, pRhs->zTerm, pRhs->nTerm);
    }
    if( rc==0 ){
      rc = rc2;
    }
  }else{
    rc = (pLhs->aNode==0) - (pRhs->aNode==0);
  }
  if( rc==0 ){
    rc = pRhs->iIdx - pLhs->iIdx;
  }
  ((void) (0));
  return rc;
}
# 118974 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3SegReaderDoclistCmp(Fts3SegReader *pLhs, Fts3SegReader *pRhs){
  int rc = (pLhs->pOffsetList==0)-(pRhs->pOffsetList==0);
  if( rc==0 ){
    if( pLhs->iDocid==pRhs->iDocid ){
      rc = pRhs->iIdx - pLhs->iIdx;
    }else{
      rc = (pLhs->iDocid > pRhs->iDocid) ? 1 : -1;
    }
  }
  ((void) (0));
  return rc;
}
# 118995 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3SegReaderTermCmp(
  Fts3SegReader *pSeg,
  const char *zTerm,
  int nTerm
){
  int res = 0;
  if( pSeg->aNode ){
    if( pSeg->nTerm>nTerm ){
      res = memcmp(pSeg->zTerm, zTerm, nTerm);
    }else{
      res = memcmp(pSeg->zTerm, zTerm, pSeg->nTerm);
    }
    if( res==0 ){
      res = pSeg->nTerm-nTerm;
    }
  }
  return res;
}







static void fts3SegReaderSort(
  Fts3SegReader **apSegment,
  int nSegment,
  int nSuspect,
  int (*xCmp)(Fts3SegReader *, Fts3SegReader *)
){
  int i;

  ((void) (0));

  if( nSuspect==nSegment ) nSuspect--;
  for(i=nSuspect-1; i>=0; i--){
    int j;
    for(j=i; j<(nSegment-1); j++){
      Fts3SegReader *pTmp;
      if( xCmp(apSegment[j], apSegment[j+1])<0 ) break;
      pTmp = apSegment[j+1];
      apSegment[j+1] = apSegment[j];
      apSegment[j] = pTmp;
    }
  }







}




static int fts3WriteSegment(
  Fts3Table *p,
  sqlite3_int64 iBlock,
  char *z,
  int n
){
  sqlite3_stmt *pStmt;
  int rc = fts3SqlStmt(p, 9, &pStmt, 0);
  if( rc==0 ){
    sqlite3_bind_int64(pStmt, 1, iBlock);
    sqlite3_bind_blob(pStmt, 2, z, n, ((sqlite3_destructor_type)0));
    sqlite3_step(pStmt);
    rc = sqlite3_reset(pStmt);
  }
  return rc;
}




static int fts3WriteSegdir(
  Fts3Table *p,
  int iLevel,
  int iIdx,
  sqlite3_int64 iStartBlock,
  sqlite3_int64 iLeafEndBlock,
  sqlite3_int64 iEndBlock,
  char *zRoot,
  int nRoot
){
  sqlite3_stmt *pStmt;
  int rc = fts3SqlStmt(p, 11, &pStmt, 0);
  if( rc==0 ){
    sqlite3_bind_int(pStmt, 1, iLevel);
    sqlite3_bind_int(pStmt, 2, iIdx);
    sqlite3_bind_int64(pStmt, 3, iStartBlock);
    sqlite3_bind_int64(pStmt, 4, iLeafEndBlock);
    sqlite3_bind_int64(pStmt, 5, iEndBlock);
    sqlite3_bind_blob(pStmt, 6, zRoot, nRoot, ((sqlite3_destructor_type)0));
    sqlite3_step(pStmt);
    rc = sqlite3_reset(pStmt);
  }
  return rc;
}
# 119106 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3PrefixCompress(
  const char *zPrev,
  int nPrev,
  const char *zNext,
  int nNext
){
  int n;
  (void)(nNext);
  for(n=0; n<nPrev && zPrev[n]==zNext[n]; n++);
  return n;
}





static int fts3NodeAddTerm(
  Fts3Table *p,
  SegmentNode **ppTree,
  int isCopyTerm,
  const char *zTerm,
  int nTerm
){
  SegmentNode *pTree = *ppTree;
  int rc;
  SegmentNode *pNew;




  if( pTree ){
    int nData = pTree->nData;
    int nReq = nData;
    int nPrefix;
    int nSuffix;

    nPrefix = fts3PrefixCompress(pTree->zTerm, pTree->nTerm, zTerm, nTerm);
    nSuffix = nTerm-nPrefix;

    nReq += sqlite3Fts3VarintLen(nPrefix)+sqlite3Fts3VarintLen(nSuffix)+nSuffix;
    if( nReq<=p->nNodeSize || !pTree->zTerm ){

      if( nReq>p->nNodeSize ){







        ((void) (0));
        pTree->aData = (char *)sqlite3_malloc(nReq);
        if( !pTree->aData ){
          return 7;
        }
      }

      if( pTree->zTerm ){

        nData += sqlite3Fts3PutVarint(&pTree->aData[nData], nPrefix);
      }

      nData += sqlite3Fts3PutVarint(&pTree->aData[nData], nSuffix);
      memcpy(&pTree->aData[nData], &zTerm[nPrefix], nSuffix);
      pTree->nData = nData + nSuffix;
      pTree->nEntry++;

      if( isCopyTerm ){
        if( pTree->nMalloc<nTerm ){
          char *zNew = sqlite3_realloc(pTree->zMalloc, nTerm*2);
          if( !zNew ){
            return 7;
          }
          pTree->nMalloc = nTerm*2;
          pTree->zMalloc = zNew;
        }
        pTree->zTerm = pTree->zMalloc;
        memcpy(pTree->zTerm, zTerm, nTerm);
        pTree->nTerm = nTerm;
      }else{
        pTree->zTerm = (char *)zTerm;
        pTree->nTerm = nTerm;
      }
      return 0;
    }
  }
# 119201 "ext/sqlite3/libsqlite/sqlite3.c"
  pNew = (SegmentNode *)sqlite3_malloc(sizeof(SegmentNode) + p->nNodeSize);
  if( !pNew ){
    return 7;
  }
  memset(pNew, 0, sizeof(SegmentNode));
  pNew->nData = 1 + 10;
  pNew->aData = (char *)&pNew[1];

  if( pTree ){
    SegmentNode *pParent = pTree->pParent;
    rc = fts3NodeAddTerm(p, &pParent, isCopyTerm, zTerm, nTerm);
    if( pTree->pParent==0 ){
      pTree->pParent = pParent;
    }
    pTree->pRight = pNew;
    pNew->pLeftmost = pTree->pLeftmost;
    pNew->pParent = pParent;
    pNew->zMalloc = pTree->zMalloc;
    pNew->nMalloc = pTree->nMalloc;
    pTree->zMalloc = 0;
  }else{
    pNew->pLeftmost = pNew;
    rc = fts3NodeAddTerm(p, &pNew, isCopyTerm, zTerm, nTerm);
  }

  *ppTree = pNew;
  return rc;
}




static int fts3TreeFinishNode(
  SegmentNode *pTree,
  int iHeight,
  sqlite3_int64 iLeftChild
){
  int nStart;
  ((void) (0));
  nStart = 10 - sqlite3Fts3VarintLen(iLeftChild);
  pTree->aData[nStart] = (char)iHeight;
  sqlite3Fts3PutVarint(&pTree->aData[nStart+1], iLeftChild);
  return nStart;
}
# 119259 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3NodeWrite(
  Fts3Table *p,
  SegmentNode *pTree,
  int iHeight,
  sqlite3_int64 iLeaf,
  sqlite3_int64 iFree,
  sqlite3_int64 *piLast,
  char **paRoot,
  int *pnRoot
){
  int rc = 0;

  if( !pTree->pParent ){

    int nStart = fts3TreeFinishNode(pTree, iHeight, iLeaf);
    *piLast = iFree-1;
    *pnRoot = pTree->nData - nStart;
    *paRoot = &pTree->aData[nStart];
  }else{
    SegmentNode *pIter;
    sqlite3_int64 iNextFree = iFree;
    sqlite3_int64 iNextLeaf = iLeaf;
    for(pIter=pTree->pLeftmost; pIter && rc==0; pIter=pIter->pRight){
      int nStart = fts3TreeFinishNode(pIter, iHeight, iNextLeaf);
      int nWrite = pIter->nData - nStart;

      rc = fts3WriteSegment(p, iNextFree, &pIter->aData[nStart], nWrite);
      iNextFree++;
      iNextLeaf += (pIter->nEntry+1);
    }
    if( rc==0 ){
      ((void) (0));
      rc = fts3NodeWrite(
          p, pTree->pParent, iHeight+1, iFree, iNextFree, piLast, paRoot, pnRoot
      );
    }
  }

  return rc;
}




static void fts3NodeFree(SegmentNode *pTree){
  if( pTree ){
    SegmentNode *p = pTree->pLeftmost;
    fts3NodeFree(p->pParent);
    while( p ){
      SegmentNode *pRight = p->pRight;
      if( p->aData!=(char *)&p[1] ){
        sqlite3_free(p->aData);
      }
      ((void) (0));
      sqlite3_free(p->zMalloc);
      sqlite3_free(p);
      p = pRight;
    }
  }
}
# 119328 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3SegWriterAdd(
  Fts3Table *p,
  SegmentWriter **ppWriter,
  int isCopyTerm,
  const char *zTerm,
  int nTerm,
  const char *aDoclist,
  int nDoclist
){
  int nPrefix;
  int nSuffix;
  int nReq;
  int nData;
  SegmentWriter *pWriter = *ppWriter;

  if( !pWriter ){
    int rc;
    sqlite3_stmt *pStmt;


    pWriter = (SegmentWriter *)sqlite3_malloc(sizeof(SegmentWriter));
    if( !pWriter ) return 7;
    memset(pWriter, 0, sizeof(SegmentWriter));
    *ppWriter = pWriter;


    pWriter->aData = (char *)sqlite3_malloc(p->nNodeSize);
    if( !pWriter->aData ) return 7;
    pWriter->nSize = p->nNodeSize;


    rc = fts3SqlStmt(p, 10, &pStmt, 0);
    if( rc!=0 ) return rc;
    if( 100==sqlite3_step(pStmt) ){
      pWriter->iFree = sqlite3_column_int64(pStmt, 0);
      pWriter->iFirst = pWriter->iFree;
    }
    rc = sqlite3_reset(pStmt);
    if( rc!=0 ) return rc;
  }
  nData = pWriter->nData;

  nPrefix = fts3PrefixCompress(pWriter->zTerm, pWriter->nTerm, zTerm, nTerm);
  nSuffix = nTerm-nPrefix;


  nReq = sqlite3Fts3VarintLen(nPrefix) +
    sqlite3Fts3VarintLen(nSuffix) +
    nSuffix +
    sqlite3Fts3VarintLen(nDoclist) +
    nDoclist;

  if( nData>0 && nData+nReq>p->nNodeSize ){
    int rc;


    rc = fts3WriteSegment(p, pWriter->iFree++, pWriter->aData, nData);
    if( rc!=0 ) return rc;
# 119399 "ext/sqlite3/libsqlite/sqlite3.c"
    ((void) (0));
    rc = fts3NodeAddTerm(p, &pWriter->pTree, isCopyTerm, zTerm, nPrefix+1);
    if( rc!=0 ) return rc;

    nData = 0;
    pWriter->nTerm = 0;

    nPrefix = 0;
    nSuffix = nTerm;
    nReq = 1 +
      sqlite3Fts3VarintLen(nTerm) +
      nTerm +
      sqlite3Fts3VarintLen(nDoclist) +
      nDoclist;
  }




  if( nReq>pWriter->nSize ){
    char *aNew = sqlite3_realloc(pWriter->aData, nReq);
    if( !aNew ) return 7;
    pWriter->aData = aNew;
    pWriter->nSize = nReq;
  }
  ((void) (0));


  nData += sqlite3Fts3PutVarint(&pWriter->aData[nData], nPrefix);
  nData += sqlite3Fts3PutVarint(&pWriter->aData[nData], nSuffix);
  memcpy(&pWriter->aData[nData], &zTerm[nPrefix], nSuffix);
  nData += nSuffix;
  nData += sqlite3Fts3PutVarint(&pWriter->aData[nData], nDoclist);
  memcpy(&pWriter->aData[nData], aDoclist, nDoclist);
  pWriter->nData = nData + nDoclist;






  if( isCopyTerm ){
    if( nTerm>pWriter->nMalloc ){
      char *zNew = sqlite3_realloc(pWriter->zMalloc, nTerm*2);
      if( !zNew ){
        return 7;
      }
      pWriter->nMalloc = nTerm*2;
      pWriter->zMalloc = zNew;
      pWriter->zTerm = zNew;
    }
    ((void) (0));
    memcpy(pWriter->zTerm, zTerm, nTerm);
  }else{
    pWriter->zTerm = (char *)zTerm;
  }
  pWriter->nTerm = nTerm;

  return 0;
}







static int fts3SegWriterFlush(
  Fts3Table *p,
  SegmentWriter *pWriter,
  int iLevel,
  int iIdx
){
  int rc;
  if( pWriter->pTree ){
    sqlite3_int64 iLast = 0;
    sqlite3_int64 iLastLeaf;
    char *zRoot = ((void*)0);
    int nRoot = 0;

    iLastLeaf = pWriter->iFree;
    rc = fts3WriteSegment(p, pWriter->iFree++, pWriter->aData, pWriter->nData);
    if( rc==0 ){
      rc = fts3NodeWrite(p, pWriter->pTree, 1,
          pWriter->iFirst, pWriter->iFree, &iLast, &zRoot, &nRoot);
    }
    if( rc==0 ){
      rc = fts3WriteSegdir(
          p, iLevel, iIdx, pWriter->iFirst, iLastLeaf, iLast, zRoot, nRoot);
    }
  }else{

    rc = fts3WriteSegdir(
        p, iLevel, iIdx, 0, 0, 0, pWriter->aData, pWriter->nData);
  }
  return rc;
}





static void fts3SegWriterFree(SegmentWriter *pWriter){
  if( pWriter ){
    sqlite3_free(pWriter->aData);
    sqlite3_free(pWriter->zMalloc);
    fts3NodeFree(pWriter->pTree);
    sqlite3_free(pWriter);
  }
}
# 119520 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3IsEmpty(Fts3Table *p, sqlite3_value **apVal, int *pisEmpty){
  sqlite3_stmt *pStmt;
  int rc;
  rc = fts3SqlStmt(p, 1, &pStmt, apVal);
  if( rc==0 ){
    if( 100==sqlite3_step(pStmt) ){
      *pisEmpty = sqlite3_column_int(pStmt, 0);
    }
    rc = sqlite3_reset(pStmt);
  }
  return rc;
}
# 119540 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3SegmentCountMax(Fts3Table *p, int *pnSegment, int *pnMax){
  sqlite3_stmt *pStmt;
  int rc;

  rc = fts3SqlStmt(p, 15, &pStmt, 0);
  if( rc!=0 ) return rc;
  if( 100==sqlite3_step(pStmt) ){
    *pnSegment = sqlite3_column_int(pStmt, 0);
    *pnMax = sqlite3_column_int(pStmt, 1);
  }
  return sqlite3_reset(pStmt);
}
# 119567 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3DeleteSegdir(
  Fts3Table *p,
  int iLevel,
  Fts3SegReader **apSegment,
  int nReader
){
  int rc;
  int i;
  sqlite3_stmt *pDelete;

  rc = fts3SqlStmt(p, 17, &pDelete, 0);
  for(i=0; rc==0 && i<nReader; i++){
    Fts3SegReader *pSegment = apSegment[i];
    if( pSegment->iStartBlock ){
      sqlite3_bind_int64(pDelete, 1, pSegment->iStartBlock);
      sqlite3_bind_int64(pDelete, 2, pSegment->iEndBlock);
      sqlite3_step(pDelete);
      rc = sqlite3_reset(pDelete);
    }
  }
  if( rc!=0 ){
    return rc;
  }

  if( iLevel==-2 ){
    fts3SqlExec(&rc, p, 4, 0);
  }else if( iLevel==-1 ){
    sqlite3Fts3PendingTermsClear(p);
  }else{
    ((void) (0));
    rc = fts3SqlStmt(p, 16, &pDelete, 0);
    if( rc==0 ){
      sqlite3_bind_int(pDelete, 1, iLevel);
      sqlite3_step(pDelete);
      rc = sqlite3_reset(pDelete);
    }
  }

  return rc;
}
# 119617 "ext/sqlite3/libsqlite/sqlite3.c"
static void fts3ColumnFilter(
  int iCol,
  char **ppList,
  int *pnList
){
  char *pList = *ppList;
  int nList = *pnList;
  char *pEnd = &pList[nList];
  int iCurrent = 0;
  char *p = pList;

  ((void) (0));
  while( 1 ){
    char c = 0;
    while( p<pEnd && (c | *p)&0xFE ) c = *p++ & 0x80;

    if( iCol==iCurrent ){
      nList = (int)(p - pList);
      break;
    }

    nList -= (int)(p - pList);
    pList = p;
    if( nList==0 ){
      break;
    }
    p = &pList[1];
    p += sqlite3Fts3GetVarint32(p, &iCurrent);
  }

  *ppList = pList;
  *pnList = nList;
}

static int sqlite3Fts3SegReaderStart(
  Fts3Table *p,
  Fts3SegReaderCursor *pCsr,
  Fts3SegFilter *pFilter
){
  int i;


  pCsr->pFilter = pFilter;







  for(i=0; i<pCsr->nSegment; i++){
    int nTerm = pFilter->nTerm;
    const char *zTerm = pFilter->zTerm;
    Fts3SegReader *pSeg = pCsr->apSegment[i];
    do {
      int rc = fts3SegReaderNext(p, pSeg);
      if( rc!=0 ) return rc;
    }while( zTerm && fts3SegReaderTermCmp(pSeg, zTerm, nTerm)<0 );
  }
  fts3SegReaderSort(
      pCsr->apSegment, pCsr->nSegment, pCsr->nSegment, fts3SegReaderCmp);

  return 0;
}

static int sqlite3Fts3SegReaderStep(
  Fts3Table *p,
  Fts3SegReaderCursor *pCsr
){
  int rc = 0;

  int isIgnoreEmpty = (pCsr->pFilter->flags & 0x00000002);
  int isRequirePos = (pCsr->pFilter->flags & 0x00000001);
  int isColFilter = (pCsr->pFilter->flags & 0x00000004);
  int isPrefix = (pCsr->pFilter->flags & 0x00000008);
  int isScan = (pCsr->pFilter->flags & 0x00000010);

  Fts3SegReader **apSegment = pCsr->apSegment;
  int nSegment = pCsr->nSegment;
  Fts3SegFilter *pFilter = pCsr->pFilter;

  if( pCsr->nSegment==0 ) return 0;

  do {
    int nMerge;
    int i;




    for(i=0; i<pCsr->nAdvance; i++){
      rc = fts3SegReaderNext(p, apSegment[i]);
      if( rc!=0 ) return rc;
    }
    fts3SegReaderSort(apSegment, nSegment, pCsr->nAdvance, fts3SegReaderCmp);
    pCsr->nAdvance = 0;


    ((void) (0));
    if( apSegment[0]->aNode==0 ) break;

    pCsr->nTerm = apSegment[0]->nTerm;
    pCsr->zTerm = apSegment[0]->zTerm;
# 119728 "ext/sqlite3/libsqlite/sqlite3.c"
    if( pFilter->zTerm && !isScan ){
      if( pCsr->nTerm<pFilter->nTerm
       || (!isPrefix && pCsr->nTerm>pFilter->nTerm)
       || memcmp(pCsr->zTerm, pFilter->zTerm, pFilter->nTerm)
      ){
        break;
      }
    }

    nMerge = 1;
    while( nMerge<nSegment
        && apSegment[nMerge]->aNode
        && apSegment[nMerge]->nTerm==pCsr->nTerm
        && 0==memcmp(pCsr->zTerm, apSegment[nMerge]->zTerm, pCsr->nTerm)
    ){
      nMerge++;
    }

    ((void) (0));
    if( nMerge==1 && !isIgnoreEmpty ){
      pCsr->aDoclist = apSegment[0]->aDoclist;
      pCsr->nDoclist = apSegment[0]->nDoclist;
      rc = 100;
    }else{
      int nDoclist = 0;
      sqlite3_int64 iPrev = 0;





      for(i=0; i<nMerge; i++){
        fts3SegReaderFirstDocid(apSegment[i]);
      }
      fts3SegReaderSort(apSegment, nMerge, nMerge, fts3SegReaderDoclistCmp);
      while( apSegment[0]->pOffsetList ){
        int j;
        char *pList;
        int nList;
        int nByte;
        sqlite3_int64 iDocid = apSegment[0]->iDocid;
        fts3SegReaderNextDocid(apSegment[0], &pList, &nList);
        j = 1;
        while( j<nMerge
            && apSegment[j]->pOffsetList
            && apSegment[j]->iDocid==iDocid
        ){
          fts3SegReaderNextDocid(apSegment[j], 0, 0);
          j++;
        }

        if( isColFilter ){
          fts3ColumnFilter(pFilter->iCol, &pList, &nList);
        }

        if( !isIgnoreEmpty || nList>0 ){
          nByte = sqlite3Fts3VarintLen(iDocid-iPrev) + (isRequirePos?nList+1:0);
          if( nDoclist+nByte>pCsr->nBuffer ){
            char *aNew;
            pCsr->nBuffer = (nDoclist+nByte)*2;
            aNew = sqlite3_realloc(pCsr->aBuffer, pCsr->nBuffer);
            if( !aNew ){
              return 7;
            }
            pCsr->aBuffer = aNew;
          }
          nDoclist += sqlite3Fts3PutVarint(
              &pCsr->aBuffer[nDoclist], iDocid-iPrev
          );
          iPrev = iDocid;
          if( isRequirePos ){
            memcpy(&pCsr->aBuffer[nDoclist], pList, nList);
            nDoclist += nList;
            pCsr->aBuffer[nDoclist++] = '\0';
          }
        }

        fts3SegReaderSort(apSegment, nMerge, j, fts3SegReaderDoclistCmp);
      }
      if( nDoclist>0 ){
        pCsr->aDoclist = pCsr->aBuffer;
        pCsr->nDoclist = nDoclist;
        rc = 100;
      }
    }
    pCsr->nAdvance = nMerge;
  }while( rc==0 );

  return rc;
}

static void sqlite3Fts3SegReaderFinish(
  Fts3SegReaderCursor *pCsr
){
  if( pCsr ){
    int i;
    for(i=0; i<pCsr->nSegment; i++){
      sqlite3Fts3SegReaderFree(pCsr->apSegment[i]);
    }
    sqlite3_free(pCsr->apSegment);
    sqlite3_free(pCsr->aBuffer);

    pCsr->nSegment = 0;
    pCsr->apSegment = 0;
    pCsr->aBuffer = 0;
  }
}
# 119847 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3SegmentMerge(Fts3Table *p, int iLevel){
  int rc;
  int iIdx = 0;
  int iNewLevel = 0;
  SegmentWriter *pWriter = 0;
  Fts3SegFilter filter;
  Fts3SegReaderCursor csr;

  rc = sqlite3Fts3SegReaderCursor(p, iLevel, 0, 0, 1, 0, &csr);
  if( rc!=0 || csr.nSegment==0 ) goto finished;

  if( iLevel==-2 ){




    int nDummy;
    if( csr.nSegment==1 ){
      rc = 101;
      goto finished;
    }
    rc = fts3SegmentCountMax(p, &nDummy, &iNewLevel);
  }else{




    iNewLevel = iLevel+1;
    rc = fts3AllocateSegdirIdx(p, iNewLevel, &iIdx);
  }
  if( rc!=0 ) goto finished;
  ((void) (0));
  ((void) (0));

  memset(&filter, 0, sizeof(Fts3SegFilter));
  filter.flags = 0x00000001;
  filter.flags |= (iLevel==-2 ? 0x00000002 : 0);

  rc = sqlite3Fts3SegReaderStart(p, &csr, &filter);
  while( 0==rc ){
    rc = sqlite3Fts3SegReaderStep(p, &csr);
    if( rc!=100 ) break;
    rc = fts3SegWriterAdd(p, &pWriter, 1,
        csr.zTerm, csr.nTerm, csr.aDoclist, csr.nDoclist);
  }
  if( rc!=0 ) goto finished;
  ((void) (0));

  rc = fts3DeleteSegdir(p, iLevel, csr.apSegment, csr.nSegment);
  if( rc!=0 ) goto finished;
  rc = fts3SegWriterFlush(p, pWriter, iNewLevel, iIdx);

 finished:
  fts3SegWriterFree(pWriter);
  sqlite3Fts3SegReaderFinish(&csr);
  return rc;
}





static int sqlite3Fts3PendingTermsFlush(Fts3Table *p){
  return fts3SegmentMerge(p, -1);
}




static void fts3EncodeIntArray(
  int N,
  u32 *a,
  char *zBuf,
  int *pNBuf
){
  int i, j;
  for(i=j=0; i<N; i++){
    j += sqlite3Fts3PutVarint(&zBuf[j], (sqlite3_int64)a[i]);
  }
  *pNBuf = j;
}




static void fts3DecodeIntArray(
  int N,
  u32 *a,
  const char *zBuf,
  int nBuf
){
  int i, j;
  (void)(nBuf);
  for(i=j=0; i<N; i++){
    sqlite3_int64 x;
    j += sqlite3Fts3GetVarint(&zBuf[j], &x);
    ((void) (0));
    a[i] = (u32)(x & 0xffffffff);
  }
}






static void fts3InsertDocsize(
  int *pRC,
  Fts3Table *p,
  u32 *aSz
){
  char *pBlob;
  int nBlob;
  sqlite3_stmt *pStmt;
  int rc;

  if( *pRC ) return;
  pBlob = sqlite3_malloc( 10*p->nColumn );
  if( pBlob==0 ){
    *pRC = 7;
    return;
  }
  fts3EncodeIntArray(p->nColumn, aSz, pBlob, &nBlob);
  rc = fts3SqlStmt(p, 20, &pStmt, 0);
  if( rc ){
    sqlite3_free(pBlob);
    *pRC = rc;
    return;
  }
  sqlite3_bind_int64(pStmt, 1, p->iPrevDocid);
  sqlite3_bind_blob(pStmt, 2, pBlob, nBlob, sqlite3_free);
  sqlite3_step(pStmt);
  *pRC = sqlite3_reset(pStmt);
}
# 119997 "ext/sqlite3/libsqlite/sqlite3.c"
static void fts3UpdateDocTotals(
  int *pRC,
  Fts3Table *p,
  u32 *aSzIns,
  u32 *aSzDel,
  int nChng
){
  char *pBlob;
  int nBlob;
  u32 *a;
  sqlite3_stmt *pStmt;
  int i;
  int rc;

  const int nStat = p->nColumn+2;

  if( *pRC ) return;
  a = sqlite3_malloc( (sizeof(u32)+10)*nStat );
  if( a==0 ){
    *pRC = 7;
    return;
  }
  pBlob = (char*)&a[nStat];
  rc = fts3SqlStmt(p, 22, &pStmt, 0);
  if( rc ){
    sqlite3_free(a);
    *pRC = rc;
    return;
  }
  if( sqlite3_step(pStmt)==100 ){
    fts3DecodeIntArray(nStat, a,
         sqlite3_column_blob(pStmt, 0),
         sqlite3_column_bytes(pStmt, 0));
  }else{
    memset(a, 0, sizeof(u32)*(nStat) );
  }
  sqlite3_reset(pStmt);
  if( nChng<0 && a[0]<(u32)(-nChng) ){
    a[0] = 0;
  }else{
    a[0] += nChng;
  }
  for(i=0; i<p->nColumn+1; i++){
    u32 x = a[i+1];
    if( x+aSzIns[i] < aSzDel[i] ){
      x = 0;
    }else{
      x = x + aSzIns[i] - aSzDel[i];
    }
    a[i+1] = x;
  }
  fts3EncodeIntArray(nStat, a, pBlob, &nBlob);
  rc = fts3SqlStmt(p, 23, &pStmt, 0);
  if( rc ){
    sqlite3_free(a);
    *pRC = rc;
    return;
  }
  sqlite3_bind_blob(pStmt, 1, pBlob, nBlob, ((sqlite3_destructor_type)0));
  sqlite3_step(pStmt);
  *pRC = sqlite3_reset(pStmt);
  sqlite3_free(a);
}
# 120069 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3SpecialInsert(Fts3Table *p, sqlite3_value *pVal){
  int rc;
  const char *zVal = (const char *)sqlite3_value_text(pVal);
  int nVal = sqlite3_value_bytes(pVal);

  if( !zVal ){
    return 7;
  }else if( nVal==8 && 0==sqlite3_strnicmp(zVal, "optimize", 8) ){
    rc = fts3SegmentMerge(p, -2);
    if( rc==101 ){
      rc = 0;
    }else{
      sqlite3Fts3PendingTermsClear(p);
    }
# 120091 "ext/sqlite3/libsqlite/sqlite3.c"
  }else{
    rc = 1;
  }

  sqlite3Fts3SegmentsClose(p);
  return rc;
}






static char *sqlite3Fts3DeferredDoclist(Fts3DeferredToken *pDeferred, int *pnByte){
  if( pDeferred->pList ){
    *pnByte = pDeferred->pList->nData;
    return pDeferred->pList->aData;
  }
  *pnByte = 0;
  return 0;
}






static void fts3DeferredDoclistClear(Fts3Expr *pExpr){
  if( pExpr ){
    fts3DeferredDoclistClear(pExpr->pLeft);
    fts3DeferredDoclistClear(pExpr->pRight);
    if( pExpr->isLoaded ){
      sqlite3_free(pExpr->aDoclist);
      pExpr->isLoaded = 0;
      pExpr->aDoclist = 0;
      pExpr->nDoclist = 0;
      pExpr->pCurrent = 0;
      pExpr->iCurrent = 0;
    }
  }
}





static void sqlite3Fts3FreeDeferredDoclists(Fts3Cursor *pCsr){
  Fts3DeferredToken *pDef;
  for(pDef=pCsr->pDeferred; pDef; pDef=pDef->pNext){
    sqlite3_free(pDef->pList);
    pDef->pList = 0;
  }
  if( pCsr->pDeferred ){
    fts3DeferredDoclistClear(pCsr->pExpr);
  }
}





static void sqlite3Fts3FreeDeferredTokens(Fts3Cursor *pCsr){
  Fts3DeferredToken *pDef;
  Fts3DeferredToken *pNext;
  for(pDef=pCsr->pDeferred; pDef; pDef=pNext){
    pNext = pDef->pNext;
    sqlite3_free(pDef->pList);
    sqlite3_free(pDef);
  }
  pCsr->pDeferred = 0;
}
# 120171 "ext/sqlite3/libsqlite/sqlite3.c"
static int sqlite3Fts3CacheDeferredDoclists(Fts3Cursor *pCsr){
  int rc = 0;
  if( pCsr->pDeferred ){
    int i;
    sqlite3_int64 iDocid;
    Fts3DeferredToken *pDef;

    Fts3Table *p = (Fts3Table *)pCsr->base.pVtab;
    sqlite3_tokenizer *pT = p->pTokenizer;
    sqlite3_tokenizer_module const *pModule = pT->pModule;

    ((void) (0));
    iDocid = sqlite3_column_int64(pCsr->pStmt, 0);

    for(i=0; i<p->nColumn && rc==0; i++){
      const char *zText = (const char *)sqlite3_column_text(pCsr->pStmt, i+1);
      sqlite3_tokenizer_cursor *pTC = 0;

      rc = pModule->xOpen(pT, zText, -1, &pTC);
      while( rc==0 ){
        char const *zToken;
        int nToken;
        int iDum1, iDum2;
        int iPos;

        pTC->pTokenizer = pT;
        rc = pModule->xNext(pTC, &zToken, &nToken, &iDum1, &iDum2, &iPos);
        for(pDef=pCsr->pDeferred; pDef && rc==0; pDef=pDef->pNext){
          Fts3PhraseToken *pPT = pDef->pToken;
          if( (pDef->iCol>=p->nColumn || pDef->iCol==i)
           && (pPT->n==nToken || (pPT->isPrefix && pPT->n<nToken))
           && (0==memcmp(zToken, pPT->z, pPT->n))
          ){
            fts3PendingListAppend(&pDef->pList, iDocid, i, iPos, &rc);
          }
        }
      }
      if( pTC ) pModule->xClose(pTC);
      if( rc==101 ) rc = 0;
    }

    for(pDef=pCsr->pDeferred; pDef && rc==0; pDef=pDef->pNext){
      if( pDef->pList ){
        rc = fts3PendingListAppendVarint(&pDef->pList, 0);
      }
    }
  }

  return rc;
}




static int sqlite3Fts3DeferToken(
  Fts3Cursor *pCsr,
  Fts3PhraseToken *pToken,
  int iCol
){
  Fts3DeferredToken *pDeferred;
  pDeferred = sqlite3_malloc(sizeof(*pDeferred));
  if( !pDeferred ){
    return 7;
  }
  memset(pDeferred, 0, sizeof(*pDeferred));
  pDeferred->pToken = pToken;
  pDeferred->pNext = pCsr->pDeferred;
  pDeferred->iCol = iCol;
  pCsr->pDeferred = pDeferred;

  ((void) (0));
  pToken->pDeferred = pDeferred;

  return 0;
}






static int sqlite3Fts3UpdateMethod(
  sqlite3_vtab *pVtab,
  int nArg,
  sqlite3_value **apVal,
  sqlite_int64 *pRowid
){
  Fts3Table *p = (Fts3Table *)pVtab;
  int rc = 0;
  int isRemove = 0;
  sqlite3_int64 iRemove = 0;
  u32 *aSzIns;
  u32 *aSzDel;
  int nChng = 0;

  ((void) (0));


  aSzIns = sqlite3_malloc( sizeof(aSzIns[0])*(p->nColumn+1)*2 );
  if( aSzIns==0 ) return 7;
  aSzDel = &aSzIns[p->nColumn+1];
  memset(aSzIns, 0, sizeof(aSzIns[0])*(p->nColumn+1)*2);


  if( sqlite3_value_type(apVal[0])!=5 ){
    int isEmpty = 0;
    rc = fts3IsEmpty(p, apVal, &isEmpty);
    if( rc==0 ){
      if( isEmpty ){




        rc = fts3DeleteAll(p);
      }else{
        isRemove = 1;
        iRemove = sqlite3_value_int64(apVal[0]);
        rc = fts3PendingTermsDocid(p, iRemove);
        fts3DeleteTerms(&rc, p, apVal, aSzDel);
        fts3SqlExec(&rc, p, 0, apVal);
        if( p->bHasDocsize ){
          fts3SqlExec(&rc, p, 19, apVal);
        }
        nChng--;
      }
    }
  }else if( sqlite3_value_type(apVal[p->nColumn+2])!=5 ){
    sqlite3_free(aSzIns);
    return fts3SpecialInsert(p, apVal[p->nColumn+2]);
  }


  if( nArg>1 && rc==0 ){
    rc = fts3InsertData(p, apVal, pRowid);
    if( rc==0 && (!isRemove || *pRowid!=iRemove) ){
      rc = fts3PendingTermsDocid(p, *pRowid);
    }
    if( rc==0 ){
      rc = fts3InsertTerms(p, apVal, aSzIns);
    }
    if( p->bHasDocsize ){
      fts3InsertDocsize(&rc, p, aSzIns);
    }
    nChng++;
  }

  if( p->bHasStat ){
    fts3UpdateDocTotals(&rc, p, aSzIns, aSzDel, nChng);
  }

  sqlite3_free(aSzIns);
  sqlite3Fts3SegmentsClose(p);
  return rc;
}






static int sqlite3Fts3Optimize(Fts3Table *p){
  int rc;
  rc = sqlite3_exec(p->db, "SAVEPOINT fts3", 0, 0, 0);
  if( rc==0 ){
    rc = fts3SegmentMerge(p, -2);
    if( rc==0 ){
      rc = sqlite3_exec(p->db, "RELEASE fts3", 0, 0, 0);
      if( rc==0 ){
        sqlite3Fts3PendingTermsClear(p);
      }
    }else{
      sqlite3_exec(p->db, "ROLLBACK TO fts3", 0, 0, 0);
      sqlite3_exec(p->db, "RELEASE fts3", 0, 0, 0);
    }
  }
  sqlite3Fts3SegmentsClose(p);
  return rc;
}
# 120391 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct LoadDoclistCtx LoadDoclistCtx;
struct LoadDoclistCtx {
  Fts3Cursor *pCsr;
  int nPhrase;
  int nToken;
};





typedef struct SnippetIter SnippetIter;
typedef struct SnippetPhrase SnippetPhrase;
typedef struct SnippetFragment SnippetFragment;

struct SnippetIter {
  Fts3Cursor *pCsr;
  int iCol;
  int nSnippet;
  int nPhrase;
  SnippetPhrase *aPhrase;
  int iCurrent;
};

struct SnippetPhrase {
  int nToken;
  char *pList;
  int iHead;
  char *pHead;
  int iTail;
  char *pTail;
};

struct SnippetFragment {
  int iCol;
  int iPos;
  u64 covered;
  u64 hlmask;
};





typedef struct MatchInfo MatchInfo;
struct MatchInfo {
  Fts3Cursor *pCursor;
  int nCol;
  int nPhrase;
  sqlite3_int64 nDoc;
  u32 *aMatchinfo;
};
# 120451 "ext/sqlite3/libsqlite/sqlite3.c"
typedef struct StrBuffer StrBuffer;
struct StrBuffer {
  char *z;
  int n;
  int nAlloc;
};
# 120479 "ext/sqlite3/libsqlite/sqlite3.c"
static void fts3GetDeltaPosition(char **pp, int *piPos){
  int iVal;
  *pp += sqlite3Fts3GetVarint32(*pp, &iVal);
  *piPos += (iVal-2);
}




static int fts3ExprIterate2(
  Fts3Expr *pExpr,
  int *piPhrase,
  int (*x)(Fts3Expr*,int,void*),
  void *pCtx
){
  int rc;
  int eType = pExpr->eType;

  if( eType!=5 ){
    ((void) (0));
    rc = fts3ExprIterate2(pExpr->pLeft, piPhrase, x, pCtx);
    if( rc==0 && eType!=2 ){
      rc = fts3ExprIterate2(pExpr->pRight, piPhrase, x, pCtx);
    }
  }else{
    rc = x(pExpr, *piPhrase, pCtx);
    (*piPhrase)++;
  }
  return rc;
}
# 120520 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3ExprIterate(
  Fts3Expr *pExpr,
  int (*x)(Fts3Expr*,int,void*),
  void *pCtx
){
  int iPhrase = 0;
  return fts3ExprIterate2(pExpr, &iPhrase, x, pCtx);
}
# 120543 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3ExprNearTrim(Fts3Expr *pExpr){
  int rc = 0;
  Fts3Expr *pParent = pExpr->pParent;

  ((void) (0));
  while( rc==0
   && pParent
   && pParent->eType==1
   && pParent->pRight==pExpr
  ){



    int nNear = pParent->nNear;
    Fts3Expr *pLeft = pParent->pLeft;

    if( pLeft->eType!=5 ){
      ((void) (0));
      ((void) (0));
      pLeft = pLeft->pRight;
    }

    rc = sqlite3Fts3ExprNearTrim(pLeft, pExpr, nNear);

    pExpr = pLeft;
    pParent = pExpr->pParent;
  }

  return rc;
}






static int fts3ExprLoadDoclistsCb(Fts3Expr *pExpr, int iPhrase, void *ctx){
  int rc = 0;
  LoadDoclistCtx *p = (LoadDoclistCtx *)ctx;

  (void)(iPhrase);

  p->nPhrase++;
  p->nToken += pExpr->pPhrase->nToken;

  if( pExpr->isLoaded==0 ){
    rc = sqlite3Fts3ExprLoadDoclist(p->pCsr, pExpr);
    pExpr->isLoaded = 1;
    if( rc==0 ){
      rc = fts3ExprNearTrim(pExpr);
    }
  }

  return rc;
}
# 120609 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3ExprLoadDoclists(
  Fts3Cursor *pCsr,
  int *pnPhrase,
  int *pnToken
){
  int rc;
  LoadDoclistCtx sCtx = {0,0,0};
  sCtx.pCsr = pCsr;
  rc = fts3ExprIterate(pCsr->pExpr, fts3ExprLoadDoclistsCb, (void *)&sCtx);
  if( pnPhrase ) *pnPhrase = sCtx.nPhrase;
  if( pnToken ) *pnToken = sCtx.nToken;
  return rc;
}

static int fts3ExprPhraseCountCb(Fts3Expr *pExpr, int iPhrase, void *ctx){
  (*(int *)ctx)++;
  (void)(pExpr);
  (void)(iPhrase);
  return 0;
}
static int fts3ExprPhraseCount(Fts3Expr *pExpr){
  int nPhrase = 0;
  (void)fts3ExprIterate(pExpr, fts3ExprPhraseCountCb, (void *)&nPhrase);
  return nPhrase;
}






static void fts3SnippetAdvance(char **ppIter, int *piIter, int iNext){
  char *pIter = *ppIter;
  if( pIter ){
    int iIter = *piIter;

    while( iIter<iNext ){
      if( 0==(*pIter & 0xFE) ){
        iIter = -1;
        pIter = 0;
        break;
      }
      fts3GetDeltaPosition(&pIter, &iIter);
    }

    *piIter = iIter;
    *ppIter = pIter;
  }
}




static int fts3SnippetNextCandidate(SnippetIter *pIter){
  int i;

  if( pIter->iCurrent<0 ){




    pIter->iCurrent = 0;




    for(i=0; i<pIter->nPhrase; i++){
      SnippetPhrase *pPhrase = &pIter->aPhrase[i];
      fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, pIter->nSnippet);
    }
  }else{
    int iStart;
    int iEnd = 0x7FFFFFFF;

    for(i=0; i<pIter->nPhrase; i++){
      SnippetPhrase *pPhrase = &pIter->aPhrase[i];
      if( pPhrase->pHead && pPhrase->iHead<iEnd ){
        iEnd = pPhrase->iHead;
      }
    }
    if( iEnd==0x7FFFFFFF ){
      return 1;
    }

    pIter->iCurrent = iStart = iEnd - pIter->nSnippet + 1;
    for(i=0; i<pIter->nPhrase; i++){
      SnippetPhrase *pPhrase = &pIter->aPhrase[i];
      fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1);
      fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);
    }
  }

  return 0;
}





static void fts3SnippetDetails(
  SnippetIter *pIter,
  u64 mCovered,
  int *piToken,
  int *piScore,
  u64 *pmCover,
  u64 *pmHighlight
){
  int iStart = pIter->iCurrent;
  int iScore = 0;
  int i;
  u64 mCover = 0;
  u64 mHighlight = 0;

  for(i=0; i<pIter->nPhrase; i++){
    SnippetPhrase *pPhrase = &pIter->aPhrase[i];
    if( pPhrase->pTail ){
      char *pCsr = pPhrase->pTail;
      int iCsr = pPhrase->iTail;

      while( iCsr<(iStart+pIter->nSnippet) ){
        int j;
        u64 mPhrase = (u64)1 << i;
        u64 mPos = (u64)1 << (iCsr - iStart);
        ((void) (0));
        if( (mCover|mCovered)&mPhrase ){
          iScore++;
        }else{
          iScore += 1000;
        }
        mCover |= mPhrase;

        for(j=0; j<pPhrase->nToken; j++){
          mHighlight |= (mPos>>j);
        }

        if( 0==(*pCsr & 0x0FE) ) break;
        fts3GetDeltaPosition(&pCsr, &iCsr);
      }
    }
  }


  *piToken = iStart;
  *piScore = iScore;
  *pmCover = mCover;
  *pmHighlight = mHighlight;
}





static int fts3SnippetFindPositions(Fts3Expr *pExpr, int iPhrase, void *ctx){
  SnippetIter *p = (SnippetIter *)ctx;
  SnippetPhrase *pPhrase = &p->aPhrase[iPhrase];
  char *pCsr;

  pPhrase->nToken = pExpr->pPhrase->nToken;

  pCsr = sqlite3Fts3FindPositions(pExpr, p->pCsr->iPrevId, p->iCol);
  if( pCsr ){
    int iFirst = 0;
    pPhrase->pList = pCsr;
    fts3GetDeltaPosition(&pCsr, &iFirst);
    pPhrase->pHead = pCsr;
    pPhrase->pTail = pCsr;
    pPhrase->iHead = iFirst;
    pPhrase->iTail = iFirst;
  }else{
    ((void) (0));
  }

  return 0;
}
# 120799 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3BestSnippet(
  int nSnippet,
  Fts3Cursor *pCsr,
  int iCol,
  u64 mCovered,
  u64 *pmSeen,
  SnippetFragment *pFragment,
  int *piScore
){
  int rc;
  int nList;
  SnippetIter sIter;
  int nByte;
  int iBestScore = -1;
  int i;

  memset(&sIter, 0, sizeof(sIter));




  rc = fts3ExprLoadDoclists(pCsr, &nList, 0);
  if( rc!=0 ){
    return rc;
  }




  nByte = sizeof(SnippetPhrase) * nList;
  sIter.aPhrase = (SnippetPhrase *)sqlite3_malloc(nByte);
  if( !sIter.aPhrase ){
    return 7;
  }
  memset(sIter.aPhrase, 0, nByte);




  sIter.pCsr = pCsr;
  sIter.iCol = iCol;
  sIter.nSnippet = nSnippet;
  sIter.nPhrase = nList;
  sIter.iCurrent = -1;
  (void)fts3ExprIterate(pCsr->pExpr, fts3SnippetFindPositions, (void *)&sIter);


  for(i=0; i<nList; i++){
    if( sIter.aPhrase[i].pHead ){
      *pmSeen |= (u64)1 << i;
    }
  }




  pFragment->iCol = iCol;
  while( !fts3SnippetNextCandidate(&sIter) ){
    int iPos;
    int iScore;
    u64 mCover;
    u64 mHighlight;
    fts3SnippetDetails(&sIter, mCovered, &iPos, &iScore, &mCover, &mHighlight);
    ((void) (0));
    if( iScore>iBestScore ){
      pFragment->iPos = iPos;
      pFragment->hlmask = mHighlight;
      pFragment->covered = mCover;
      iBestScore = iScore;
    }
  }

  sqlite3_free(sIter.aPhrase);
  *piScore = iBestScore;
  return 0;
}
# 120883 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3StringAppend(
  StrBuffer *pStr,
  const char *zAppend,
  int nAppend
){
  if( nAppend<0 ){
    nAppend = (int)strlen(zAppend);
  }





  if( pStr->n+nAppend+1>=pStr->nAlloc ){
    int nAlloc = pStr->nAlloc+nAppend+100;
    char *zNew = sqlite3_realloc(pStr->z, nAlloc);
    if( !zNew ){
      return 7;
    }
    pStr->z = zNew;
    pStr->nAlloc = nAlloc;
  }


  memcpy(&pStr->z[pStr->n], zAppend, nAppend);
  pStr->n += nAppend;
  pStr->z[pStr->n] = '\0';

  return 0;
}
# 120934 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3SnippetShift(
  Fts3Table *pTab,
  int nSnippet,
  const char *zDoc,
  int nDoc,
  int *piPos,
  u64 *pHlmask
){
  u64 hlmask = *pHlmask;

  if( hlmask ){
    int nLeft;
    int nRight;
    int nDesired;

    for(nLeft=0; !(hlmask & ((u64)1 << nLeft)); nLeft++);
    for(nRight=0; !(hlmask & ((u64)1 << (nSnippet-1-nRight))); nRight++);
    nDesired = (nLeft-nRight)/2;
# 120960 "ext/sqlite3/libsqlite/sqlite3.c"
    if( nDesired>0 ){
      int nShift;
      int iCurrent = 0;
      int rc;
      sqlite3_tokenizer_module *pMod;
      sqlite3_tokenizer_cursor *pC;
      pMod = (sqlite3_tokenizer_module *)pTab->pTokenizer->pModule;




      rc = pMod->xOpen(pTab->pTokenizer, zDoc, nDoc, &pC);
      if( rc!=0 ){
        return rc;
      }
      pC->pTokenizer = pTab->pTokenizer;
      while( rc==0 && iCurrent<(nSnippet+nDesired) ){
        const char *ZDUMMY; int DUMMY1, DUMMY2, DUMMY3;
        rc = pMod->xNext(pC, &ZDUMMY, &DUMMY1, &DUMMY2, &DUMMY3, &iCurrent);
      }
      pMod->xClose(pC);
      if( rc!=0 && rc!=101 ){ return rc; }

      nShift = (rc==101)+iCurrent-nSnippet;
      ((void) (0));
      if( nShift>0 ){
        *piPos += nShift;
        *pHlmask = hlmask >> nShift;
      }
    }
  }
  return 0;
}





static int fts3SnippetText(
  Fts3Cursor *pCsr,
  SnippetFragment *pFragment,
  int iFragment,
  int isLast,
  int nSnippet,
  const char *zOpen,
  const char *zClose,
  const char *zEllipsis,
  StrBuffer *pOut
){
  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
  int rc;
  const char *zDoc;
  int nDoc;
  int iCurrent = 0;
  int iEnd = 0;
  int isShiftDone = 0;
  int iPos = pFragment->iPos;
  u64 hlmask = pFragment->hlmask;
  int iCol = pFragment->iCol+1;
  sqlite3_tokenizer_module *pMod;
  sqlite3_tokenizer_cursor *pC;
  const char *ZDUMMY;
  int DUMMY1;

  zDoc = (const char *)sqlite3_column_text(pCsr->pStmt, iCol);
  if( zDoc==0 ){
    if( sqlite3_column_type(pCsr->pStmt, iCol)!=5 ){
      return 7;
    }
    return 0;
  }
  nDoc = sqlite3_column_bytes(pCsr->pStmt, iCol);


  pMod = (sqlite3_tokenizer_module *)pTab->pTokenizer->pModule;
  rc = pMod->xOpen(pTab->pTokenizer, zDoc, nDoc, &pC);
  if( rc!=0 ){
    return rc;
  }
  pC->pTokenizer = pTab->pTokenizer;

  while( rc==0 ){
    int iBegin;
    int iFin;
    int isHighlight;

    rc = pMod->xNext(pC, &ZDUMMY, &DUMMY1, &iBegin, &iFin, &iCurrent);
    if( rc!=0 ){
      if( rc==101 ){




        rc = fts3StringAppend(pOut, &zDoc[iEnd], -1);
      }
      break;
    }
    if( iCurrent<iPos ){ continue; }

    if( !isShiftDone ){
      int n = nDoc - iBegin;
      rc = fts3SnippetShift(pTab, nSnippet, &zDoc[iBegin], n, &iPos, &hlmask);
      isShiftDone = 1;





      if( rc==0 && (iPos>0 || iFragment>0) ){
        rc = fts3StringAppend(pOut, zEllipsis, -1);
      }
      if( rc!=0 || iCurrent<iPos ) continue;
    }

    if( iCurrent>=(iPos+nSnippet) ){
      if( isLast ){
        rc = fts3StringAppend(pOut, zEllipsis, -1);
      }
      break;
    }


    isHighlight = (hlmask & ((u64)1 << (iCurrent-iPos)))!=0;

    if( iCurrent>iPos ) rc = fts3StringAppend(pOut, &zDoc[iEnd], iBegin-iEnd);
    if( rc==0 && isHighlight ) rc = fts3StringAppend(pOut, zOpen, -1);
    if( rc==0 ) rc = fts3StringAppend(pOut, &zDoc[iBegin], iFin-iBegin);
    if( rc==0 && isHighlight ) rc = fts3StringAppend(pOut, zClose, -1);

    iEnd = iFin;
  }

  pMod->xClose(pC);
  return rc;
}
# 121110 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3ColumnlistCount(char **ppCollist){
  char *pEnd = *ppCollist;
  char c = 0;
  int nEntry = 0;


  while( 0xFE & (*pEnd | c) ){
    c = *pEnd++ & 0x80;
    if( !c ) nEntry++;
  }

  *ppCollist = pEnd;
  return nEntry;
}

static void fts3LoadColumnlistCounts(char **pp, u32 *aOut, int isGlobal){
  char *pCsr = *pp;
  while( *pCsr ){
    int nHit;
    sqlite3_int64 iCol = 0;
    if( *pCsr==0x01 ){
      pCsr++;
      pCsr += sqlite3Fts3GetVarint(pCsr, &iCol);
    }
    nHit = fts3ColumnlistCount(&pCsr);
    ((void) (0));
    if( isGlobal ){
      aOut[iCol*3+1]++;
    }
    aOut[iCol*3] += nHit;
  }
  pCsr++;
  *pp = pCsr;
}
# 121172 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3ExprGlobalHitsCb(
  Fts3Expr *pExpr,
  int iPhrase,
  void *pCtx
){
  MatchInfo *p = (MatchInfo *)pCtx;
  Fts3Cursor *pCsr = p->pCursor;
  char *pIter;
  char *pEnd;
  char *pFree = 0;
  u32 *aOut = &p->aMatchinfo[3*iPhrase*p->nCol];

  ((void) (0));
  ((void) (0));

  if( pCsr->pDeferred ){
    Fts3Phrase *pPhrase = pExpr->pPhrase;
    int ii;
    for(ii=0; ii<pPhrase->nToken; ii++){
      if( pPhrase->aToken[ii].bFulltext ) break;
    }
    if( ii<pPhrase->nToken ){
      int nFree = 0;
      int rc = sqlite3Fts3ExprLoadFtDoclist(pCsr, pExpr, &pFree, &nFree);
      if( rc!=0 ) return rc;
      pIter = pFree;
      pEnd = &pFree[nFree];
    }else{
      int iCol;
      for(iCol=0; iCol<p->nCol; iCol++){
        aOut[iCol*3 + 1] = (u32)p->nDoc;
        aOut[iCol*3 + 2] = (u32)p->nDoc;
      }
      return 0;
    }
  }else{
    pIter = pExpr->aDoclist;
    pEnd = &pExpr->aDoclist[pExpr->nDoclist];
  }


  while( pIter<pEnd ){
    while( *pIter++ & 0x80 );
    fts3LoadColumnlistCounts(&pIter, &aOut[1], 1);
  }

  sqlite3_free(pFree);
  return 0;
}






static int fts3ExprLocalHitsCb(
  Fts3Expr *pExpr,
  int iPhrase,
  void *pCtx
){
  MatchInfo *p = (MatchInfo *)pCtx;
  int iStart = iPhrase * p->nCol * 3;
  int i;

  for(i=0; i<p->nCol; i++) p->aMatchinfo[iStart+i*3] = 0;

  if( pExpr->aDoclist ){
    char *pCsr;

    pCsr = sqlite3Fts3FindPositions(pExpr, p->pCursor->iPrevId, -1);
    if( pCsr ){
      fts3LoadColumnlistCounts(&pCsr, &p->aMatchinfo[iStart], 0);
    }
  }

  return 0;
}

static int fts3MatchinfoCheck(
  Fts3Table *pTab,
  char cArg,
  char **pzErr
){
  if( (cArg=='p')
   || (cArg=='c')
   || (cArg=='n' && pTab->bHasStat)
   || (cArg=='a' && pTab->bHasStat)
   || (cArg=='l' && pTab->bHasDocsize)
   || (cArg=='s')
   || (cArg=='x')
  ){
    return 0;
  }
  *pzErr = sqlite3_mprintf("unrecognized matchinfo request: %c", cArg);
  return 1;
}

static int fts3MatchinfoSize(MatchInfo *pInfo, char cArg){
  int nVal;

  switch( cArg ){
    case 'n':
    case 'p':
    case 'c':
      nVal = 1;
      break;

    case 'a':
    case 'l':
    case 's':
      nVal = pInfo->nCol;
      break;

    default:
      ((void) (0));
      nVal = pInfo->nCol * pInfo->nPhrase * 3;
      break;
  }

  return nVal;
}

static int fts3MatchinfoSelectDoctotal(
  Fts3Table *pTab,
  sqlite3_stmt **ppStmt,
  sqlite3_int64 *pnDoc,
  const char **paLen
){
  sqlite3_stmt *pStmt;
  const char *a;
  sqlite3_int64 nDoc;

  if( !*ppStmt ){
    int rc = sqlite3Fts3SelectDoctotal(pTab, ppStmt);
    if( rc!=0 ) return rc;
  }
  pStmt = *ppStmt;
  ((void) (0));

  a = sqlite3_column_blob(pStmt, 0);
  a += sqlite3Fts3GetVarint(a, &nDoc);
  if( nDoc==0 ) return 11;
  *pnDoc = (u32)nDoc;

  if( paLen ) *paLen = a;
  return 0;
}







typedef struct LcsIterator LcsIterator;
struct LcsIterator {
  Fts3Expr *pExpr;
  char *pRead;
  int iPosOffset;
  int iCol;
  int iPos;
};







static int fts3MatchinfoLcsCb(
  Fts3Expr *pExpr,
  int iPhrase,
  void *pCtx
){
  LcsIterator *aIter = (LcsIterator *)pCtx;
  aIter[iPhrase].pExpr = pExpr;
  return 0;
}






static int fts3LcsIteratorAdvance(LcsIterator *pIter){
  char *pRead = pIter->pRead;
  sqlite3_int64 iRead;
  int rc = 0;

  pRead += sqlite3Fts3GetVarint(pRead, &iRead);
  if( iRead==0 ){
    pIter->iCol = 0x7FFFFFFF;;
    rc = 1;
  }else{
    if( iRead==1 ){
      pRead += sqlite3Fts3GetVarint(pRead, &iRead);
      pIter->iCol = (int)iRead;
      pIter->iPos = pIter->iPosOffset;
      pRead += sqlite3Fts3GetVarint(pRead, &iRead);
      rc = 1;
    }
    pIter->iPos += (int)(iRead-2);
  }

  pIter->pRead = pRead;
  return rc;
}
# 121391 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3MatchinfoLcs(Fts3Cursor *pCsr, MatchInfo *pInfo){
  LcsIterator *aIter;
  int i;
  int iCol;
  int nToken = 0;




  aIter = sqlite3_malloc(sizeof(LcsIterator) * pCsr->nPhrase);
  if( !aIter ) return 7;
  memset(aIter, 0, sizeof(LcsIterator) * pCsr->nPhrase);
  (void)fts3ExprIterate(pCsr->pExpr, fts3MatchinfoLcsCb, (void*)aIter);
  for(i=0; i<pInfo->nPhrase; i++){
    LcsIterator *pIter = &aIter[i];
    nToken -= pIter->pExpr->pPhrase->nToken;
    pIter->iPosOffset = nToken;
    pIter->pRead = sqlite3Fts3FindPositions(pIter->pExpr, pCsr->iPrevId, -1);
    if( pIter->pRead ){
      pIter->iPos = pIter->iPosOffset;
      fts3LcsIteratorAdvance(&aIter[i]);
    }else{
      pIter->iCol = 0x7FFFFFFF;;
    }
  }

  for(iCol=0; iCol<pInfo->nCol; iCol++){
    int nLcs = 0;
    int nLive = 0;




    for(i=0; i<pInfo->nPhrase; i++){
      ((void) (0));
      if( aIter[i].iCol==iCol ) nLive++;
    }





    while( nLive>0 ){
      LcsIterator *pAdv = 0;
      int nThisLcs = 0;

      for(i=0; i<pInfo->nPhrase; i++){
        LcsIterator *pIter = &aIter[i];
        if( iCol!=pIter->iCol ){

          nThisLcs = 0;
        }else{
          if( pAdv==0 || pIter->iPos<pAdv->iPos ){
            pAdv = pIter;
          }
          if( nThisLcs==0 || pIter->iPos==pIter[-1].iPos ){
            nThisLcs++;
          }else{
            nThisLcs = 1;
          }
          if( nThisLcs>nLcs ) nLcs = nThisLcs;
        }
      }
      if( fts3LcsIteratorAdvance(pAdv) ) nLive--;
    }

    pInfo->aMatchinfo[iCol] = nLcs;
  }

  sqlite3_free(aIter);
  return 0;
}
# 121481 "ext/sqlite3/libsqlite/sqlite3.c"
static int fts3MatchinfoValues(
  Fts3Cursor *pCsr,
  int bGlobal,
  MatchInfo *pInfo,
  const char *zArg
){
  int rc = 0;
  int i;
  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
  sqlite3_stmt *pSelect = 0;

  for(i=0; rc==0 && zArg[i]; i++){

    switch( zArg[i] ){
      case 'p':
        if( bGlobal ) pInfo->aMatchinfo[0] = pInfo->nPhrase;
        break;

      case 'c':
        if( bGlobal ) pInfo->aMatchinfo[0] = pInfo->nCol;
        break;

      case 'n':
        if( bGlobal ){
          sqlite3_int64 nDoc;
          rc = fts3MatchinfoSelectDoctotal(pTab, &pSelect, &nDoc, 0);
          pInfo->aMatchinfo[0] = (u32)nDoc;
        }
        break;

      case 'a':
        if( bGlobal ){
          sqlite3_int64 nDoc;
          const char *a;

          rc = fts3MatchinfoSelectDoctotal(pTab, &pSelect, &nDoc, &a);
          if( rc==0 ){
            int iCol;
            for(iCol=0; iCol<pInfo->nCol; iCol++){
              u32 iVal;
              sqlite3_int64 nToken;
              a += sqlite3Fts3GetVarint(a, &nToken);
              iVal = (u32)(((u32)(nToken&0xffffffff)+nDoc/2)/nDoc);
              pInfo->aMatchinfo[iCol] = iVal;
            }
          }
        }
        break;

      case 'l': {
        sqlite3_stmt *pSelectDocsize = 0;
        rc = sqlite3Fts3SelectDocsize(pTab, pCsr->iPrevId, &pSelectDocsize);
        if( rc==0 ){
          int iCol;
          const char *a = sqlite3_column_blob(pSelectDocsize, 0);
          for(iCol=0; iCol<pInfo->nCol; iCol++){
            sqlite3_int64 nToken;
            a += sqlite3Fts3GetVarint(a, &nToken);
            pInfo->aMatchinfo[iCol] = (u32)nToken;
          }
        }
        sqlite3_reset(pSelectDocsize);
        break;
      }

      case 's':
        rc = fts3ExprLoadDoclists(pCsr, 0, 0);
        if( rc==0 ){
          rc = fts3MatchinfoLcs(pCsr, pInfo);
        }
        break;

      default: {
        Fts3Expr *pExpr;
        ((void) (0));
        pExpr = pCsr->pExpr;
        rc = fts3ExprLoadDoclists(pCsr, 0, 0);
        if( rc!=0 ) break;
        if( bGlobal ){
          if( pCsr->pDeferred ){
            rc = fts3MatchinfoSelectDoctotal(pTab, &pSelect, &pInfo->nDoc, 0);
            if( rc!=0 ) break;
          }
          rc = fts3ExprIterate(pExpr, fts3ExprGlobalHitsCb,(void*)pInfo);
          if( rc!=0 ) break;
        }
        (void)fts3ExprIterate(pExpr, fts3ExprLocalHitsCb,(void*)pInfo);
        break;
      }
    }

    pInfo->aMatchinfo += fts3MatchinfoSize(pInfo, zArg[i]);
  }

  sqlite3_reset(pSelect);
  return rc;
}






static int fts3GetMatchinfo(
  Fts3Cursor *pCsr,
  const char *zArg
){
  MatchInfo sInfo;
  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
  int rc = 0;
  int bGlobal = 0;

  memset(&sInfo, 0, sizeof(MatchInfo));
  sInfo.pCursor = pCsr;
  sInfo.nCol = pTab->nColumn;




  if( pCsr->zMatchinfo && __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (pCsr->zMatchinfo) && __builtin_constant_p (zArg) && (__s1_len = __builtin_strlen (pCsr->zMatchinfo), __s2_len = __builtin_strlen (zArg), (!((size_t)(const void *)((pCsr->zMatchinfo) + 1) - (size_t)(const void *)(pCsr->zMatchinfo) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((zArg) + 1) - (size_t)(const void *)(zArg) == 1) || __s2_len >= 4)) ? __builtin_strcmp (pCsr->zMatchinfo, zArg) : (__builtin_constant_p (pCsr->zMatchinfo) && ((size_t)(const void *)((pCsr->zMatchinfo) + 1) - (size_t)(const void *)(pCsr->zMatchinfo) == 1) && (__s1_len = __builtin_strlen (pCsr->zMatchinfo), __s1_len < 4) ? (__builtin_constant_p (zArg) && ((size_t)(const void *)((zArg) + 1) - (size_t)(const void *)(zArg) == 1) ? __builtin_strcmp (pCsr->zMatchinfo, zArg) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (zArg); int __result = (((const unsigned char *) (const char *) (pCsr->zMatchinfo))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (pCsr->zMatchinfo))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (pCsr->zMatchinfo))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (pCsr->zMatchinfo))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (zArg) && ((size_t)(const void *)((zArg) + 1) - (size_t)(const void *)(zArg) == 1) && (__s2_len = __builtin_strlen (zArg), __s2_len < 4) ? (__builtin_constant_p (pCsr->zMatchinfo) && ((size_t)(const void *)((pCsr->zMatchinfo) + 1) - (size_t)(const void *)(pCsr->zMatchinfo) == 1) ? __builtin_strcmp (pCsr->zMatchinfo, zArg) : (- (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (pCsr->zMatchinfo); int __result = (((const unsigned char *) (const char *) (zArg))[0] - __s2[0]); if (__s2_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (zArg))[1] - __s2[1]); if (__s2_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (zArg))[2] - __s2[2]); if (__s2_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (zArg))[3] - __s2[3]); } } __result; })))) : __builtin_strcmp (pCsr->zMatchinfo, zArg)))); }) ){
    ((void) (0));
    sqlite3_free(pCsr->aMatchinfo);
    pCsr->zMatchinfo = 0;
    pCsr->aMatchinfo = 0;
  }






  if( pCsr->aMatchinfo==0 ){
    int nMatchinfo = 0;
    int nArg;
    int i;


    pCsr->nPhrase = fts3ExprPhraseCount(pCsr->pExpr);
    sInfo.nPhrase = pCsr->nPhrase;


    for(i=0; zArg[i]; i++){
      nMatchinfo += fts3MatchinfoSize(&sInfo, zArg[i]);
    }


    nArg = (int)strlen(zArg);
    pCsr->aMatchinfo = (u32 *)sqlite3_malloc(sizeof(u32)*nMatchinfo + nArg + 1);
    if( !pCsr->aMatchinfo ) return 7;

    pCsr->zMatchinfo = (char *)&pCsr->aMatchinfo[nMatchinfo];
    pCsr->nMatchinfo = nMatchinfo;
    memcpy(pCsr->zMatchinfo, zArg, nArg+1);
    memset(pCsr->aMatchinfo, 0, sizeof(u32)*nMatchinfo);
    pCsr->isMatchinfoNeeded = 1;
    bGlobal = 1;
  }

  sInfo.aMatchinfo = pCsr->aMatchinfo;
  sInfo.nPhrase = pCsr->nPhrase;
  if( pCsr->isMatchinfoNeeded ){
    rc = fts3MatchinfoValues(pCsr, bGlobal, &sInfo, zArg);
    pCsr->isMatchinfoNeeded = 0;
  }

  return rc;
}




static void sqlite3Fts3Snippet(
  sqlite3_context *pCtx,
  Fts3Cursor *pCsr,
  const char *zStart,
  const char *zEnd,
  const char *zEllipsis,
  int iCol,
  int nToken
){
  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
  int rc = 0;
  int i;
  StrBuffer res = {0, 0, 0};
# 121674 "ext/sqlite3/libsqlite/sqlite3.c"
  int nSnippet = 0;
  SnippetFragment aSnippet[4];
  int nFToken = -1;

  if( !pCsr->pExpr ){
    sqlite3_result_text(pCtx, "", 0, ((sqlite3_destructor_type)0));
    return;
  }

  for(nSnippet=1; 1; nSnippet++){

    int iSnip;
    u64 mCovered = 0;
    u64 mSeen = 0;

    if( nToken>=0 ){
      nFToken = (nToken+nSnippet-1) / nSnippet;
    }else{
      nFToken = -1 * nToken;
    }

    for(iSnip=0; iSnip<nSnippet; iSnip++){
      int iBestScore = -1;
      int iRead;
      SnippetFragment *pFragment = &aSnippet[iSnip];

      memset(pFragment, 0, sizeof(*pFragment));





      for(iRead=0; iRead<pTab->nColumn; iRead++){
        SnippetFragment sF = {0, 0, 0, 0};
        int iS;
        if( iCol>=0 && iRead!=iCol ) continue;


        rc = fts3BestSnippet(nFToken, pCsr, iRead, mCovered, &mSeen, &sF, &iS);
        if( rc!=0 ){
          goto snippet_out;
        }
        if( iS>iBestScore ){
          *pFragment = sF;
          iBestScore = iS;
        }
      }

      mCovered |= pFragment->covered;
    }




    ((void) (0));
    if( mSeen==mCovered || nSnippet==((int)(sizeof(aSnippet)/sizeof(aSnippet[0]))) ) break;
  }

  ((void) (0));

  for(i=0; i<nSnippet && rc==0; i++){
    rc = fts3SnippetText(pCsr, &aSnippet[i],
        i, (i==nSnippet-1), nFToken, zStart, zEnd, zEllipsis, &res
    );
  }

 snippet_out:
  sqlite3Fts3SegmentsClose(pTab);
  if( rc!=0 ){
    sqlite3_result_error_code(pCtx, rc);
    sqlite3_free(res.z);
  }else{
    sqlite3_result_text(pCtx, res.z, -1, sqlite3_free);
  }
}


typedef struct TermOffset TermOffset;
typedef struct TermOffsetCtx TermOffsetCtx;

struct TermOffset {
  char *pList;
  int iPos;
  int iOff;
};

struct TermOffsetCtx {
  int iCol;
  int iTerm;
  sqlite3_int64 iDocid;
  TermOffset *aTerm;
};




static int fts3ExprTermOffsetInit(Fts3Expr *pExpr, int iPhrase, void *ctx){
  TermOffsetCtx *p = (TermOffsetCtx *)ctx;
  int nTerm;
  int iTerm;
  char *pList;
  int iPos = 0;

  (void)(iPhrase);
  pList = sqlite3Fts3FindPositions(pExpr, p->iDocid, p->iCol);
  nTerm = pExpr->pPhrase->nToken;
  if( pList ){
    fts3GetDeltaPosition(&pList, &iPos);
    ((void) (0));
  }

  for(iTerm=0; iTerm<nTerm; iTerm++){
    TermOffset *pT = &p->aTerm[p->iTerm++];
    pT->iOff = nTerm-iTerm-1;
    pT->pList = pList;
    pT->iPos = iPos;
  }

  return 0;
}




static void sqlite3Fts3Offsets(
  sqlite3_context *pCtx,
  Fts3Cursor *pCsr
){
  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
  sqlite3_tokenizer_module const *pMod = pTab->pTokenizer->pModule;
  const char *ZDUMMY;
  int NDUMMY;
  int rc;
  int nToken;
  int iCol;
  StrBuffer res = {0, 0, 0};
  TermOffsetCtx sCtx;

  if( !pCsr->pExpr ){
    sqlite3_result_text(pCtx, "", 0, ((sqlite3_destructor_type)0));
    return;
  }

  memset(&sCtx, 0, sizeof(sCtx));
  ((void) (0));


  rc = fts3ExprLoadDoclists(pCsr, 0, &nToken);
  if( rc!=0 ) goto offsets_out;


  sCtx.aTerm = (TermOffset *)sqlite3_malloc(sizeof(TermOffset)*nToken);
  if( 0==sCtx.aTerm ){
    rc = 7;
    goto offsets_out;
  }
  sCtx.iDocid = pCsr->iPrevId;




  for(iCol=0; iCol<pTab->nColumn; iCol++){
    sqlite3_tokenizer_cursor *pC;
    int iStart;
    int iEnd;
    int iCurrent;
    const char *zDoc;
    int nDoc;





    sCtx.iCol = iCol;
    sCtx.iTerm = 0;
    (void)fts3ExprIterate(pCsr->pExpr, fts3ExprTermOffsetInit, (void *)&sCtx);







    zDoc = (const char *)sqlite3_column_text(pCsr->pStmt, iCol+1);
    nDoc = sqlite3_column_bytes(pCsr->pStmt, iCol+1);
    if( zDoc==0 ){
      if( sqlite3_column_type(pCsr->pStmt, iCol+1)==5 ){
        continue;
      }
      rc = 7;
      goto offsets_out;
    }


    rc = pMod->xOpen(pTab->pTokenizer, zDoc, nDoc, &pC);
    if( rc!=0 ) goto offsets_out;
    pC->pTokenizer = pTab->pTokenizer;

    rc = pMod->xNext(pC, &ZDUMMY, &NDUMMY, &iStart, &iEnd, &iCurrent);
    while( rc==0 ){
      int i;
      int iMinPos = 0x7FFFFFFF;
      TermOffset *pTerm = 0;

      for(i=0; i<nToken; i++){
        TermOffset *pT = &sCtx.aTerm[i];
        if( pT->pList && (pT->iPos-pT->iOff)<iMinPos ){
          iMinPos = pT->iPos-pT->iOff;
          pTerm = pT;
        }
      }

      if( !pTerm ){

        break;
      }else{
        ((void) (0));
        if( 0==(0xFE&*pTerm->pList) ){
          pTerm->pList = 0;
        }else{
          fts3GetDeltaPosition(&pTerm->pList, &pTerm->iPos);
        }
        while( rc==0 && iCurrent<iMinPos ){
          rc = pMod->xNext(pC, &ZDUMMY, &NDUMMY, &iStart, &iEnd, &iCurrent);
        }
        if( rc==0 ){
          char aBuffer[64];
          sqlite3_snprintf(sizeof(aBuffer), aBuffer,
              "%d %d %d %d ", iCol, pTerm-sCtx.aTerm, iStart, iEnd-iStart
          );
          rc = fts3StringAppend(&res, aBuffer, -1);
        }else if( rc==101 ){
          rc = 11;
        }
      }
    }
    if( rc==101 ){
      rc = 0;
    }

    pMod->xClose(pC);
    if( rc!=0 ) goto offsets_out;
  }

 offsets_out:
  sqlite3_free(sCtx.aTerm);
  ((void) (0));
  sqlite3Fts3SegmentsClose(pTab);
  if( rc!=0 ){
    sqlite3_result_error_code(pCtx, rc);
    sqlite3_free(res.z);
  }else{
    sqlite3_result_text(pCtx, res.z, res.n-1, sqlite3_free);
  }
  return;
}




static void sqlite3Fts3Matchinfo(
  sqlite3_context *pContext,
  Fts3Cursor *pCsr,
  const char *zArg
){
  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;
  int rc;
  int i;
  const char *zFormat;

  if( zArg ){
    for(i=0; zArg[i]; i++){
      char *zErr = 0;
      if( fts3MatchinfoCheck(pTab, zArg[i], &zErr) ){
        sqlite3_result_error(pContext, zErr, -1);
        sqlite3_free(zErr);
        return;
      }
    }
    zFormat = zArg;
  }else{
    zFormat = "pcx";
  }

  if( !pCsr->pExpr ){
    sqlite3_result_blob(pContext, "", 0, ((sqlite3_destructor_type)0));
    return;
  }


  rc = fts3GetMatchinfo(pCsr, zFormat);
  sqlite3Fts3SegmentsClose(pTab);

  if( rc!=0 ){
    sqlite3_result_error_code(pContext, rc);
  }else{
    int n = pCsr->nMatchinfo * sizeof(u32);
    sqlite3_result_blob(pContext, pCsr->aMatchinfo, n, ((sqlite3_destructor_type)-1));
  }
}
